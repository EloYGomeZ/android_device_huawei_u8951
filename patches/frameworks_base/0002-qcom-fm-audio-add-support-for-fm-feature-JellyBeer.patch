From 84e83d81a7e0e6924425e381970bcac347cbb8fb Mon Sep 17 00:00:00 2001
From: EloYGomeZ <eloygomez83@gmail.com>
Date: Sat, 23 Nov 2013 21:32:55 +0100
Subject: [PATCH] qcom fm audio add support for fm feature JellyBeer

Change-Id: Id48a52ceb7359deb65d4a69e664b22ed80cf997c

Conflicts:

        core/java/android/content/Intent.java
        policy/src/com/android/internal/policy/impl/PhoneWindowManager.java

audio: fix for FM mute issue

- Add STREAM_FM in mMuteAffectedStreams
  so that FM stream can be muted
- Add STREAM_FM in STREAM_NAMES

Change-Id: I52f802d0b8b6af8d49e7cdbc413e53165ba825c9
---
 core/java/android/content/Intent.java              | 14009 ++++++++---------
 core/java/android/provider/Settings.java           | 15056 ++++++++++---------
 core/java/android/view/VolumePanel.java            |  2282 +--
 media/java/android/media/AudioManager.java         |  5092 +++----
 media/java/android/media/AudioService.java         | 12738 ++++++++--------
 media/java/android/media/AudioSystem.java          |   847 +-
 media/java/android/media/MediaRecorder.java        |  2027 +--
 .../android/providers/settings/DatabaseHelper.java |  4625 +++---
 .../internal/policy/impl/PhoneWindowManager.java   | 11212 +++++++-------
 .../policy/impl/keyguard/KeyguardViewBase.java     |   537 +-
 10 files changed, 34300 insertions(+), 34125 deletions(-)

diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java
index bf8397d..1bd0d6c 100644
--- a/core/java/android/content/Intent.java
+++ b/core/java/android/content/Intent.java
@@ -1,6992 +1,7017 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.content;
-
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-
-import android.annotation.SdkConstant;
-import android.annotation.SdkConstant.SdkConstantType;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.Rect;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.IBinder;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.util.AttributeSet;
-import android.util.Log;
-
-import com.android.internal.util.XmlUtils;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.net.URISyntaxException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Locale;
-import java.util.Set;
-
-/**
- * An intent is an abstract description of an operation to be performed.  It
- * can be used with {@link Context#startActivity(Intent) startActivity} to
- * launch an {@link android.app.Activity},
- * {@link android.content.Context#sendBroadcast(Intent) broadcastIntent} to
- * send it to any interested {@link BroadcastReceiver BroadcastReceiver} components,
- * and {@link android.content.Context#startService} or
- * {@link android.content.Context#bindService} to communicate with a
- * background {@link android.app.Service}.
- *
- * <p>An Intent provides a facility for performing late runtime binding between the code in
- * different applications. Its most significant use is in the launching of activities, where it
- * can be thought of as the glue between activities. It is basically a passive data structure
- * holding an abstract description of an action to be performed.</p>
- *
- * <div class="special reference">
- * <h3>Developer Guides</h3>
- * <p>For information about how to create and resolve intents, read the
- * <a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>
- * developer guide.</p>
- * </div>
- *
- * <a name="IntentStructure"></a>
- * <h3>Intent Structure</h3>
- * <p>The primary pieces of information in an intent are:</p>
- *
- * <ul>
- *   <li> <p><b>action</b> -- The general action to be performed, such as
- *     {@link #ACTION_VIEW}, {@link #ACTION_EDIT}, {@link #ACTION_MAIN},
- *     etc.</p>
- *   </li>
- *   <li> <p><b>data</b> -- The data to operate on, such as a person record
- *     in the contacts database, expressed as a {@link android.net.Uri}.</p>
- *   </li>
- * </ul>
- *
- *
- * <p>Some examples of action/data pairs are:</p>
- *
- * <ul>
- *   <li> <p><b>{@link #ACTION_VIEW} <i>content://contacts/people/1</i></b> -- Display
- *     information about the person whose identifier is "1".</p>
- *   </li>
- *   <li> <p><b>{@link #ACTION_DIAL} <i>content://contacts/people/1</i></b> -- Display
- *     the phone dialer with the person filled in.</p>
- *   </li>
- *   <li> <p><b>{@link #ACTION_VIEW} <i>tel:123</i></b> -- Display
- *     the phone dialer with the given number filled in.  Note how the
- *     VIEW action does what what is considered the most reasonable thing for
- *     a particular URI.</p>
- *   </li>
- *   <li> <p><b>{@link #ACTION_DIAL} <i>tel:123</i></b> -- Display
- *     the phone dialer with the given number filled in.</p>
- *   </li>
- *   <li> <p><b>{@link #ACTION_EDIT} <i>content://contacts/people/1</i></b> -- Edit
- *     information about the person whose identifier is "1".</p>
- *   </li>
- *   <li> <p><b>{@link #ACTION_VIEW} <i>content://contacts/people/</i></b> -- Display
- *     a list of people, which the user can browse through.  This example is a
- *     typical top-level entry into the Contacts application, showing you the
- *     list of people. Selecting a particular person to view would result in a
- *     new intent { <b>{@link #ACTION_VIEW} <i>content://contacts/N</i></b> }
- *     being used to start an activity to display that person.</p>
- *   </li>
- * </ul>
- *
- * <p>In addition to these primary attributes, there are a number of secondary
- * attributes that you can also include with an intent:</p>
- *
- * <ul>
- *     <li> <p><b>category</b> -- Gives additional information about the action
- *         to execute.  For example, {@link #CATEGORY_LAUNCHER} means it should
- *         appear in the Launcher as a top-level application, while
- *         {@link #CATEGORY_ALTERNATIVE} means it should be included in a list
- *         of alternative actions the user can perform on a piece of data.</p>
- *     <li> <p><b>type</b> -- Specifies an explicit type (a MIME type) of the
- *         intent data.  Normally the type is inferred from the data itself.
- *         By setting this attribute, you disable that evaluation and force
- *         an explicit type.</p>
- *     <li> <p><b>component</b> -- Specifies an explicit name of a component
- *         class to use for the intent.  Normally this is determined by looking
- *         at the other information in the intent (the action, data/type, and
- *         categories) and matching that with a component that can handle it.
- *         If this attribute is set then none of the evaluation is performed,
- *         and this component is used exactly as is.  By specifying this attribute,
- *         all of the other Intent attributes become optional.</p>
- *     <li> <p><b>extras</b> -- This is a {@link Bundle} of any additional information.
- *         This can be used to provide extended information to the component.
- *         For example, if we have a action to send an e-mail message, we could
- *         also include extra pieces of data here to supply a subject, body,
- *         etc.</p>
- * </ul>
- *
- * <p>Here are some examples of other operations you can specify as intents
- * using these additional parameters:</p>
- *
- * <ul>
- *   <li> <p><b>{@link #ACTION_MAIN} with category {@link #CATEGORY_HOME}</b> --
- *     Launch the home screen.</p>
- *   </li>
- *   <li> <p><b>{@link #ACTION_GET_CONTENT} with MIME type
- *     <i>{@link android.provider.Contacts.Phones#CONTENT_URI
- *     vnd.android.cursor.item/phone}</i></b>
- *     -- Display the list of people's phone numbers, allowing the user to
- *     browse through them and pick one and return it to the parent activity.</p>
- *   </li>
- *   <li> <p><b>{@link #ACTION_GET_CONTENT} with MIME type
- *     <i>*{@literal /}*</i> and category {@link #CATEGORY_OPENABLE}</b>
- *     -- Display all pickers for data that can be opened with
- *     {@link ContentResolver#openInputStream(Uri) ContentResolver.openInputStream()},
- *     allowing the user to pick one of them and then some data inside of it
- *     and returning the resulting URI to the caller.  This can be used,
- *     for example, in an e-mail application to allow the user to pick some
- *     data to include as an attachment.</p>
- *   </li>
- * </ul>
- *
- * <p>There are a variety of standard Intent action and category constants
- * defined in the Intent class, but applications can also define their own.
- * These strings use java style scoping, to ensure they are unique -- for
- * example, the standard {@link #ACTION_VIEW} is called
- * "android.intent.action.VIEW".</p>
- *
- * <p>Put together, the set of actions, data types, categories, and extra data
- * defines a language for the system allowing for the expression of phrases
- * such as "call john smith's cell".  As applications are added to the system,
- * they can extend this language by adding new actions, types, and categories, or
- * they can modify the behavior of existing phrases by supplying their own
- * activities that handle them.</p>
- *
- * <a name="IntentResolution"></a>
- * <h3>Intent Resolution</h3>
- *
- * <p>There are two primary forms of intents you will use.
- *
- * <ul>
- *     <li> <p><b>Explicit Intents</b> have specified a component (via
- *     {@link #setComponent} or {@link #setClass}), which provides the exact
- *     class to be run.  Often these will not include any other information,
- *     simply being a way for an application to launch various internal
- *     activities it has as the user interacts with the application.
- *
- *     <li> <p><b>Implicit Intents</b> have not specified a component;
- *     instead, they must include enough information for the system to
- *     determine which of the available components is best to run for that
- *     intent.
- * </ul>
- *
- * <p>When using implicit intents, given such an arbitrary intent we need to
- * know what to do with it. This is handled by the process of <em>Intent
- * resolution</em>, which maps an Intent to an {@link android.app.Activity},
- * {@link BroadcastReceiver}, or {@link android.app.Service} (or sometimes two or
- * more activities/receivers) that can handle it.</p>
- *
- * <p>The intent resolution mechanism basically revolves around matching an
- * Intent against all of the &lt;intent-filter&gt; descriptions in the
- * installed application packages.  (Plus, in the case of broadcasts, any {@link BroadcastReceiver}
- * objects explicitly registered with {@link Context#registerReceiver}.)  More
- * details on this can be found in the documentation on the {@link
- * IntentFilter} class.</p>
- *
- * <p>There are three pieces of information in the Intent that are used for
- * resolution: the action, type, and category.  Using this information, a query
- * is done on the {@link PackageManager} for a component that can handle the
- * intent. The appropriate component is determined based on the intent
- * information supplied in the <code>AndroidManifest.xml</code> file as
- * follows:</p>
- *
- * <ul>
- *     <li> <p>The <b>action</b>, if given, must be listed by the component as
- *         one it handles.</p>
- *     <li> <p>The <b>type</b> is retrieved from the Intent's data, if not
- *         already supplied in the Intent.  Like the action, if a type is
- *         included in the intent (either explicitly or implicitly in its
- *         data), then this must be listed by the component as one it handles.</p>
- *     <li> For data that is not a <code>content:</code> URI and where no explicit
- *         type is included in the Intent, instead the <b>scheme</b> of the
- *         intent data (such as <code>http:</code> or <code>mailto:</code>) is
- *         considered. Again like the action, if we are matching a scheme it
- *         must be listed by the component as one it can handle.
- *     <li> <p>The <b>categories</b>, if supplied, must <em>all</em> be listed
- *         by the activity as categories it handles.  That is, if you include
- *         the categories {@link #CATEGORY_LAUNCHER} and
- *         {@link #CATEGORY_ALTERNATIVE}, then you will only resolve to components
- *         with an intent that lists <em>both</em> of those categories.
- *         Activities will very often need to support the
- *         {@link #CATEGORY_DEFAULT} so that they can be found by
- *         {@link Context#startActivity Context.startActivity()}.</p>
- * </ul>
- *
- * <p>For example, consider the Note Pad sample application that
- * allows user to browse through a list of notes data and view details about
- * individual items.  Text in italics indicate places were you would replace a
- * name with one specific to your own package.</p>
- *
- * <pre> &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
- *       package="<i>com.android.notepad</i>"&gt;
- *     &lt;application android:icon="@drawable/app_notes"
- *             android:label="@string/app_name"&gt;
- *
- *         &lt;provider class=".NotePadProvider"
- *                 android:authorities="<i>com.google.provider.NotePad</i>" /&gt;
- *
- *         &lt;activity class=".NotesList" android:label="@string/title_notes_list"&gt;
- *             &lt;intent-filter&gt;
- *                 &lt;action android:name="android.intent.action.MAIN" /&gt;
- *                 &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
- *             &lt;/intent-filter&gt;
- *             &lt;intent-filter&gt;
- *                 &lt;action android:name="android.intent.action.VIEW" /&gt;
- *                 &lt;action android:name="android.intent.action.EDIT" /&gt;
- *                 &lt;action android:name="android.intent.action.PICK" /&gt;
- *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
- *                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
- *             &lt;/intent-filter&gt;
- *             &lt;intent-filter&gt;
- *                 &lt;action android:name="android.intent.action.GET_CONTENT" /&gt;
- *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
- *                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
- *             &lt;/intent-filter&gt;
- *         &lt;/activity&gt;
- *
- *         &lt;activity class=".NoteEditor" android:label="@string/title_note"&gt;
- *             &lt;intent-filter android:label="@string/resolve_edit"&gt;
- *                 &lt;action android:name="android.intent.action.VIEW" /&gt;
- *                 &lt;action android:name="android.intent.action.EDIT" /&gt;
- *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
- *                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
- *             &lt;/intent-filter&gt;
- *
- *             &lt;intent-filter&gt;
- *                 &lt;action android:name="android.intent.action.INSERT" /&gt;
- *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
- *                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
- *             &lt;/intent-filter&gt;
- *
- *         &lt;/activity&gt;
- *
- *         &lt;activity class=".TitleEditor" android:label="@string/title_edit_title"
- *                 android:theme="@android:style/Theme.Dialog"&gt;
- *             &lt;intent-filter android:label="@string/resolve_title"&gt;
- *                 &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
- *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
- *                 &lt;category android:name="android.intent.category.ALTERNATIVE" /&gt;
- *                 &lt;category android:name="android.intent.category.SELECTED_ALTERNATIVE" /&gt;
- *                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
- *             &lt;/intent-filter&gt;
- *         &lt;/activity&gt;
- *
- *     &lt;/application&gt;
- * &lt;/manifest&gt;</pre>
- *
- * <p>The first activity,
- * <code>com.android.notepad.NotesList</code>, serves as our main
- * entry into the app.  It can do three things as described by its three intent
- * templates:
- * <ol>
- * <li><pre>
- * &lt;intent-filter&gt;
- *     &lt;action android:name="{@link #ACTION_MAIN android.intent.action.MAIN}" /&gt;
- *     &lt;category android:name="{@link #CATEGORY_LAUNCHER android.intent.category.LAUNCHER}" /&gt;
- * &lt;/intent-filter&gt;</pre>
- * <p>This provides a top-level entry into the NotePad application: the standard
- * MAIN action is a main entry point (not requiring any other information in
- * the Intent), and the LAUNCHER category says that this entry point should be
- * listed in the application launcher.</p>
- * <li><pre>
- * &lt;intent-filter&gt;
- *     &lt;action android:name="{@link #ACTION_VIEW android.intent.action.VIEW}" /&gt;
- *     &lt;action android:name="{@link #ACTION_EDIT android.intent.action.EDIT}" /&gt;
- *     &lt;action android:name="{@link #ACTION_PICK android.intent.action.PICK}" /&gt;
- *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
- *     &lt;data mimeType:name="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
- * &lt;/intent-filter&gt;</pre>
- * <p>This declares the things that the activity can do on a directory of
- * notes.  The type being supported is given with the &lt;type&gt; tag, where
- * <code>vnd.android.cursor.dir/vnd.google.note</code> is a URI from which
- * a Cursor of zero or more items (<code>vnd.android.cursor.dir</code>) can
- * be retrieved which holds our note pad data (<code>vnd.google.note</code>).
- * The activity allows the user to view or edit the directory of data (via
- * the VIEW and EDIT actions), or to pick a particular note and return it
- * to the caller (via the PICK action).  Note also the DEFAULT category
- * supplied here: this is <em>required</em> for the
- * {@link Context#startActivity Context.startActivity} method to resolve your
- * activity when its component name is not explicitly specified.</p>
- * <li><pre>
- * &lt;intent-filter&gt;
- *     &lt;action android:name="{@link #ACTION_GET_CONTENT android.intent.action.GET_CONTENT}" /&gt;
- *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
- *     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
- * &lt;/intent-filter&gt;</pre>
- * <p>This filter describes the ability return to the caller a note selected by
- * the user without needing to know where it came from.  The data type
- * <code>vnd.android.cursor.item/vnd.google.note</code> is a URI from which
- * a Cursor of exactly one (<code>vnd.android.cursor.item</code>) item can
- * be retrieved which contains our note pad data (<code>vnd.google.note</code>).
- * The GET_CONTENT action is similar to the PICK action, where the activity
- * will return to its caller a piece of data selected by the user.  Here,
- * however, the caller specifies the type of data they desire instead of
- * the type of data the user will be picking from.</p>
- * </ol>
- *
- * <p>Given these capabilities, the following intents will resolve to the
- * NotesList activity:</p>
- *
- * <ul>
- *     <li> <p><b>{ action=android.app.action.MAIN }</b> matches all of the
- *         activities that can be used as top-level entry points into an
- *         application.</p>
- *     <li> <p><b>{ action=android.app.action.MAIN,
- *         category=android.app.category.LAUNCHER }</b> is the actual intent
- *         used by the Launcher to populate its top-level list.</p>
- *     <li> <p><b>{ action=android.intent.action.VIEW
- *          data=content://com.google.provider.NotePad/notes }</b>
- *         displays a list of all the notes under
- *         "content://com.google.provider.NotePad/notes", which
- *         the user can browse through and see the details on.</p>
- *     <li> <p><b>{ action=android.app.action.PICK
- *          data=content://com.google.provider.NotePad/notes }</b>
- *         provides a list of the notes under
- *         "content://com.google.provider.NotePad/notes", from which
- *         the user can pick a note whose data URL is returned back to the caller.</p>
- *     <li> <p><b>{ action=android.app.action.GET_CONTENT
- *          type=vnd.android.cursor.item/vnd.google.note }</b>
- *         is similar to the pick action, but allows the caller to specify the
- *         kind of data they want back so that the system can find the appropriate
- *         activity to pick something of that data type.</p>
- * </ul>
- *
- * <p>The second activity,
- * <code>com.android.notepad.NoteEditor</code>, shows the user a single
- * note entry and allows them to edit it.  It can do two things as described
- * by its two intent templates:
- * <ol>
- * <li><pre>
- * &lt;intent-filter android:label="@string/resolve_edit"&gt;
- *     &lt;action android:name="{@link #ACTION_VIEW android.intent.action.VIEW}" /&gt;
- *     &lt;action android:name="{@link #ACTION_EDIT android.intent.action.EDIT}" /&gt;
- *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
- *     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
- * &lt;/intent-filter&gt;</pre>
- * <p>The first, primary, purpose of this activity is to let the user interact
- * with a single note, as decribed by the MIME type
- * <code>vnd.android.cursor.item/vnd.google.note</code>.  The activity can
- * either VIEW a note or allow the user to EDIT it.  Again we support the
- * DEFAULT category to allow the activity to be launched without explicitly
- * specifying its component.</p>
- * <li><pre>
- * &lt;intent-filter&gt;
- *     &lt;action android:name="{@link #ACTION_INSERT android.intent.action.INSERT}" /&gt;
- *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
- *     &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
- * &lt;/intent-filter&gt;</pre>
- * <p>The secondary use of this activity is to insert a new note entry into
- * an existing directory of notes.  This is used when the user creates a new
- * note: the INSERT action is executed on the directory of notes, causing
- * this activity to run and have the user create the new note data which
- * it then adds to the content provider.</p>
- * </ol>
- *
- * <p>Given these capabilities, the following intents will resolve to the
- * NoteEditor activity:</p>
- *
- * <ul>
- *     <li> <p><b>{ action=android.intent.action.VIEW
- *          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }</b>
- *         shows the user the content of note <var>{ID}</var>.</p>
- *     <li> <p><b>{ action=android.app.action.EDIT
- *          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }</b>
- *         allows the user to edit the content of note <var>{ID}</var>.</p>
- *     <li> <p><b>{ action=android.app.action.INSERT
- *          data=content://com.google.provider.NotePad/notes }</b>
- *         creates a new, empty note in the notes list at
- *         "content://com.google.provider.NotePad/notes"
- *         and allows the user to edit it.  If they keep their changes, the URI
- *         of the newly created note is returned to the caller.</p>
- * </ul>
- *
- * <p>The last activity,
- * <code>com.android.notepad.TitleEditor</code>, allows the user to
- * edit the title of a note.  This could be implemented as a class that the
- * application directly invokes (by explicitly setting its component in
- * the Intent), but here we show a way you can publish alternative
- * operations on existing data:</p>
- *
- * <pre>
- * &lt;intent-filter android:label="@string/resolve_title"&gt;
- *     &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
- *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
- *     &lt;category android:name="{@link #CATEGORY_ALTERNATIVE android.intent.category.ALTERNATIVE}" /&gt;
- *     &lt;category android:name="{@link #CATEGORY_SELECTED_ALTERNATIVE android.intent.category.SELECTED_ALTERNATIVE}" /&gt;
- *     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
- * &lt;/intent-filter&gt;</pre>
- *
- * <p>In the single intent template here, we
- * have created our own private action called
- * <code>com.android.notepad.action.EDIT_TITLE</code> which means to
- * edit the title of a note.  It must be invoked on a specific note
- * (data type <code>vnd.android.cursor.item/vnd.google.note</code>) like the previous
- * view and edit actions, but here displays and edits the title contained
- * in the note data.
- *
- * <p>In addition to supporting the default category as usual, our title editor
- * also supports two other standard categories: ALTERNATIVE and
- * SELECTED_ALTERNATIVE.  Implementing
- * these categories allows others to find the special action it provides
- * without directly knowing about it, through the
- * {@link android.content.pm.PackageManager#queryIntentActivityOptions} method, or
- * more often to build dynamic menu items with
- * {@link android.view.Menu#addIntentOptions}.  Note that in the intent
- * template here was also supply an explicit name for the template
- * (via <code>android:label="@string/resolve_title"</code>) to better control
- * what the user sees when presented with this activity as an alternative
- * action to the data they are viewing.
- *
- * <p>Given these capabilities, the following intent will resolve to the
- * TitleEditor activity:</p>
- *
- * <ul>
- *     <li> <p><b>{ action=com.android.notepad.action.EDIT_TITLE
- *          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }</b>
- *         displays and allows the user to edit the title associated
- *         with note <var>{ID}</var>.</p>
- * </ul>
- *
- * <h3>Standard Activity Actions</h3>
- *
- * <p>These are the current standard actions that Intent defines for launching
- * activities (usually through {@link Context#startActivity}.  The most
- * important, and by far most frequently used, are {@link #ACTION_MAIN} and
- * {@link #ACTION_EDIT}.
- *
- * <ul>
- *     <li> {@link #ACTION_MAIN}
- *     <li> {@link #ACTION_VIEW}
- *     <li> {@link #ACTION_ATTACH_DATA}
- *     <li> {@link #ACTION_EDIT}
- *     <li> {@link #ACTION_PICK}
- *     <li> {@link #ACTION_CHOOSER}
- *     <li> {@link #ACTION_GET_CONTENT}
- *     <li> {@link #ACTION_DIAL}
- *     <li> {@link #ACTION_CALL}
- *     <li> {@link #ACTION_SEND}
- *     <li> {@link #ACTION_SENDTO}
- *     <li> {@link #ACTION_ANSWER}
- *     <li> {@link #ACTION_INSERT}
- *     <li> {@link #ACTION_DELETE}
- *     <li> {@link #ACTION_RUN}
- *     <li> {@link #ACTION_SYNC}
- *     <li> {@link #ACTION_PICK_ACTIVITY}
- *     <li> {@link #ACTION_SEARCH}
- *     <li> {@link #ACTION_WEB_SEARCH}
- *     <li> {@link #ACTION_FACTORY_TEST}
- * </ul>
- *
- * <h3>Standard Broadcast Actions</h3>
- *
- * <p>These are the current standard actions that Intent defines for receiving
- * broadcasts (usually through {@link Context#registerReceiver} or a
- * &lt;receiver&gt; tag in a manifest).
- *
- * <ul>
- *     <li> {@link #ACTION_TIME_TICK}
- *     <li> {@link #ACTION_TIME_CHANGED}
- *     <li> {@link #ACTION_TIMEZONE_CHANGED}
- *     <li> {@link #ACTION_BOOT_COMPLETED}
- *     <li> {@link #ACTION_PACKAGE_ADDED}
- *     <li> {@link #ACTION_PACKAGE_CHANGED}
- *     <li> {@link #ACTION_PACKAGE_REMOVED}
- *     <li> {@link #ACTION_PACKAGE_RESTARTED}
- *     <li> {@link #ACTION_PACKAGE_DATA_CLEARED}
- *     <li> {@link #ACTION_UID_REMOVED}
- *     <li> {@link #ACTION_BATTERY_CHANGED}
- *     <li> {@link #ACTION_POWER_CONNECTED}
- *     <li> {@link #ACTION_POWER_DISCONNECTED}
- *     <li> {@link #ACTION_SHUTDOWN}
- * </ul>
- *
- * <h3>Standard Categories</h3>
- *
- * <p>These are the current standard categories that can be used to further
- * clarify an Intent via {@link #addCategory}.
- *
- * <ul>
- *     <li> {@link #CATEGORY_DEFAULT}
- *     <li> {@link #CATEGORY_BROWSABLE}
- *     <li> {@link #CATEGORY_TAB}
- *     <li> {@link #CATEGORY_ALTERNATIVE}
- *     <li> {@link #CATEGORY_SELECTED_ALTERNATIVE}
- *     <li> {@link #CATEGORY_LAUNCHER}
- *     <li> {@link #CATEGORY_INFO}
- *     <li> {@link #CATEGORY_HOME}
- *     <li> {@link #CATEGORY_PREFERENCE}
- *     <li> {@link #CATEGORY_TEST}
- *     <li> {@link #CATEGORY_CAR_DOCK}
- *     <li> {@link #CATEGORY_DESK_DOCK}
- *     <li> {@link #CATEGORY_LE_DESK_DOCK}
- *     <li> {@link #CATEGORY_HE_DESK_DOCK}
- *     <li> {@link #CATEGORY_CAR_MODE}
- *     <li> {@link #CATEGORY_APP_MARKET}
- * </ul>
- *
- * <h3>Standard Extra Data</h3>
- *
- * <p>These are the current standard fields that can be used as extra data via
- * {@link #putExtra}.
- *
- * <ul>
- *     <li> {@link #EXTRA_ALARM_COUNT}
- *     <li> {@link #EXTRA_BCC}
- *     <li> {@link #EXTRA_CC}
- *     <li> {@link #EXTRA_CHANGED_COMPONENT_NAME}
- *     <li> {@link #EXTRA_DATA_REMOVED}
- *     <li> {@link #EXTRA_DOCK_STATE}
- *     <li> {@link #EXTRA_DOCK_STATE_HE_DESK}
- *     <li> {@link #EXTRA_DOCK_STATE_LE_DESK}
- *     <li> {@link #EXTRA_DOCK_STATE_CAR}
- *     <li> {@link #EXTRA_DOCK_STATE_DESK}
- *     <li> {@link #EXTRA_DOCK_STATE_UNDOCKED}
- *     <li> {@link #EXTRA_DONT_KILL_APP}
- *     <li> {@link #EXTRA_EMAIL}
- *     <li> {@link #EXTRA_INITIAL_INTENTS}
- *     <li> {@link #EXTRA_INTENT}
- *     <li> {@link #EXTRA_KEY_EVENT}
- *     <li> {@link #EXTRA_ORIGINATING_URI}
- *     <li> {@link #EXTRA_PHONE_NUMBER}
- *     <li> {@link #EXTRA_REFERRER}
- *     <li> {@link #EXTRA_REMOTE_INTENT_TOKEN}
- *     <li> {@link #EXTRA_REPLACING}
- *     <li> {@link #EXTRA_SHORTCUT_ICON}
- *     <li> {@link #EXTRA_SHORTCUT_ICON_RESOURCE}
- *     <li> {@link #EXTRA_SHORTCUT_INTENT}
- *     <li> {@link #EXTRA_STREAM}
- *     <li> {@link #EXTRA_SHORTCUT_NAME}
- *     <li> {@link #EXTRA_SUBJECT}
- *     <li> {@link #EXTRA_TEMPLATE}
- *     <li> {@link #EXTRA_TEXT}
- *     <li> {@link #EXTRA_TITLE}
- *     <li> {@link #EXTRA_UID}
- * </ul>
- *
- * <h3>Flags</h3>
- *
- * <p>These are the possible flags that can be used in the Intent via
- * {@link #setFlags} and {@link #addFlags}.  See {@link #setFlags} for a list
- * of all possible flags.
- */
-public class Intent implements Parcelable, Cloneable {
-    // ---------------------------------------------------------------------
-    // ---------------------------------------------------------------------
-    // Standard intent activity actions (see action variable).
-
-    /**
-     *  Activity Action: Start as a main entry point, does not expect to
-     *  receive data.
-     *  <p>Input: nothing
-     *  <p>Output: nothing
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_MAIN = "android.intent.action.MAIN";
-
-    /**
-     * Activity Action: Display the data to the user.  This is the most common
-     * action performed on data -- it is the generic action you can use on
-     * a piece of data to get the most reasonable thing to occur.  For example,
-     * when used on a contacts entry it will view the entry; when used on a
-     * mailto: URI it will bring up a compose window filled with the information
-     * supplied by the URI; when used with a tel: URI it will invoke the
-     * dialer.
-     * <p>Input: {@link #getData} is URI from which to retrieve data.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_VIEW = "android.intent.action.VIEW";
-
-    /**
-     * A synonym for {@link #ACTION_VIEW}, the "standard" action that is
-     * performed on a piece of data.
-     */
-    public static final String ACTION_DEFAULT = ACTION_VIEW;
-
-    /**
-     * Used to indicate that some piece of data should be attached to some other
-     * place.  For example, image data could be attached to a contact.  It is up
-     * to the recipient to decide where the data should be attached; the intent
-     * does not specify the ultimate destination.
-     * <p>Input: {@link #getData} is URI of data to be attached.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_ATTACH_DATA = "android.intent.action.ATTACH_DATA";
-
-    /**
-     * Activity Action: Provide explicit editable access to the given data.
-     * <p>Input: {@link #getData} is URI of data to be edited.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_EDIT = "android.intent.action.EDIT";
-
-    /**
-     * Activity Action: Pick an existing item, or insert a new item, and then edit it.
-     * <p>Input: {@link #getType} is the desired MIME type of the item to create or edit.
-     * The extras can contain type specific data to pass through to the editing/creating
-     * activity.
-     * <p>Output: The URI of the item that was picked.  This must be a content:
-     * URI so that any receiver can access it.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_INSERT_OR_EDIT = "android.intent.action.INSERT_OR_EDIT";
-
-    /**
-     * Activity Action: Pick an item from the data, returning what was selected.
-     * <p>Input: {@link #getData} is URI containing a directory of data
-     * (vnd.android.cursor.dir/*) from which to pick an item.
-     * <p>Output: The URI of the item that was picked.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_PICK = "android.intent.action.PICK";
-
-    /**
-     * Activity Action: Creates a shortcut.
-     * <p>Input: Nothing.</p>
-     * <p>Output: An Intent representing the shortcut. The intent must contain three
-     * extras: SHORTCUT_INTENT (value: Intent), SHORTCUT_NAME (value: String),
-     * and SHORTCUT_ICON (value: Bitmap) or SHORTCUT_ICON_RESOURCE
-     * (value: ShortcutIconResource).</p>
-     *
-     * @see #EXTRA_SHORTCUT_INTENT
-     * @see #EXTRA_SHORTCUT_NAME
-     * @see #EXTRA_SHORTCUT_ICON
-     * @see #EXTRA_SHORTCUT_ICON_RESOURCE
-     * @see android.content.Intent.ShortcutIconResource
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_CREATE_SHORTCUT = "android.intent.action.CREATE_SHORTCUT";
-
-    /**
-     * The name of the extra used to define the Intent of a shortcut.
-     *
-     * @see #ACTION_CREATE_SHORTCUT
-     */
-    public static final String EXTRA_SHORTCUT_INTENT = "android.intent.extra.shortcut.INTENT";
-    /**
-     * The name of the extra used to define the name of a shortcut.
-     *
-     * @see #ACTION_CREATE_SHORTCUT
-     */
-    public static final String EXTRA_SHORTCUT_NAME = "android.intent.extra.shortcut.NAME";
-    /**
-     * The name of the extra used to define the icon, as a Bitmap, of a shortcut.
-     *
-     * @see #ACTION_CREATE_SHORTCUT
-     */
-    public static final String EXTRA_SHORTCUT_ICON = "android.intent.extra.shortcut.ICON";
-    /**
-     * The name of the extra used to define the icon, as a ShortcutIconResource, of a shortcut.
-     *
-     * @see #ACTION_CREATE_SHORTCUT
-     * @see android.content.Intent.ShortcutIconResource
-     */
-    public static final String EXTRA_SHORTCUT_ICON_RESOURCE =
-            "android.intent.extra.shortcut.ICON_RESOURCE";
-
-    /**
-     * Represents a shortcut/live folder icon resource.
-     *
-     * @see Intent#ACTION_CREATE_SHORTCUT
-     * @see Intent#EXTRA_SHORTCUT_ICON_RESOURCE
-     * @see android.provider.LiveFolders#ACTION_CREATE_LIVE_FOLDER
-     * @see android.provider.LiveFolders#EXTRA_LIVE_FOLDER_ICON
-     */
-    public static class ShortcutIconResource implements Parcelable {
-        /**
-         * The package name of the application containing the icon.
-         */
-        public String packageName;
-
-        /**
-         * The resource name of the icon, including package, name and type.
-         */
-        public String resourceName;
-
-        /**
-         * Creates a new ShortcutIconResource for the specified context and resource
-         * identifier.
-         *
-         * @param context The context of the application.
-         * @param resourceId The resource idenfitier for the icon.
-         * @return A new ShortcutIconResource with the specified's context package name
-         *         and icon resource idenfitier.
-         */
-        public static ShortcutIconResource fromContext(Context context, int resourceId) {
-            ShortcutIconResource icon = new ShortcutIconResource();
-            icon.packageName = context.getPackageName();
-            icon.resourceName = context.getResources().getResourceName(resourceId);
-            return icon;
-        }
-
-        /**
-         * Used to read a ShortcutIconResource from a Parcel.
-         */
-        public static final Parcelable.Creator<ShortcutIconResource> CREATOR =
-            new Parcelable.Creator<ShortcutIconResource>() {
-
-                public ShortcutIconResource createFromParcel(Parcel source) {
-                    ShortcutIconResource icon = new ShortcutIconResource();
-                    icon.packageName = source.readString();
-                    icon.resourceName = source.readString();
-                    return icon;
-                }
-
-                public ShortcutIconResource[] newArray(int size) {
-                    return new ShortcutIconResource[size];
-                }
-            };
-
-        /**
-         * No special parcel contents.
-         */
-        public int describeContents() {
-            return 0;
-        }
-
-        public void writeToParcel(Parcel dest, int flags) {
-            dest.writeString(packageName);
-            dest.writeString(resourceName);
-        }
-
-        @Override
-        public String toString() {
-            return resourceName;
-        }
-    }
-
-    /**
-     * Activity Action: Display an activity chooser, allowing the user to pick
-     * what they want to before proceeding.  This can be used as an alternative
-     * to the standard activity picker that is displayed by the system when
-     * you try to start an activity with multiple possible matches, with these
-     * differences in behavior:
-     * <ul>
-     * <li>You can specify the title that will appear in the activity chooser.
-     * <li>The user does not have the option to make one of the matching
-     * activities a preferred activity, and all possible activities will
-     * always be shown even if one of them is currently marked as the
-     * preferred activity.
-     * </ul>
-     * <p>
-     * This action should be used when the user will naturally expect to
-     * select an activity in order to proceed.  An example if when not to use
-     * it is when the user clicks on a "mailto:" link.  They would naturally
-     * expect to go directly to their mail app, so startActivity() should be
-     * called directly: it will
-     * either launch the current preferred app, or put up a dialog allowing the
-     * user to pick an app to use and optionally marking that as preferred.
-     * <p>
-     * In contrast, if the user is selecting a menu item to send a picture
-     * they are viewing to someone else, there are many different things they
-     * may want to do at this point: send it through e-mail, upload it to a
-     * web service, etc.  In this case the CHOOSER action should be used, to
-     * always present to the user a list of the things they can do, with a
-     * nice title given by the caller such as "Send this photo with:".
-     * <p>
-     * If you need to grant URI permissions through a chooser, you must specify
-     * the permissions to be granted on the ACTION_CHOOSER Intent
-     * <em>in addition</em> to the EXTRA_INTENT inside.  This means using
-     * {@link #setClipData} to specify the URIs to be granted as well as
-     * {@link #FLAG_GRANT_READ_URI_PERMISSION} and/or
-     * {@link #FLAG_GRANT_WRITE_URI_PERMISSION} as appropriate.
-     * <p>
-     * As a convenience, an Intent of this form can be created with the
-     * {@link #createChooser} function.
-     * <p>
-     * Input: No data should be specified.  get*Extra must have
-     * a {@link #EXTRA_INTENT} field containing the Intent being executed,
-     * and can optionally have a {@link #EXTRA_TITLE} field containing the
-     * title text to display in the chooser.
-     * <p>
-     * Output: Depends on the protocol of {@link #EXTRA_INTENT}.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_CHOOSER = "android.intent.action.CHOOSER";
-
-    /**
-     * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
-     *
-     * <p>Builds a new {@link #ACTION_CHOOSER} Intent that wraps the given
-     * target intent, also optionally supplying a title.  If the target
-     * intent has specified {@link #FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, then these flags will also be
-     * set in the returned chooser intent, with its ClipData set appropriately:
-     * either a direct reflection of {@link #getClipData()} if that is non-null,
-     * or a new ClipData build from {@link #getData()}.
-     *
-     * @param target The Intent that the user will be selecting an activity
-     * to perform.
-     * @param title Optional title that will be displayed in the chooser.
-     * @return Return a new Intent object that you can hand to
-     * {@link Context#startActivity(Intent) Context.startActivity()} and
-     * related methods.
-     */
-    public static Intent createChooser(Intent target, CharSequence title) {
-        Intent intent = new Intent(ACTION_CHOOSER);
-        intent.putExtra(EXTRA_INTENT, target);
-        if (title != null) {
-            intent.putExtra(EXTRA_TITLE, title);
-        }
-
-        // Migrate any clip data and flags from target.
-        int permFlags = target.getFlags()
-                & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);
-        if (permFlags != 0) {
-            ClipData targetClipData = target.getClipData();
-            if (targetClipData == null && target.getData() != null) {
-                ClipData.Item item = new ClipData.Item(target.getData());
-                String[] mimeTypes;
-                if (target.getType() != null) {
-                    mimeTypes = new String[] { target.getType() };
-                } else {
-                    mimeTypes = new String[] { };
-                }
-                targetClipData = new ClipData(null, mimeTypes, item);
-            }
-            if (targetClipData != null) {
-                intent.setClipData(targetClipData);
-                intent.addFlags(permFlags);
-            }
-        }
-
-        return intent;
-    }
-
-    /**
-     * Activity Action: Allow the user to select a particular kind of data and
-     * return it.  This is different than {@link #ACTION_PICK} in that here we
-     * just say what kind of data is desired, not a URI of existing data from
-     * which the user can pick.  A ACTION_GET_CONTENT could allow the user to
-     * create the data as it runs (for example taking a picture or recording a
-     * sound), let them browse over the web and download the desired data,
-     * etc.
-     * <p>
-     * There are two main ways to use this action: if you want a specific kind
-     * of data, such as a person contact, you set the MIME type to the kind of
-     * data you want and launch it with {@link Context#startActivity(Intent)}.
-     * The system will then launch the best application to select that kind
-     * of data for you.
-     * <p>
-     * You may also be interested in any of a set of types of content the user
-     * can pick.  For example, an e-mail application that wants to allow the
-     * user to add an attachment to an e-mail message can use this action to
-     * bring up a list of all of the types of content the user can attach.
-     * <p>
-     * In this case, you should wrap the GET_CONTENT intent with a chooser
-     * (through {@link #createChooser}), which will give the proper interface
-     * for the user to pick how to send your data and allow you to specify
-     * a prompt indicating what they are doing.  You will usually specify a
-     * broad MIME type (such as image/* or {@literal *}/*), resulting in a
-     * broad range of content types the user can select from.
-     * <p>
-     * When using such a broad GET_CONTENT action, it is often desirable to
-     * only pick from data that can be represented as a stream.  This is
-     * accomplished by requiring the {@link #CATEGORY_OPENABLE} in the Intent.
-     * <p>
-     * Callers can optionally specify {@link #EXTRA_LOCAL_ONLY} to request that
-     * the launched content chooser only returns results representing data that
-     * is locally available on the device.  For example, if this extra is set
-     * to true then an image picker should not show any pictures that are available
-     * from a remote server but not already on the local device (thus requiring
-     * they be downloaded when opened).
-     * <p>
-     * Input: {@link #getType} is the desired MIME type to retrieve.  Note
-     * that no URI is supplied in the intent, as there are no constraints on
-     * where the returned data originally comes from.  You may also include the
-     * {@link #CATEGORY_OPENABLE} if you can only accept data that can be
-     * opened as a stream.  You may use {@link #EXTRA_LOCAL_ONLY} to limit content
-     * selection to local data.
-     * <p>
-     * Output: The URI of the item that was picked.  This must be a content:
-     * URI so that any receiver can access it.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_GET_CONTENT = "android.intent.action.GET_CONTENT";
-    /**
-     * Activity Action: Dial a number as specified by the data.  This shows a
-     * UI with the number being dialed, allowing the user to explicitly
-     * initiate the call.
-     * <p>Input: If nothing, an empty dialer is started; else {@link #getData}
-     * is URI of a phone number to be dialed or a tel: URI of an explicit phone
-     * number.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_DIAL = "android.intent.action.DIAL";
-    /**
-     * Activity Action: Perform a call to someone specified by the data.
-     * <p>Input: If nothing, an empty dialer is started; else {@link #getData}
-     * is URI of a phone number to be dialed or a tel: URI of an explicit phone
-     * number.
-     * <p>Output: nothing.
-     *
-     * <p>Note: there will be restrictions on which applications can initiate a
-     * call; most applications should use the {@link #ACTION_DIAL}.
-     * <p>Note: this Intent <strong>cannot</strong> be used to call emergency
-     * numbers.  Applications can <strong>dial</strong> emergency numbers using
-     * {@link #ACTION_DIAL}, however.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_CALL = "android.intent.action.CALL";
-    /**
-     * Activity Action: Perform a call to an emergency number specified by the
-     * data.
-     * <p>Input: {@link #getData} is URI of a phone number to be dialed or a
-     * tel: URI of an explicit phone number.
-     * <p>Output: nothing.
-     * @hide
-     */
-    public static final String ACTION_CALL_EMERGENCY = "android.intent.action.CALL_EMERGENCY";
-    /**
-     * Activity action: Perform a call to any number (emergency or not)
-     * specified by the data.
-     * <p>Input: {@link #getData} is URI of a phone number to be dialed or a
-     * tel: URI of an explicit phone number.
-     * <p>Output: nothing.
-     * @hide
-     */
-    public static final String ACTION_CALL_PRIVILEGED = "android.intent.action.CALL_PRIVILEGED";
-    /**
-     * Activity Action: Send a message to someone specified by the data.
-     * <p>Input: {@link #getData} is URI describing the target.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SENDTO = "android.intent.action.SENDTO";
-    /**
-     * Activity Action: Deliver some data to someone else.  Who the data is
-     * being delivered to is not specified; it is up to the receiver of this
-     * action to ask the user where the data should be sent.
-     * <p>
-     * When launching a SEND intent, you should usually wrap it in a chooser
-     * (through {@link #createChooser}), which will give the proper interface
-     * for the user to pick how to send your data and allow you to specify
-     * a prompt indicating what they are doing.
-     * <p>
-     * Input: {@link #getType} is the MIME type of the data being sent.
-     * get*Extra can have either a {@link #EXTRA_TEXT}
-     * or {@link #EXTRA_STREAM} field, containing the data to be sent.  If
-     * using EXTRA_TEXT, the MIME type should be "text/plain"; otherwise it
-     * should be the MIME type of the data in EXTRA_STREAM.  Use {@literal *}/*
-     * if the MIME type is unknown (this will only allow senders that can
-     * handle generic data streams).  If using {@link #EXTRA_TEXT}, you can
-     * also optionally supply {@link #EXTRA_HTML_TEXT} for clients to retrieve
-     * your text with HTML formatting.
-     * <p>
-     * As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, the data
-     * being sent can be supplied through {@link #setClipData(ClipData)}.  This
-     * allows you to use {@link #FLAG_GRANT_READ_URI_PERMISSION} when sharing
-     * content: URIs and other advanced features of {@link ClipData}.  If
-     * using this approach, you still must supply the same data through the
-     * {@link #EXTRA_TEXT} or {@link #EXTRA_STREAM} fields described below
-     * for compatibility with old applications.  If you don't set a ClipData,
-     * it will be copied there for you when calling {@link Context#startActivity(Intent)}.
-     * <p>
-     * Optional standard extras, which may be interpreted by some recipients as
-     * appropriate, are: {@link #EXTRA_EMAIL}, {@link #EXTRA_CC},
-     * {@link #EXTRA_BCC}, {@link #EXTRA_SUBJECT}.
-     * <p>
-     * Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SEND = "android.intent.action.SEND";
-    /**
-     * Activity Action: Deliver multiple data to someone else.
-     * <p>
-     * Like {@link #ACTION_SEND}, except the data is multiple.
-     * <p>
-     * Input: {@link #getType} is the MIME type of the data being sent.
-     * get*ArrayListExtra can have either a {@link #EXTRA_TEXT} or {@link
-     * #EXTRA_STREAM} field, containing the data to be sent.  If using
-     * {@link #EXTRA_TEXT}, you can also optionally supply {@link #EXTRA_HTML_TEXT}
-     * for clients to retrieve your text with HTML formatting.
-     * <p>
-     * Multiple types are supported, and receivers should handle mixed types
-     * whenever possible. The right way for the receiver to check them is to
-     * use the content resolver on each URI. The intent sender should try to
-     * put the most concrete mime type in the intent type, but it can fall
-     * back to {@literal <type>/*} or {@literal *}/* as needed.
-     * <p>
-     * e.g. if you are sending image/jpg and image/jpg, the intent's type can
-     * be image/jpg, but if you are sending image/jpg and image/png, then the
-     * intent's type should be image/*.
-     * <p>
-     * As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, the data
-     * being sent can be supplied through {@link #setClipData(ClipData)}.  This
-     * allows you to use {@link #FLAG_GRANT_READ_URI_PERMISSION} when sharing
-     * content: URIs and other advanced features of {@link ClipData}.  If
-     * using this approach, you still must supply the same data through the
-     * {@link #EXTRA_TEXT} or {@link #EXTRA_STREAM} fields described below
-     * for compatibility with old applications.  If you don't set a ClipData,
-     * it will be copied there for you when calling {@link Context#startActivity(Intent)}.
-     * <p>
-     * Optional standard extras, which may be interpreted by some recipients as
-     * appropriate, are: {@link #EXTRA_EMAIL}, {@link #EXTRA_CC},
-     * {@link #EXTRA_BCC}, {@link #EXTRA_SUBJECT}.
-     * <p>
-     * Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SEND_MULTIPLE = "android.intent.action.SEND_MULTIPLE";
-    /**
-     * Activity Action: Handle an incoming phone call.
-     * <p>Input: nothing.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_ANSWER = "android.intent.action.ANSWER";
-    /**
-     * Activity Action: Insert an empty item into the given container.
-     * <p>Input: {@link #getData} is URI of the directory (vnd.android.cursor.dir/*)
-     * in which to place the data.
-     * <p>Output: URI of the new data that was created.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_INSERT = "android.intent.action.INSERT";
-    /**
-     * Activity Action: Create a new item in the given container, initializing it
-     * from the current contents of the clipboard.
-     * <p>Input: {@link #getData} is URI of the directory (vnd.android.cursor.dir/*)
-     * in which to place the data.
-     * <p>Output: URI of the new data that was created.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_PASTE = "android.intent.action.PASTE";
-    /**
-     * Activity Action: Delete the given data from its container.
-     * <p>Input: {@link #getData} is URI of data to be deleted.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_DELETE = "android.intent.action.DELETE";
-    /**
-     * Activity Action: Run the data, whatever that means.
-     * <p>Input: ?  (Note: this is currently specific to the test harness.)
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_RUN = "android.intent.action.RUN";
-    /**
-     * Activity Action: Perform a data synchronization.
-     * <p>Input: ?
-     * <p>Output: ?
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SYNC = "android.intent.action.SYNC";
-    /**
-     * Activity Action: Pick an activity given an intent, returning the class
-     * selected.
-     * <p>Input: get*Extra field {@link #EXTRA_INTENT} is an Intent
-     * used with {@link PackageManager#queryIntentActivities} to determine the
-     * set of activities from which to pick.
-     * <p>Output: Class name of the activity that was selected.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_PICK_ACTIVITY = "android.intent.action.PICK_ACTIVITY";
-    /**
-     * Activity Action: Perform a search.
-     * <p>Input: {@link android.app.SearchManager#QUERY getStringExtra(SearchManager.QUERY)}
-     * is the text to search for.  If empty, simply
-     * enter your search results Activity with the search UI activated.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SEARCH = "android.intent.action.SEARCH";
-    /**
-     * Activity Action: Start the platform-defined tutorial
-     * <p>Input: {@link android.app.SearchManager#QUERY getStringExtra(SearchManager.QUERY)}
-     * is the text to search for.  If empty, simply
-     * enter your search results Activity with the search UI activated.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SYSTEM_TUTORIAL = "android.intent.action.SYSTEM_TUTORIAL";
-    /**
-     * Activity Action: Perform a web search.
-     * <p>
-     * Input: {@link android.app.SearchManager#QUERY
-     * getStringExtra(SearchManager.QUERY)} is the text to search for. If it is
-     * a url starts with http or https, the site will be opened. If it is plain
-     * text, Google search will be applied.
-     * <p>
-     * Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_WEB_SEARCH = "android.intent.action.WEB_SEARCH";
-    /**
-     * Activity Action: Perform assist action.
-     * <p>
-     * Input: nothing
-     * Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_ASSIST = "android.intent.action.ASSIST";
-    /**
-     * Activity Action: List all available applications
-     * <p>Input: Nothing.
-     * <p>Output: nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_ALL_APPS = "android.intent.action.ALL_APPS";
-    /**
-     * Activity Action: Show settings for choosing wallpaper
-     * <p>Input: Nothing.
-     * <p>Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SET_WALLPAPER = "android.intent.action.SET_WALLPAPER";
-
-    /**
-     * Activity Action: Show activity for reporting a bug.
-     * <p>Input: Nothing.
-     * <p>Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_BUG_REPORT = "android.intent.action.BUG_REPORT";
-
-    /**
-     *  Activity Action: Main entry point for factory tests.  Only used when
-     *  the device is booting in factory test node.  The implementing package
-     *  must be installed in the system image.
-     *  <p>Input: nothing
-     *  <p>Output: nothing
-     */
-    public static final String ACTION_FACTORY_TEST = "android.intent.action.FACTORY_TEST";
-
-    /**
-     * Activity Action: The user pressed the "call" button to go to the dialer
-     * or other appropriate UI for placing a call.
-     * <p>Input: Nothing.
-     * <p>Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_CALL_BUTTON = "android.intent.action.CALL_BUTTON";
-
-    /**
-     * Activity Action: Start Voice Command.
-     * <p>Input: Nothing.
-     * <p>Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_VOICE_COMMAND = "android.intent.action.VOICE_COMMAND";
-
-    /**
-     * Activity Action: Start action associated with long pressing on the
-     * search key.
-     * <p>Input: Nothing.
-     * <p>Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SEARCH_LONG_PRESS = "android.intent.action.SEARCH_LONG_PRESS";
-
-    /**
-     * Activity Action: The user pressed the "Report" button in the crash/ANR dialog.
-     * This intent is delivered to the package which installed the application, usually
-     * Google Play.
-     * <p>Input: No data is specified. The bug report is passed in using
-     * an {@link #EXTRA_BUG_REPORT} field.
-     * <p>Output: Nothing.
-     *
-     * @see #EXTRA_BUG_REPORT
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_APP_ERROR = "android.intent.action.APP_ERROR";
-
-    /**
-     * Activity Action: Show power usage information to the user.
-     * <p>Input: Nothing.
-     * <p>Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_POWER_USAGE_SUMMARY = "android.intent.action.POWER_USAGE_SUMMARY";
-
-    /**
-     * Activity Action: Setup wizard to launch after a platform update.  This
-     * activity should have a string meta-data field associated with it,
-     * {@link #METADATA_SETUP_VERSION}, which defines the current version of
-     * the platform for setup.  The activity will be launched only if
-     * {@link android.provider.Settings.Secure#LAST_SETUP_SHOWN} is not the
-     * same value.
-     * <p>Input: Nothing.
-     * <p>Output: Nothing.
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_UPGRADE_SETUP = "android.intent.action.UPGRADE_SETUP";
-
-    /**
-     * Activity Action: Show settings for managing network data usage of a
-     * specific application. Applications should define an activity that offers
-     * options to control data usage.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_MANAGE_NETWORK_USAGE =
-            "android.intent.action.MANAGE_NETWORK_USAGE";
-
-    /**
-     * Activity Action: Launch application installer.
-     * <p>
-     * Input: The data must be a content: or file: URI at which the application
-     * can be retrieved.  As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1},
-     * you can also use "package:<package-name>" to install an application for the
-     * current user that is already installed for another user. You can optionally supply
-     * {@link #EXTRA_INSTALLER_PACKAGE_NAME}, {@link #EXTRA_NOT_UNKNOWN_SOURCE},
-     * {@link #EXTRA_ALLOW_REPLACE}, and {@link #EXTRA_RETURN_RESULT}.
-     * <p>
-     * Output: If {@link #EXTRA_RETURN_RESULT}, returns whether the install
-     * succeeded.
-     *
-     * @see #EXTRA_INSTALLER_PACKAGE_NAME
-     * @see #EXTRA_NOT_UNKNOWN_SOURCE
-     * @see #EXTRA_RETURN_RESULT
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_INSTALL_PACKAGE = "android.intent.action.INSTALL_PACKAGE";
-
-    /**
-     * Used as a string extra field with {@link #ACTION_INSTALL_PACKAGE} to install a
-     * package.  Specifies the installer package name; this package will receive the
-     * {@link #ACTION_APP_ERROR} intent.
-     */
-    public static final String EXTRA_INSTALLER_PACKAGE_NAME
-            = "android.intent.extra.INSTALLER_PACKAGE_NAME";
-
-    /**
-     * Used as a boolean extra field with {@link #ACTION_INSTALL_PACKAGE} to install a
-     * package.  Specifies that the application being installed should not be
-     * treated as coming from an unknown source, but as coming from the app
-     * invoking the Intent.  For this to work you must start the installer with
-     * startActivityForResult().
-     */
-    public static final String EXTRA_NOT_UNKNOWN_SOURCE
-            = "android.intent.extra.NOT_UNKNOWN_SOURCE";
-
-    /**
-     * Used as a URI extra field with {@link #ACTION_INSTALL_PACKAGE} and
-     * {@link #ACTION_VIEW} to indicate the URI from which the local APK in the Intent
-     * data field originated from.
-     */
-    public static final String EXTRA_ORIGINATING_URI
-            = "android.intent.extra.ORIGINATING_URI";
-
-    /**
-     * Used as a URI extra field with {@link #ACTION_INSTALL_PACKAGE} and
-     * {@link #ACTION_VIEW} to indicate the HTTP referrer URI associated with the Intent
-     * data field or {@link #EXTRA_ORIGINATING_URI}.
-     */
-    public static final String EXTRA_REFERRER
-            = "android.intent.extra.REFERRER";
-
-    /**
-     * Used as an int extra field with {@link #ACTION_INSTALL_PACKAGE} and
-     * {@link} #ACTION_VIEW} to indicate the uid of the package that initiated the install
-     * @hide
-     */
-    public static final String EXTRA_ORIGINATING_UID
-            = "android.intent.extra.ORIGINATING_UID";
-
-    /**
-     * Used as a boolean extra field with {@link #ACTION_INSTALL_PACKAGE} to install a
-     * package.  Tells the installer UI to skip the confirmation with the user
-     * if the .apk is replacing an existing one.
-     * @deprecated As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, Android
-     * will no longer show an interstitial message about updating existing
-     * applications so this is no longer needed.
-     */
-    @Deprecated
-    public static final String EXTRA_ALLOW_REPLACE
-            = "android.intent.extra.ALLOW_REPLACE";
-
-    /**
-     * Used as a boolean extra field with {@link #ACTION_INSTALL_PACKAGE} or
-     * {@link #ACTION_UNINSTALL_PACKAGE}.  Specifies that the installer UI should
-     * return to the application the result code of the install/uninstall.  The returned result
-     * code will be {@link android.app.Activity#RESULT_OK} on success or
-     * {@link android.app.Activity#RESULT_FIRST_USER} on failure.
-     */
-    public static final String EXTRA_RETURN_RESULT
-            = "android.intent.extra.RETURN_RESULT";
-
-    /**
-     * Package manager install result code.  @hide because result codes are not
-     * yet ready to be exposed.
-     */
-    public static final String EXTRA_INSTALL_RESULT
-            = "android.intent.extra.INSTALL_RESULT";
-
-    /**
-     * Activity Action: Launch application uninstaller.
-     * <p>
-     * Input: The data must be a package: URI whose scheme specific part is
-     * the package name of the current installed package to be uninstalled.
-     * You can optionally supply {@link #EXTRA_RETURN_RESULT}.
-     * <p>
-     * Output: If {@link #EXTRA_RETURN_RESULT}, returns whether the install
-     * succeeded.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_UNINSTALL_PACKAGE = "android.intent.action.UNINSTALL_PACKAGE";
-
-    /**
-     * Specify whether the package should be uninstalled for all users.
-     * @hide because these should not be part of normal application flow.
-     */
-    public static final String EXTRA_UNINSTALL_ALL_USERS
-            = "android.intent.extra.UNINSTALL_ALL_USERS";
-
-    /**
-     * A string associated with a {@link #ACTION_UPGRADE_SETUP} activity
-     * describing the last run version of the platform that was setup.
-     * @hide
-     */
-    public static final String METADATA_SETUP_VERSION = "android.SETUP_VERSION";
-
-    // ---------------------------------------------------------------------
-    // ---------------------------------------------------------------------
-    // Standard intent broadcast actions (see action variable).
-
-    /**
-     * Broadcast Action: Sent after the screen turns off.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_SCREEN_OFF = "android.intent.action.SCREEN_OFF";
-    /**
-     * Broadcast Action: Sent after the screen turns on.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_SCREEN_ON = "android.intent.action.SCREEN_ON";
-
-    /**
-     * Broadcast Action: Sent after the system stops dreaming.
-     *
-     * <p class="note">This is a protected intent that can only be sent by the system.
-     * It is only sent to registered receivers.</p>
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_DREAMING_STOPPED = "android.intent.action.DREAMING_STOPPED";
-
-    /**
-     * Broadcast Action: Sent after the system starts dreaming.
-     *
-     * <p class="note">This is a protected intent that can only be sent by the system.
-     * It is only sent to registered receivers.</p>
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_DREAMING_STARTED = "android.intent.action.DREAMING_STARTED";
-
-    /**
-     * Broadcast Action: Sent when the user is present after device wakes up (e.g when the
-     * keyguard is gone).
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_USER_PRESENT = "android.intent.action.USER_PRESENT";
-
-    /**
-     * Broadcast Action: The current time has changed.  Sent every
-     * minute.  You can <em>not</em> receive this through components declared
-     * in manifests, only by exlicitly registering for it with
-     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
-     * Context.registerReceiver()}.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_TIME_TICK = "android.intent.action.TIME_TICK";
-    /**
-     * Broadcast Action: The time was set.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_TIME_CHANGED = "android.intent.action.TIME_SET";
-    /**
-     * Broadcast Action: The date has changed.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_DATE_CHANGED = "android.intent.action.DATE_CHANGED";
-    /**
-     * Broadcast Action: The timezone has changed. The intent will have the following extra values:</p>
-     * <ul>
-     *   <li><em>time-zone</em> - The java.util.TimeZone.getID() value identifying the new time zone.</li>
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_TIMEZONE_CHANGED = "android.intent.action.TIMEZONE_CHANGED";
-    /**
-     * Clear DNS Cache Action: This is broadcast when networks have changed and old
-     * DNS entries should be tossed.
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_CLEAR_DNS_CACHE = "android.intent.action.CLEAR_DNS_CACHE";
-    /**
-     * Alarm Changed Action: This is broadcast when the AlarmClock
-     * application's alarm is set or unset.  It is used by the
-     * AlarmClock application and the StatusBar service.
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_ALARM_CHANGED = "android.intent.action.ALARM_CHANGED";
-    /**
-     * Sync State Changed Action: This is broadcast when the sync starts or stops or when one has
-     * been failing for a long time.  It is used by the SyncManager and the StatusBar service.
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_SYNC_STATE_CHANGED
-            = "android.intent.action.SYNC_STATE_CHANGED";
-    /**
-     * Broadcast Action: This is broadcast once, after the system has finished
-     * booting.  It can be used to perform application-specific initialization,
-     * such as installing alarms.  You must hold the
-     * {@link android.Manifest.permission#RECEIVE_BOOT_COMPLETED} permission
-     * in order to receive this broadcast.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_BOOT_COMPLETED = "android.intent.action.BOOT_COMPLETED";
-    /**
-     * Broadcast Action: This is broadcast when a user action should request a
-     * temporary system dialog to dismiss.  Some examples of temporary system
-     * dialogs are the notification window-shade and the recent tasks dialog.
-     */
-    public static final String ACTION_CLOSE_SYSTEM_DIALOGS = "android.intent.action.CLOSE_SYSTEM_DIALOGS";
-    /**
-     * Broadcast Action: Trigger the download and eventual installation
-     * of a package.
-     * <p>Input: {@link #getData} is the URI of the package file to download.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     *
-     * @deprecated This constant has never been used.
-     */
-    @Deprecated
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_INSTALL = "android.intent.action.PACKAGE_INSTALL";
-    /**
-     * Broadcast Action: A new application package has been installed on the
-     * device. The data contains the name of the package.  Note that the
-     * newly installed package does <em>not</em> receive this broadcast.
-     * <p>May include the following extras:
-     * <ul>
-     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
-     * <li> {@link #EXTRA_REPLACING} is set to true if this is following
-     * an {@link #ACTION_PACKAGE_REMOVED} broadcast for the same package.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_ADDED = "android.intent.action.PACKAGE_ADDED";
-    /**
-     * Broadcast Action: A new version of an application package has been
-     * installed, replacing an existing version that was previously installed.
-     * The data contains the name of the package.
-     * <p>May include the following extras:
-     * <ul>
-     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_REPLACED = "android.intent.action.PACKAGE_REPLACED";
-    /**
-     * Broadcast Action: A new version of your application has been installed
-     * over an existing one.  This is only sent to the application that was
-     * replaced.  It does not contain any additional data; to receive it, just
-     * use an intent filter for this action.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MY_PACKAGE_REPLACED = "android.intent.action.MY_PACKAGE_REPLACED";
-    /**
-     * Broadcast Action: An existing application package has been removed from
-     * the device.  The data contains the name of the package.  The package
-     * that is being installed does <em>not</em> receive this Intent.
-     * <ul>
-     * <li> {@link #EXTRA_UID} containing the integer uid previously assigned
-     * to the package.
-     * <li> {@link #EXTRA_DATA_REMOVED} is set to true if the entire
-     * application -- data and code -- is being removed.
-     * <li> {@link #EXTRA_REPLACING} is set to true if this will be followed
-     * by an {@link #ACTION_PACKAGE_ADDED} broadcast for the same package.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_REMOVED = "android.intent.action.PACKAGE_REMOVED";
-    /**
-     * Broadcast Action: An existing application package has been completely
-     * removed from the device.  The data contains the name of the package.
-     * This is like {@link #ACTION_PACKAGE_REMOVED}, but only set when
-     * {@link #EXTRA_DATA_REMOVED} is true and
-     * {@link #EXTRA_REPLACING} is false of that broadcast.
-     *
-     * <ul>
-     * <li> {@link #EXTRA_UID} containing the integer uid previously assigned
-     * to the package.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_FULLY_REMOVED
-            = "android.intent.action.PACKAGE_FULLY_REMOVED";
-    /**
-     * Broadcast Action: An existing application package has been changed (e.g.
-     * a component has been enabled or disabled).  The data contains the name of
-     * the package.
-     * <ul>
-     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
-     * <li> {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST} containing the class name
-     * of the changed components.
-     * <li> {@link #EXTRA_DONT_KILL_APP} containing boolean field to override the
-     * default action of restarting the application.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_CHANGED = "android.intent.action.PACKAGE_CHANGED";
-    /**
-     * @hide
-     * Broadcast Action: Ask system services if there is any reason to
-     * restart the given package.  The data contains the name of the
-     * package.
-     * <ul>
-     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
-     * <li> {@link #EXTRA_PACKAGES} String array of all packages to check.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_QUERY_PACKAGE_RESTART = "android.intent.action.QUERY_PACKAGE_RESTART";
-    /**
-     * Broadcast Action: The user has restarted a package, and all of its
-     * processes have been killed.  All runtime state
-     * associated with it (processes, alarms, notifications, etc) should
-     * be removed.  Note that the restarted package does <em>not</em>
-     * receive this broadcast.
-     * The data contains the name of the package.
-     * <ul>
-     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_RESTARTED = "android.intent.action.PACKAGE_RESTARTED";
-    /**
-     * Broadcast Action: The user has cleared the data of a package.  This should
-     * be preceded by {@link #ACTION_PACKAGE_RESTARTED}, after which all of
-     * its persistent data is erased and this broadcast sent.
-     * Note that the cleared package does <em>not</em>
-     * receive this broadcast. The data contains the name of the package.
-     * <ul>
-     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_DATA_CLEARED = "android.intent.action.PACKAGE_DATA_CLEARED";
-    /**
-     * Broadcast Action: A user ID has been removed from the system.  The user
-     * ID number is stored in the extra data under {@link #EXTRA_UID}.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_UID_REMOVED = "android.intent.action.UID_REMOVED";
-
-    /**
-     * Broadcast Action: Sent to the installer package of an application
-     * when that application is first launched (that is the first time it
-     * is moved out of the stopped state).  The data contains the name of the package.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_FIRST_LAUNCH = "android.intent.action.PACKAGE_FIRST_LAUNCH";
-
-    /**
-     * Broadcast Action: Sent to the system package verifier when a package
-     * needs to be verified. The data contains the package URI.
-     * <p class="note">
-     * This is a protected intent that can only be sent by the system.
-     * </p>
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_NEEDS_VERIFICATION = "android.intent.action.PACKAGE_NEEDS_VERIFICATION";
-
-    /**
-     * Broadcast Action: Sent to the system package verifier when a package is
-     * verified. The data contains the package URI.
-     * <p class="note">
-     * This is a protected intent that can only be sent by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PACKAGE_VERIFIED = "android.intent.action.PACKAGE_VERIFIED";
-
-    /**
-     * Broadcast Action: Resources for a set of packages (which were
-     * previously unavailable) are currently
-     * available since the media on which they exist is available.
-     * The extra data {@link #EXTRA_CHANGED_PACKAGE_LIST} contains a
-     * list of packages whose availability changed.
-     * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
-     * list of uids of packages whose availability changed.
-     * Note that the
-     * packages in this list do <em>not</em> receive this broadcast.
-     * The specified set of packages are now available on the system.
-     * <p>Includes the following extras:
-     * <ul>
-     * <li> {@link #EXTRA_CHANGED_PACKAGE_LIST} is the set of packages
-     * whose resources(were previously unavailable) are currently available.
-     * {@link #EXTRA_CHANGED_UID_LIST} is the set of uids of the
-     * packages whose resources(were previously unavailable)
-     * are  currently available.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_EXTERNAL_APPLICATIONS_AVAILABLE =
-        "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
-
-    /**
-     * Broadcast Action: Resources for a set of packages are currently
-     * unavailable since the media on which they exist is unavailable.
-     * The extra data {@link #EXTRA_CHANGED_PACKAGE_LIST} contains a
-     * list of packages whose availability changed.
-     * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
-     * list of uids of packages whose availability changed.
-     * The specified set of packages can no longer be
-     * launched and are practically unavailable on the system.
-     * <p>Inclues the following extras:
-     * <ul>
-     * <li> {@link #EXTRA_CHANGED_PACKAGE_LIST} is the set of packages
-     * whose resources are no longer available.
-     * {@link #EXTRA_CHANGED_UID_LIST} is the set of packages
-     * whose resources are no longer available.
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE =
-        "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
-
-    /**
-     * Broadcast Action:  The current system wallpaper has changed.  See
-     * {@link android.app.WallpaperManager} for retrieving the new wallpaper.
-     * This should <em>only</em> be used to determine when the wallpaper
-     * has changed to show the new wallpaper to the user.  You should certainly
-     * never, in response to this, change the wallpaper or other attributes of
-     * it such as the suggested size.  That would be crazy, right?  You'd cause
-     * all kinds of loops, especially if other apps are doing similar things,
-     * right?  Of course.  So please don't do this.
-     *
-     * @deprecated Modern applications should use
-     * {@link android.view.WindowManager.LayoutParams#FLAG_SHOW_WALLPAPER
-     * WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER} to have the wallpaper
-     * shown behind their UI, rather than watching for this broadcast and
-     * rendering the wallpaper on their own.
-     */
-    @Deprecated @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_WALLPAPER_CHANGED = "android.intent.action.WALLPAPER_CHANGED";
-    /**
-     * Broadcast Action: The current device {@link android.content.res.Configuration}
-     * (orientation, locale, etc) has changed.  When such a change happens, the
-     * UIs (view hierarchy) will need to be rebuilt based on this new
-     * information; for the most part, applications don't need to worry about
-     * this, because the system will take care of stopping and restarting the
-     * application to make sure it sees the new changes.  Some system code that
-     * can not be restarted will need to watch for this action and handle it
-     * appropriately.
-     *
-     * <p class="note">
-     * You can <em>not</em> receive this through components declared
-     * in manifests, only by explicitly registering for it with
-     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
-     * Context.registerReceiver()}.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     *
-     * @see android.content.res.Configuration
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_CONFIGURATION_CHANGED = "android.intent.action.CONFIGURATION_CHANGED";
-    /**
-     * Broadcast Action: The current device's locale has changed.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_LOCALE_CHANGED = "android.intent.action.LOCALE_CHANGED";
-    /**
-     * Broadcast Action:  This is a <em>sticky broadcast</em> containing the
-     * charging state, level, and other information about the battery.
-     * See {@link android.os.BatteryManager} for documentation on the
-     * contents of the Intent.
-     *
-     * <p class="note">
-     * You can <em>not</em> receive this through components declared
-     * in manifests, only by explicitly registering for it with
-     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
-     * Context.registerReceiver()}.  See {@link #ACTION_BATTERY_LOW},
-     * {@link #ACTION_BATTERY_OKAY}, {@link #ACTION_POWER_CONNECTED},
-     * and {@link #ACTION_POWER_DISCONNECTED} for distinct battery-related
-     * broadcasts that are sent and can be received through manifest
-     * receivers.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_BATTERY_CHANGED = "android.intent.action.BATTERY_CHANGED";
-    /**
-     * Broadcast Action:  Indicates low battery condition on the device.
-     * This broadcast corresponds to the "Low battery warning" system dialog.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_BATTERY_LOW = "android.intent.action.BATTERY_LOW";
-    /**
-     * Broadcast Action:  Indicates the battery is now okay after being low.
-     * This will be sent after {@link #ACTION_BATTERY_LOW} once the battery has
-     * gone back up to an okay state.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_BATTERY_OKAY = "android.intent.action.BATTERY_OKAY";
-    /**
-     * Broadcast Action:  External power has been connected to the device.
-     * This is intended for applications that wish to register specifically to this notification.
-     * Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
-     * stay active to receive this notification.  This action can be used to implement actions
-     * that wait until power is available to trigger.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_POWER_CONNECTED = "android.intent.action.ACTION_POWER_CONNECTED";
-    /**
-     * Broadcast Action:  External power has been removed from the device.
-     * This is intended for applications that wish to register specifically to this notification.
-     * Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
-     * stay active to receive this notification.  This action can be used to implement actions
-     * that wait until power is available to trigger.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_POWER_DISCONNECTED =
-            "android.intent.action.ACTION_POWER_DISCONNECTED";
-    /**
-     * Broadcast Action:  Device is shutting down.
-     * This is broadcast when the device is being shut down (completely turned
-     * off, not sleeping).  Once the broadcast is complete, the final shutdown
-     * will proceed and all unsaved data lost.  Apps will not normally need
-     * to handle this, since the foreground activity will be paused as well.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_SHUTDOWN = "android.intent.action.ACTION_SHUTDOWN";
-    /**
-     * Activity Action:  Start this activity to request system shutdown.
-     * The optional boolean extra field {@link #EXTRA_KEY_CONFIRM} can be set to true
-     * to request confirmation from the user before shutting down.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     *
-     * {@hide}
-     */
-    public static final String ACTION_REQUEST_SHUTDOWN = "android.intent.action.ACTION_REQUEST_SHUTDOWN";
-    /**
-     * Broadcast Action:  A sticky broadcast that indicates low memory
-     * condition on the device
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_DEVICE_STORAGE_LOW = "android.intent.action.DEVICE_STORAGE_LOW";
-    /**
-     * Broadcast Action:  Indicates low memory condition on the device no longer exists
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_DEVICE_STORAGE_OK = "android.intent.action.DEVICE_STORAGE_OK";
-    /**
-     * Broadcast Action:  A sticky broadcast that indicates a memory full
-     * condition on the device. This is intended for activities that want
-     * to be able to fill the data partition completely, leaving only
-     * enough free space to prevent system-wide SQLite failures.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     *
-     * {@hide}
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_DEVICE_STORAGE_FULL = "android.intent.action.DEVICE_STORAGE_FULL";
-    /**
-     * Broadcast Action:  Indicates memory full condition on the device
-     * no longer exists.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     *
-     * {@hide}
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_DEVICE_STORAGE_NOT_FULL = "android.intent.action.DEVICE_STORAGE_NOT_FULL";
-    /**
-     * Broadcast Action:  Indicates low memory condition notification acknowledged by user
-     * and package management should be started.
-     * This is triggered by the user from the ACTION_DEVICE_STORAGE_LOW
-     * notification.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MANAGE_PACKAGE_STORAGE = "android.intent.action.MANAGE_PACKAGE_STORAGE";
-    /**
-     * Broadcast Action:  The device has entered USB Mass Storage mode.
-     * This is used mainly for the USB Settings panel.
-     * Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
-     * when the SD card file system is mounted or unmounted
-     * @deprecated replaced by android.os.storage.StorageEventListener
-     */
-    @Deprecated
-    public static final String ACTION_UMS_CONNECTED = "android.intent.action.UMS_CONNECTED";
-
-    /**
-     * Broadcast Action:  The device has exited USB Mass Storage mode.
-     * This is used mainly for the USB Settings panel.
-     * Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
-     * when the SD card file system is mounted or unmounted
-     * @deprecated replaced by android.os.storage.StorageEventListener
-     */
-    @Deprecated
-    public static final String ACTION_UMS_DISCONNECTED = "android.intent.action.UMS_DISCONNECTED";
-
-    /**
-     * Broadcast Action:  External media has been removed.
-     * The path to the mount point for the removed media is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_REMOVED = "android.intent.action.MEDIA_REMOVED";
-
-    /**
-     * Broadcast Action:  External media is present, but not mounted at its mount point.
-     * The path to the mount point for the removed media is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_UNMOUNTED = "android.intent.action.MEDIA_UNMOUNTED";
-
-    /**
-     * Broadcast Action:  External media is present, and being disk-checked
-     * The path to the mount point for the checking media is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_CHECKING = "android.intent.action.MEDIA_CHECKING";
-
-    /**
-     * Broadcast Action:  External media is present, but is using an incompatible fs (or is blank)
-     * The path to the mount point for the checking media is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_NOFS = "android.intent.action.MEDIA_NOFS";
-
-    /**
-     * Broadcast Action:  External media is present and mounted at its mount point.
-     * The path to the mount point for the removed media is contained in the Intent.mData field.
-     * The Intent contains an extra with name "read-only" and Boolean value to indicate if the
-     * media was mounted read only.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_MOUNTED = "android.intent.action.MEDIA_MOUNTED";
-
-    /**
-     * Broadcast Action:  External media is unmounted because it is being shared via USB mass storage.
-     * The path to the mount point for the shared media is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_SHARED = "android.intent.action.MEDIA_SHARED";
-
-    /**
-     * Broadcast Action:  External media is no longer being shared via USB mass storage.
-     * The path to the mount point for the previously shared media is contained in the Intent.mData field.
-     *
-     * @hide
-     */
-    public static final String ACTION_MEDIA_UNSHARED = "android.intent.action.MEDIA_UNSHARED";
-
-    /**
-     * Broadcast Action:  External media was removed from SD card slot, but mount point was not unmounted.
-     * The path to the mount point for the removed media is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_BAD_REMOVAL = "android.intent.action.MEDIA_BAD_REMOVAL";
-
-    /**
-     * Broadcast Action:  External media is present but cannot be mounted.
-     * The path to the mount point for the removed media is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_UNMOUNTABLE = "android.intent.action.MEDIA_UNMOUNTABLE";
-
-   /**
-     * Broadcast Action:  User has expressed the desire to remove the external storage media.
-     * Applications should close all files they have open within the mount point when they receive this intent.
-     * The path to the mount point for the media to be ejected is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_EJECT = "android.intent.action.MEDIA_EJECT";
-
-    /**
-     * Broadcast Action:  The media scanner has started scanning a directory.
-     * The path to the directory being scanned is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_SCANNER_STARTED = "android.intent.action.MEDIA_SCANNER_STARTED";
-
-   /**
-     * Broadcast Action:  The media scanner has finished scanning a directory.
-     * The path to the scanned directory is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_SCANNER_FINISHED = "android.intent.action.MEDIA_SCANNER_FINISHED";
-
-   /**
-     * Broadcast Action:  Request the media scanner to scan a file and add it to the media database.
-     * The path to the file is contained in the Intent.mData field.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_SCANNER_SCAN_FILE = "android.intent.action.MEDIA_SCANNER_SCAN_FILE";
-
-   /**
-     * Broadcast Action:  The "Media Button" was pressed.  Includes a single
-     * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
-     * caused the broadcast.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_MEDIA_BUTTON = "android.intent.action.MEDIA_BUTTON";
-
-    /**
-     * Broadcast Action:  The "Camera Button" was pressed.  Includes a single
-     * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
-     * caused the broadcast.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_CAMERA_BUTTON = "android.intent.action.CAMERA_BUTTON";
-
-    // *** NOTE: @todo(*) The following really should go into a more domain-specific
-    // location; they are not general-purpose actions.
-
-    /**
-     * Broadcast Action: A GTalk connection has been established.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_GTALK_SERVICE_CONNECTED =
-            "android.intent.action.GTALK_CONNECTED";
-
-    /**
-     * Broadcast Action: A GTalk connection has been disconnected.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_GTALK_SERVICE_DISCONNECTED =
-            "android.intent.action.GTALK_DISCONNECTED";
-
-    /**
-     * Broadcast Action: An input method has been changed.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_INPUT_METHOD_CHANGED =
-            "android.intent.action.INPUT_METHOD_CHANGED";
-
-    /**
-     * <p>Broadcast Action: The user has switched the phone into or out of Airplane Mode. One or
-     * more radios have been turned off or on. The intent will have the following extra value:</p>
-     * <ul>
-     *   <li><em>state</em> - A boolean value indicating whether Airplane Mode is on. If true,
-     *   then cell radio and possibly other radios such as bluetooth or WiFi may have also been
-     *   turned off</li>
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_AIRPLANE_MODE_CHANGED = "android.intent.action.AIRPLANE_MODE";
-
-    /**
-     * Broadcast Action: Some content providers have parts of their namespace
-     * where they publish new events or items that the user may be especially
-     * interested in. For these things, they may broadcast this action when the
-     * set of interesting items change.
-     *
-     * For example, GmailProvider sends this notification when the set of unread
-     * mail in the inbox changes.
-     *
-     * <p>The data of the intent identifies which part of which provider
-     * changed. When queried through the content resolver, the data URI will
-     * return the data set in question.
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>count</em> - The number of items in the data set. This is the
-     *       same as the number of items in the cursor returned by querying the
-     *       data URI. </li>
-     * </ul>
-     *
-     * This intent will be sent at boot (if the count is non-zero) and when the
-     * data set changes. It is possible for the data set to change without the
-     * count changing (for example, if a new unread message arrives in the same
-     * sync operation in which a message is archived). The phone should still
-     * ring/vibrate/etc as normal in this case.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_PROVIDER_CHANGED =
-            "android.intent.action.PROVIDER_CHANGED";
-
-    /**
-     * Broadcast Action: Wired Headset plugged in or unplugged.
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
-     *   <li><em>name</em> - Headset type, human readable string </li>
-     *   <li><em>microphone</em> - 1 if headset has a microphone, 0 otherwise </li>
-     * </ul>
-     * </ul>
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_HEADSET_PLUG =
-            "android.intent.action.HEADSET_PLUG";
-
-    /**
-     * Broadcast Action: WiFi Display audio is enabled or disabled
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
-     * </ul>
-     * @hide
-     */
-    public static final String ACTION_WIFI_DISPLAY_AUDIO =
-            "qualcomm.intent.action.WIFI_DISPLAY_AUDIO";
-
-    /**
-     * Broadcast Action: WiFi Display video is enabled or disabled
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
-     * </ul>
-     * @hide
-     */
-
-    public static final String ACTION_WIFI_DISPLAY_VIDEO =
-            "qualcomm.intent.action.WIFI_DISPLAY_VIDEO";
-
-    /**
-     * Broadcast Action: An analog audio speaker/headset plugged in or unplugged.
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
-     *   <li><em>name</em> - Headset type, human readable string </li>
-     * </ul>
-     * </ul>
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_ANALOG_AUDIO_DOCK_PLUG =
-            "android.intent.action.ANALOG_AUDIO_DOCK_PLUG";
-
-    /**
-     * Broadcast Action: A digital audio speaker/headset plugged in or unplugged.
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
-     *   <li><em>name</em> - Headset type, human readable string </li>
-     * </ul>
-     * </ul>
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_DIGITAL_AUDIO_DOCK_PLUG =
-            "android.intent.action.DIGITAL_AUDIO_DOCK_PLUG";
-
-    /**
-     * Broadcast Action: A HMDI cable was plugged or unplugged
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
-     *   <li><em>name</em> - HDMI cable, human readable string </li>
-     * </ul>
-     * </ul>
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_HDMI_AUDIO_PLUG =
-            "android.intent.action.HDMI_AUDIO_PLUG";
-
-    /**
-     * Broadcast Action: A USB audio accessory was plugged in or unplugged.
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
-     *   <li><em>card</em> - ALSA card number (integer) </li>
-     *   <li><em>device</em> - ALSA device number (integer) </li>
-     * </ul>
-     * </ul>
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_USB_AUDIO_ACCESSORY_PLUG =
-            "android.intent.action.USB_AUDIO_ACCESSORY_PLUG";
-
-    /**
-     * Broadcast Action: A USB audio device was plugged in or unplugged.
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
-     *   <li><em>card</em> - ALSA card number (integer) </li>
-     *   <li><em>device</em> - ALSA device number (integer) </li>
-     * </ul>
-     * </ul>
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_USB_AUDIO_DEVICE_PLUG =
-            "android.intent.action.USB_AUDIO_DEVICE_PLUG";
-
-    /**
-     * <p>Broadcast Action: The user has switched on advanced settings in the settings app:</p>
-     * <ul>
-     *   <li><em>state</em> - A boolean value indicating whether the settings is on or off.</li>
-     * </ul>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     *
-     * @hide
-     */
-    //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_ADVANCED_SETTINGS_CHANGED
-            = "android.intent.action.ADVANCED_SETTINGS";
-
-    /**
-     * Broadcast Action: An outgoing call is about to be placed.
-     *
-     * <p>The Intent will have the following extra value:
-     * <ul>
-     *   <li><em>{@link android.content.Intent#EXTRA_PHONE_NUMBER}</em> -
-     *       the phone number originally intended to be dialed.</li>
-     * </ul>
-     * <p>Once the broadcast is finished, the resultData is used as the actual
-     * number to call.  If  <code>null</code>, no call will be placed.</p>
-     * <p>It is perfectly acceptable for multiple receivers to process the
-     * outgoing call in turn: for example, a parental control application
-     * might verify that the user is authorized to place the call at that
-     * time, then a number-rewriting application might add an area code if
-     * one was not specified.</p>
-     * <p>For consistency, any receiver whose purpose is to prohibit phone
-     * calls should have a priority of 0, to ensure it will see the final
-     * phone number to be dialed.
-     * Any receiver whose purpose is to rewrite phone numbers to be called
-     * should have a positive priority.
-     * Negative priorities are reserved for the system for this broadcast;
-     * using them may cause problems.</p>
-     * <p>Any BroadcastReceiver receiving this Intent <em>must not</em>
-     * abort the broadcast.</p>
-     * <p>Emergency calls cannot be intercepted using this mechanism, and
-     * other calls cannot be modified to call emergency numbers using this
-     * mechanism.
-     * <p>You must hold the
-     * {@link android.Manifest.permission#PROCESS_OUTGOING_CALLS}
-     * permission to receive this Intent.</p>
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_NEW_OUTGOING_CALL =
-            "android.intent.action.NEW_OUTGOING_CALL";
-
-    /**
-     * Broadcast Action: An outgoing sms is about to be sent.
-     *
-     * The Intent will have the following extras:
-     * destAddr - the phone number originally intended to be dialled
-     * scAddr - the service center address
-     * multipart - indicate whether this is a multipart or single message
-     * parts - ArrayList<String> of text parts (one item if multipart=false)
-     * sentIntents - ArrayList<PendingIntent> to send on send
-     * deliveryIntents - ArrayList<PendingIntent> to send on delivery
-     *
-     * Once the broadcast is finished, resultData is used as the actual
-     * number to text.
-     *
-     * @hide
-     */
-    public static final String ACTION_NEW_OUTGOING_SMS =
-            "android.intent.action.NEW_OUTGOING_SMS";
-
-    /**
-     * Broadcast Action: Have the device reboot.  This is only for use by
-     * system code.
-     *
-     * <p class="note">This is a protected intent that can only be sent
-     * by the system.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_REBOOT =
-            "android.intent.action.REBOOT";
-
-    /**
-     * Broadcast Action:  A sticky broadcast for changes in the physical
-     * docking state of the device.
-     *
-     * <p>The intent will have the following extra values:
-     * <ul>
-     *   <li><em>{@link #EXTRA_DOCK_STATE}</em> - the current dock
-     *       state, indicating which dock the device is physically in.</li>
-     * </ul>
-     * <p>This is intended for monitoring the current physical dock state.
-     * See {@link android.app.UiModeManager} for the normal API dealing with
-     * dock mode changes.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_DOCK_EVENT =
-            "android.intent.action.DOCK_EVENT";
-
-    /**
-     * Broadcast Action: a remote intent is to be broadcasted.
-     *
-     * A remote intent is used for remote RPC between devices. The remote intent
-     * is serialized and sent from one device to another device. The receiving
-     * device parses the remote intent and broadcasts it. Note that anyone can
-     * broadcast a remote intent. However, if the intent receiver of the remote intent
-     * does not trust intent broadcasts from arbitrary intent senders, it should require
-     * the sender to hold certain permissions so only trusted sender's broadcast will be
-     * let through.
-     * @hide
-     */
-    public static final String ACTION_REMOTE_INTENT =
-            "com.google.android.c2dm.intent.RECEIVE";
-
-    /**
-     * Broadcast Action: hook for permforming cleanup after a system update.
-     *
-     * The broadcast is sent when the system is booting, before the
-     * BOOT_COMPLETED broadcast.  It is only sent to receivers in the system
-     * image.  A receiver for this should do its work and then disable itself
-     * so that it does not get run again at the next boot.
-     * @hide
-     */
-    public static final String ACTION_PRE_BOOT_COMPLETED =
-            "android.intent.action.PRE_BOOT_COMPLETED";
-
-    /**
-     * Sent the first time a user is starting, to allow system apps to
-     * perform one time initialization.  (This will not be seen by third
-     * party applications because a newly initialized user does not have any
-     * third party applications installed for it.)  This is sent early in
-     * starting the user, around the time the home app is started, before
-     * {@link #ACTION_BOOT_COMPLETED} is sent.  This is sent as a foreground
-     * broadcast, since it is part of a visible user interaction; be as quick
-     * as possible when handling it.
-     */
-    public static final String ACTION_USER_INITIALIZE =
-            "android.intent.action.USER_INITIALIZE";
-
-    /**
-     * Sent when a user switch is happening, causing the process's user to be
-     * brought to the foreground.  This is only sent to receivers registered
-     * through {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
-     * Context.registerReceiver}.  It is sent to the user that is going to the
-     * foreground.  This is sent as a foreground
-     * broadcast, since it is part of a visible user interaction; be as quick
-     * as possible when handling it.
-     */
-    public static final String ACTION_USER_FOREGROUND =
-            "android.intent.action.USER_FOREGROUND";
-
-    /**
-     * Sent when a user switch is happening, causing the process's user to be
-     * sent to the background.  This is only sent to receivers registered
-     * through {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
-     * Context.registerReceiver}.  It is sent to the user that is going to the
-     * background.  This is sent as a foreground
-     * broadcast, since it is part of a visible user interaction; be as quick
-     * as possible when handling it.
-     */
-    public static final String ACTION_USER_BACKGROUND =
-            "android.intent.action.USER_BACKGROUND";
-
-    /**
-     * Broadcast sent to the system when a user is added. Carries an extra
-     * EXTRA_USER_HANDLE that has the userHandle of the new user.  It is sent to
-     * all running users.  You must hold
-     * {@link android.Manifest.permission#MANAGE_USERS} to receive this broadcast.
-     * @hide
-     */
-    public static final String ACTION_USER_ADDED =
-            "android.intent.action.USER_ADDED";
-
-    /**
-     * Broadcast sent by the system when a user is started. Carries an extra
-     * EXTRA_USER_HANDLE that has the userHandle of the user.  This is only sent to
-     * registered receivers, not manifest receivers.  It is sent to the user
-     * that has been started.  This is sent as a foreground
-     * broadcast, since it is part of a visible user interaction; be as quick
-     * as possible when handling it.
-     * @hide
-     */
-    public static final String ACTION_USER_STARTED =
-            "android.intent.action.USER_STARTED";
-
-    /**
-     * Broadcast sent when a user is in the process of starting.  Carries an extra
-     * EXTRA_USER_HANDLE that has the userHandle of the user.  This is only
-     * sent to registered receivers, not manifest receivers.  It is sent to all
-     * users (including the one that is being started).  You must hold
-     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} to receive
-     * this broadcast.  This is sent as a background broadcast, since
-     * its result is not part of the primary UX flow; to safely keep track of
-     * started/stopped state of a user you can use this in conjunction with
-     * {@link #ACTION_USER_STOPPING}.  It is <b>not</b> generally safe to use with
-     * other user state broadcasts since those are foreground broadcasts so can
-     * execute in a different order.
-     * @hide
-     */
-    public static final String ACTION_USER_STARTING =
-            "android.intent.action.USER_STARTING";
-
-    /**
-     * Broadcast sent when a user is going to be stopped.  Carries an extra
-     * EXTRA_USER_HANDLE that has the userHandle of the user.  This is only
-     * sent to registered receivers, not manifest receivers.  It is sent to all
-     * users (including the one that is being stopped).  You must hold
-     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} to receive
-     * this broadcast.  The user will not stop until all receivers have
-     * handled the broadcast.  This is sent as a background broadcast, since
-     * its result is not part of the primary UX flow; to safely keep track of
-     * started/stopped state of a user you can use this in conjunction with
-     * {@link #ACTION_USER_STARTING}.  It is <b>not</b> generally safe to use with
-     * other user state broadcasts since those are foreground broadcasts so can
-     * execute in a different order.
-     * @hide
-     */
-    public static final String ACTION_USER_STOPPING =
-            "android.intent.action.USER_STOPPING";
-
-    /**
-     * Broadcast sent to the system when a user is stopped. Carries an extra
-     * EXTRA_USER_HANDLE that has the userHandle of the user.  This is similar to
-     * {@link #ACTION_PACKAGE_RESTARTED}, but for an entire user instead of a
-     * specific package.  This is only sent to registered receivers, not manifest
-     * receivers.  It is sent to all running users <em>except</em> the one that
-     * has just been stopped (which is no longer running).
-     * @hide
-     */
-    public static final String ACTION_USER_STOPPED =
-            "android.intent.action.USER_STOPPED";
-
-    /**
-     * Broadcast sent to the system when a user is removed. Carries an extra EXTRA_USER_HANDLE that has
-     * the userHandle of the user.  It is sent to all running users except the
-     * one that has been removed. The user will not be completely removed until all receivers have
-     * handled the broadcast. You must hold
-     * {@link android.Manifest.permission#MANAGE_USERS} to receive this broadcast.
-     * @hide
-     */
-    public static final String ACTION_USER_REMOVED =
-            "android.intent.action.USER_REMOVED";
-
-    /**
-     * Broadcast sent to the system when the user switches. Carries an extra EXTRA_USER_HANDLE that has
-     * the userHandle of the user to become the current one. This is only sent to
-     * registered receivers, not manifest receivers.  It is sent to all running users.
-     * You must hold
-     * {@link android.Manifest.permission#MANAGE_USERS} to receive this broadcast.
-     * @hide
-     */
-    public static final String ACTION_USER_SWITCHED =
-            "android.intent.action.USER_SWITCHED";
-
-    /**
-     * Broadcast sent to the system when a user's information changes. Carries an extra
-     * {@link #EXTRA_USER_HANDLE} to indicate which user's information changed.
-     * This is only sent to registered receivers, not manifest receivers. It is sent to the user
-     * whose information has changed.
-     * @hide
-     */
-    public static final String ACTION_USER_INFO_CHANGED =
-            "android.intent.action.USER_INFO_CHANGED";
-
-    /**
-     * Sent when the user taps on the clock widget in the system's "quick settings" area.
-     */
-    public static final String ACTION_QUICK_CLOCK =
-            "android.intent.action.QUICK_CLOCK";
-
-    /**
-     * Broadcast Action: Indicate that unrecoverable error happened during app launch.
-     * Could indicate that curently applied theme is malicious.
-     * @hide
-     */
-    public static final String ACTION_APP_LAUNCH_FAILURE = "com.tmobile.intent.action.APP_LAUNCH_FAILURE";
-
-    /**
-     * Broadcast Action: Request to reset the unrecoverable errors count to 0.
-     * @hide
-     */
-    public static final String ACTION_APP_LAUNCH_FAILURE_RESET = "com.tmobile.intent.action.APP_LAUNCH_FAILURE_RESET";
-
-    // ---------------------------------------------------------------------
-    // ---------------------------------------------------------------------
-    // Standard intent categories (see addCategory()).
-
-    /**
-     * Set if the activity should be an option for the default action
-     * (center press) to perform on a piece of data.  Setting this will
-     * hide from the user any activities without it set when performing an
-     * action on some data.  Note that this is normal -not- set in the
-     * Intent when initiating an action -- it is for use in intent filters
-     * specified in packages.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_DEFAULT = "android.intent.category.DEFAULT";
-    /**
-     * Activities that can be safely invoked from a browser must support this
-     * category.  For example, if the user is viewing a web page or an e-mail
-     * and clicks on a link in the text, the Intent generated execute that
-     * link will require the BROWSABLE category, so that only activities
-     * supporting this category will be considered as possible actions.  By
-     * supporting this category, you are promising that there is nothing
-     * damaging (without user intervention) that can happen by invoking any
-     * matching Intent.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_BROWSABLE = "android.intent.category.BROWSABLE";
-    /**
-     * Set if the activity should be considered as an alternative action to
-     * the data the user is currently viewing.  See also
-     * {@link #CATEGORY_SELECTED_ALTERNATIVE} for an alternative action that
-     * applies to the selection in a list of items.
-     *
-     * <p>Supporting this category means that you would like your activity to be
-     * displayed in the set of alternative things the user can do, usually as
-     * part of the current activity's options menu.  You will usually want to
-     * include a specific label in the &lt;intent-filter&gt; of this action
-     * describing to the user what it does.
-     *
-     * <p>The action of IntentFilter with this category is important in that it
-     * describes the specific action the target will perform.  This generally
-     * should not be a generic action (such as {@link #ACTION_VIEW}, but rather
-     * a specific name such as "com.android.camera.action.CROP.  Only one
-     * alternative of any particular action will be shown to the user, so using
-     * a specific action like this makes sure that your alternative will be
-     * displayed while also allowing other applications to provide their own
-     * overrides of that particular action.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_ALTERNATIVE = "android.intent.category.ALTERNATIVE";
-    /**
-     * Set if the activity should be considered as an alternative selection
-     * action to the data the user has currently selected.  This is like
-     * {@link #CATEGORY_ALTERNATIVE}, but is used in activities showing a list
-     * of items from which the user can select, giving them alternatives to the
-     * default action that will be performed on it.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_SELECTED_ALTERNATIVE = "android.intent.category.SELECTED_ALTERNATIVE";
-    /**
-     * Intended to be used as a tab inside of a containing TabActivity.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_TAB = "android.intent.category.TAB";
-    /**
-     * Should be displayed in the top-level launcher.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_LAUNCHER = "android.intent.category.LAUNCHER";
-    /**
-     * Provides information about the package it is in; typically used if
-     * a package does not contain a {@link #CATEGORY_LAUNCHER} to provide
-     * a front-door to the user without having to be shown in the all apps list.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_INFO = "android.intent.category.INFO";
-    /**
-     * This is the home activity, that is the first activity that is displayed
-     * when the device boots.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_HOME = "android.intent.category.HOME";
-    /**
-     * This activity is a preference panel.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_PREFERENCE = "android.intent.category.PREFERENCE";
-    /**
-     * This activity is a development preference panel.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_DEVELOPMENT_PREFERENCE = "android.intent.category.DEVELOPMENT_PREFERENCE";
-    /**
-     * Capable of running inside a parent activity container.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_EMBED = "android.intent.category.EMBED";
-    /**
-     * This activity allows the user to browse and download new applications.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_MARKET = "android.intent.category.APP_MARKET";
-    /**
-     * This activity may be exercised by the monkey or other automated test tools.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_MONKEY = "android.intent.category.MONKEY";
-    /**
-     * To be used as a test (not part of the normal user experience).
-     */
-    public static final String CATEGORY_TEST = "android.intent.category.TEST";
-    /**
-     * To be used as a unit test (run through the Test Harness).
-     */
-    public static final String CATEGORY_UNIT_TEST = "android.intent.category.UNIT_TEST";
-    /**
-     * To be used as a sample code example (not part of the normal user
-     * experience).
-     */
-    public static final String CATEGORY_SAMPLE_CODE = "android.intent.category.SAMPLE_CODE";
-    /**
-     * Used to indicate that a GET_CONTENT intent only wants URIs that can be opened with
-     * ContentResolver.openInputStream. Openable URIs must support the columns in OpenableColumns
-     * when queried, though it is allowable for those columns to be blank.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_OPENABLE = "android.intent.category.OPENABLE";
-
-    /**
-     * To be used as code under test for framework instrumentation tests.
-     */
-    public static final String CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST =
-            "android.intent.category.FRAMEWORK_INSTRUMENTATION_TEST";
-
-    /**
-     * An activity to run when device is inserted into a car dock.
-     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
-     * information, see {@link android.app.UiModeManager}.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_CAR_DOCK = "android.intent.category.CAR_DOCK";
-    /**
-     * An activity to run when device is inserted into a car dock.
-     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
-     * information, see {@link android.app.UiModeManager}.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_DESK_DOCK = "android.intent.category.DESK_DOCK";
-    /**
-     * An activity to run when device is inserted into a analog (low end) dock.
-     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
-     * information, see {@link android.app.UiModeManager}.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_LE_DESK_DOCK = "android.intent.category.LE_DESK_DOCK";
-
-    /**
-     * An activity to run when device is inserted into a digital (high end) dock.
-     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
-     * information, see {@link android.app.UiModeManager}.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_HE_DESK_DOCK = "android.intent.category.HE_DESK_DOCK";
-
-    /**
-     * Used to indicate that the activity can be used in a car environment.
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_CAR_MODE = "android.intent.category.CAR_MODE";
-
-    /**
-     * Used to indicate that a theme package has been installed or un-installed.
-     *
-     * @hide
-     */
-    public static final String CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE =
-            "com.tmobile.intent.category.THEME_PACKAGE_INSTALL_STATE_CHANGE";
-
-    // ---------------------------------------------------------------------
-    // ---------------------------------------------------------------------
-    // Application launch intent categories (see addCategory()).
-
-    /**
-     * Used with {@link #ACTION_MAIN} to launch the browser application.
-     * The activity should be able to browse the Internet.
-     * <p>NOTE: This should not be used as the primary key of an Intent,
-     * since it will not result in the app launching with the correct
-     * action and category.  Instead, use this with
-     * {@link #makeMainSelectorActivity(String, String)} to generate a main
-     * Intent with this category in the selector.</p>
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_BROWSER = "android.intent.category.APP_BROWSER";
-
-    /**
-     * Used with {@link #ACTION_MAIN} to launch the calculator application.
-     * The activity should be able to perform standard arithmetic operations.
-     * <p>NOTE: This should not be used as the primary key of an Intent,
-     * since it will not result in the app launching with the correct
-     * action and category.  Instead, use this with
-     * {@link #makeMainSelectorActivity(String, String)} to generate a main
-     * Intent with this category in the selector.</p>
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_CALCULATOR = "android.intent.category.APP_CALCULATOR";
-
-    /**
-     * Used with {@link #ACTION_MAIN} to launch the calendar application.
-     * The activity should be able to view and manipulate calendar entries.
-     * <p>NOTE: This should not be used as the primary key of an Intent,
-     * since it will not result in the app launching with the correct
-     * action and category.  Instead, use this with
-     * {@link #makeMainSelectorActivity(String, String)} to generate a main
-     * Intent with this category in the selector.</p>
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_CALENDAR = "android.intent.category.APP_CALENDAR";
-
-    /**
-     * Used with {@link #ACTION_MAIN} to launch the contacts application.
-     * The activity should be able to view and manipulate address book entries.
-     * <p>NOTE: This should not be used as the primary key of an Intent,
-     * since it will not result in the app launching with the correct
-     * action and category.  Instead, use this with
-     * {@link #makeMainSelectorActivity(String, String)} to generate a main
-     * Intent with this category in the selector.</p>
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_CONTACTS = "android.intent.category.APP_CONTACTS";
-
-    /**
-     * Used with {@link #ACTION_MAIN} to launch the email application.
-     * The activity should be able to send and receive email.
-     * <p>NOTE: This should not be used as the primary key of an Intent,
-     * since it will not result in the app launching with the correct
-     * action and category.  Instead, use this with
-     * {@link #makeMainSelectorActivity(String, String)} to generate a main
-     * Intent with this category in the selector.</p>
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_EMAIL = "android.intent.category.APP_EMAIL";
-
-    /**
-     * Used with {@link #ACTION_MAIN} to launch the gallery application.
-     * The activity should be able to view and manipulate image and video files
-     * stored on the device.
-     * <p>NOTE: This should not be used as the primary key of an Intent,
-     * since it will not result in the app launching with the correct
-     * action and category.  Instead, use this with
-     * {@link #makeMainSelectorActivity(String, String)} to generate a main
-     * Intent with this category in the selector.</p>
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_GALLERY = "android.intent.category.APP_GALLERY";
-
-    /**
-     * Used with {@link #ACTION_MAIN} to launch the maps application.
-     * The activity should be able to show the user's current location and surroundings.
-     * <p>NOTE: This should not be used as the primary key of an Intent,
-     * since it will not result in the app launching with the correct
-     * action and category.  Instead, use this with
-     * {@link #makeMainSelectorActivity(String, String)} to generate a main
-     * Intent with this category in the selector.</p>
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_MAPS = "android.intent.category.APP_MAPS";
-
-    /**
-     * Used with {@link #ACTION_MAIN} to launch the messaging application.
-     * The activity should be able to send and receive text messages.
-     * <p>NOTE: This should not be used as the primary key of an Intent,
-     * since it will not result in the app launching with the correct
-     * action and category.  Instead, use this with
-     * {@link #makeMainSelectorActivity(String, String)} to generate a main
-     * Intent with this category in the selector.</p>
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_MESSAGING = "android.intent.category.APP_MESSAGING";
-
-    /**
-     * Used with {@link #ACTION_MAIN} to launch the music application.
-     * The activity should be able to play, browse, or manipulate music files
-     * stored on the device.
-     * <p>NOTE: This should not be used as the primary key of an Intent,
-     * since it will not result in the app launching with the correct
-     * action and category.  Instead, use this with
-     * {@link #makeMainSelectorActivity(String, String)} to generate a main
-     * Intent with this category in the selector.</p>
-     */
-    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
-    public static final String CATEGORY_APP_MUSIC = "android.intent.category.APP_MUSIC";
-
-    // ---------------------------------------------------------------------
-    // ---------------------------------------------------------------------
-    // Standard extra data keys.
-
-    /**
-     * The initial data to place in a newly created record.  Use with
-     * {@link #ACTION_INSERT}.  The data here is a Map containing the same
-     * fields as would be given to the underlying ContentProvider.insert()
-     * call.
-     */
-    public static final String EXTRA_TEMPLATE = "android.intent.extra.TEMPLATE";
-
-    /**
-     * A constant CharSequence that is associated with the Intent, used with
-     * {@link #ACTION_SEND} to supply the literal data to be sent.  Note that
-     * this may be a styled CharSequence, so you must use
-     * {@link Bundle#getCharSequence(String) Bundle.getCharSequence()} to
-     * retrieve it.
-     */
-    public static final String EXTRA_TEXT = "android.intent.extra.TEXT";
-
-    /**
-     * A constant String that is associated with the Intent, used with
-     * {@link #ACTION_SEND} to supply an alternative to {@link #EXTRA_TEXT}
-     * as HTML formatted text.  Note that you <em>must</em> also supply
-     * {@link #EXTRA_TEXT}.
-     */
-    public static final String EXTRA_HTML_TEXT = "android.intent.extra.HTML_TEXT";
-
-    /**
-     * A content: URI holding a stream of data associated with the Intent,
-     * used with {@link #ACTION_SEND} to supply the data being sent.
-     */
-    public static final String EXTRA_STREAM = "android.intent.extra.STREAM";
-
-    /**
-     * A String[] holding e-mail addresses that should be delivered to.
-     */
-    public static final String EXTRA_EMAIL       = "android.intent.extra.EMAIL";
-
-    /**
-     * A String[] holding e-mail addresses that should be carbon copied.
-     */
-    public static final String EXTRA_CC       = "android.intent.extra.CC";
-
-    /**
-     * A String[] holding e-mail addresses that should be blind carbon copied.
-     */
-    public static final String EXTRA_BCC      = "android.intent.extra.BCC";
-
-    /**
-     * A constant string holding the desired subject line of a message.
-     */
-    public static final String EXTRA_SUBJECT  = "android.intent.extra.SUBJECT";
-
-    /**
-     * An Intent describing the choices you would like shown with
-     * {@link #ACTION_PICK_ACTIVITY}.
-     */
-    public static final String EXTRA_INTENT = "android.intent.extra.INTENT";
-
-    /**
-     * A CharSequence dialog title to provide to the user when used with a
-     * {@link #ACTION_CHOOSER}.
-     */
-    public static final String EXTRA_TITLE = "android.intent.extra.TITLE";
-
-    /**
-     * A Parcelable[] of {@link Intent} or
-     * {@link android.content.pm.LabeledIntent} objects as set with
-     * {@link #putExtra(String, Parcelable[])} of additional activities to place
-     * a the front of the list of choices, when shown to the user with a
-     * {@link #ACTION_CHOOSER}.
-     */
-    public static final String EXTRA_INITIAL_INTENTS = "android.intent.extra.INITIAL_INTENTS";
-
-    /**
-     * A {@link android.view.KeyEvent} object containing the event that
-     * triggered the creation of the Intent it is in.
-     */
-    public static final String EXTRA_KEY_EVENT = "android.intent.extra.KEY_EVENT";
-
-    /**
-     * Set to true in {@link #ACTION_REQUEST_SHUTDOWN} to request confirmation from the user
-     * before shutting down.
-     *
-     * {@hide}
-     */
-    public static final String EXTRA_KEY_CONFIRM = "android.intent.extra.KEY_CONFIRM";
-
-    /**
-     * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED} or
-     * {@link android.content.Intent#ACTION_PACKAGE_CHANGED} intents to override the default action
-     * of restarting the application.
-     */
-    public static final String EXTRA_DONT_KILL_APP = "android.intent.extra.DONT_KILL_APP";
-
-    /**
-     * A String holding the phone number originally entered in
-     * {@link android.content.Intent#ACTION_NEW_OUTGOING_CALL}, or the actual
-     * number to call in a {@link android.content.Intent#ACTION_CALL}.
-     */
-    public static final String EXTRA_PHONE_NUMBER = "android.intent.extra.PHONE_NUMBER";
-
-    /**
-     * Used as an int extra field in {@link android.content.Intent#ACTION_UID_REMOVED}
-     * intents to supply the uid the package had been assigned.  Also an optional
-     * extra in {@link android.content.Intent#ACTION_PACKAGE_REMOVED} or
-     * {@link android.content.Intent#ACTION_PACKAGE_CHANGED} for the same
-     * purpose.
-     */
-    public static final String EXTRA_UID = "android.intent.extra.UID";
-
-    /**
-     * @hide String array of package names.
-     */
-    public static final String EXTRA_PACKAGES = "android.intent.extra.PACKAGES";
-
-    /**
-     * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED}
-     * intents to indicate whether this represents a full uninstall (removing
-     * both the code and its data) or a partial uninstall (leaving its data,
-     * implying that this is an update).
-     */
-    public static final String EXTRA_DATA_REMOVED = "android.intent.extra.DATA_REMOVED";
-
-    /**
-     * @hide
-     * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED}
-     * intents to indicate that at this point the package has been removed for
-     * all users on the device.
-     */
-    public static final String EXTRA_REMOVED_FOR_ALL_USERS
-            = "android.intent.extra.REMOVED_FOR_ALL_USERS";
-
-    /**
-     * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED}
-     * intents to indicate that this is a replacement of the package, so this
-     * broadcast will immediately be followed by an add broadcast for a
-     * different version of the same package.
-     */
-    public static final String EXTRA_REPLACING = "android.intent.extra.REPLACING";
-
-    /**
-     * Used as an int extra field in {@link android.app.AlarmManager} intents
-     * to tell the application being invoked how many pending alarms are being
-     * delievered with the intent.  For one-shot alarms this will always be 1.
-     * For recurring alarms, this might be greater than 1 if the device was
-     * asleep or powered off at the time an earlier alarm would have been
-     * delivered.
-     */
-    public static final String EXTRA_ALARM_COUNT = "android.intent.extra.ALARM_COUNT";
-
-    /**
-     * Used as an int extra field in {@link android.content.Intent#ACTION_DOCK_EVENT}
-     * intents to request the dock state.  Possible values are
-     * {@link android.content.Intent#EXTRA_DOCK_STATE_UNDOCKED},
-     * {@link android.content.Intent#EXTRA_DOCK_STATE_DESK}, or
-     * {@link android.content.Intent#EXTRA_DOCK_STATE_CAR}, or
-     * {@link android.content.Intent#EXTRA_DOCK_STATE_LE_DESK}, or
-     * {@link android.content.Intent#EXTRA_DOCK_STATE_HE_DESK}.
-     */
-    public static final String EXTRA_DOCK_STATE = "android.intent.extra.DOCK_STATE";
-
-    /**
-     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
-     * to represent that the phone is not in any dock.
-     */
-    public static final int EXTRA_DOCK_STATE_UNDOCKED = 0;
-
-    /**
-     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
-     * to represent that the phone is in a desk dock.
-     */
-    public static final int EXTRA_DOCK_STATE_DESK = 1;
-
-    /**
-     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
-     * to represent that the phone is in a car dock.
-     */
-    public static final int EXTRA_DOCK_STATE_CAR = 2;
-
-    /**
-     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
-     * to represent that the phone is in a analog (low end) dock.
-     */
-    public static final int EXTRA_DOCK_STATE_LE_DESK = 3;
-
-    /**
-     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
-     * to represent that the phone is in a digital (high end) dock.
-     */
-    public static final int EXTRA_DOCK_STATE_HE_DESK = 4;
-
-    /**
-     * Boolean that can be supplied as meta-data with a dock activity, to
-     * indicate that the dock should take over the home key when it is active.
-     */
-    public static final String METADATA_DOCK_HOME = "android.dock_home";
-
-    /**
-     * Used as a parcelable extra field in {@link #ACTION_APP_ERROR}, containing
-     * the bug report.
-     */
-    public static final String EXTRA_BUG_REPORT = "android.intent.extra.BUG_REPORT";
-
-    /**
-     * Used in the extra field in the remote intent. It's astring token passed with the
-     * remote intent.
-     */
-    public static final String EXTRA_REMOTE_INTENT_TOKEN =
-            "android.intent.extra.remote_intent_token";
-
-    /**
-     * @deprecated See {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST}; this field
-     * will contain only the first name in the list.
-     */
-    @Deprecated public static final String EXTRA_CHANGED_COMPONENT_NAME =
-            "android.intent.extra.changed_component_name";
-
-    /**
-     * This field is part of {@link android.content.Intent#ACTION_PACKAGE_CHANGED},
-     * and contains a string array of all of the components that have changed.
-     */
-    public static final String EXTRA_CHANGED_COMPONENT_NAME_LIST =
-            "android.intent.extra.changed_component_name_list";
-
-    /**
-     * This field is part of
-     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
-     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
-     * and contains a string array of all of the components that have changed.
-     */
-    public static final String EXTRA_CHANGED_PACKAGE_LIST =
-            "android.intent.extra.changed_package_list";
-
-    /**
-     * This field is part of
-     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
-     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
-     * and contains an integer array of uids of all of the components
-     * that have changed.
-     */
-    public static final String EXTRA_CHANGED_UID_LIST =
-            "android.intent.extra.changed_uid_list";
-
-    /**
-     * @hide
-     * Magic extra system code can use when binding, to give a label for
-     * who it is that has bound to a service.  This is an integer giving
-     * a framework string resource that can be displayed to the user.
-     */
-    public static final String EXTRA_CLIENT_LABEL =
-            "android.intent.extra.client_label";
-
-    /**
-     * @hide
-     * Magic extra system code can use when binding, to give a PendingIntent object
-     * that can be launched for the user to disable the system's use of this
-     * service.
-     */
-    public static final String EXTRA_CLIENT_INTENT =
-            "android.intent.extra.client_intent";
-
-    /**
-     * Used to indicate that a {@link #ACTION_GET_CONTENT} intent should only return
-     * data that is on the local device.  This is a boolean extra; the default
-     * is false.  If true, an implementation of ACTION_GET_CONTENT should only allow
-     * the user to select media that is already on the device, not requiring it
-     * be downloaded from a remote service when opened.  Another way to look
-     * at it is that such content should generally have a "_data" column to the
-     * path of the content on local external storage.
-     */
-    public static final String EXTRA_LOCAL_ONLY =
-        "android.intent.extra.LOCAL_ONLY";
-
-    /**
-     * The userHandle carried with broadcast intents related to addition, removal and switching of users
-     * - {@link #ACTION_USER_ADDED}, {@link #ACTION_USER_REMOVED} and {@link #ACTION_USER_SWITCHED}.
-     * @hide
-     */
-    public static final String EXTRA_USER_HANDLE =
-            "android.intent.extra.user_handle";
-
-    // ---------------------------------------------------------------------
-    // ---------------------------------------------------------------------
-    // Intent flags (see mFlags variable).
-
-    /**
-     * If set, the recipient of this Intent will be granted permission to
-     * perform read operations on the Uri in the Intent's data and any URIs
-     * specified in its ClipData.  When applying to an Intent's ClipData,
-     * all URIs as well as recursive traversals through data or other ClipData
-     * in Intent items will be granted; only the grant flags of the top-level
-     * Intent are used.
-     */
-    public static final int FLAG_GRANT_READ_URI_PERMISSION = 0x00000001;
-    /**
-     * If set, the recipient of this Intent will be granted permission to
-     * perform write operations on the Uri in the Intent's data and any URIs
-     * specified in its ClipData.  When applying to an Intent's ClipData,
-     * all URIs as well as recursive traversals through data or other ClipData
-     * in Intent items will be granted; only the grant flags of the top-level
-     * Intent are used.
-     */
-    public static final int FLAG_GRANT_WRITE_URI_PERMISSION = 0x00000002;
-    /**
-     * Can be set by the caller to indicate that this Intent is coming from
-     * a background operation, not from direct user interaction.
-     */
-    public static final int FLAG_FROM_BACKGROUND = 0x00000004;
-    /**
-     * A flag you can enable for debugging: when set, log messages will be
-     * printed during the resolution of this intent to show you what has
-     * been found to create the final resolved list.
-     */
-    public static final int FLAG_DEBUG_LOG_RESOLUTION = 0x00000008;
-    /**
-     * If set, this intent will not match any components in packages that
-     * are currently stopped.  If this is not set, then the default behavior
-     * is to include such applications in the result.
-     */
-    public static final int FLAG_EXCLUDE_STOPPED_PACKAGES = 0x00000010;
-    /**
-     * If set, this intent will always match any components in packages that
-     * are currently stopped.  This is the default behavior when
-     * {@link #FLAG_EXCLUDE_STOPPED_PACKAGES} is not set.  If both of these
-     * flags are set, this one wins (it allows overriding of exclude for
-     * places where the framework may automatically set the exclude flag).
-     */
-    public static final int FLAG_INCLUDE_STOPPED_PACKAGES = 0x00000020;
-
-    /**
-     * If set, this intent will always match start up as a floating window
-     * in mutil window scenarios.
-     */
-    public static final int FLAG_MULTI_WINDOW = 0x00000040;
-
-    /**
-     * If set, the new activity is not kept in the history stack.  As soon as
-     * the user navigates away from it, the activity is finished.  This may also
-     * be set with the {@link android.R.styleable#AndroidManifestActivity_noHistory
-     * noHistory} attribute.
-     */
-    public static final int FLAG_ACTIVITY_NO_HISTORY = 0x40000000;
-    /**
-     * If set, the activity will not be launched if it is already running
-     * at the top of the history stack.
-     */
-    public static final int FLAG_ACTIVITY_SINGLE_TOP = 0x20000000;
-    /**
-     * If set, this activity will become the start of a new task on this
-     * history stack.  A task (from the activity that started it to the
-     * next task activity) defines an atomic group of activities that the
-     * user can move to.  Tasks can be moved to the foreground and background;
-     * all of the activities inside of a particular task always remain in
-     * the same order.  See
-     * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
-     * Stack</a> for more information about tasks.
-     *
-     * <p>This flag is generally used by activities that want
-     * to present a "launcher" style behavior: they give the user a list of
-     * separate things that can be done, which otherwise run completely
-     * independently of the activity launching them.
-     *
-     * <p>When using this flag, if a task is already running for the activity
-     * you are now starting, then a new activity will not be started; instead,
-     * the current task will simply be brought to the front of the screen with
-     * the state it was last in.  See {@link #FLAG_ACTIVITY_MULTIPLE_TASK} for a flag
-     * to disable this behavior.
-     *
-     * <p>This flag can not be used when the caller is requesting a result from
-     * the activity being launched.
-     */
-    public static final int FLAG_ACTIVITY_NEW_TASK = 0x10000000;
-    /**
-     * <strong>Do not use this flag unless you are implementing your own
-     * top-level application launcher.</strong>  Used in conjunction with
-     * {@link #FLAG_ACTIVITY_NEW_TASK} to disable the
-     * behavior of bringing an existing task to the foreground.  When set,
-     * a new task is <em>always</em> started to host the Activity for the
-     * Intent, regardless of whether there is already an existing task running
-     * the same thing.
-     *
-     * <p><strong>Because the default system does not include graphical task management,
-     * you should not use this flag unless you provide some way for a user to
-     * return back to the tasks you have launched.</strong>
-     *
-     * <p>This flag is ignored if
-     * {@link #FLAG_ACTIVITY_NEW_TASK} is not set.
-     *
-     * <p>See
-     * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
-     * Stack</a> for more information about tasks.
-     */
-    public static final int FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;
-    /**
-     * If set, and the activity being launched is already running in the
-     * current task, then instead of launching a new instance of that activity,
-     * all of the other activities on top of it will be closed and this Intent
-     * will be delivered to the (now on top) old activity as a new Intent.
-     *
-     * <p>For example, consider a task consisting of the activities: A, B, C, D.
-     * If D calls startActivity() with an Intent that resolves to the component
-     * of activity B, then C and D will be finished and B receive the given
-     * Intent, resulting in the stack now being: A, B.
-     *
-     * <p>The currently running instance of activity B in the above example will
-     * either receive the new intent you are starting here in its
-     * onNewIntent() method, or be itself finished and restarted with the
-     * new intent.  If it has declared its launch mode to be "multiple" (the
-     * default) and you have not set {@link #FLAG_ACTIVITY_SINGLE_TOP} in
-     * the same intent, then it will be finished and re-created; for all other
-     * launch modes or if {@link #FLAG_ACTIVITY_SINGLE_TOP} is set then this
-     * Intent will be delivered to the current instance's onNewIntent().
-     *
-     * <p>This launch mode can also be used to good effect in conjunction with
-     * {@link #FLAG_ACTIVITY_NEW_TASK}: if used to start the root activity
-     * of a task, it will bring any currently running instance of that task
-     * to the foreground, and then clear it to its root state.  This is
-     * especially useful, for example, when launching an activity from the
-     * notification manager.
-     *
-     * <p>See
-     * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
-     * Stack</a> for more information about tasks.
-     */
-    public static final int FLAG_ACTIVITY_CLEAR_TOP = 0x04000000;
-    /**
-     * If set and this intent is being used to launch a new activity from an
-     * existing one, then the reply target of the existing activity will be
-     * transfered to the new activity.  This way the new activity can call
-     * {@link android.app.Activity#setResult} and have that result sent back to
-     * the reply target of the original activity.
-     */
-    public static final int FLAG_ACTIVITY_FORWARD_RESULT = 0x02000000;
-    /**
-     * If set and this intent is being used to launch a new activity from an
-     * existing one, the current activity will not be counted as the top
-     * activity for deciding whether the new intent should be delivered to
-     * the top instead of starting a new one.  The previous activity will
-     * be used as the top, with the assumption being that the current activity
-     * will finish itself immediately.
-     */
-    public static final int FLAG_ACTIVITY_PREVIOUS_IS_TOP = 0x01000000;
-    /**
-     * If set, the new activity is not kept in the list of recently launched
-     * activities.
-     */
-    public static final int FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS = 0x00800000;
-    /**
-     * This flag is not normally set by application code, but set for you by
-     * the system as described in the
-     * {@link android.R.styleable#AndroidManifestActivity_launchMode
-     * launchMode} documentation for the singleTask mode.
-     */
-    public static final int FLAG_ACTIVITY_BROUGHT_TO_FRONT = 0x00400000;
-    /**
-     * If set, and this activity is either being started in a new task or
-     * bringing to the top an existing task, then it will be launched as
-     * the front door of the task.  This will result in the application of
-     * any affinities needed to have that task in the proper state (either
-     * moving activities to or from it), or simply resetting that task to
-     * its initial state if needed.
-     */
-    public static final int FLAG_ACTIVITY_RESET_TASK_IF_NEEDED = 0x00200000;
-    /**
-     * This flag is not normally set by application code, but set for you by
-     * the system if this activity is being launched from history
-     * (longpress home key).
-     */
-    public static final int FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY = 0x00100000;
-    /**
-     * If set, this marks a point in the task's activity stack that should
-     * be cleared when the task is reset.  That is, the next time the task
-     * is brought to the foreground with
-     * {@link #FLAG_ACTIVITY_RESET_TASK_IF_NEEDED} (typically as a result of
-     * the user re-launching it from home), this activity and all on top of
-     * it will be finished so that the user does not return to them, but
-     * instead returns to whatever activity preceeded it.
-     *
-     * <p>This is useful for cases where you have a logical break in your
-     * application.  For example, an e-mail application may have a command
-     * to view an attachment, which launches an image view activity to
-     * display it.  This activity should be part of the e-mail application's
-     * task, since it is a part of the task the user is involved in.  However,
-     * if the user leaves that task, and later selects the e-mail app from
-     * home, we may like them to return to the conversation they were
-     * viewing, not the picture attachment, since that is confusing.  By
-     * setting this flag when launching the image viewer, that viewer and
-     * any activities it starts will be removed the next time the user returns
-     * to mail.
-     */
-    public static final int FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET = 0x00080000;
-    /**
-     * If set, this flag will prevent the normal {@link android.app.Activity#onUserLeaveHint}
-     * callback from occurring on the current frontmost activity before it is
-     * paused as the newly-started activity is brought to the front.
-     *
-     * <p>Typically, an activity can rely on that callback to indicate that an
-     * explicit user action has caused their activity to be moved out of the
-     * foreground. The callback marks an appropriate point in the activity's
-     * lifecycle for it to dismiss any notifications that it intends to display
-     * "until the user has seen them," such as a blinking LED.
-     *
-     * <p>If an activity is ever started via any non-user-driven events such as
-     * phone-call receipt or an alarm handler, this flag should be passed to {@link
-     * Context#startActivity Context.startActivity}, ensuring that the pausing
-     * activity does not think the user has acknowledged its notification.
-     */
-    public static final int FLAG_ACTIVITY_NO_USER_ACTION = 0x00040000;
-    /**
-     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
-     * this flag will cause the launched activity to be brought to the front of its
-     * task's history stack if it is already running.
-     *
-     * <p>For example, consider a task consisting of four activities: A, B, C, D.
-     * If D calls startActivity() with an Intent that resolves to the component
-     * of activity B, then B will be brought to the front of the history stack,
-     * with this resulting order:  A, C, D, B.
-     *
-     * This flag will be ignored if {@link #FLAG_ACTIVITY_CLEAR_TOP} is also
-     * specified.
-     */
-    public static final int FLAG_ACTIVITY_REORDER_TO_FRONT = 0X00020000;
-    /**
-     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
-     * this flag will prevent the system from applying an activity transition
-     * animation to go to the next activity state.  This doesn't mean an
-     * animation will never run -- if another activity change happens that doesn't
-     * specify this flag before the activity started here is displayed, then
-     * that transition will be used.  This flag can be put to good use
-     * when you are going to do a series of activity operations but the
-     * animation seen by the user shouldn't be driven by the first activity
-     * change but rather a later one.
-     */
-    public static final int FLAG_ACTIVITY_NO_ANIMATION = 0X00010000;
-    /**
-     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
-     * this flag will cause any existing task that would be associated with the
-     * activity to be cleared before the activity is started.  That is, the activity
-     * becomes the new root of an otherwise empty task, and any old activities
-     * are finished.  This can only be used in conjunction with {@link #FLAG_ACTIVITY_NEW_TASK}.
-     */
-    public static final int FLAG_ACTIVITY_CLEAR_TASK = 0X00008000;
-    /**
-     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
-     * this flag will cause a newly launching task to be placed on top of the current
-     * home activity task (if there is one).  That is, pressing back from the task
-     * will always return the user to home even if that was not the last activity they
-     * saw.   This can only be used in conjunction with {@link #FLAG_ACTIVITY_NEW_TASK}.
-     */
-    public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;
-    /**
-     * If set, when sending a broadcast only registered receivers will be
-     * called -- no BroadcastReceiver components will be launched.
-     */
-    public static final int FLAG_RECEIVER_REGISTERED_ONLY = 0x40000000;
-    /**
-     * If set, when sending a broadcast the new broadcast will replace
-     * any existing pending broadcast that matches it.  Matching is defined
-     * by {@link Intent#filterEquals(Intent) Intent.filterEquals} returning
-     * true for the intents of the two broadcasts.  When a match is found,
-     * the new broadcast (and receivers associated with it) will replace the
-     * existing one in the pending broadcast list, remaining at the same
-     * position in the list.
-     *
-     * <p>This flag is most typically used with sticky broadcasts, which
-     * only care about delivering the most recent values of the broadcast
-     * to their receivers.
-     */
-    public static final int FLAG_RECEIVER_REPLACE_PENDING = 0x20000000;
-    /**
-     * If set, when sending a broadcast the recipient is allowed to run at
-     * foreground priority, with a shorter timeout interval.  During normal
-     * broadcasts the receivers are not automatically hoisted out of the
-     * background priority class.
-     */
-    public static final int FLAG_RECEIVER_FOREGROUND = 0x10000000;
-    /**
-     * If set, when sending a broadcast <i>before boot has completed</i> only
-     * registered receivers will be called -- no BroadcastReceiver components
-     * will be launched.  Sticky intent state will be recorded properly even
-     * if no receivers wind up being called.  If {@link #FLAG_RECEIVER_REGISTERED_ONLY}
-     * is specified in the broadcast intent, this flag is unnecessary.
-     *
-     * <p>This flag is only for use by system sevices as a convenience to
-     * avoid having to implement a more complex mechanism around detection
-     * of boot completion.
-     *
-     * @hide
-     */
-    public static final int FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT = 0x08000000;
-    /**
-     * Set when this broadcast is for a boot upgrade, a special mode that
-     * allows the broadcast to be sent before the system is ready and launches
-     * the app process with no providers running in it.
-     * @hide
-     */
-    public static final int FLAG_RECEIVER_BOOT_UPGRADE = 0x04000000;
-
-    /**
-     * @hide Flags that can't be changed with PendingIntent.
-     */
-    public static final int IMMUTABLE_FLAGS =
-            FLAG_GRANT_READ_URI_PERMISSION
-            | FLAG_GRANT_WRITE_URI_PERMISSION;
-
-    // ---------------------------------------------------------------------
-    // ---------------------------------------------------------------------
-    // toUri() and parseUri() options.
-
-    /**
-     * Flag for use with {@link #toUri} and {@link #parseUri}: the URI string
-     * always has the "intent:" scheme.  This syntax can be used when you want
-     * to later disambiguate between URIs that are intended to describe an
-     * Intent vs. all others that should be treated as raw URIs.  When used
-     * with {@link #parseUri}, any other scheme will result in a generic
-     * VIEW action for that raw URI.
-     */
-    public static final int URI_INTENT_SCHEME = 1<<0;
-
-    // ---------------------------------------------------------------------
-
-    private String mAction;
-    private Uri mData;
-    private String mType;
-    private String mPackage;
-    private ComponentName mComponent;
-    private int mFlags;
-    private HashSet<String> mCategories;
-    private Bundle mExtras;
-    private Rect mSourceBounds;
-    private Intent mSelector;
-    private ClipData mClipData;
-
-    // ---------------------------------------------------------------------
-
-    /**
-     * Create an empty intent.
-     */
-    public Intent() {
-    }
-
-    /**
-     * Copy constructor.
-     */
-    public Intent(Intent o) {
-        this.mAction = o.mAction;
-        this.mData = o.mData;
-        this.mType = o.mType;
-        this.mPackage = o.mPackage;
-        this.mComponent = o.mComponent;
-        this.mFlags = o.mFlags;
-        if (o.mCategories != null) {
-            this.mCategories = new HashSet<String>(o.mCategories);
-        }
-        if (o.mExtras != null) {
-            this.mExtras = new Bundle(o.mExtras);
-        }
-        if (o.mSourceBounds != null) {
-            this.mSourceBounds = new Rect(o.mSourceBounds);
-        }
-        if (o.mSelector != null) {
-            this.mSelector = new Intent(o.mSelector);
-        }
-        if (o.mClipData != null) {
-            this.mClipData = new ClipData(o.mClipData);
-        }
-    }
-
-    @Override
-    public Object clone() {
-        return new Intent(this);
-    }
-
-    private Intent(Intent o, boolean all) {
-        this.mAction = o.mAction;
-        this.mData = o.mData;
-        this.mType = o.mType;
-        this.mPackage = o.mPackage;
-        this.mComponent = o.mComponent;
-        if (o.mCategories != null) {
-            this.mCategories = new HashSet<String>(o.mCategories);
-        }
-    }
-
-    /**
-     * Make a clone of only the parts of the Intent that are relevant for
-     * filter matching: the action, data, type, component, and categories.
-     */
-    public Intent cloneFilter() {
-        return new Intent(this, false);
-    }
-
-    /**
-     * Create an intent with a given action.  All other fields (data, type,
-     * class) are null.  Note that the action <em>must</em> be in a
-     * namespace because Intents are used globally in the system -- for
-     * example the system VIEW action is android.intent.action.VIEW; an
-     * application's custom action would be something like
-     * com.google.app.myapp.CUSTOM_ACTION.
-     *
-     * @param action The Intent action, such as ACTION_VIEW.
-     */
-    public Intent(String action) {
-        setAction(action);
-    }
-
-    /**
-     * Create an intent with a given action and for a given data url.  Note
-     * that the action <em>must</em> be in a namespace because Intents are
-     * used globally in the system -- for example the system VIEW action is
-     * android.intent.action.VIEW; an application's custom action would be
-     * something like com.google.app.myapp.CUSTOM_ACTION.
-     *
-     * <p><em>Note: scheme and host name matching in the Android framework is
-     * case-sensitive, unlike the formal RFC.  As a result,
-     * you should always ensure that you write your Uri with these elements
-     * using lower case letters, and normalize any Uris you receive from
-     * outside of Android to ensure the scheme and host is lower case.</em></p>
-     *
-     * @param action The Intent action, such as ACTION_VIEW.
-     * @param uri The Intent data URI.
-     */
-    public Intent(String action, Uri uri) {
-        setAction(action);
-        mData = uri;
-    }
-
-    /**
-     * Create an intent for a specific component.  All other fields (action, data,
-     * type, class) are null, though they can be modified later with explicit
-     * calls.  This provides a convenient way to create an intent that is
-     * intended to execute a hard-coded class name, rather than relying on the
-     * system to find an appropriate class for you; see {@link #setComponent}
-     * for more information on the repercussions of this.
-     *
-     * @param packageContext A Context of the application package implementing
-     * this class.
-     * @param cls The component class that is to be used for the intent.
-     *
-     * @see #setClass
-     * @see #setComponent
-     * @see #Intent(String, android.net.Uri , Context, Class)
-     */
-    public Intent(Context packageContext, Class<?> cls) {
-        mComponent = new ComponentName(packageContext, cls);
-    }
-
-    /**
-     * Create an intent for a specific component with a specified action and data.
-     * This is equivalent using {@link #Intent(String, android.net.Uri)} to
-     * construct the Intent and then calling {@link #setClass} to set its
-     * class.
-     *
-     * <p><em>Note: scheme and host name matching in the Android framework is
-     * case-sensitive, unlike the formal RFC.  As a result,
-     * you should always ensure that you write your Uri with these elements
-     * using lower case letters, and normalize any Uris you receive from
-     * outside of Android to ensure the scheme and host is lower case.</em></p>
-     *
-     * @param action The Intent action, such as ACTION_VIEW.
-     * @param uri The Intent data URI.
-     * @param packageContext A Context of the application package implementing
-     * this class.
-     * @param cls The component class that is to be used for the intent.
-     *
-     * @see #Intent(String, android.net.Uri)
-     * @see #Intent(Context, Class)
-     * @see #setClass
-     * @see #setComponent
-     */
-    public Intent(String action, Uri uri,
-            Context packageContext, Class<?> cls) {
-        setAction(action);
-        mData = uri;
-        mComponent = new ComponentName(packageContext, cls);
-    }
-
-    /**
-     * Create an intent to launch the main (root) activity of a task.  This
-     * is the Intent that is started when the application's is launched from
-     * Home.  For anything else that wants to launch an application in the
-     * same way, it is important that they use an Intent structured the same
-     * way, and can use this function to ensure this is the case.
-     *
-     * <p>The returned Intent has the given Activity component as its explicit
-     * component, {@link #ACTION_MAIN} as its action, and includes the
-     * category {@link #CATEGORY_LAUNCHER}.  This does <em>not</em> have
-     * {@link #FLAG_ACTIVITY_NEW_TASK} set, though typically you will want
-     * to do that through {@link #addFlags(int)} on the returned Intent.
-     *
-     * @param mainActivity The main activity component that this Intent will
-     * launch.
-     * @return Returns a newly created Intent that can be used to launch the
-     * activity as a main application entry.
-     *
-     * @see #setClass
-     * @see #setComponent
-     */
-    public static Intent makeMainActivity(ComponentName mainActivity) {
-        Intent intent = new Intent(ACTION_MAIN);
-        intent.setComponent(mainActivity);
-        intent.addCategory(CATEGORY_LAUNCHER);
-        return intent;
-    }
-
-    /**
-     * Make an Intent for the main activity of an application, without
-     * specifying a specific activity to run but giving a selector to find
-     * the activity.  This results in a final Intent that is structured
-     * the same as when the application is launched from
-     * Home.  For anything else that wants to launch an application in the
-     * same way, it is important that they use an Intent structured the same
-     * way, and can use this function to ensure this is the case.
-     *
-     * <p>The returned Intent has {@link #ACTION_MAIN} as its action, and includes the
-     * category {@link #CATEGORY_LAUNCHER}.  This does <em>not</em> have
-     * {@link #FLAG_ACTIVITY_NEW_TASK} set, though typically you will want
-     * to do that through {@link #addFlags(int)} on the returned Intent.
-     *
-     * @param selectorAction The action name of the Intent's selector.
-     * @param selectorCategory The name of a category to add to the Intent's
-     * selector.
-     * @return Returns a newly created Intent that can be used to launch the
-     * activity as a main application entry.
-     *
-     * @see #setSelector(Intent)
-     */
-    public static Intent makeMainSelectorActivity(String selectorAction,
-            String selectorCategory) {
-        Intent intent = new Intent(ACTION_MAIN);
-        intent.addCategory(CATEGORY_LAUNCHER);
-        Intent selector = new Intent();
-        selector.setAction(selectorAction);
-        selector.addCategory(selectorCategory);
-        intent.setSelector(selector);
-        return intent;
-    }
-
-    /**
-     * Make an Intent that can be used to re-launch an application's task
-     * in its base state.  This is like {@link #makeMainActivity(ComponentName)},
-     * but also sets the flags {@link #FLAG_ACTIVITY_NEW_TASK} and
-     * {@link #FLAG_ACTIVITY_CLEAR_TASK}.
-     *
-     * @param mainActivity The activity component that is the root of the
-     * task; this is the activity that has been published in the application's
-     * manifest as the main launcher icon.
-     *
-     * @return Returns a newly created Intent that can be used to relaunch the
-     * activity's task in its root state.
-     */
-    public static Intent makeRestartActivityTask(ComponentName mainActivity) {
-        Intent intent = makeMainActivity(mainActivity);
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                | Intent.FLAG_ACTIVITY_CLEAR_TASK);
-        return intent;
-    }
-
-    /**
-     * Call {@link #parseUri} with 0 flags.
-     * @deprecated Use {@link #parseUri} instead.
-     */
-    @Deprecated
-    public static Intent getIntent(String uri) throws URISyntaxException {
-        return parseUri(uri, 0);
-    }
-
-    /**
-     * Create an intent from a URI.  This URI may encode the action,
-     * category, and other intent fields, if it was returned by
-     * {@link #toUri}.  If the Intent was not generate by toUri(), its data
-     * will be the entire URI and its action will be ACTION_VIEW.
-     *
-     * <p>The URI given here must not be relative -- that is, it must include
-     * the scheme and full path.
-     *
-     * @param uri The URI to turn into an Intent.
-     * @param flags Additional processing flags.  Either 0 or
-     * {@link #URI_INTENT_SCHEME}.
-     *
-     * @return Intent The newly created Intent object.
-     *
-     * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
-     * it bad (as parsed by the Uri class) or the Intent data within the
-     * URI is invalid.
-     *
-     * @see #toUri
-     */
-    public static Intent parseUri(String uri, int flags) throws URISyntaxException {
-        int i = 0;
-        try {
-            // Validate intent scheme for if requested.
-            if ((flags&URI_INTENT_SCHEME) != 0) {
-                if (!uri.startsWith("intent:")) {
-                    Intent intent = new Intent(ACTION_VIEW);
-                    try {
-                        intent.setData(Uri.parse(uri));
-                    } catch (IllegalArgumentException e) {
-                        throw new URISyntaxException(uri, e.getMessage());
-                    }
-                    return intent;
-                }
-            }
-
-            // simple case
-            i = uri.lastIndexOf("#");
-            if (i == -1) return new Intent(ACTION_VIEW, Uri.parse(uri));
-
-            // old format Intent URI
-            if (!uri.startsWith("#Intent;", i)) return getIntentOld(uri);
-
-            // new format
-            Intent intent = new Intent(ACTION_VIEW);
-            Intent baseIntent = intent;
-
-            // fetch data part, if present
-            String data = i >= 0 ? uri.substring(0, i) : null;
-            String scheme = null;
-            i += "#Intent;".length();
-
-            // loop over contents of Intent, all name=value;
-            while (!uri.startsWith("end", i)) {
-                int eq = uri.indexOf('=', i);
-                if (eq < 0) eq = i-1;
-                int semi = uri.indexOf(';', i);
-                String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : "";
-
-                // action
-                if (uri.startsWith("action=", i)) {
-                    intent.setAction(value);
-                }
-
-                // categories
-                else if (uri.startsWith("category=", i)) {
-                    intent.addCategory(value);
-                }
-
-                // type
-                else if (uri.startsWith("type=", i)) {
-                    intent.mType = value;
-                }
-
-                // launch flags
-                else if (uri.startsWith("launchFlags=", i)) {
-                    intent.mFlags = Integer.decode(value).intValue();
-                }
-
-                // package
-                else if (uri.startsWith("package=", i)) {
-                    intent.mPackage = value;
-                }
-
-                // component
-                else if (uri.startsWith("component=", i)) {
-                    intent.mComponent = ComponentName.unflattenFromString(value);
-                }
-
-                // scheme
-                else if (uri.startsWith("scheme=", i)) {
-                    scheme = value;
-                }
-
-                // source bounds
-                else if (uri.startsWith("sourceBounds=", i)) {
-                    intent.mSourceBounds = Rect.unflattenFromString(value);
-                }
-
-                // selector
-                else if (semi == (i+3) && uri.startsWith("SEL", i)) {
-                    intent = new Intent();
-                }
-
-                // extra
-                else {
-                    String key = Uri.decode(uri.substring(i + 2, eq));
-                    // create Bundle if it doesn't already exist
-                    if (intent.mExtras == null) intent.mExtras = new Bundle();
-                    Bundle b = intent.mExtras;
-                    // add EXTRA
-                    if      (uri.startsWith("S.", i)) b.putString(key, value);
-                    else if (uri.startsWith("B.", i)) b.putBoolean(key, Boolean.parseBoolean(value));
-                    else if (uri.startsWith("b.", i)) b.putByte(key, Byte.parseByte(value));
-                    else if (uri.startsWith("c.", i)) b.putChar(key, value.charAt(0));
-                    else if (uri.startsWith("d.", i)) b.putDouble(key, Double.parseDouble(value));
-                    else if (uri.startsWith("f.", i)) b.putFloat(key, Float.parseFloat(value));
-                    else if (uri.startsWith("i.", i)) b.putInt(key, Integer.parseInt(value));
-                    else if (uri.startsWith("l.", i)) b.putLong(key, Long.parseLong(value));
-                    else if (uri.startsWith("s.", i)) b.putShort(key, Short.parseShort(value));
-                    else throw new URISyntaxException(uri, "unknown EXTRA type", i);
-                }
-
-                // move to the next item
-                i = semi + 1;
-            }
-
-            if (intent != baseIntent) {
-                // The Intent had a selector; fix it up.
-                baseIntent.setSelector(intent);
-                intent = baseIntent;
-            }
-
-            if (data != null) {
-                if (data.startsWith("intent:")) {
-                    data = data.substring(7);
-                    if (scheme != null) {
-                        data = scheme + ':' + data;
-                    }
-                }
-
-                if (data.length() > 0) {
-                    try {
-                        intent.mData = Uri.parse(data);
-                    } catch (IllegalArgumentException e) {
-                        throw new URISyntaxException(uri, e.getMessage());
-                    }
-                }
-            }
-
-            return intent;
-
-        } catch (IndexOutOfBoundsException e) {
-            throw new URISyntaxException(uri, "illegal Intent URI format", i);
-        }
-    }
-
-    public static Intent getIntentOld(String uri) throws URISyntaxException {
-        Intent intent;
-
-        int i = uri.lastIndexOf('#');
-        if (i >= 0) {
-            String action = null;
-            final int intentFragmentStart = i;
-            boolean isIntentFragment = false;
-
-            i++;
-
-            if (uri.regionMatches(i, "action(", 0, 7)) {
-                isIntentFragment = true;
-                i += 7;
-                int j = uri.indexOf(')', i);
-                action = uri.substring(i, j);
-                i = j + 1;
-            }
-
-            intent = new Intent(action);
-
-            if (uri.regionMatches(i, "categories(", 0, 11)) {
-                isIntentFragment = true;
-                i += 11;
-                int j = uri.indexOf(')', i);
-                while (i < j) {
-                    int sep = uri.indexOf('!', i);
-                    if (sep < 0) sep = j;
-                    if (i < sep) {
-                        intent.addCategory(uri.substring(i, sep));
-                    }
-                    i = sep + 1;
-                }
-                i = j + 1;
-            }
-
-            if (uri.regionMatches(i, "type(", 0, 5)) {
-                isIntentFragment = true;
-                i += 5;
-                int j = uri.indexOf(')', i);
-                intent.mType = uri.substring(i, j);
-                i = j + 1;
-            }
-
-            if (uri.regionMatches(i, "launchFlags(", 0, 12)) {
-                isIntentFragment = true;
-                i += 12;
-                int j = uri.indexOf(')', i);
-                intent.mFlags = Integer.decode(uri.substring(i, j)).intValue();
-                i = j + 1;
-            }
-
-            if (uri.regionMatches(i, "component(", 0, 10)) {
-                isIntentFragment = true;
-                i += 10;
-                int j = uri.indexOf(')', i);
-                int sep = uri.indexOf('!', i);
-                if (sep >= 0 && sep < j) {
-                    String pkg = uri.substring(i, sep);
-                    String cls = uri.substring(sep + 1, j);
-                    intent.mComponent = new ComponentName(pkg, cls);
-                }
-                i = j + 1;
-            }
-
-            if (uri.regionMatches(i, "extras(", 0, 7)) {
-                isIntentFragment = true;
-                i += 7;
-
-                final int closeParen = uri.indexOf(')', i);
-                if (closeParen == -1) throw new URISyntaxException(uri,
-                        "EXTRA missing trailing ')'", i);
-
-                while (i < closeParen) {
-                    // fetch the key value
-                    int j = uri.indexOf('=', i);
-                    if (j <= i + 1 || i >= closeParen) {
-                        throw new URISyntaxException(uri, "EXTRA missing '='", i);
-                    }
-                    char type = uri.charAt(i);
-                    i++;
-                    String key = uri.substring(i, j);
-                    i = j + 1;
-
-                    // get type-value
-                    j = uri.indexOf('!', i);
-                    if (j == -1 || j >= closeParen) j = closeParen;
-                    if (i >= j) throw new URISyntaxException(uri, "EXTRA missing '!'", i);
-                    String value = uri.substring(i, j);
-                    i = j;
-
-                    // create Bundle if it doesn't already exist
-                    if (intent.mExtras == null) intent.mExtras = new Bundle();
-
-                    // add item to bundle
-                    try {
-                        switch (type) {
-                            case 'S':
-                                intent.mExtras.putString(key, Uri.decode(value));
-                                break;
-                            case 'B':
-                                intent.mExtras.putBoolean(key, Boolean.parseBoolean(value));
-                                break;
-                            case 'b':
-                                intent.mExtras.putByte(key, Byte.parseByte(value));
-                                break;
-                            case 'c':
-                                intent.mExtras.putChar(key, Uri.decode(value).charAt(0));
-                                break;
-                            case 'd':
-                                intent.mExtras.putDouble(key, Double.parseDouble(value));
-                                break;
-                            case 'f':
-                                intent.mExtras.putFloat(key, Float.parseFloat(value));
-                                break;
-                            case 'i':
-                                intent.mExtras.putInt(key, Integer.parseInt(value));
-                                break;
-                            case 'l':
-                                intent.mExtras.putLong(key, Long.parseLong(value));
-                                break;
-                            case 's':
-                                intent.mExtras.putShort(key, Short.parseShort(value));
-                                break;
-                            default:
-                                throw new URISyntaxException(uri, "EXTRA has unknown type", i);
-                        }
-                    } catch (NumberFormatException e) {
-                        throw new URISyntaxException(uri, "EXTRA value can't be parsed", i);
-                    }
-
-                    char ch = uri.charAt(i);
-                    if (ch == ')') break;
-                    if (ch != '!') throw new URISyntaxException(uri, "EXTRA missing '!'", i);
-                    i++;
-                }
-            }
-
-            if (isIntentFragment) {
-                intent.mData = Uri.parse(uri.substring(0, intentFragmentStart));
-            } else {
-                intent.mData = Uri.parse(uri);
-            }
-
-            if (intent.mAction == null) {
-                // By default, if no action is specified, then use VIEW.
-                intent.mAction = ACTION_VIEW;
-            }
-
-        } else {
-            intent = new Intent(ACTION_VIEW, Uri.parse(uri));
-        }
-
-        return intent;
-    }
-
-    /**
-     * Retrieve the general action to be performed, such as
-     * {@link #ACTION_VIEW}.  The action describes the general way the rest of
-     * the information in the intent should be interpreted -- most importantly,
-     * what to do with the data returned by {@link #getData}.
-     *
-     * @return The action of this intent or null if none is specified.
-     *
-     * @see #setAction
-     */
-    public String getAction() {
-        return mAction;
-    }
-
-    /**
-     * Retrieve data this intent is operating on.  This URI specifies the name
-     * of the data; often it uses the content: scheme, specifying data in a
-     * content provider.  Other schemes may be handled by specific activities,
-     * such as http: by the web browser.
-     *
-     * @return The URI of the data this intent is targeting or null.
-     *
-     * @see #getScheme
-     * @see #setData
-     */
-    public Uri getData() {
-        return mData;
-    }
-
-    /**
-     * The same as {@link #getData()}, but returns the URI as an encoded
-     * String.
-     */
-    public String getDataString() {
-        return mData != null ? mData.toString() : null;
-    }
-
-    /**
-     * Return the scheme portion of the intent's data.  If the data is null or
-     * does not include a scheme, null is returned.  Otherwise, the scheme
-     * prefix without the final ':' is returned, i.e. "http".
-     *
-     * <p>This is the same as calling getData().getScheme() (and checking for
-     * null data).
-     *
-     * @return The scheme of this intent.
-     *
-     * @see #getData
-     */
-    public String getScheme() {
-        return mData != null ? mData.getScheme() : null;
-    }
-
-    /**
-     * Retrieve any explicit MIME type included in the intent.  This is usually
-     * null, as the type is determined by the intent data.
-     *
-     * @return If a type was manually set, it is returned; else null is
-     *         returned.
-     *
-     * @see #resolveType(ContentResolver)
-     * @see #setType
-     */
-    public String getType() {
-        return mType;
-    }
-
-    /**
-     * Return the MIME data type of this intent.  If the type field is
-     * explicitly set, that is simply returned.  Otherwise, if the data is set,
-     * the type of that data is returned.  If neither fields are set, a null is
-     * returned.
-     *
-     * @return The MIME type of this intent.
-     *
-     * @see #getType
-     * @see #resolveType(ContentResolver)
-     */
-    public String resolveType(Context context) {
-        return resolveType(context.getContentResolver());
-    }
-
-    /**
-     * Return the MIME data type of this intent.  If the type field is
-     * explicitly set, that is simply returned.  Otherwise, if the data is set,
-     * the type of that data is returned.  If neither fields are set, a null is
-     * returned.
-     *
-     * @param resolver A ContentResolver that can be used to determine the MIME
-     *                 type of the intent's data.
-     *
-     * @return The MIME type of this intent.
-     *
-     * @see #getType
-     * @see #resolveType(Context)
-     */
-    public String resolveType(ContentResolver resolver) {
-        if (mType != null) {
-            return mType;
-        }
-        if (mData != null) {
-            if ("content".equals(mData.getScheme())) {
-                return resolver.getType(mData);
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Return the MIME data type of this intent, only if it will be needed for
-     * intent resolution.  This is not generally useful for application code;
-     * it is used by the frameworks for communicating with back-end system
-     * services.
-     *
-     * @param resolver A ContentResolver that can be used to determine the MIME
-     *                 type of the intent's data.
-     *
-     * @return The MIME type of this intent, or null if it is unknown or not
-     *         needed.
-     */
-    public String resolveTypeIfNeeded(ContentResolver resolver) {
-        if (mComponent != null) {
-            return mType;
-        }
-        return resolveType(resolver);
-    }
-
-    /**
-     * Check if a category exists in the intent.
-     *
-     * @param category The category to check.
-     *
-     * @return boolean True if the intent contains the category, else false.
-     *
-     * @see #getCategories
-     * @see #addCategory
-     */
-    public boolean hasCategory(String category) {
-        return mCategories != null && mCategories.contains(category);
-    }
-
-    /**
-     * Return the set of all categories in the intent.  If there are no categories,
-     * returns NULL.
-     *
-     * @return The set of categories you can examine.  Do not modify!
-     *
-     * @see #hasCategory
-     * @see #addCategory
-     */
-    public Set<String> getCategories() {
-        return mCategories;
-    }
-
-    /**
-     * Return the specific selector associated with this Intent.  If there is
-     * none, returns null.  See {@link #setSelector} for more information.
-     *
-     * @see #setSelector
-     */
-    public Intent getSelector() {
-        return mSelector;
-    }
-
-    /**
-     * Return the {@link ClipData} associated with this Intent.  If there is
-     * none, returns null.  See {@link #setClipData} for more information.
-     *
-     * @see #setClipData;
-     */
-    public ClipData getClipData() {
-        return mClipData;
-    }
-
-    /**
-     * Sets the ClassLoader that will be used when unmarshalling
-     * any Parcelable values from the extras of this Intent.
-     *
-     * @param loader a ClassLoader, or null to use the default loader
-     * at the time of unmarshalling.
-     */
-    public void setExtrasClassLoader(ClassLoader loader) {
-        if (mExtras != null) {
-            mExtras.setClassLoader(loader);
-        }
-    }
-
-    /**
-     * Returns true if an extra value is associated with the given name.
-     * @param name the extra's name
-     * @return true if the given extra is present.
-     */
-    public boolean hasExtra(String name) {
-        return mExtras != null && mExtras.containsKey(name);
-    }
-
-    /**
-     * Returns true if the Intent's extras contain a parcelled file descriptor.
-     * @return true if the Intent contains a parcelled file descriptor.
-     */
-    public boolean hasFileDescriptors() {
-        return mExtras != null && mExtras.hasFileDescriptors();
-    }
-
-    /** @hide */
-    public void setAllowFds(boolean allowFds) {
-        if (mExtras != null) {
-            mExtras.setAllowFds(allowFds);
-        }
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if none was found.
-     *
-     * @deprecated
-     * @hide
-     */
-    @Deprecated
-    public Object getExtra(String name) {
-        return getExtra(name, null);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     * @param defaultValue the value to be returned if no value of the desired
-     * type is stored with the given name.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or the default value if none was found.
-     *
-     * @see #putExtra(String, boolean)
-     */
-    public boolean getBooleanExtra(String name, boolean defaultValue) {
-        return mExtras == null ? defaultValue :
-            mExtras.getBoolean(name, defaultValue);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     * @param defaultValue the value to be returned if no value of the desired
-     * type is stored with the given name.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or the default value if none was found.
-     *
-     * @see #putExtra(String, byte)
-     */
-    public byte getByteExtra(String name, byte defaultValue) {
-        return mExtras == null ? defaultValue :
-            mExtras.getByte(name, defaultValue);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     * @param defaultValue the value to be returned if no value of the desired
-     * type is stored with the given name.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or the default value if none was found.
-     *
-     * @see #putExtra(String, short)
-     */
-    public short getShortExtra(String name, short defaultValue) {
-        return mExtras == null ? defaultValue :
-            mExtras.getShort(name, defaultValue);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     * @param defaultValue the value to be returned if no value of the desired
-     * type is stored with the given name.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or the default value if none was found.
-     *
-     * @see #putExtra(String, char)
-     */
-    public char getCharExtra(String name, char defaultValue) {
-        return mExtras == null ? defaultValue :
-            mExtras.getChar(name, defaultValue);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     * @param defaultValue the value to be returned if no value of the desired
-     * type is stored with the given name.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or the default value if none was found.
-     *
-     * @see #putExtra(String, int)
-     */
-    public int getIntExtra(String name, int defaultValue) {
-        return mExtras == null ? defaultValue :
-            mExtras.getInt(name, defaultValue);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     * @param defaultValue the value to be returned if no value of the desired
-     * type is stored with the given name.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or the default value if none was found.
-     *
-     * @see #putExtra(String, long)
-     */
-    public long getLongExtra(String name, long defaultValue) {
-        return mExtras == null ? defaultValue :
-            mExtras.getLong(name, defaultValue);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     * @param defaultValue the value to be returned if no value of the desired
-     * type is stored with the given name.
-     *
-     * @return the value of an item that previously added with putExtra(),
-     * or the default value if no such item is present
-     *
-     * @see #putExtra(String, float)
-     */
-    public float getFloatExtra(String name, float defaultValue) {
-        return mExtras == null ? defaultValue :
-            mExtras.getFloat(name, defaultValue);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     * @param defaultValue the value to be returned if no value of the desired
-     * type is stored with the given name.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or the default value if none was found.
-     *
-     * @see #putExtra(String, double)
-     */
-    public double getDoubleExtra(String name, double defaultValue) {
-        return mExtras == null ? defaultValue :
-            mExtras.getDouble(name, defaultValue);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no String value was found.
-     *
-     * @see #putExtra(String, String)
-     */
-    public String getStringExtra(String name) {
-        return mExtras == null ? null : mExtras.getString(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no CharSequence value was found.
-     *
-     * @see #putExtra(String, CharSequence)
-     */
-    public CharSequence getCharSequenceExtra(String name) {
-        return mExtras == null ? null : mExtras.getCharSequence(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no Parcelable value was found.
-     *
-     * @see #putExtra(String, Parcelable)
-     */
-    public <T extends Parcelable> T getParcelableExtra(String name) {
-        return mExtras == null ? null : mExtras.<T>getParcelable(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no Parcelable[] value was found.
-     *
-     * @see #putExtra(String, Parcelable[])
-     */
-    public Parcelable[] getParcelableArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getParcelableArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no ArrayList<Parcelable> value was found.
-     *
-     * @see #putParcelableArrayListExtra(String, ArrayList)
-     */
-    public <T extends Parcelable> ArrayList<T> getParcelableArrayListExtra(String name) {
-        return mExtras == null ? null : mExtras.<T>getParcelableArrayList(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no Serializable value was found.
-     *
-     * @see #putExtra(String, Serializable)
-     */
-    public Serializable getSerializableExtra(String name) {
-        return mExtras == null ? null : mExtras.getSerializable(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no ArrayList<Integer> value was found.
-     *
-     * @see #putIntegerArrayListExtra(String, ArrayList)
-     */
-    public ArrayList<Integer> getIntegerArrayListExtra(String name) {
-        return mExtras == null ? null : mExtras.getIntegerArrayList(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no ArrayList<String> value was found.
-     *
-     * @see #putStringArrayListExtra(String, ArrayList)
-     */
-    public ArrayList<String> getStringArrayListExtra(String name) {
-        return mExtras == null ? null : mExtras.getStringArrayList(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no ArrayList<CharSequence> value was found.
-     *
-     * @see #putCharSequenceArrayListExtra(String, ArrayList)
-     */
-    public ArrayList<CharSequence> getCharSequenceArrayListExtra(String name) {
-        return mExtras == null ? null : mExtras.getCharSequenceArrayList(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no boolean array value was found.
-     *
-     * @see #putExtra(String, boolean[])
-     */
-    public boolean[] getBooleanArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getBooleanArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no byte array value was found.
-     *
-     * @see #putExtra(String, byte[])
-     */
-    public byte[] getByteArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getByteArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no short array value was found.
-     *
-     * @see #putExtra(String, short[])
-     */
-    public short[] getShortArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getShortArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no char array value was found.
-     *
-     * @see #putExtra(String, char[])
-     */
-    public char[] getCharArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getCharArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no int array value was found.
-     *
-     * @see #putExtra(String, int[])
-     */
-    public int[] getIntArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getIntArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no long array value was found.
-     *
-     * @see #putExtra(String, long[])
-     */
-    public long[] getLongArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getLongArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no float array value was found.
-     *
-     * @see #putExtra(String, float[])
-     */
-    public float[] getFloatArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getFloatArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no double array value was found.
-     *
-     * @see #putExtra(String, double[])
-     */
-    public double[] getDoubleArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getDoubleArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no String array value was found.
-     *
-     * @see #putExtra(String, String[])
-     */
-    public String[] getStringArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getStringArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no CharSequence array value was found.
-     *
-     * @see #putExtra(String, CharSequence[])
-     */
-    public CharSequence[] getCharSequenceArrayExtra(String name) {
-        return mExtras == null ? null : mExtras.getCharSequenceArray(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no Bundle value was found.
-     *
-     * @see #putExtra(String, Bundle)
-     */
-    public Bundle getBundleExtra(String name) {
-        return mExtras == null ? null : mExtras.getBundle(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or null if no IBinder value was found.
-     *
-     * @see #putExtra(String, IBinder)
-     *
-     * @deprecated
-     * @hide
-     */
-    @Deprecated
-    public IBinder getIBinderExtra(String name) {
-        return mExtras == null ? null : mExtras.getIBinder(name);
-    }
-
-    /**
-     * Retrieve extended data from the intent.
-     *
-     * @param name The name of the desired item.
-     * @param defaultValue The default value to return in case no item is
-     * associated with the key 'name'
-     *
-     * @return the value of an item that previously added with putExtra()
-     * or defaultValue if none was found.
-     *
-     * @see #putExtra
-     *
-     * @deprecated
-     * @hide
-     */
-    @Deprecated
-    public Object getExtra(String name, Object defaultValue) {
-        Object result = defaultValue;
-        if (mExtras != null) {
-            Object result2 = mExtras.get(name);
-            if (result2 != null) {
-                result = result2;
-            }
-        }
-
-        return result;
-    }
-
-    /**
-     * Retrieves a map of extended data from the intent.
-     *
-     * @return the map of all extras previously added with putExtra(),
-     * or null if none have been added.
-     */
-    public Bundle getExtras() {
-        return (mExtras != null)
-                ? new Bundle(mExtras)
-                : null;
-    }
-
-    /**
-     * Retrieve any special flags associated with this intent.  You will
-     * normally just set them with {@link #setFlags} and let the system
-     * take the appropriate action with them.
-     *
-     * @return int The currently set flags.
-     *
-     * @see #setFlags
-     */
-    public int getFlags() {
-        return mFlags;
-    }
-
-    /** @hide */
-    public boolean isExcludingStopped() {
-        return (mFlags&(FLAG_EXCLUDE_STOPPED_PACKAGES|FLAG_INCLUDE_STOPPED_PACKAGES))
-                == FLAG_EXCLUDE_STOPPED_PACKAGES;
-    }
-
-    /**
-     * Retrieve the application package name this Intent is limited to.  When
-     * resolving an Intent, if non-null this limits the resolution to only
-     * components in the given application package.
-     *
-     * @return The name of the application package for the Intent.
-     *
-     * @see #resolveActivity
-     * @see #setPackage
-     */
-    public String getPackage() {
-        return mPackage;
-    }
-
-    /**
-     * Retrieve the concrete component associated with the intent.  When receiving
-     * an intent, this is the component that was found to best handle it (that is,
-     * yourself) and will always be non-null; in all other cases it will be
-     * null unless explicitly set.
-     *
-     * @return The name of the application component to handle the intent.
-     *
-     * @see #resolveActivity
-     * @see #setComponent
-     */
-    public ComponentName getComponent() {
-        return mComponent;
-    }
-
-    /**
-     * Get the bounds of the sender of this intent, in screen coordinates.  This can be
-     * used as a hint to the receiver for animations and the like.  Null means that there
-     * is no source bounds.
-     */
-    public Rect getSourceBounds() {
-        return mSourceBounds;
-    }
-
-    /**
-     * Return the Activity component that should be used to handle this intent.
-     * The appropriate component is determined based on the information in the
-     * intent, evaluated as follows:
-     *
-     * <p>If {@link #getComponent} returns an explicit class, that is returned
-     * without any further consideration.
-     *
-     * <p>The activity must handle the {@link Intent#CATEGORY_DEFAULT} Intent
-     * category to be considered.
-     *
-     * <p>If {@link #getAction} is non-NULL, the activity must handle this
-     * action.
-     *
-     * <p>If {@link #resolveType} returns non-NULL, the activity must handle
-     * this type.
-     *
-     * <p>If {@link #addCategory} has added any categories, the activity must
-     * handle ALL of the categories specified.
-     *
-     * <p>If {@link #getPackage} is non-NULL, only activity components in
-     * that application package will be considered.
-     *
-     * <p>If there are no activities that satisfy all of these conditions, a
-     * null string is returned.
-     *
-     * <p>If multiple activities are found to satisfy the intent, the one with
-     * the highest priority will be used.  If there are multiple activities
-     * with the same priority, the system will either pick the best activity
-     * based on user preference, or resolve to a system class that will allow
-     * the user to pick an activity and forward from there.
-     *
-     * <p>This method is implemented simply by calling
-     * {@link PackageManager#resolveActivity} with the "defaultOnly" parameter
-     * true.</p>
-     * <p> This API is called for you as part of starting an activity from an
-     * intent.  You do not normally need to call it yourself.</p>
-     *
-     * @param pm The package manager with which to resolve the Intent.
-     *
-     * @return Name of the component implementing an activity that can
-     *         display the intent.
-     *
-     * @see #setComponent
-     * @see #getComponent
-     * @see #resolveActivityInfo
-     */
-    public ComponentName resolveActivity(PackageManager pm) {
-        if (mComponent != null) {
-            return mComponent;
-        }
-
-        ResolveInfo info = pm.resolveActivity(
-            this, PackageManager.MATCH_DEFAULT_ONLY);
-        if (info != null) {
-            return new ComponentName(
-                    info.activityInfo.applicationInfo.packageName,
-                    info.activityInfo.name);
-        }
-
-        return null;
-    }
-
-    /**
-     * Resolve the Intent into an {@link ActivityInfo}
-     * describing the activity that should execute the intent.  Resolution
-     * follows the same rules as described for {@link #resolveActivity}, but
-     * you get back the completely information about the resolved activity
-     * instead of just its class name.
-     *
-     * @param pm The package manager with which to resolve the Intent.
-     * @param flags Addition information to retrieve as per
-     * {@link PackageManager#getActivityInfo(ComponentName, int)
-     * PackageManager.getActivityInfo()}.
-     *
-     * @return PackageManager.ActivityInfo
-     *
-     * @see #resolveActivity
-     */
-    public ActivityInfo resolveActivityInfo(PackageManager pm, int flags) {
-        ActivityInfo ai = null;
-        if (mComponent != null) {
-            try {
-                ai = pm.getActivityInfo(mComponent, flags);
-            } catch (PackageManager.NameNotFoundException e) {
-                // ignore
-            }
-        } else {
-            ResolveInfo info = pm.resolveActivity(
-                this, PackageManager.MATCH_DEFAULT_ONLY | flags);
-            if (info != null) {
-                ai = info.activityInfo;
-            }
-        }
-
-        return ai;
-    }
-
-    /**
-     * Set the general action to be performed.
-     *
-     * @param action An action name, such as ACTION_VIEW.  Application-specific
-     *               actions should be prefixed with the vendor's package name.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #getAction
-     */
-    public Intent setAction(String action) {
-        mAction = action != null ? action.intern() : null;
-        return this;
-    }
-
-    /**
-     * Set the data this intent is operating on.  This method automatically
-     * clears any type that was previously set by {@link #setType} or
-     * {@link #setTypeAndNormalize}.
-     *
-     * <p><em>Note: scheme matching in the Android framework is
-     * case-sensitive, unlike the formal RFC. As a result,
-     * you should always write your Uri with a lower case scheme,
-     * or use {@link Uri#normalizeScheme} or
-     * {@link #setDataAndNormalize}
-     * to ensure that the scheme is converted to lower case.</em>
-     *
-     * @param data The Uri of the data this intent is now targeting.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #getData
-     * @see #setDataAndNormalize
-     * @see android.net.Intent#normalize
-     */
-    public Intent setData(Uri data) {
-        mData = data;
-        mType = null;
-        return this;
-    }
-
-    /**
-     * Normalize and set the data this intent is operating on.
-     *
-     * <p>This method automatically clears any type that was
-     * previously set (for example, by {@link #setType}).
-     *
-     * <p>The data Uri is normalized using
-     * {@link android.net.Uri#normalizeScheme} before it is set,
-     * so really this is just a convenience method for
-     * <pre>
-     * setData(data.normalize())
-     * </pre>
-     *
-     * @param data The Uri of the data this intent is now targeting.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #getData
-     * @see #setType
-     * @see android.net.Uri#normalizeScheme
-     */
-    public Intent setDataAndNormalize(Uri data) {
-        return setData(data.normalizeScheme());
-    }
-
-    /**
-     * Set an explicit MIME data type.
-     *
-     * <p>This is used to create intents that only specify a type and not data,
-     * for example to indicate the type of data to return.
-     *
-     * <p>This method automatically clears any data that was
-     * previously set (for example by {@link #setData}).
-     *
-     * <p><em>Note: MIME type matching in the Android framework is
-     * case-sensitive, unlike formal RFC MIME types.  As a result,
-     * you should always write your MIME types with lower case letters,
-     * or use {@link #normalizeMimeType} or {@link #setTypeAndNormalize}
-     * to ensure that it is converted to lower case.</em>
-     *
-     * @param type The MIME type of the data being handled by this intent.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #getType
-     * @see #setTypeAndNormalize
-     * @see #setDataAndType
-     * @see #normalizeMimeType
-     */
-    public Intent setType(String type) {
-        mData = null;
-        mType = type;
-        return this;
-    }
-
-    /**
-     * Normalize and set an explicit MIME data type.
-     *
-     * <p>This is used to create intents that only specify a type and not data,
-     * for example to indicate the type of data to return.
-     *
-     * <p>This method automatically clears any data that was
-     * previously set (for example by {@link #setData}).
-     *
-     * <p>The MIME type is normalized using
-     * {@link #normalizeMimeType} before it is set,
-     * so really this is just a convenience method for
-     * <pre>
-     * setType(Intent.normalizeMimeType(type))
-     * </pre>
-     *
-     * @param type The MIME type of the data being handled by this intent.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #getType
-     * @see #setData
-     * @see #normalizeMimeType
-     */
-    public Intent setTypeAndNormalize(String type) {
-        return setType(normalizeMimeType(type));
-    }
-
-    /**
-     * (Usually optional) Set the data for the intent along with an explicit
-     * MIME data type.  This method should very rarely be used -- it allows you
-     * to override the MIME type that would ordinarily be inferred from the
-     * data with your own type given here.
-     *
-     * <p><em>Note: MIME type and Uri scheme matching in the
-     * Android framework is case-sensitive, unlike the formal RFC definitions.
-     * As a result, you should always write these elements with lower case letters,
-     * or use {@link #normalizeMimeType} or {@link android.net.Uri#normalizeScheme} or
-     * {@link #setDataAndTypeAndNormalize}
-     * to ensure that they are converted to lower case.</em>
-     *
-     * @param data The Uri of the data this intent is now targeting.
-     * @param type The MIME type of the data being handled by this intent.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #setType
-     * @see #setData
-     * @see #normalizeMimeType
-     * @see android.net.Uri#normalizeScheme
-     * @see #setDataAndTypeAndNormalize
-     */
-    public Intent setDataAndType(Uri data, String type) {
-        mData = data;
-        mType = type;
-        return this;
-    }
-
-    /**
-     * (Usually optional) Normalize and set both the data Uri and an explicit
-     * MIME data type.  This method should very rarely be used -- it allows you
-     * to override the MIME type that would ordinarily be inferred from the
-     * data with your own type given here.
-     *
-     * <p>The data Uri and the MIME type are normalize using
-     * {@link android.net.Uri#normalizeScheme} and {@link #normalizeMimeType}
-     * before they are set, so really this is just a convenience method for
-     * <pre>
-     * setDataAndType(data.normalize(), Intent.normalizeMimeType(type))
-     * </pre>
-     *
-     * @param data The Uri of the data this intent is now targeting.
-     * @param type The MIME type of the data being handled by this intent.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #setType
-     * @see #setData
-     * @see #setDataAndType
-     * @see #normalizeMimeType
-     * @see android.net.Uri#normalizeScheme
-     */
-    public Intent setDataAndTypeAndNormalize(Uri data, String type) {
-        return setDataAndType(data.normalizeScheme(), normalizeMimeType(type));
-    }
-
-    /**
-     * Add a new category to the intent.  Categories provide additional detail
-     * about the action the intent performs.  When resolving an intent, only
-     * activities that provide <em>all</em> of the requested categories will be
-     * used.
-     *
-     * @param category The desired category.  This can be either one of the
-     *               predefined Intent categories, or a custom category in your own
-     *               namespace.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #hasCategory
-     * @see #removeCategory
-     */
-    public Intent addCategory(String category) {
-        if (mCategories == null) {
-            mCategories = new HashSet<String>();
-        }
-        mCategories.add(category.intern());
-        return this;
-    }
-
-    /**
-     * Remove a category from an intent.
-     *
-     * @param category The category to remove.
-     *
-     * @see #addCategory
-     */
-    public void removeCategory(String category) {
-        if (mCategories != null) {
-            mCategories.remove(category);
-            if (mCategories.size() == 0) {
-                mCategories = null;
-            }
-        }
-    }
-
-    /**
-     * Set a selector for this Intent.  This is a modification to the kinds of
-     * things the Intent will match.  If the selector is set, it will be used
-     * when trying to find entities that can handle the Intent, instead of the
-     * main contents of the Intent.  This allows you build an Intent containing
-     * a generic protocol while targeting it more specifically.
-     *
-     * <p>An example of where this may be used is with things like
-     * {@link #CATEGORY_APP_BROWSER}.  This category allows you to build an
-     * Intent that will launch the Browser application.  However, the correct
-     * main entry point of an application is actually {@link #ACTION_MAIN}
-     * {@link #CATEGORY_LAUNCHER} with {@link #setComponent(ComponentName)}
-     * used to specify the actual Activity to launch.  If you launch the browser
-     * with something different, undesired behavior may happen if the user has
-     * previously or later launches it the normal way, since they do not match.
-     * Instead, you can build an Intent with the MAIN action (but no ComponentName
-     * yet specified) and set a selector with {@link #ACTION_MAIN} and
-     * {@link #CATEGORY_APP_BROWSER} to point it specifically to the browser activity.
-     *
-     * <p>Setting a selector does not impact the behavior of
-     * {@link #filterEquals(Intent)} and {@link #filterHashCode()}.  This is part of the
-     * desired behavior of a selector -- it does not impact the base meaning
-     * of the Intent, just what kinds of things will be matched against it
-     * when determining who can handle it.</p>
-     *
-     * <p>You can not use both a selector and {@link #setPackage(String)} on
-     * the same base Intent.</p>
-     *
-     * @param selector The desired selector Intent; set to null to not use
-     * a special selector.
-     */
-    public void setSelector(Intent selector) {
-        if (selector == this) {
-            throw new IllegalArgumentException(
-                    "Intent being set as a selector of itself");
-        }
-        if (selector != null && mPackage != null) {
-            throw new IllegalArgumentException(
-                    "Can't set selector when package name is already set");
-        }
-        mSelector = selector;
-    }
-
-    /**
-     * Set a {@link ClipData} associated with this Intent.  This replaces any
-     * previously set ClipData.
-     *
-     * <p>The ClipData in an intent is not used for Intent matching or other
-     * such operations.  Semantically it is like extras, used to transmit
-     * additional data with the Intent.  The main feature of using this over
-     * the extras for data is that {@link #FLAG_GRANT_READ_URI_PERMISSION}
-     * and {@link #FLAG_GRANT_WRITE_URI_PERMISSION} will operate on any URI
-     * items included in the clip data.  This is useful, in particular, if
-     * you want to transmit an Intent containing multiple <code>content:</code>
-     * URIs for which the recipient may not have global permission to access the
-     * content provider.
-     *
-     * <p>If the ClipData contains items that are themselves Intents, any
-     * grant flags in those Intents will be ignored.  Only the top-level flags
-     * of the main Intent are respected, and will be applied to all Uri or
-     * Intent items in the clip (or sub-items of the clip).
-     *
-     * <p>The MIME type, label, and icon in the ClipData object are not
-     * directly used by Intent.  Applications should generally rely on the
-     * MIME type of the Intent itself, not what it may find in the ClipData.
-     * A common practice is to construct a ClipData for use with an Intent
-     * with a MIME type of "*\/*".
-     *
-     * @param clip The new clip to set.  May be null to clear the current clip.
-     */
-    public void setClipData(ClipData clip) {
-        mClipData = clip;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The boolean data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getBooleanExtra(String, boolean)
-     */
-    public Intent putExtra(String name, boolean value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putBoolean(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The byte data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getByteExtra(String, byte)
-     */
-    public Intent putExtra(String name, byte value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putByte(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The char data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getCharExtra(String, char)
-     */
-    public Intent putExtra(String name, char value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putChar(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The short data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getShortExtra(String, short)
-     */
-    public Intent putExtra(String name, short value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putShort(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The integer data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getIntExtra(String, int)
-     */
-    public Intent putExtra(String name, int value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putInt(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The long data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getLongExtra(String, long)
-     */
-    public Intent putExtra(String name, long value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putLong(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The float data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getFloatExtra(String, float)
-     */
-    public Intent putExtra(String name, float value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putFloat(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The double data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getDoubleExtra(String, double)
-     */
-    public Intent putExtra(String name, double value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putDouble(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The String data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getStringExtra(String)
-     */
-    public Intent putExtra(String name, String value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putString(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The CharSequence data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getCharSequenceExtra(String)
-     */
-    public Intent putExtra(String name, CharSequence value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putCharSequence(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The Parcelable data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getParcelableExtra(String)
-     */
-    public Intent putExtra(String name, Parcelable value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putParcelable(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The Parcelable[] data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getParcelableArrayExtra(String)
-     */
-    public Intent putExtra(String name, Parcelable[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putParcelableArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The ArrayList<Parcelable> data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getParcelableArrayListExtra(String)
-     */
-    public Intent putParcelableArrayListExtra(String name, ArrayList<? extends Parcelable> value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putParcelableArrayList(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The ArrayList<Integer> data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getIntegerArrayListExtra(String)
-     */
-    public Intent putIntegerArrayListExtra(String name, ArrayList<Integer> value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putIntegerArrayList(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The ArrayList<String> data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getStringArrayListExtra(String)
-     */
-    public Intent putStringArrayListExtra(String name, ArrayList<String> value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putStringArrayList(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The ArrayList<CharSequence> data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getCharSequenceArrayListExtra(String)
-     */
-    public Intent putCharSequenceArrayListExtra(String name, ArrayList<CharSequence> value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putCharSequenceArrayList(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The Serializable data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getSerializableExtra(String)
-     */
-    public Intent putExtra(String name, Serializable value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putSerializable(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The boolean array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getBooleanArrayExtra(String)
-     */
-    public Intent putExtra(String name, boolean[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putBooleanArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The byte array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getByteArrayExtra(String)
-     */
-    public Intent putExtra(String name, byte[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putByteArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The short array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getShortArrayExtra(String)
-     */
-    public Intent putExtra(String name, short[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putShortArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The char array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getCharArrayExtra(String)
-     */
-    public Intent putExtra(String name, char[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putCharArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The int array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getIntArrayExtra(String)
-     */
-    public Intent putExtra(String name, int[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putIntArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The byte array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getLongArrayExtra(String)
-     */
-    public Intent putExtra(String name, long[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putLongArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The float array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getFloatArrayExtra(String)
-     */
-    public Intent putExtra(String name, float[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putFloatArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The double array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getDoubleArrayExtra(String)
-     */
-    public Intent putExtra(String name, double[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putDoubleArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The String array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getStringArrayExtra(String)
-     */
-    public Intent putExtra(String name, String[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putStringArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The CharSequence array data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getCharSequenceArrayExtra(String)
-     */
-    public Intent putExtra(String name, CharSequence[] value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putCharSequenceArray(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The Bundle data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getBundleExtra(String)
-     */
-    public Intent putExtra(String name, Bundle value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putBundle(name, value);
-        return this;
-    }
-
-    /**
-     * Add extended data to the intent.  The name must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param name The name of the extra data, with package prefix.
-     * @param value The IBinder data value.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #putExtras
-     * @see #removeExtra
-     * @see #getIBinderExtra(String)
-     *
-     * @deprecated
-     * @hide
-     */
-    @Deprecated
-    public Intent putExtra(String name, IBinder value) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putIBinder(name, value);
-        return this;
-    }
-
-    /**
-     * Copy all extras in 'src' in to this intent.
-     *
-     * @param src Contains the extras to copy.
-     *
-     * @see #putExtra
-     */
-    public Intent putExtras(Intent src) {
-        if (src.mExtras != null) {
-            if (mExtras == null) {
-                mExtras = new Bundle(src.mExtras);
-            } else {
-                mExtras.putAll(src.mExtras);
-            }
-        }
-        return this;
-    }
-
-    /**
-     * Add a set of extended data to the intent.  The keys must include a package
-     * prefix, for example the app com.android.contacts would use names
-     * like "com.android.contacts.ShowAll".
-     *
-     * @param extras The Bundle of extras to add to this intent.
-     *
-     * @see #putExtra
-     * @see #removeExtra
-     */
-    public Intent putExtras(Bundle extras) {
-        if (mExtras == null) {
-            mExtras = new Bundle();
-        }
-        mExtras.putAll(extras);
-        return this;
-    }
-
-    /**
-     * Completely replace the extras in the Intent with the extras in the
-     * given Intent.
-     *
-     * @param src The exact extras contained in this Intent are copied
-     * into the target intent, replacing any that were previously there.
-     */
-    public Intent replaceExtras(Intent src) {
-        mExtras = src.mExtras != null ? new Bundle(src.mExtras) : null;
-        return this;
-    }
-
-    /**
-     * Completely replace the extras in the Intent with the given Bundle of
-     * extras.
-     *
-     * @param extras The new set of extras in the Intent, or null to erase
-     * all extras.
-     */
-    public Intent replaceExtras(Bundle extras) {
-        mExtras = extras != null ? new Bundle(extras) : null;
-        return this;
-    }
-
-    /**
-     * Remove extended data from the intent.
-     *
-     * @see #putExtra
-     */
-    public void removeExtra(String name) {
-        if (mExtras != null) {
-            mExtras.remove(name);
-            if (mExtras.size() == 0) {
-                mExtras = null;
-            }
-        }
-    }
-
-    /**
-     * Set special flags controlling how this intent is handled.  Most values
-     * here depend on the type of component being executed by the Intent,
-     * specifically the FLAG_ACTIVITY_* flags are all for use with
-     * {@link Context#startActivity Context.startActivity()} and the
-     * FLAG_RECEIVER_* flags are all for use with
-     * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
-     *
-     * <p>See the
-     * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
-     * Stack</a> documentation for important information on how some of these options impact
-     * the behavior of your application.
-     *
-     * @param flags The desired flags.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #getFlags
-     * @see #addFlags
-     *
-     * @see #FLAG_GRANT_READ_URI_PERMISSION
-     * @see #FLAG_GRANT_WRITE_URI_PERMISSION
-     * @see #FLAG_DEBUG_LOG_RESOLUTION
-     * @see #FLAG_FROM_BACKGROUND
-     * @see #FLAG_ACTIVITY_BROUGHT_TO_FRONT
-     * @see #FLAG_ACTIVITY_CLEAR_TASK
-     * @see #FLAG_ACTIVITY_CLEAR_TOP
-     * @see #FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET
-     * @see #FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
-     * @see #FLAG_ACTIVITY_FORWARD_RESULT
-     * @see #FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
-     * @see #FLAG_ACTIVITY_MULTIPLE_TASK
-     * @see #FLAG_ACTIVITY_NEW_TASK
-     * @see #FLAG_ACTIVITY_NO_ANIMATION
-     * @see #FLAG_ACTIVITY_NO_HISTORY
-     * @see #FLAG_ACTIVITY_NO_USER_ACTION
-     * @see #FLAG_ACTIVITY_PREVIOUS_IS_TOP
-     * @see #FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
-     * @see #FLAG_ACTIVITY_REORDER_TO_FRONT
-     * @see #FLAG_ACTIVITY_SINGLE_TOP
-     * @see #FLAG_ACTIVITY_TASK_ON_HOME
-     * @see #FLAG_RECEIVER_REGISTERED_ONLY
-     */
-    public Intent setFlags(int flags) {
-        mFlags = flags;
-        return this;
-    }
-
-    /**
-     * Add additional flags to the intent (or with existing flags
-     * value).
-     *
-     * @param flags The new flags to set.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #setFlags
-     */
-    public Intent addFlags(int flags) {
-        mFlags |= flags;
-        return this;
-    }
-
-    /**
-     * (Usually optional) Set an explicit application package name that limits
-     * the components this Intent will resolve to.  If left to the default
-     * value of null, all components in all applications will considered.
-     * If non-null, the Intent can only match the components in the given
-     * application package.
-     *
-     * @param packageName The name of the application package to handle the
-     * intent, or null to allow any application package.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #getPackage
-     * @see #resolveActivity
-     */
-    public Intent setPackage(String packageName) {
-        if (packageName != null && mSelector != null) {
-            throw new IllegalArgumentException(
-                    "Can't set package name when selector is already set");
-        }
-        mPackage = packageName;
-        return this;
-    }
-
-    /**
-     * (Usually optional) Explicitly set the component to handle the intent.
-     * If left with the default value of null, the system will determine the
-     * appropriate class to use based on the other fields (action, data,
-     * type, categories) in the Intent.  If this class is defined, the
-     * specified class will always be used regardless of the other fields.  You
-     * should only set this value when you know you absolutely want a specific
-     * class to be used; otherwise it is better to let the system find the
-     * appropriate class so that you will respect the installed applications
-     * and user preferences.
-     *
-     * @param component The name of the application component to handle the
-     * intent, or null to let the system find one for you.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #setClass
-     * @see #setClassName(Context, String)
-     * @see #setClassName(String, String)
-     * @see #getComponent
-     * @see #resolveActivity
-     */
-    public Intent setComponent(ComponentName component) {
-        mComponent = component;
-        return this;
-    }
-
-    /**
-     * Convenience for calling {@link #setComponent} with an
-     * explicit class name.
-     *
-     * @param packageContext A Context of the application package implementing
-     * this class.
-     * @param className The name of a class inside of the application package
-     * that will be used as the component for this Intent.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #setComponent
-     * @see #setClass
-     */
-    public Intent setClassName(Context packageContext, String className) {
-        mComponent = new ComponentName(packageContext, className);
-        return this;
-    }
-
-    /**
-     * Convenience for calling {@link #setComponent} with an
-     * explicit application package name and class name.
-     *
-     * @param packageName The name of the package implementing the desired
-     * component.
-     * @param className The name of a class inside of the application package
-     * that will be used as the component for this Intent.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #setComponent
-     * @see #setClass
-     */
-    public Intent setClassName(String packageName, String className) {
-        mComponent = new ComponentName(packageName, className);
-        return this;
-    }
-
-    /**
-     * Convenience for calling {@link #setComponent(ComponentName)} with the
-     * name returned by a {@link Class} object.
-     *
-     * @param packageContext A Context of the application package implementing
-     * this class.
-     * @param cls The class name to set, equivalent to
-     *            <code>setClassName(context, cls.getName())</code>.
-     *
-     * @return Returns the same Intent object, for chaining multiple calls
-     * into a single statement.
-     *
-     * @see #setComponent
-     */
-    public Intent setClass(Context packageContext, Class<?> cls) {
-        mComponent = new ComponentName(packageContext, cls);
-        return this;
-    }
-
-    /**
-     * Set the bounds of the sender of this intent, in screen coordinates.  This can be
-     * used as a hint to the receiver for animations and the like.  Null means that there
-     * is no source bounds.
-     */
-    public void setSourceBounds(Rect r) {
-        if (r != null) {
-            mSourceBounds = new Rect(r);
-        } else {
-            mSourceBounds = null;
-        }
-    }
-
-    /**
-     * Use with {@link #fillIn} to allow the current action value to be
-     * overwritten, even if it is already set.
-     */
-    public static final int FILL_IN_ACTION = 1<<0;
-
-    /**
-     * Use with {@link #fillIn} to allow the current data or type value
-     * overwritten, even if it is already set.
-     */
-    public static final int FILL_IN_DATA = 1<<1;
-
-    /**
-     * Use with {@link #fillIn} to allow the current categories to be
-     * overwritten, even if they are already set.
-     */
-    public static final int FILL_IN_CATEGORIES = 1<<2;
-
-    /**
-     * Use with {@link #fillIn} to allow the current component value to be
-     * overwritten, even if it is already set.
-     */
-    public static final int FILL_IN_COMPONENT = 1<<3;
-
-    /**
-     * Use with {@link #fillIn} to allow the current package value to be
-     * overwritten, even if it is already set.
-     */
-    public static final int FILL_IN_PACKAGE = 1<<4;
-
-    /**
-     * Use with {@link #fillIn} to allow the current bounds rectangle to be
-     * overwritten, even if it is already set.
-     */
-    public static final int FILL_IN_SOURCE_BOUNDS = 1<<5;
-
-    /**
-     * Use with {@link #fillIn} to allow the current selector to be
-     * overwritten, even if it is already set.
-     */
-    public static final int FILL_IN_SELECTOR = 1<<6;
-
-    /**
-     * Use with {@link #fillIn} to allow the current ClipData to be
-     * overwritten, even if it is already set.
-     */
-    public static final int FILL_IN_CLIP_DATA = 1<<7;
-
-    /**
-     * Copy the contents of <var>other</var> in to this object, but only
-     * where fields are not defined by this object.  For purposes of a field
-     * being defined, the following pieces of data in the Intent are
-     * considered to be separate fields:
-     *
-     * <ul>
-     * <li> action, as set by {@link #setAction}.
-     * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
-     * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
-     * <li> categories, as set by {@link #addCategory}.
-     * <li> package, as set by {@link #setPackage}.
-     * <li> component, as set by {@link #setComponent(ComponentName)} or
-     * related methods.
-     * <li> source bounds, as set by {@link #setSourceBounds}.
-     * <li> selector, as set by {@link #setSelector(Intent)}.
-     * <li> clip data, as set by {@link #setClipData(ClipData)}.
-     * <li> each top-level name in the associated extras.
-     * </ul>
-     *
-     * <p>In addition, you can use the {@link #FILL_IN_ACTION},
-     * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
-     * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
-     * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
-     * the restriction where the corresponding field will not be replaced if
-     * it is already set.
-     *
-     * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
-     * is explicitly specified.  The selector will only be copied if
-     * {@link #FILL_IN_SELECTOR} is explicitly specified.
-     *
-     * <p>For example, consider Intent A with {data="foo", categories="bar"}
-     * and Intent B with {action="gotit", data-type="some/thing",
-     * categories="one","two"}.
-     *
-     * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
-     * containing: {action="gotit", data-type="some/thing",
-     * categories="bar"}.
-     *
-     * @param other Another Intent whose values are to be used to fill in
-     * the current one.
-     * @param flags Options to control which fields can be filled in.
-     *
-     * @return Returns a bit mask of {@link #FILL_IN_ACTION},
-     * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
-     * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
-     * {@link #FILL_IN_SELECTOR} indicating which fields were changed.
-     */
-    public int fillIn(Intent other, int flags) {
-        int changes = 0;
-        if (other.mAction != null
-                && (mAction == null || (flags&FILL_IN_ACTION) != 0)) {
-            mAction = other.mAction;
-            changes |= FILL_IN_ACTION;
-        }
-        if ((other.mData != null || other.mType != null)
-                && ((mData == null && mType == null)
-                        || (flags&FILL_IN_DATA) != 0)) {
-            mData = other.mData;
-            mType = other.mType;
-            changes |= FILL_IN_DATA;
-        }
-        if (other.mCategories != null
-                && (mCategories == null || (flags&FILL_IN_CATEGORIES) != 0)) {
-            if (other.mCategories != null) {
-                mCategories = new HashSet<String>(other.mCategories);
-            }
-            changes |= FILL_IN_CATEGORIES;
-        }
-        if (other.mPackage != null
-                && (mPackage == null || (flags&FILL_IN_PACKAGE) != 0)) {
-            // Only do this if mSelector is not set.
-            if (mSelector == null) {
-                mPackage = other.mPackage;
-                changes |= FILL_IN_PACKAGE;
-            }
-        }
-        // Selector is special: it can only be set if explicitly allowed,
-        // for the same reason as the component name.
-        if (other.mSelector != null && (flags&FILL_IN_SELECTOR) != 0) {
-            if (mPackage == null) {
-                mSelector = new Intent(other.mSelector);
-                mPackage = null;
-                changes |= FILL_IN_SELECTOR;
-            }
-        }
-        if (other.mClipData != null
-                && (mClipData == null || (flags&FILL_IN_CLIP_DATA) != 0)) {
-            mClipData = other.mClipData;
-            changes |= FILL_IN_CLIP_DATA;
-        }
-        // Component is special: it can -only- be set if explicitly allowed,
-        // since otherwise the sender could force the intent somewhere the
-        // originator didn't intend.
-        if (other.mComponent != null && (flags&FILL_IN_COMPONENT) != 0) {
-            mComponent = other.mComponent;
-            changes |= FILL_IN_COMPONENT;
-        }
-        mFlags |= other.mFlags;
-        if (other.mSourceBounds != null
-                && (mSourceBounds == null || (flags&FILL_IN_SOURCE_BOUNDS) != 0)) {
-            mSourceBounds = new Rect(other.mSourceBounds);
-            changes |= FILL_IN_SOURCE_BOUNDS;
-        }
-        if (mExtras == null) {
-            if (other.mExtras != null) {
-                mExtras = new Bundle(other.mExtras);
-            }
-        } else if (other.mExtras != null) {
-            try {
-                Bundle newb = new Bundle(other.mExtras);
-                newb.putAll(mExtras);
-                mExtras = newb;
-            } catch (RuntimeException e) {
-                // Modifying the extras can cause us to unparcel the contents
-                // of the bundle, and if we do this in the system process that
-                // may fail.  We really should handle this (i.e., the Bundle
-                // impl shouldn't be on top of a plain map), but for now just
-                // ignore it and keep the original contents. :(
-                Log.w("Intent", "Failure filling in extras", e);
-            }
-        }
-        return changes;
-    }
-
-    /**
-     * Wrapper class holding an Intent and implementing comparisons on it for
-     * the purpose of filtering.  The class implements its
-     * {@link #equals equals()} and {@link #hashCode hashCode()} methods as
-     * simple calls to {@link Intent#filterEquals(Intent)}  filterEquals()} and
-     * {@link android.content.Intent#filterHashCode()}  filterHashCode()}
-     * on the wrapped Intent.
-     */
-    public static final class FilterComparison {
-        private final Intent mIntent;
-        private final int mHashCode;
-
-        public FilterComparison(Intent intent) {
-            mIntent = intent;
-            mHashCode = intent.filterHashCode();
-        }
-
-        /**
-         * Return the Intent that this FilterComparison represents.
-         * @return Returns the Intent held by the FilterComparison.  Do
-         * not modify!
-         */
-        public Intent getIntent() {
-            return mIntent;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj instanceof FilterComparison) {
-                Intent other = ((FilterComparison)obj).mIntent;
-                return mIntent.filterEquals(other);
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            return mHashCode;
-        }
-    }
-
-    /**
-     * Determine if two intents are the same for the purposes of intent
-     * resolution (filtering). That is, if their action, data, type,
-     * class, and categories are the same.  This does <em>not</em> compare
-     * any extra data included in the intents.
-     *
-     * @param other The other Intent to compare against.
-     *
-     * @return Returns true if action, data, type, class, and categories
-     *         are the same.
-     */
-    public boolean filterEquals(Intent other) {
-        if (other == null) {
-            return false;
-        }
-        if (mAction != other.mAction) {
-            if (mAction != null) {
-                if (!mAction.equals(other.mAction)) {
-                    return false;
-                }
-            } else {
-                if (!other.mAction.equals(mAction)) {
-                    return false;
-                }
-            }
-        }
-        if (mData != other.mData) {
-            if (mData != null) {
-                if (!mData.equals(other.mData)) {
-                    return false;
-                }
-            } else {
-                if (!other.mData.equals(mData)) {
-                    return false;
-                }
-            }
-        }
-        if (mType != other.mType) {
-            if (mType != null) {
-                if (!mType.equals(other.mType)) {
-                    return false;
-                }
-            } else {
-                if (!other.mType.equals(mType)) {
-                    return false;
-                }
-            }
-        }
-        if (mPackage != other.mPackage) {
-            if (mPackage != null) {
-                if (!mPackage.equals(other.mPackage)) {
-                    return false;
-                }
-            } else {
-                if (!other.mPackage.equals(mPackage)) {
-                    return false;
-                }
-            }
-        }
-        if (mComponent != other.mComponent) {
-            if (mComponent != null) {
-                if (!mComponent.equals(other.mComponent)) {
-                    return false;
-                }
-            } else {
-                if (!other.mComponent.equals(mComponent)) {
-                    return false;
-                }
-            }
-        }
-        if (mCategories != other.mCategories) {
-            if (mCategories != null) {
-                if (!mCategories.equals(other.mCategories)) {
-                    return false;
-                }
-            } else {
-                if (!other.mCategories.equals(mCategories)) {
-                    return false;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Generate hash code that matches semantics of filterEquals().
-     *
-     * @return Returns the hash value of the action, data, type, class, and
-     *         categories.
-     *
-     * @see #filterEquals
-     */
-    public int filterHashCode() {
-        int code = 0;
-        if (mAction != null) {
-            code += mAction.hashCode();
-        }
-        if (mData != null) {
-            code += mData.hashCode();
-        }
-        if (mType != null) {
-            code += mType.hashCode();
-        }
-        if (mPackage != null) {
-            code += mPackage.hashCode();
-        }
-        if (mComponent != null) {
-            code += mComponent.hashCode();
-        }
-        if (mCategories != null) {
-            code += mCategories.hashCode();
-        }
-        return code;
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder b = new StringBuilder(128);
-
-        b.append("Intent { ");
-        toShortString(b, true, true, true, false);
-        b.append(" }");
-
-        return b.toString();
-    }
-
-    /** @hide */
-    public String toInsecureString() {
-        StringBuilder b = new StringBuilder(128);
-
-        b.append("Intent { ");
-        toShortString(b, false, true, true, false);
-        b.append(" }");
-
-        return b.toString();
-    }
-
-    /** @hide */
-    public String toInsecureStringWithClip() {
-        StringBuilder b = new StringBuilder(128);
-
-        b.append("Intent { ");
-        toShortString(b, false, true, true, true);
-        b.append(" }");
-
-        return b.toString();
-    }
-
-    /** @hide */
-    public String toShortString(boolean secure, boolean comp, boolean extras, boolean clip) {
-        StringBuilder b = new StringBuilder(128);
-        toShortString(b, secure, comp, extras, clip);
-        return b.toString();
-    }
-
-    /** @hide */
-    public void toShortString(StringBuilder b, boolean secure, boolean comp, boolean extras,
-            boolean clip) {
-        boolean first = true;
-        if (mAction != null) {
-            b.append("act=").append(mAction);
-            first = false;
-        }
-        if (mCategories != null) {
-            if (!first) {
-                b.append(' ');
-            }
-            first = false;
-            b.append("cat=[");
-            Iterator<String> i = mCategories.iterator();
-            boolean didone = false;
-            while (i.hasNext()) {
-                if (didone) b.append(",");
-                didone = true;
-                b.append(i.next());
-            }
-            b.append("]");
-        }
-        if (mData != null) {
-            if (!first) {
-                b.append(' ');
-            }
-            first = false;
-            b.append("dat=");
-            if (secure) {
-                b.append(mData.toSafeString());
-            } else {
-                b.append(mData);
-            }
-        }
-        if (mType != null) {
-            if (!first) {
-                b.append(' ');
-            }
-            first = false;
-            b.append("typ=").append(mType);
-        }
-        if (mFlags != 0) {
-            if (!first) {
-                b.append(' ');
-            }
-            first = false;
-            b.append("flg=0x").append(Integer.toHexString(mFlags));
-        }
-        if (mPackage != null) {
-            if (!first) {
-                b.append(' ');
-            }
-            first = false;
-            b.append("pkg=").append(mPackage);
-        }
-        if (comp && mComponent != null) {
-            if (!first) {
-                b.append(' ');
-            }
-            first = false;
-            b.append("cmp=").append(mComponent.flattenToShortString());
-        }
-        if (mSourceBounds != null) {
-            if (!first) {
-                b.append(' ');
-            }
-            first = false;
-            b.append("bnds=").append(mSourceBounds.toShortString());
-        }
-        if (mClipData != null) {
-            if (!first) {
-                b.append(' ');
-            }
-            first = false;
-            if (clip) {
-                b.append("clip={");
-                mClipData.toShortString(b);
-                b.append('}');
-            } else {
-                b.append("(has clip)");
-            }
-        }
-        if (extras && mExtras != null) {
-            if (!first) {
-                b.append(' ');
-            }
-            first = false;
-            b.append("(has extras)");
-        }
-        if (mSelector != null) {
-            b.append(" sel={");
-            mSelector.toShortString(b, secure, comp, extras, clip);
-            b.append("}");
-        }
-    }
-
-    /**
-     * Call {@link #toUri} with 0 flags.
-     * @deprecated Use {@link #toUri} instead.
-     */
-    @Deprecated
-    public String toURI() {
-        return toUri(0);
-    }
-
-    /**
-     * Convert this Intent into a String holding a URI representation of it.
-     * The returned URI string has been properly URI encoded, so it can be
-     * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
-     * Intent's data as the base URI, with an additional fragment describing
-     * the action, categories, type, flags, package, component, and extras.
-     *
-     * <p>You can convert the returned string back to an Intent with
-     * {@link #getIntent}.
-     *
-     * @param flags Additional operating flags.  Either 0 or
-     * {@link #URI_INTENT_SCHEME}.
-     *
-     * @return Returns a URI encoding URI string describing the entire contents
-     * of the Intent.
-     */
-    public String toUri(int flags) {
-        StringBuilder uri = new StringBuilder(128);
-        String scheme = null;
-        if (mData != null) {
-            String data = mData.toString();
-            if ((flags&URI_INTENT_SCHEME) != 0) {
-                final int N = data.length();
-                for (int i=0; i<N; i++) {
-                    char c = data.charAt(i);
-                    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
-                            || c == '.' || c == '-') {
-                        continue;
-                    }
-                    if (c == ':' && i > 0) {
-                        // Valid scheme.
-                        scheme = data.substring(0, i);
-                        uri.append("intent:");
-                        data = data.substring(i+1);
-                        break;
-                    }
-
-                    // No scheme.
-                    break;
-                }
-            }
-            uri.append(data);
-
-        } else if ((flags&URI_INTENT_SCHEME) != 0) {
-            uri.append("intent:");
-        }
-
-        uri.append("#Intent;");
-
-        toUriInner(uri, scheme, flags);
-        if (mSelector != null) {
-            uri.append("SEL;");
-            // Note that for now we are not going to try to handle the
-            // data part; not clear how to represent this as a URI, and
-            // not much utility in it.
-            mSelector.toUriInner(uri, null, flags);
-        }
-
-        uri.append("end");
-
-        return uri.toString();
-    }
-
-    private void toUriInner(StringBuilder uri, String scheme, int flags) {
-        if (scheme != null) {
-            uri.append("scheme=").append(scheme).append(';');
-        }
-        if (mAction != null) {
-            uri.append("action=").append(Uri.encode(mAction)).append(';');
-        }
-        if (mCategories != null) {
-            for (String category : mCategories) {
-                uri.append("category=").append(Uri.encode(category)).append(';');
-            }
-        }
-        if (mType != null) {
-            uri.append("type=").append(Uri.encode(mType, "/")).append(';');
-        }
-        if (mFlags != 0) {
-            uri.append("launchFlags=0x").append(Integer.toHexString(mFlags)).append(';');
-        }
-        if (mPackage != null) {
-            uri.append("package=").append(Uri.encode(mPackage)).append(';');
-        }
-        if (mComponent != null) {
-            uri.append("component=").append(Uri.encode(
-                    mComponent.flattenToShortString(), "/")).append(';');
-        }
-        if (mSourceBounds != null) {
-            uri.append("sourceBounds=")
-                    .append(Uri.encode(mSourceBounds.flattenToString()))
-                    .append(';');
-        }
-        if (mExtras != null) {
-            for (String key : mExtras.keySet()) {
-                final Object value = mExtras.get(key);
-                char entryType =
-                        value instanceof String    ? 'S' :
-                        value instanceof Boolean   ? 'B' :
-                        value instanceof Byte      ? 'b' :
-                        value instanceof Character ? 'c' :
-                        value instanceof Double    ? 'd' :
-                        value instanceof Float     ? 'f' :
-                        value instanceof Integer   ? 'i' :
-                        value instanceof Long      ? 'l' :
-                        value instanceof Short     ? 's' :
-                        '\0';
-
-                if (entryType != '\0') {
-                    uri.append(entryType);
-                    uri.append('.');
-                    uri.append(Uri.encode(key));
-                    uri.append('=');
-                    uri.append(Uri.encode(value.toString()));
-                    uri.append(';');
-                }
-            }
-        }
-    }
-
-    public int describeContents() {
-        return (mExtras != null) ? mExtras.describeContents() : 0;
-    }
-
-    public void writeToParcel(Parcel out, int flags) {
-        out.writeString(mAction);
-        Uri.writeToParcel(out, mData);
-        out.writeString(mType);
-        out.writeInt(mFlags);
-        out.writeString(mPackage);
-        ComponentName.writeToParcel(mComponent, out);
-
-        if (mSourceBounds != null) {
-            out.writeInt(1);
-            mSourceBounds.writeToParcel(out, flags);
-        } else {
-            out.writeInt(0);
-        }
-
-        if (mCategories != null) {
-            out.writeInt(mCategories.size());
-            for (String category : mCategories) {
-                out.writeString(category);
-            }
-        } else {
-            out.writeInt(0);
-        }
-
-        if (mSelector != null) {
-            out.writeInt(1);
-            mSelector.writeToParcel(out, flags);
-        } else {
-            out.writeInt(0);
-        }
-
-        if (mClipData != null) {
-            out.writeInt(1);
-            mClipData.writeToParcel(out, flags);
-        } else {
-            out.writeInt(0);
-        }
-
-        out.writeBundle(mExtras);
-    }
-
-    public static final Parcelable.Creator<Intent> CREATOR
-            = new Parcelable.Creator<Intent>() {
-        public Intent createFromParcel(Parcel in) {
-            return new Intent(in);
-        }
-        public Intent[] newArray(int size) {
-            return new Intent[size];
-        }
-    };
-
-    /** @hide */
-    protected Intent(Parcel in) {
-        readFromParcel(in);
-    }
-
-    public void readFromParcel(Parcel in) {
-        setAction(in.readString());
-        mData = Uri.CREATOR.createFromParcel(in);
-        mType = in.readString();
-        mFlags = in.readInt();
-        mPackage = in.readString();
-        mComponent = ComponentName.readFromParcel(in);
-
-        if (in.readInt() != 0) {
-            mSourceBounds = Rect.CREATOR.createFromParcel(in);
-        }
-
-        int N = in.readInt();
-        if (N > 0) {
-            mCategories = new HashSet<String>();
-            int i;
-            for (i=0; i<N; i++) {
-                mCategories.add(in.readString().intern());
-            }
-        } else {
-            mCategories = null;
-        }
-
-        if (in.readInt() != 0) {
-            mSelector = new Intent(in);
-        }
-
-        if (in.readInt() != 0) {
-            mClipData = new ClipData(in);
-        }
-
-        mExtras = in.readBundle();
-    }
-
-    /**
-     * Parses the "intent" element (and its children) from XML and instantiates
-     * an Intent object.  The given XML parser should be located at the tag
-     * where parsing should start (often named "intent"), from which the
-     * basic action, data, type, and package and class name will be
-     * retrieved.  The function will then parse in to any child elements,
-     * looking for <category android:name="xxx"> tags to add categories and
-     * <extra android:name="xxx" android:value="yyy"> to attach extra data
-     * to the intent.
-     *
-     * @param resources The Resources to use when inflating resources.
-     * @param parser The XML parser pointing at an "intent" tag.
-     * @param attrs The AttributeSet interface for retrieving extended
-     * attribute data at the current <var>parser</var> location.
-     * @return An Intent object matching the XML data.
-     * @throws XmlPullParserException If there was an XML parsing error.
-     * @throws IOException If there was an I/O error.
-     */
-    public static Intent parseIntent(Resources resources, XmlPullParser parser, AttributeSet attrs)
-            throws XmlPullParserException, IOException {
-        Intent intent = new Intent();
-
-        TypedArray sa = resources.obtainAttributes(attrs,
-                com.android.internal.R.styleable.Intent);
-
-        intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
-
-        String data = sa.getString(com.android.internal.R.styleable.Intent_data);
-        String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
-        intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
-
-        String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
-        String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
-        if (packageName != null && className != null) {
-            intent.setComponent(new ComponentName(packageName, className));
-        }
-
-        sa.recycle();
-
-        int outerDepth = parser.getDepth();
-        int type;
-        while ((type=parser.next()) != XmlPullParser.END_DOCUMENT
-               && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
-            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
-                continue;
-            }
-
-            String nodeName = parser.getName();
-            if (nodeName.equals("category")) {
-                sa = resources.obtainAttributes(attrs,
-                        com.android.internal.R.styleable.IntentCategory);
-                String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
-                sa.recycle();
-
-                if (cat != null) {
-                    intent.addCategory(cat);
-                }
-                XmlUtils.skipCurrentTag(parser);
-
-            } else if (nodeName.equals("extra")) {
-                if (intent.mExtras == null) {
-                    intent.mExtras = new Bundle();
-                }
-                resources.parseBundleExtra("extra", attrs, intent.mExtras);
-                XmlUtils.skipCurrentTag(parser);
-
-            } else {
-                XmlUtils.skipCurrentTag(parser);
-            }
-        }
-
-        return intent;
-    }
-
-    /**
-     * Normalize a MIME data type.
-     *
-     * <p>A normalized MIME type has white-space trimmed,
-     * content-type parameters removed, and is lower-case.
-     * This aligns the type with Android best practices for
-     * intent filtering.
-     *
-     * <p>For example, "text/plain; charset=utf-8" becomes "text/plain".
-     * "text/x-vCard" becomes "text/x-vcard".
-     *
-     * <p>All MIME types received from outside Android (such as user input,
-     * or external sources like Bluetooth, NFC, or the Internet) should
-     * be normalized before they are used to create an Intent.
-     *
-     * @param type MIME data type to normalize
-     * @return normalized MIME data type, or null if the input was null
-     * @see {@link #setType}
-     * @see {@link #setTypeAndNormalize}
-     */
-    public static String normalizeMimeType(String type) {
-        if (type == null) {
-            return null;
-        }
-
-        type = type.trim().toLowerCase(Locale.US);
-
-        final int semicolonIndex = type.indexOf(';');
-        if (semicolonIndex != -1) {
-            type = type.substring(0, semicolonIndex);
-        }
-        return type;
-    }
-
-    /**
-     * Migrate any {@link #EXTRA_STREAM} in {@link #ACTION_SEND} and
-     * {@link #ACTION_SEND_MULTIPLE} to {@link ClipData}. Also inspects nested
-     * intents in {@link #ACTION_CHOOSER}.
-     *
-     * @return Whether any contents were migrated.
-     * @hide
-     */
-    public boolean migrateExtraStreamToClipData() {
-        // Refuse to touch if extras already parcelled
-        if (mExtras != null && mExtras.isParcelled()) return false;
-
-        // Bail when someone already gave us ClipData
-        if (getClipData() != null) return false;
-
-        final String action = getAction();
-        if (ACTION_CHOOSER.equals(action)) {
-            try {
-                // Inspect target intent to see if we need to migrate
-                final Intent target = getParcelableExtra(EXTRA_INTENT);
-                if (target != null && target.migrateExtraStreamToClipData()) {
-                    // Since we migrated in child, we need to promote ClipData
-                    // and flags to ourselves to grant.
-                    setClipData(target.getClipData());
-                    addFlags(target.getFlags()
-                            & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION));
-                    return true;
-                } else {
-                    return false;
-                }
-            } catch (ClassCastException e) {
-            }
-
-        } else if (ACTION_SEND.equals(action)) {
-            try {
-                final Uri stream = getParcelableExtra(EXTRA_STREAM);
-                final CharSequence text = getCharSequenceExtra(EXTRA_TEXT);
-                final String htmlText = getStringExtra(EXTRA_HTML_TEXT);
-                if (stream != null || text != null || htmlText != null) {
-                    final ClipData clipData = new ClipData(
-                            null, new String[] { getType() },
-                            new ClipData.Item(text, htmlText, null, stream));
-                    setClipData(clipData);
-                    addFlags(FLAG_GRANT_READ_URI_PERMISSION);
-                    return true;
-                }
-            } catch (ClassCastException e) {
-            }
-
-        } else if (ACTION_SEND_MULTIPLE.equals(action)) {
-            try {
-                final ArrayList<Uri> streams = getParcelableArrayListExtra(EXTRA_STREAM);
-                final ArrayList<CharSequence> texts = getCharSequenceArrayListExtra(EXTRA_TEXT);
-                final ArrayList<String> htmlTexts = getStringArrayListExtra(EXTRA_HTML_TEXT);
-                int num = -1;
-                if (streams != null) {
-                    num = streams.size();
-                }
-                if (texts != null) {
-                    if (num >= 0 && num != texts.size()) {
-                        // Wha...!  F- you.
-                        return false;
-                    }
-                    num = texts.size();
-                }
-                if (htmlTexts != null) {
-                    if (num >= 0 && num != htmlTexts.size()) {
-                        // Wha...!  F- you.
-                        return false;
-                    }
-                    num = htmlTexts.size();
-                }
-                if (num > 0) {
-                    final ClipData clipData = new ClipData(
-                            null, new String[] { getType() },
-                            makeClipItem(streams, texts, htmlTexts, 0));
-
-                    for (int i = 1; i < num; i++) {
-                        clipData.addItem(makeClipItem(streams, texts, htmlTexts, i));
-                    }
-
-                    setClipData(clipData);
-                    addFlags(FLAG_GRANT_READ_URI_PERMISSION);
-                    return true;
-                }
-            } catch (ClassCastException e) {
-            }
-        }
-
-        return false;
-    }
-
-    private static ClipData.Item makeClipItem(ArrayList<Uri> streams, ArrayList<CharSequence> texts,
-            ArrayList<String> htmlTexts, int which) {
-        Uri uri = streams != null ? streams.get(which) : null;
-        CharSequence text = texts != null ? texts.get(which) : null;
-        String htmlText = htmlTexts != null ? htmlTexts.get(which) : null;
-        return new ClipData.Item(text, htmlText, null, uri);
-    }
-}
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.util.Log;
+
+import com.android.internal.util.XmlUtils;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.net.URISyntaxException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Locale;
+import java.util.Set;
+
+/**
+ * An intent is an abstract description of an operation to be performed.  It
+ * can be used with {@link Context#startActivity(Intent) startActivity} to
+ * launch an {@link android.app.Activity},
+ * {@link android.content.Context#sendBroadcast(Intent) broadcastIntent} to
+ * send it to any interested {@link BroadcastReceiver BroadcastReceiver} components,
+ * and {@link android.content.Context#startService} or
+ * {@link android.content.Context#bindService} to communicate with a
+ * background {@link android.app.Service}.
+ *
+ * <p>An Intent provides a facility for performing late runtime binding between the code in
+ * different applications. Its most significant use is in the launching of activities, where it
+ * can be thought of as the glue between activities. It is basically a passive data structure
+ * holding an abstract description of an action to be performed.</p>
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For information about how to create and resolve intents, read the
+ * <a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>
+ * developer guide.</p>
+ * </div>
+ *
+ * <a name="IntentStructure"></a>
+ * <h3>Intent Structure</h3>
+ * <p>The primary pieces of information in an intent are:</p>
+ *
+ * <ul>
+ *   <li> <p><b>action</b> -- The general action to be performed, such as
+ *     {@link #ACTION_VIEW}, {@link #ACTION_EDIT}, {@link #ACTION_MAIN},
+ *     etc.</p>
+ *   </li>
+ *   <li> <p><b>data</b> -- The data to operate on, such as a person record
+ *     in the contacts database, expressed as a {@link android.net.Uri}.</p>
+ *   </li>
+ * </ul>
+ *
+ *
+ * <p>Some examples of action/data pairs are:</p>
+ *
+ * <ul>
+ *   <li> <p><b>{@link #ACTION_VIEW} <i>content://contacts/people/1</i></b> -- Display
+ *     information about the person whose identifier is "1".</p>
+ *   </li>
+ *   <li> <p><b>{@link #ACTION_DIAL} <i>content://contacts/people/1</i></b> -- Display
+ *     the phone dialer with the person filled in.</p>
+ *   </li>
+ *   <li> <p><b>{@link #ACTION_VIEW} <i>tel:123</i></b> -- Display
+ *     the phone dialer with the given number filled in.  Note how the
+ *     VIEW action does what what is considered the most reasonable thing for
+ *     a particular URI.</p>
+ *   </li>
+ *   <li> <p><b>{@link #ACTION_DIAL} <i>tel:123</i></b> -- Display
+ *     the phone dialer with the given number filled in.</p>
+ *   </li>
+ *   <li> <p><b>{@link #ACTION_EDIT} <i>content://contacts/people/1</i></b> -- Edit
+ *     information about the person whose identifier is "1".</p>
+ *   </li>
+ *   <li> <p><b>{@link #ACTION_VIEW} <i>content://contacts/people/</i></b> -- Display
+ *     a list of people, which the user can browse through.  This example is a
+ *     typical top-level entry into the Contacts application, showing you the
+ *     list of people. Selecting a particular person to view would result in a
+ *     new intent { <b>{@link #ACTION_VIEW} <i>content://contacts/N</i></b> }
+ *     being used to start an activity to display that person.</p>
+ *   </li>
+ * </ul>
+ *
+ * <p>In addition to these primary attributes, there are a number of secondary
+ * attributes that you can also include with an intent:</p>
+ *
+ * <ul>
+ *     <li> <p><b>category</b> -- Gives additional information about the action
+ *         to execute.  For example, {@link #CATEGORY_LAUNCHER} means it should
+ *         appear in the Launcher as a top-level application, while
+ *         {@link #CATEGORY_ALTERNATIVE} means it should be included in a list
+ *         of alternative actions the user can perform on a piece of data.</p>
+ *     <li> <p><b>type</b> -- Specifies an explicit type (a MIME type) of the
+ *         intent data.  Normally the type is inferred from the data itself.
+ *         By setting this attribute, you disable that evaluation and force
+ *         an explicit type.</p>
+ *     <li> <p><b>component</b> -- Specifies an explicit name of a component
+ *         class to use for the intent.  Normally this is determined by looking
+ *         at the other information in the intent (the action, data/type, and
+ *         categories) and matching that with a component that can handle it.
+ *         If this attribute is set then none of the evaluation is performed,
+ *         and this component is used exactly as is.  By specifying this attribute,
+ *         all of the other Intent attributes become optional.</p>
+ *     <li> <p><b>extras</b> -- This is a {@link Bundle} of any additional information.
+ *         This can be used to provide extended information to the component.
+ *         For example, if we have a action to send an e-mail message, we could
+ *         also include extra pieces of data here to supply a subject, body,
+ *         etc.</p>
+ * </ul>
+ *
+ * <p>Here are some examples of other operations you can specify as intents
+ * using these additional parameters:</p>
+ *
+ * <ul>
+ *   <li> <p><b>{@link #ACTION_MAIN} with category {@link #CATEGORY_HOME}</b> --
+ *     Launch the home screen.</p>
+ *   </li>
+ *   <li> <p><b>{@link #ACTION_GET_CONTENT} with MIME type
+ *     <i>{@link android.provider.Contacts.Phones#CONTENT_URI
+ *     vnd.android.cursor.item/phone}</i></b>
+ *     -- Display the list of people's phone numbers, allowing the user to
+ *     browse through them and pick one and return it to the parent activity.</p>
+ *   </li>
+ *   <li> <p><b>{@link #ACTION_GET_CONTENT} with MIME type
+ *     <i>*{@literal /}*</i> and category {@link #CATEGORY_OPENABLE}</b>
+ *     -- Display all pickers for data that can be opened with
+ *     {@link ContentResolver#openInputStream(Uri) ContentResolver.openInputStream()},
+ *     allowing the user to pick one of them and then some data inside of it
+ *     and returning the resulting URI to the caller.  This can be used,
+ *     for example, in an e-mail application to allow the user to pick some
+ *     data to include as an attachment.</p>
+ *   </li>
+ * </ul>
+ *
+ * <p>There are a variety of standard Intent action and category constants
+ * defined in the Intent class, but applications can also define their own.
+ * These strings use java style scoping, to ensure they are unique -- for
+ * example, the standard {@link #ACTION_VIEW} is called
+ * "android.intent.action.VIEW".</p>
+ *
+ * <p>Put together, the set of actions, data types, categories, and extra data
+ * defines a language for the system allowing for the expression of phrases
+ * such as "call john smith's cell".  As applications are added to the system,
+ * they can extend this language by adding new actions, types, and categories, or
+ * they can modify the behavior of existing phrases by supplying their own
+ * activities that handle them.</p>
+ *
+ * <a name="IntentResolution"></a>
+ * <h3>Intent Resolution</h3>
+ *
+ * <p>There are two primary forms of intents you will use.
+ *
+ * <ul>
+ *     <li> <p><b>Explicit Intents</b> have specified a component (via
+ *     {@link #setComponent} or {@link #setClass}), which provides the exact
+ *     class to be run.  Often these will not include any other information,
+ *     simply being a way for an application to launch various internal
+ *     activities it has as the user interacts with the application.
+ *
+ *     <li> <p><b>Implicit Intents</b> have not specified a component;
+ *     instead, they must include enough information for the system to
+ *     determine which of the available components is best to run for that
+ *     intent.
+ * </ul>
+ *
+ * <p>When using implicit intents, given such an arbitrary intent we need to
+ * know what to do with it. This is handled by the process of <em>Intent
+ * resolution</em>, which maps an Intent to an {@link android.app.Activity},
+ * {@link BroadcastReceiver}, or {@link android.app.Service} (or sometimes two or
+ * more activities/receivers) that can handle it.</p>
+ *
+ * <p>The intent resolution mechanism basically revolves around matching an
+ * Intent against all of the &lt;intent-filter&gt; descriptions in the
+ * installed application packages.  (Plus, in the case of broadcasts, any {@link BroadcastReceiver}
+ * objects explicitly registered with {@link Context#registerReceiver}.)  More
+ * details on this can be found in the documentation on the {@link
+ * IntentFilter} class.</p>
+ *
+ * <p>There are three pieces of information in the Intent that are used for
+ * resolution: the action, type, and category.  Using this information, a query
+ * is done on the {@link PackageManager} for a component that can handle the
+ * intent. The appropriate component is determined based on the intent
+ * information supplied in the <code>AndroidManifest.xml</code> file as
+ * follows:</p>
+ *
+ * <ul>
+ *     <li> <p>The <b>action</b>, if given, must be listed by the component as
+ *         one it handles.</p>
+ *     <li> <p>The <b>type</b> is retrieved from the Intent's data, if not
+ *         already supplied in the Intent.  Like the action, if a type is
+ *         included in the intent (either explicitly or implicitly in its
+ *         data), then this must be listed by the component as one it handles.</p>
+ *     <li> For data that is not a <code>content:</code> URI and where no explicit
+ *         type is included in the Intent, instead the <b>scheme</b> of the
+ *         intent data (such as <code>http:</code> or <code>mailto:</code>) is
+ *         considered. Again like the action, if we are matching a scheme it
+ *         must be listed by the component as one it can handle.
+ *     <li> <p>The <b>categories</b>, if supplied, must <em>all</em> be listed
+ *         by the activity as categories it handles.  That is, if you include
+ *         the categories {@link #CATEGORY_LAUNCHER} and
+ *         {@link #CATEGORY_ALTERNATIVE}, then you will only resolve to components
+ *         with an intent that lists <em>both</em> of those categories.
+ *         Activities will very often need to support the
+ *         {@link #CATEGORY_DEFAULT} so that they can be found by
+ *         {@link Context#startActivity Context.startActivity()}.</p>
+ * </ul>
+ *
+ * <p>For example, consider the Note Pad sample application that
+ * allows user to browse through a list of notes data and view details about
+ * individual items.  Text in italics indicate places were you would replace a
+ * name with one specific to your own package.</p>
+ *
+ * <pre> &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
+ *       package="<i>com.android.notepad</i>"&gt;
+ *     &lt;application android:icon="@drawable/app_notes"
+ *             android:label="@string/app_name"&gt;
+ *
+ *         &lt;provider class=".NotePadProvider"
+ *                 android:authorities="<i>com.google.provider.NotePad</i>" /&gt;
+ *
+ *         &lt;activity class=".NotesList" android:label="@string/title_notes_list"&gt;
+ *             &lt;intent-filter&gt;
+ *                 &lt;action android:name="android.intent.action.MAIN" /&gt;
+ *                 &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
+ *             &lt;/intent-filter&gt;
+ *             &lt;intent-filter&gt;
+ *                 &lt;action android:name="android.intent.action.VIEW" /&gt;
+ *                 &lt;action android:name="android.intent.action.EDIT" /&gt;
+ *                 &lt;action android:name="android.intent.action.PICK" /&gt;
+ *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
+ *                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
+ *             &lt;/intent-filter&gt;
+ *             &lt;intent-filter&gt;
+ *                 &lt;action android:name="android.intent.action.GET_CONTENT" /&gt;
+ *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
+ *                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
+ *             &lt;/intent-filter&gt;
+ *         &lt;/activity&gt;
+ *
+ *         &lt;activity class=".NoteEditor" android:label="@string/title_note"&gt;
+ *             &lt;intent-filter android:label="@string/resolve_edit"&gt;
+ *                 &lt;action android:name="android.intent.action.VIEW" /&gt;
+ *                 &lt;action android:name="android.intent.action.EDIT" /&gt;
+ *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
+ *                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
+ *             &lt;/intent-filter&gt;
+ *
+ *             &lt;intent-filter&gt;
+ *                 &lt;action android:name="android.intent.action.INSERT" /&gt;
+ *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
+ *                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
+ *             &lt;/intent-filter&gt;
+ *
+ *         &lt;/activity&gt;
+ *
+ *         &lt;activity class=".TitleEditor" android:label="@string/title_edit_title"
+ *                 android:theme="@android:style/Theme.Dialog"&gt;
+ *             &lt;intent-filter android:label="@string/resolve_title"&gt;
+ *                 &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
+ *                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
+ *                 &lt;category android:name="android.intent.category.ALTERNATIVE" /&gt;
+ *                 &lt;category android:name="android.intent.category.SELECTED_ALTERNATIVE" /&gt;
+ *                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
+ *             &lt;/intent-filter&gt;
+ *         &lt;/activity&gt;
+ *
+ *     &lt;/application&gt;
+ * &lt;/manifest&gt;</pre>
+ *
+ * <p>The first activity,
+ * <code>com.android.notepad.NotesList</code>, serves as our main
+ * entry into the app.  It can do three things as described by its three intent
+ * templates:
+ * <ol>
+ * <li><pre>
+ * &lt;intent-filter&gt;
+ *     &lt;action android:name="{@link #ACTION_MAIN android.intent.action.MAIN}" /&gt;
+ *     &lt;category android:name="{@link #CATEGORY_LAUNCHER android.intent.category.LAUNCHER}" /&gt;
+ * &lt;/intent-filter&gt;</pre>
+ * <p>This provides a top-level entry into the NotePad application: the standard
+ * MAIN action is a main entry point (not requiring any other information in
+ * the Intent), and the LAUNCHER category says that this entry point should be
+ * listed in the application launcher.</p>
+ * <li><pre>
+ * &lt;intent-filter&gt;
+ *     &lt;action android:name="{@link #ACTION_VIEW android.intent.action.VIEW}" /&gt;
+ *     &lt;action android:name="{@link #ACTION_EDIT android.intent.action.EDIT}" /&gt;
+ *     &lt;action android:name="{@link #ACTION_PICK android.intent.action.PICK}" /&gt;
+ *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
+ *     &lt;data mimeType:name="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
+ * &lt;/intent-filter&gt;</pre>
+ * <p>This declares the things that the activity can do on a directory of
+ * notes.  The type being supported is given with the &lt;type&gt; tag, where
+ * <code>vnd.android.cursor.dir/vnd.google.note</code> is a URI from which
+ * a Cursor of zero or more items (<code>vnd.android.cursor.dir</code>) can
+ * be retrieved which holds our note pad data (<code>vnd.google.note</code>).
+ * The activity allows the user to view or edit the directory of data (via
+ * the VIEW and EDIT actions), or to pick a particular note and return it
+ * to the caller (via the PICK action).  Note also the DEFAULT category
+ * supplied here: this is <em>required</em> for the
+ * {@link Context#startActivity Context.startActivity} method to resolve your
+ * activity when its component name is not explicitly specified.</p>
+ * <li><pre>
+ * &lt;intent-filter&gt;
+ *     &lt;action android:name="{@link #ACTION_GET_CONTENT android.intent.action.GET_CONTENT}" /&gt;
+ *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
+ *     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
+ * &lt;/intent-filter&gt;</pre>
+ * <p>This filter describes the ability return to the caller a note selected by
+ * the user without needing to know where it came from.  The data type
+ * <code>vnd.android.cursor.item/vnd.google.note</code> is a URI from which
+ * a Cursor of exactly one (<code>vnd.android.cursor.item</code>) item can
+ * be retrieved which contains our note pad data (<code>vnd.google.note</code>).
+ * The GET_CONTENT action is similar to the PICK action, where the activity
+ * will return to its caller a piece of data selected by the user.  Here,
+ * however, the caller specifies the type of data they desire instead of
+ * the type of data the user will be picking from.</p>
+ * </ol>
+ *
+ * <p>Given these capabilities, the following intents will resolve to the
+ * NotesList activity:</p>
+ *
+ * <ul>
+ *     <li> <p><b>{ action=android.app.action.MAIN }</b> matches all of the
+ *         activities that can be used as top-level entry points into an
+ *         application.</p>
+ *     <li> <p><b>{ action=android.app.action.MAIN,
+ *         category=android.app.category.LAUNCHER }</b> is the actual intent
+ *         used by the Launcher to populate its top-level list.</p>
+ *     <li> <p><b>{ action=android.intent.action.VIEW
+ *          data=content://com.google.provider.NotePad/notes }</b>
+ *         displays a list of all the notes under
+ *         "content://com.google.provider.NotePad/notes", which
+ *         the user can browse through and see the details on.</p>
+ *     <li> <p><b>{ action=android.app.action.PICK
+ *          data=content://com.google.provider.NotePad/notes }</b>
+ *         provides a list of the notes under
+ *         "content://com.google.provider.NotePad/notes", from which
+ *         the user can pick a note whose data URL is returned back to the caller.</p>
+ *     <li> <p><b>{ action=android.app.action.GET_CONTENT
+ *          type=vnd.android.cursor.item/vnd.google.note }</b>
+ *         is similar to the pick action, but allows the caller to specify the
+ *         kind of data they want back so that the system can find the appropriate
+ *         activity to pick something of that data type.</p>
+ * </ul>
+ *
+ * <p>The second activity,
+ * <code>com.android.notepad.NoteEditor</code>, shows the user a single
+ * note entry and allows them to edit it.  It can do two things as described
+ * by its two intent templates:
+ * <ol>
+ * <li><pre>
+ * &lt;intent-filter android:label="@string/resolve_edit"&gt;
+ *     &lt;action android:name="{@link #ACTION_VIEW android.intent.action.VIEW}" /&gt;
+ *     &lt;action android:name="{@link #ACTION_EDIT android.intent.action.EDIT}" /&gt;
+ *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
+ *     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
+ * &lt;/intent-filter&gt;</pre>
+ * <p>The first, primary, purpose of this activity is to let the user interact
+ * with a single note, as decribed by the MIME type
+ * <code>vnd.android.cursor.item/vnd.google.note</code>.  The activity can
+ * either VIEW a note or allow the user to EDIT it.  Again we support the
+ * DEFAULT category to allow the activity to be launched without explicitly
+ * specifying its component.</p>
+ * <li><pre>
+ * &lt;intent-filter&gt;
+ *     &lt;action android:name="{@link #ACTION_INSERT android.intent.action.INSERT}" /&gt;
+ *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
+ *     &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
+ * &lt;/intent-filter&gt;</pre>
+ * <p>The secondary use of this activity is to insert a new note entry into
+ * an existing directory of notes.  This is used when the user creates a new
+ * note: the INSERT action is executed on the directory of notes, causing
+ * this activity to run and have the user create the new note data which
+ * it then adds to the content provider.</p>
+ * </ol>
+ *
+ * <p>Given these capabilities, the following intents will resolve to the
+ * NoteEditor activity:</p>
+ *
+ * <ul>
+ *     <li> <p><b>{ action=android.intent.action.VIEW
+ *          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }</b>
+ *         shows the user the content of note <var>{ID}</var>.</p>
+ *     <li> <p><b>{ action=android.app.action.EDIT
+ *          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }</b>
+ *         allows the user to edit the content of note <var>{ID}</var>.</p>
+ *     <li> <p><b>{ action=android.app.action.INSERT
+ *          data=content://com.google.provider.NotePad/notes }</b>
+ *         creates a new, empty note in the notes list at
+ *         "content://com.google.provider.NotePad/notes"
+ *         and allows the user to edit it.  If they keep their changes, the URI
+ *         of the newly created note is returned to the caller.</p>
+ * </ul>
+ *
+ * <p>The last activity,
+ * <code>com.android.notepad.TitleEditor</code>, allows the user to
+ * edit the title of a note.  This could be implemented as a class that the
+ * application directly invokes (by explicitly setting its component in
+ * the Intent), but here we show a way you can publish alternative
+ * operations on existing data:</p>
+ *
+ * <pre>
+ * &lt;intent-filter android:label="@string/resolve_title"&gt;
+ *     &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
+ *     &lt;category android:name="{@link #CATEGORY_DEFAULT android.intent.category.DEFAULT}" /&gt;
+ *     &lt;category android:name="{@link #CATEGORY_ALTERNATIVE android.intent.category.ALTERNATIVE}" /&gt;
+ *     &lt;category android:name="{@link #CATEGORY_SELECTED_ALTERNATIVE android.intent.category.SELECTED_ALTERNATIVE}" /&gt;
+ *     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
+ * &lt;/intent-filter&gt;</pre>
+ *
+ * <p>In the single intent template here, we
+ * have created our own private action called
+ * <code>com.android.notepad.action.EDIT_TITLE</code> which means to
+ * edit the title of a note.  It must be invoked on a specific note
+ * (data type <code>vnd.android.cursor.item/vnd.google.note</code>) like the previous
+ * view and edit actions, but here displays and edits the title contained
+ * in the note data.
+ *
+ * <p>In addition to supporting the default category as usual, our title editor
+ * also supports two other standard categories: ALTERNATIVE and
+ * SELECTED_ALTERNATIVE.  Implementing
+ * these categories allows others to find the special action it provides
+ * without directly knowing about it, through the
+ * {@link android.content.pm.PackageManager#queryIntentActivityOptions} method, or
+ * more often to build dynamic menu items with
+ * {@link android.view.Menu#addIntentOptions}.  Note that in the intent
+ * template here was also supply an explicit name for the template
+ * (via <code>android:label="@string/resolve_title"</code>) to better control
+ * what the user sees when presented with this activity as an alternative
+ * action to the data they are viewing.
+ *
+ * <p>Given these capabilities, the following intent will resolve to the
+ * TitleEditor activity:</p>
+ *
+ * <ul>
+ *     <li> <p><b>{ action=com.android.notepad.action.EDIT_TITLE
+ *          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }</b>
+ *         displays and allows the user to edit the title associated
+ *         with note <var>{ID}</var>.</p>
+ * </ul>
+ *
+ * <h3>Standard Activity Actions</h3>
+ *
+ * <p>These are the current standard actions that Intent defines for launching
+ * activities (usually through {@link Context#startActivity}.  The most
+ * important, and by far most frequently used, are {@link #ACTION_MAIN} and
+ * {@link #ACTION_EDIT}.
+ *
+ * <ul>
+ *     <li> {@link #ACTION_MAIN}
+ *     <li> {@link #ACTION_VIEW}
+ *     <li> {@link #ACTION_ATTACH_DATA}
+ *     <li> {@link #ACTION_EDIT}
+ *     <li> {@link #ACTION_PICK}
+ *     <li> {@link #ACTION_CHOOSER}
+ *     <li> {@link #ACTION_GET_CONTENT}
+ *     <li> {@link #ACTION_DIAL}
+ *     <li> {@link #ACTION_CALL}
+ *     <li> {@link #ACTION_SEND}
+ *     <li> {@link #ACTION_SENDTO}
+ *     <li> {@link #ACTION_ANSWER}
+ *     <li> {@link #ACTION_INSERT}
+ *     <li> {@link #ACTION_DELETE}
+ *     <li> {@link #ACTION_RUN}
+ *     <li> {@link #ACTION_SYNC}
+ *     <li> {@link #ACTION_PICK_ACTIVITY}
+ *     <li> {@link #ACTION_SEARCH}
+ *     <li> {@link #ACTION_WEB_SEARCH}
+ *     <li> {@link #ACTION_FACTORY_TEST}
+ * </ul>
+ *
+ * <h3>Standard Broadcast Actions</h3>
+ *
+ * <p>These are the current standard actions that Intent defines for receiving
+ * broadcasts (usually through {@link Context#registerReceiver} or a
+ * &lt;receiver&gt; tag in a manifest).
+ *
+ * <ul>
+ *     <li> {@link #ACTION_TIME_TICK}
+ *     <li> {@link #ACTION_TIME_CHANGED}
+ *     <li> {@link #ACTION_TIMEZONE_CHANGED}
+ *     <li> {@link #ACTION_BOOT_COMPLETED}
+ *     <li> {@link #ACTION_PACKAGE_ADDED}
+ *     <li> {@link #ACTION_PACKAGE_CHANGED}
+ *     <li> {@link #ACTION_PACKAGE_REMOVED}
+ *     <li> {@link #ACTION_PACKAGE_RESTARTED}
+ *     <li> {@link #ACTION_PACKAGE_DATA_CLEARED}
+ *     <li> {@link #ACTION_UID_REMOVED}
+ *     <li> {@link #ACTION_BATTERY_CHANGED}
+ *     <li> {@link #ACTION_POWER_CONNECTED}
+ *     <li> {@link #ACTION_POWER_DISCONNECTED}
+ *     <li> {@link #ACTION_SHUTDOWN}
+ * </ul>
+ *
+ * <h3>Standard Categories</h3>
+ *
+ * <p>These are the current standard categories that can be used to further
+ * clarify an Intent via {@link #addCategory}.
+ *
+ * <ul>
+ *     <li> {@link #CATEGORY_DEFAULT}
+ *     <li> {@link #CATEGORY_BROWSABLE}
+ *     <li> {@link #CATEGORY_TAB}
+ *     <li> {@link #CATEGORY_ALTERNATIVE}
+ *     <li> {@link #CATEGORY_SELECTED_ALTERNATIVE}
+ *     <li> {@link #CATEGORY_LAUNCHER}
+ *     <li> {@link #CATEGORY_INFO}
+ *     <li> {@link #CATEGORY_HOME}
+ *     <li> {@link #CATEGORY_PREFERENCE}
+ *     <li> {@link #CATEGORY_TEST}
+ *     <li> {@link #CATEGORY_CAR_DOCK}
+ *     <li> {@link #CATEGORY_DESK_DOCK}
+ *     <li> {@link #CATEGORY_LE_DESK_DOCK}
+ *     <li> {@link #CATEGORY_HE_DESK_DOCK}
+ *     <li> {@link #CATEGORY_CAR_MODE}
+ *     <li> {@link #CATEGORY_APP_MARKET}
+ * </ul>
+ *
+ * <h3>Standard Extra Data</h3>
+ *
+ * <p>These are the current standard fields that can be used as extra data via
+ * {@link #putExtra}.
+ *
+ * <ul>
+ *     <li> {@link #EXTRA_ALARM_COUNT}
+ *     <li> {@link #EXTRA_BCC}
+ *     <li> {@link #EXTRA_CC}
+ *     <li> {@link #EXTRA_CHANGED_COMPONENT_NAME}
+ *     <li> {@link #EXTRA_DATA_REMOVED}
+ *     <li> {@link #EXTRA_DOCK_STATE}
+ *     <li> {@link #EXTRA_DOCK_STATE_HE_DESK}
+ *     <li> {@link #EXTRA_DOCK_STATE_LE_DESK}
+ *     <li> {@link #EXTRA_DOCK_STATE_CAR}
+ *     <li> {@link #EXTRA_DOCK_STATE_DESK}
+ *     <li> {@link #EXTRA_DOCK_STATE_UNDOCKED}
+ *     <li> {@link #EXTRA_DONT_KILL_APP}
+ *     <li> {@link #EXTRA_EMAIL}
+ *     <li> {@link #EXTRA_INITIAL_INTENTS}
+ *     <li> {@link #EXTRA_INTENT}
+ *     <li> {@link #EXTRA_KEY_EVENT}
+ *     <li> {@link #EXTRA_ORIGINATING_URI}
+ *     <li> {@link #EXTRA_PHONE_NUMBER}
+ *     <li> {@link #EXTRA_REFERRER}
+ *     <li> {@link #EXTRA_REMOTE_INTENT_TOKEN}
+ *     <li> {@link #EXTRA_REPLACING}
+ *     <li> {@link #EXTRA_SHORTCUT_ICON}
+ *     <li> {@link #EXTRA_SHORTCUT_ICON_RESOURCE}
+ *     <li> {@link #EXTRA_SHORTCUT_INTENT}
+ *     <li> {@link #EXTRA_STREAM}
+ *     <li> {@link #EXTRA_SHORTCUT_NAME}
+ *     <li> {@link #EXTRA_SUBJECT}
+ *     <li> {@link #EXTRA_TEMPLATE}
+ *     <li> {@link #EXTRA_TEXT}
+ *     <li> {@link #EXTRA_TITLE}
+ *     <li> {@link #EXTRA_UID}
+ * </ul>
+ *
+ * <h3>Flags</h3>
+ *
+ * <p>These are the possible flags that can be used in the Intent via
+ * {@link #setFlags} and {@link #addFlags}.  See {@link #setFlags} for a list
+ * of all possible flags.
+ */
+public class Intent implements Parcelable, Cloneable {
+    // ---------------------------------------------------------------------
+    // ---------------------------------------------------------------------
+    // Standard intent activity actions (see action variable).
+
+    /**
+     *  Activity Action: Start as a main entry point, does not expect to
+     *  receive data.
+     *  <p>Input: nothing
+     *  <p>Output: nothing
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_MAIN = "android.intent.action.MAIN";
+
+    /**
+     * Activity Action: Display the data to the user.  This is the most common
+     * action performed on data -- it is the generic action you can use on
+     * a piece of data to get the most reasonable thing to occur.  For example,
+     * when used on a contacts entry it will view the entry; when used on a
+     * mailto: URI it will bring up a compose window filled with the information
+     * supplied by the URI; when used with a tel: URI it will invoke the
+     * dialer.
+     * <p>Input: {@link #getData} is URI from which to retrieve data.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_VIEW = "android.intent.action.VIEW";
+
+    /**
+     * A synonym for {@link #ACTION_VIEW}, the "standard" action that is
+     * performed on a piece of data.
+     */
+    public static final String ACTION_DEFAULT = ACTION_VIEW;
+
+    /**
+     * Used to indicate that some piece of data should be attached to some other
+     * place.  For example, image data could be attached to a contact.  It is up
+     * to the recipient to decide where the data should be attached; the intent
+     * does not specify the ultimate destination.
+     * <p>Input: {@link #getData} is URI of data to be attached.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_ATTACH_DATA = "android.intent.action.ATTACH_DATA";
+
+    /**
+     * Activity Action: Provide explicit editable access to the given data.
+     * <p>Input: {@link #getData} is URI of data to be edited.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_EDIT = "android.intent.action.EDIT";
+
+    /**
+     * Activity Action: Pick an existing item, or insert a new item, and then edit it.
+     * <p>Input: {@link #getType} is the desired MIME type of the item to create or edit.
+     * The extras can contain type specific data to pass through to the editing/creating
+     * activity.
+     * <p>Output: The URI of the item that was picked.  This must be a content:
+     * URI so that any receiver can access it.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_INSERT_OR_EDIT = "android.intent.action.INSERT_OR_EDIT";
+
+    /**
+     * Activity Action: Pick an item from the data, returning what was selected.
+     * <p>Input: {@link #getData} is URI containing a directory of data
+     * (vnd.android.cursor.dir/*) from which to pick an item.
+     * <p>Output: The URI of the item that was picked.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_PICK = "android.intent.action.PICK";
+
+    /**
+     * Activity Action: Creates a shortcut.
+     * <p>Input: Nothing.</p>
+     * <p>Output: An Intent representing the shortcut. The intent must contain three
+     * extras: SHORTCUT_INTENT (value: Intent), SHORTCUT_NAME (value: String),
+     * and SHORTCUT_ICON (value: Bitmap) or SHORTCUT_ICON_RESOURCE
+     * (value: ShortcutIconResource).</p>
+     *
+     * @see #EXTRA_SHORTCUT_INTENT
+     * @see #EXTRA_SHORTCUT_NAME
+     * @see #EXTRA_SHORTCUT_ICON
+     * @see #EXTRA_SHORTCUT_ICON_RESOURCE
+     * @see android.content.Intent.ShortcutIconResource
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_CREATE_SHORTCUT = "android.intent.action.CREATE_SHORTCUT";
+
+    /**
+     * The name of the extra used to define the Intent of a shortcut.
+     *
+     * @see #ACTION_CREATE_SHORTCUT
+     */
+    public static final String EXTRA_SHORTCUT_INTENT = "android.intent.extra.shortcut.INTENT";
+    /**
+     * The name of the extra used to define the name of a shortcut.
+     *
+     * @see #ACTION_CREATE_SHORTCUT
+     */
+    public static final String EXTRA_SHORTCUT_NAME = "android.intent.extra.shortcut.NAME";
+    /**
+     * The name of the extra used to define the icon, as a Bitmap, of a shortcut.
+     *
+     * @see #ACTION_CREATE_SHORTCUT
+     */
+    public static final String EXTRA_SHORTCUT_ICON = "android.intent.extra.shortcut.ICON";
+    /**
+     * The name of the extra used to define the icon, as a ShortcutIconResource, of a shortcut.
+     *
+     * @see #ACTION_CREATE_SHORTCUT
+     * @see android.content.Intent.ShortcutIconResource
+     */
+    public static final String EXTRA_SHORTCUT_ICON_RESOURCE =
+            "android.intent.extra.shortcut.ICON_RESOURCE";
+
+    /**
+     * Represents a shortcut/live folder icon resource.
+     *
+     * @see Intent#ACTION_CREATE_SHORTCUT
+     * @see Intent#EXTRA_SHORTCUT_ICON_RESOURCE
+     * @see android.provider.LiveFolders#ACTION_CREATE_LIVE_FOLDER
+     * @see android.provider.LiveFolders#EXTRA_LIVE_FOLDER_ICON
+     */
+    public static class ShortcutIconResource implements Parcelable {
+        /**
+         * The package name of the application containing the icon.
+         */
+        public String packageName;
+
+        /**
+         * The resource name of the icon, including package, name and type.
+         */
+        public String resourceName;
+
+        /**
+         * Creates a new ShortcutIconResource for the specified context and resource
+         * identifier.
+         *
+         * @param context The context of the application.
+         * @param resourceId The resource idenfitier for the icon.
+         * @return A new ShortcutIconResource with the specified's context package name
+         *         and icon resource idenfitier.
+         */
+        public static ShortcutIconResource fromContext(Context context, int resourceId) {
+            ShortcutIconResource icon = new ShortcutIconResource();
+            icon.packageName = context.getPackageName();
+            icon.resourceName = context.getResources().getResourceName(resourceId);
+            return icon;
+        }
+
+        /**
+         * Used to read a ShortcutIconResource from a Parcel.
+         */
+        public static final Parcelable.Creator<ShortcutIconResource> CREATOR =
+            new Parcelable.Creator<ShortcutIconResource>() {
+
+                public ShortcutIconResource createFromParcel(Parcel source) {
+                    ShortcutIconResource icon = new ShortcutIconResource();
+                    icon.packageName = source.readString();
+                    icon.resourceName = source.readString();
+                    return icon;
+                }
+
+                public ShortcutIconResource[] newArray(int size) {
+                    return new ShortcutIconResource[size];
+                }
+            };
+
+        /**
+         * No special parcel contents.
+         */
+        public int describeContents() {
+            return 0;
+        }
+
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeString(packageName);
+            dest.writeString(resourceName);
+        }
+
+        @Override
+        public String toString() {
+            return resourceName;
+        }
+    }
+
+    /**
+     * Activity Action: Display an activity chooser, allowing the user to pick
+     * what they want to before proceeding.  This can be used as an alternative
+     * to the standard activity picker that is displayed by the system when
+     * you try to start an activity with multiple possible matches, with these
+     * differences in behavior:
+     * <ul>
+     * <li>You can specify the title that will appear in the activity chooser.
+     * <li>The user does not have the option to make one of the matching
+     * activities a preferred activity, and all possible activities will
+     * always be shown even if one of them is currently marked as the
+     * preferred activity.
+     * </ul>
+     * <p>
+     * This action should be used when the user will naturally expect to
+     * select an activity in order to proceed.  An example if when not to use
+     * it is when the user clicks on a "mailto:" link.  They would naturally
+     * expect to go directly to their mail app, so startActivity() should be
+     * called directly: it will
+     * either launch the current preferred app, or put up a dialog allowing the
+     * user to pick an app to use and optionally marking that as preferred.
+     * <p>
+     * In contrast, if the user is selecting a menu item to send a picture
+     * they are viewing to someone else, there are many different things they
+     * may want to do at this point: send it through e-mail, upload it to a
+     * web service, etc.  In this case the CHOOSER action should be used, to
+     * always present to the user a list of the things they can do, with a
+     * nice title given by the caller such as "Send this photo with:".
+     * <p>
+     * If you need to grant URI permissions through a chooser, you must specify
+     * the permissions to be granted on the ACTION_CHOOSER Intent
+     * <em>in addition</em> to the EXTRA_INTENT inside.  This means using
+     * {@link #setClipData} to specify the URIs to be granted as well as
+     * {@link #FLAG_GRANT_READ_URI_PERMISSION} and/or
+     * {@link #FLAG_GRANT_WRITE_URI_PERMISSION} as appropriate.
+     * <p>
+     * As a convenience, an Intent of this form can be created with the
+     * {@link #createChooser} function.
+     * <p>
+     * Input: No data should be specified.  get*Extra must have
+     * a {@link #EXTRA_INTENT} field containing the Intent being executed,
+     * and can optionally have a {@link #EXTRA_TITLE} field containing the
+     * title text to display in the chooser.
+     * <p>
+     * Output: Depends on the protocol of {@link #EXTRA_INTENT}.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_CHOOSER = "android.intent.action.CHOOSER";
+
+    /**
+     * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
+     *
+     * <p>Builds a new {@link #ACTION_CHOOSER} Intent that wraps the given
+     * target intent, also optionally supplying a title.  If the target
+     * intent has specified {@link #FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, then these flags will also be
+     * set in the returned chooser intent, with its ClipData set appropriately:
+     * either a direct reflection of {@link #getClipData()} if that is non-null,
+     * or a new ClipData build from {@link #getData()}.
+     *
+     * @param target The Intent that the user will be selecting an activity
+     * to perform.
+     * @param title Optional title that will be displayed in the chooser.
+     * @return Return a new Intent object that you can hand to
+     * {@link Context#startActivity(Intent) Context.startActivity()} and
+     * related methods.
+     */
+    public static Intent createChooser(Intent target, CharSequence title) {
+        Intent intent = new Intent(ACTION_CHOOSER);
+        intent.putExtra(EXTRA_INTENT, target);
+        if (title != null) {
+            intent.putExtra(EXTRA_TITLE, title);
+        }
+
+        // Migrate any clip data and flags from target.
+        int permFlags = target.getFlags()
+                & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);
+        if (permFlags != 0) {
+            ClipData targetClipData = target.getClipData();
+            if (targetClipData == null && target.getData() != null) {
+                ClipData.Item item = new ClipData.Item(target.getData());
+                String[] mimeTypes;
+                if (target.getType() != null) {
+                    mimeTypes = new String[] { target.getType() };
+                } else {
+                    mimeTypes = new String[] { };
+                }
+                targetClipData = new ClipData(null, mimeTypes, item);
+            }
+            if (targetClipData != null) {
+                intent.setClipData(targetClipData);
+                intent.addFlags(permFlags);
+            }
+        }
+
+        return intent;
+    }
+
+    /**
+     * Activity Action: Allow the user to select a particular kind of data and
+     * return it.  This is different than {@link #ACTION_PICK} in that here we
+     * just say what kind of data is desired, not a URI of existing data from
+     * which the user can pick.  A ACTION_GET_CONTENT could allow the user to
+     * create the data as it runs (for example taking a picture or recording a
+     * sound), let them browse over the web and download the desired data,
+     * etc.
+     * <p>
+     * There are two main ways to use this action: if you want a specific kind
+     * of data, such as a person contact, you set the MIME type to the kind of
+     * data you want and launch it with {@link Context#startActivity(Intent)}.
+     * The system will then launch the best application to select that kind
+     * of data for you.
+     * <p>
+     * You may also be interested in any of a set of types of content the user
+     * can pick.  For example, an e-mail application that wants to allow the
+     * user to add an attachment to an e-mail message can use this action to
+     * bring up a list of all of the types of content the user can attach.
+     * <p>
+     * In this case, you should wrap the GET_CONTENT intent with a chooser
+     * (through {@link #createChooser}), which will give the proper interface
+     * for the user to pick how to send your data and allow you to specify
+     * a prompt indicating what they are doing.  You will usually specify a
+     * broad MIME type (such as image/* or {@literal *}/*), resulting in a
+     * broad range of content types the user can select from.
+     * <p>
+     * When using such a broad GET_CONTENT action, it is often desirable to
+     * only pick from data that can be represented as a stream.  This is
+     * accomplished by requiring the {@link #CATEGORY_OPENABLE} in the Intent.
+     * <p>
+     * Callers can optionally specify {@link #EXTRA_LOCAL_ONLY} to request that
+     * the launched content chooser only returns results representing data that
+     * is locally available on the device.  For example, if this extra is set
+     * to true then an image picker should not show any pictures that are available
+     * from a remote server but not already on the local device (thus requiring
+     * they be downloaded when opened).
+     * <p>
+     * Input: {@link #getType} is the desired MIME type to retrieve.  Note
+     * that no URI is supplied in the intent, as there are no constraints on
+     * where the returned data originally comes from.  You may also include the
+     * {@link #CATEGORY_OPENABLE} if you can only accept data that can be
+     * opened as a stream.  You may use {@link #EXTRA_LOCAL_ONLY} to limit content
+     * selection to local data.
+     * <p>
+     * Output: The URI of the item that was picked.  This must be a content:
+     * URI so that any receiver can access it.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_GET_CONTENT = "android.intent.action.GET_CONTENT";
+    /**
+     * Activity Action: Dial a number as specified by the data.  This shows a
+     * UI with the number being dialed, allowing the user to explicitly
+     * initiate the call.
+     * <p>Input: If nothing, an empty dialer is started; else {@link #getData}
+     * is URI of a phone number to be dialed or a tel: URI of an explicit phone
+     * number.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_DIAL = "android.intent.action.DIAL";
+    /**
+     * Activity Action: Perform a call to someone specified by the data.
+     * <p>Input: If nothing, an empty dialer is started; else {@link #getData}
+     * is URI of a phone number to be dialed or a tel: URI of an explicit phone
+     * number.
+     * <p>Output: nothing.
+     *
+     * <p>Note: there will be restrictions on which applications can initiate a
+     * call; most applications should use the {@link #ACTION_DIAL}.
+     * <p>Note: this Intent <strong>cannot</strong> be used to call emergency
+     * numbers.  Applications can <strong>dial</strong> emergency numbers using
+     * {@link #ACTION_DIAL}, however.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_CALL = "android.intent.action.CALL";
+    /**
+     * Activity Action: Perform a call to an emergency number specified by the
+     * data.
+     * <p>Input: {@link #getData} is URI of a phone number to be dialed or a
+     * tel: URI of an explicit phone number.
+     * <p>Output: nothing.
+     * @hide
+     */
+    public static final String ACTION_CALL_EMERGENCY = "android.intent.action.CALL_EMERGENCY";
+    /**
+     * Activity action: Perform a call to any number (emergency or not)
+     * specified by the data.
+     * <p>Input: {@link #getData} is URI of a phone number to be dialed or a
+     * tel: URI of an explicit phone number.
+     * <p>Output: nothing.
+     * @hide
+     */
+    public static final String ACTION_CALL_PRIVILEGED = "android.intent.action.CALL_PRIVILEGED";
+    /**
+     * Activity Action: Send a message to someone specified by the data.
+     * <p>Input: {@link #getData} is URI describing the target.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SENDTO = "android.intent.action.SENDTO";
+    /**
+     * Activity Action: Deliver some data to someone else.  Who the data is
+     * being delivered to is not specified; it is up to the receiver of this
+     * action to ask the user where the data should be sent.
+     * <p>
+     * When launching a SEND intent, you should usually wrap it in a chooser
+     * (through {@link #createChooser}), which will give the proper interface
+     * for the user to pick how to send your data and allow you to specify
+     * a prompt indicating what they are doing.
+     * <p>
+     * Input: {@link #getType} is the MIME type of the data being sent.
+     * get*Extra can have either a {@link #EXTRA_TEXT}
+     * or {@link #EXTRA_STREAM} field, containing the data to be sent.  If
+     * using EXTRA_TEXT, the MIME type should be "text/plain"; otherwise it
+     * should be the MIME type of the data in EXTRA_STREAM.  Use {@literal *}/*
+     * if the MIME type is unknown (this will only allow senders that can
+     * handle generic data streams).  If using {@link #EXTRA_TEXT}, you can
+     * also optionally supply {@link #EXTRA_HTML_TEXT} for clients to retrieve
+     * your text with HTML formatting.
+     * <p>
+     * As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, the data
+     * being sent can be supplied through {@link #setClipData(ClipData)}.  This
+     * allows you to use {@link #FLAG_GRANT_READ_URI_PERMISSION} when sharing
+     * content: URIs and other advanced features of {@link ClipData}.  If
+     * using this approach, you still must supply the same data through the
+     * {@link #EXTRA_TEXT} or {@link #EXTRA_STREAM} fields described below
+     * for compatibility with old applications.  If you don't set a ClipData,
+     * it will be copied there for you when calling {@link Context#startActivity(Intent)}.
+     * <p>
+     * Optional standard extras, which may be interpreted by some recipients as
+     * appropriate, are: {@link #EXTRA_EMAIL}, {@link #EXTRA_CC},
+     * {@link #EXTRA_BCC}, {@link #EXTRA_SUBJECT}.
+     * <p>
+     * Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SEND = "android.intent.action.SEND";
+    /**
+     * Activity Action: Deliver multiple data to someone else.
+     * <p>
+     * Like {@link #ACTION_SEND}, except the data is multiple.
+     * <p>
+     * Input: {@link #getType} is the MIME type of the data being sent.
+     * get*ArrayListExtra can have either a {@link #EXTRA_TEXT} or {@link
+     * #EXTRA_STREAM} field, containing the data to be sent.  If using
+     * {@link #EXTRA_TEXT}, you can also optionally supply {@link #EXTRA_HTML_TEXT}
+     * for clients to retrieve your text with HTML formatting.
+     * <p>
+     * Multiple types are supported, and receivers should handle mixed types
+     * whenever possible. The right way for the receiver to check them is to
+     * use the content resolver on each URI. The intent sender should try to
+     * put the most concrete mime type in the intent type, but it can fall
+     * back to {@literal <type>/*} or {@literal *}/* as needed.
+     * <p>
+     * e.g. if you are sending image/jpg and image/jpg, the intent's type can
+     * be image/jpg, but if you are sending image/jpg and image/png, then the
+     * intent's type should be image/*.
+     * <p>
+     * As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, the data
+     * being sent can be supplied through {@link #setClipData(ClipData)}.  This
+     * allows you to use {@link #FLAG_GRANT_READ_URI_PERMISSION} when sharing
+     * content: URIs and other advanced features of {@link ClipData}.  If
+     * using this approach, you still must supply the same data through the
+     * {@link #EXTRA_TEXT} or {@link #EXTRA_STREAM} fields described below
+     * for compatibility with old applications.  If you don't set a ClipData,
+     * it will be copied there for you when calling {@link Context#startActivity(Intent)}.
+     * <p>
+     * Optional standard extras, which may be interpreted by some recipients as
+     * appropriate, are: {@link #EXTRA_EMAIL}, {@link #EXTRA_CC},
+     * {@link #EXTRA_BCC}, {@link #EXTRA_SUBJECT}.
+     * <p>
+     * Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SEND_MULTIPLE = "android.intent.action.SEND_MULTIPLE";
+    /**
+     * Activity Action: Handle an incoming phone call.
+     * <p>Input: nothing.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_ANSWER = "android.intent.action.ANSWER";
+    /**
+     * Activity Action: Insert an empty item into the given container.
+     * <p>Input: {@link #getData} is URI of the directory (vnd.android.cursor.dir/*)
+     * in which to place the data.
+     * <p>Output: URI of the new data that was created.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_INSERT = "android.intent.action.INSERT";
+    /**
+     * Activity Action: Create a new item in the given container, initializing it
+     * from the current contents of the clipboard.
+     * <p>Input: {@link #getData} is URI of the directory (vnd.android.cursor.dir/*)
+     * in which to place the data.
+     * <p>Output: URI of the new data that was created.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_PASTE = "android.intent.action.PASTE";
+    /**
+     * Activity Action: Delete the given data from its container.
+     * <p>Input: {@link #getData} is URI of data to be deleted.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_DELETE = "android.intent.action.DELETE";
+    /**
+     * Activity Action: Run the data, whatever that means.
+     * <p>Input: ?  (Note: this is currently specific to the test harness.)
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_RUN = "android.intent.action.RUN";
+    /**
+     * Activity Action: Perform a data synchronization.
+     * <p>Input: ?
+     * <p>Output: ?
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SYNC = "android.intent.action.SYNC";
+    /**
+     * Activity Action: Pick an activity given an intent, returning the class
+     * selected.
+     * <p>Input: get*Extra field {@link #EXTRA_INTENT} is an Intent
+     * used with {@link PackageManager#queryIntentActivities} to determine the
+     * set of activities from which to pick.
+     * <p>Output: Class name of the activity that was selected.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_PICK_ACTIVITY = "android.intent.action.PICK_ACTIVITY";
+    /**
+     * Activity Action: Perform a search.
+     * <p>Input: {@link android.app.SearchManager#QUERY getStringExtra(SearchManager.QUERY)}
+     * is the text to search for.  If empty, simply
+     * enter your search results Activity with the search UI activated.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SEARCH = "android.intent.action.SEARCH";
+    /**
+     * Activity Action: Start the platform-defined tutorial
+     * <p>Input: {@link android.app.SearchManager#QUERY getStringExtra(SearchManager.QUERY)}
+     * is the text to search for.  If empty, simply
+     * enter your search results Activity with the search UI activated.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SYSTEM_TUTORIAL = "android.intent.action.SYSTEM_TUTORIAL";
+    /**
+     * Activity Action: Perform a web search.
+     * <p>
+     * Input: {@link android.app.SearchManager#QUERY
+     * getStringExtra(SearchManager.QUERY)} is the text to search for. If it is
+     * a url starts with http or https, the site will be opened. If it is plain
+     * text, Google search will be applied.
+     * <p>
+     * Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_WEB_SEARCH = "android.intent.action.WEB_SEARCH";
+    /**
+     * Activity Action: Perform assist action.
+     * <p>
+     * Input: nothing
+     * Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_ASSIST = "android.intent.action.ASSIST";
+    /**
+     * Activity Action: List all available applications
+     * <p>Input: Nothing.
+     * <p>Output: nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_ALL_APPS = "android.intent.action.ALL_APPS";
+    /**
+     * Activity Action: Show settings for choosing wallpaper
+     * <p>Input: Nothing.
+     * <p>Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SET_WALLPAPER = "android.intent.action.SET_WALLPAPER";
+
+    /**
+     * Activity Action: Show activity for reporting a bug.
+     * <p>Input: Nothing.
+     * <p>Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_BUG_REPORT = "android.intent.action.BUG_REPORT";
+
+    /**
+     *  Activity Action: Main entry point for factory tests.  Only used when
+     *  the device is booting in factory test node.  The implementing package
+     *  must be installed in the system image.
+     *  <p>Input: nothing
+     *  <p>Output: nothing
+     */
+    public static final String ACTION_FACTORY_TEST = "android.intent.action.FACTORY_TEST";
+
+    /**
+     * Activity Action: The user pressed the "call" button to go to the dialer
+     * or other appropriate UI for placing a call.
+     * <p>Input: Nothing.
+     * <p>Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_CALL_BUTTON = "android.intent.action.CALL_BUTTON";
+
+    /**
+     * Activity Action: Start Voice Command.
+     * <p>Input: Nothing.
+     * <p>Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_VOICE_COMMAND = "android.intent.action.VOICE_COMMAND";
+
+    /**
+     * Activity Action: Start action associated with long pressing on the
+     * search key.
+     * <p>Input: Nothing.
+     * <p>Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SEARCH_LONG_PRESS = "android.intent.action.SEARCH_LONG_PRESS";
+
+    /**
+     * Activity Action: The user pressed the "Report" button in the crash/ANR dialog.
+     * This intent is delivered to the package which installed the application, usually
+     * Google Play.
+     * <p>Input: No data is specified. The bug report is passed in using
+     * an {@link #EXTRA_BUG_REPORT} field.
+     * <p>Output: Nothing.
+     *
+     * @see #EXTRA_BUG_REPORT
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_APP_ERROR = "android.intent.action.APP_ERROR";
+
+    /**
+     * Activity Action: Show power usage information to the user.
+     * <p>Input: Nothing.
+     * <p>Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_POWER_USAGE_SUMMARY = "android.intent.action.POWER_USAGE_SUMMARY";
+
+    /**
+     * Activity Action: Setup wizard to launch after a platform update.  This
+     * activity should have a string meta-data field associated with it,
+     * {@link #METADATA_SETUP_VERSION}, which defines the current version of
+     * the platform for setup.  The activity will be launched only if
+     * {@link android.provider.Settings.Secure#LAST_SETUP_SHOWN} is not the
+     * same value.
+     * <p>Input: Nothing.
+     * <p>Output: Nothing.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_UPGRADE_SETUP = "android.intent.action.UPGRADE_SETUP";
+
+    /**
+     * Activity Action: Show settings for managing network data usage of a
+     * specific application. Applications should define an activity that offers
+     * options to control data usage.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_MANAGE_NETWORK_USAGE =
+            "android.intent.action.MANAGE_NETWORK_USAGE";
+
+    /**
+     * Activity Action: Launch application installer.
+     * <p>
+     * Input: The data must be a content: or file: URI at which the application
+     * can be retrieved.  As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1},
+     * you can also use "package:<package-name>" to install an application for the
+     * current user that is already installed for another user. You can optionally supply
+     * {@link #EXTRA_INSTALLER_PACKAGE_NAME}, {@link #EXTRA_NOT_UNKNOWN_SOURCE},
+     * {@link #EXTRA_ALLOW_REPLACE}, and {@link #EXTRA_RETURN_RESULT}.
+     * <p>
+     * Output: If {@link #EXTRA_RETURN_RESULT}, returns whether the install
+     * succeeded.
+     *
+     * @see #EXTRA_INSTALLER_PACKAGE_NAME
+     * @see #EXTRA_NOT_UNKNOWN_SOURCE
+     * @see #EXTRA_RETURN_RESULT
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_INSTALL_PACKAGE = "android.intent.action.INSTALL_PACKAGE";
+
+    /**
+     * Used as a string extra field with {@link #ACTION_INSTALL_PACKAGE} to install a
+     * package.  Specifies the installer package name; this package will receive the
+     * {@link #ACTION_APP_ERROR} intent.
+     */
+    public static final String EXTRA_INSTALLER_PACKAGE_NAME
+            = "android.intent.extra.INSTALLER_PACKAGE_NAME";
+
+    /**
+     * Used as a boolean extra field with {@link #ACTION_INSTALL_PACKAGE} to install a
+     * package.  Specifies that the application being installed should not be
+     * treated as coming from an unknown source, but as coming from the app
+     * invoking the Intent.  For this to work you must start the installer with
+     * startActivityForResult().
+     */
+    public static final String EXTRA_NOT_UNKNOWN_SOURCE
+            = "android.intent.extra.NOT_UNKNOWN_SOURCE";
+
+    /**
+     * Used as a URI extra field with {@link #ACTION_INSTALL_PACKAGE} and
+     * {@link #ACTION_VIEW} to indicate the URI from which the local APK in the Intent
+     * data field originated from.
+     */
+    public static final String EXTRA_ORIGINATING_URI
+            = "android.intent.extra.ORIGINATING_URI";
+
+    /**
+     * Used as a URI extra field with {@link #ACTION_INSTALL_PACKAGE} and
+     * {@link #ACTION_VIEW} to indicate the HTTP referrer URI associated with the Intent
+     * data field or {@link #EXTRA_ORIGINATING_URI}.
+     */
+    public static final String EXTRA_REFERRER
+            = "android.intent.extra.REFERRER";
+
+    /**
+     * Used as an int extra field with {@link #ACTION_INSTALL_PACKAGE} and
+     * {@link} #ACTION_VIEW} to indicate the uid of the package that initiated the install
+     * @hide
+     */
+    public static final String EXTRA_ORIGINATING_UID
+            = "android.intent.extra.ORIGINATING_UID";
+
+    /**
+     * Used as a boolean extra field with {@link #ACTION_INSTALL_PACKAGE} to install a
+     * package.  Tells the installer UI to skip the confirmation with the user
+     * if the .apk is replacing an existing one.
+     * @deprecated As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, Android
+     * will no longer show an interstitial message about updating existing
+     * applications so this is no longer needed.
+     */
+    @Deprecated
+    public static final String EXTRA_ALLOW_REPLACE
+            = "android.intent.extra.ALLOW_REPLACE";
+
+    /**
+     * Used as a boolean extra field with {@link #ACTION_INSTALL_PACKAGE} or
+     * {@link #ACTION_UNINSTALL_PACKAGE}.  Specifies that the installer UI should
+     * return to the application the result code of the install/uninstall.  The returned result
+     * code will be {@link android.app.Activity#RESULT_OK} on success or
+     * {@link android.app.Activity#RESULT_FIRST_USER} on failure.
+     */
+    public static final String EXTRA_RETURN_RESULT
+            = "android.intent.extra.RETURN_RESULT";
+
+    /**
+     * Package manager install result code.  @hide because result codes are not
+     * yet ready to be exposed.
+     */
+    public static final String EXTRA_INSTALL_RESULT
+            = "android.intent.extra.INSTALL_RESULT";
+
+    /**
+     * Activity Action: Launch application uninstaller.
+     * <p>
+     * Input: The data must be a package: URI whose scheme specific part is
+     * the package name of the current installed package to be uninstalled.
+     * You can optionally supply {@link #EXTRA_RETURN_RESULT}.
+     * <p>
+     * Output: If {@link #EXTRA_RETURN_RESULT}, returns whether the install
+     * succeeded.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_UNINSTALL_PACKAGE = "android.intent.action.UNINSTALL_PACKAGE";
+
+    /**
+     * Specify whether the package should be uninstalled for all users.
+     * @hide because these should not be part of normal application flow.
+     */
+    public static final String EXTRA_UNINSTALL_ALL_USERS
+            = "android.intent.extra.UNINSTALL_ALL_USERS";
+
+    /**
+     * A string associated with a {@link #ACTION_UPGRADE_SETUP} activity
+     * describing the last run version of the platform that was setup.
+     * @hide
+     */
+    public static final String METADATA_SETUP_VERSION = "android.SETUP_VERSION";
+
+    // ---------------------------------------------------------------------
+    // ---------------------------------------------------------------------
+    // Standard intent broadcast actions (see action variable).
+
+    /**
+     * Broadcast Action: Sent after the screen turns off.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_SCREEN_OFF = "android.intent.action.SCREEN_OFF";
+    /**
+     * Broadcast Action: Sent after the screen turns on.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_SCREEN_ON = "android.intent.action.SCREEN_ON";
+
+    /**
+     * Broadcast Action: Sent after the system stops dreaming.
+     *
+     * <p class="note">This is a protected intent that can only be sent by the system.
+     * It is only sent to registered receivers.</p>
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DREAMING_STOPPED = "android.intent.action.DREAMING_STOPPED";
+
+    /**
+     * Broadcast Action: Sent after the system starts dreaming.
+     *
+     * <p class="note">This is a protected intent that can only be sent by the system.
+     * It is only sent to registered receivers.</p>
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DREAMING_STARTED = "android.intent.action.DREAMING_STARTED";
+
+    /**
+     * Broadcast Action: Sent when the user is present after device wakes up (e.g when the
+     * keyguard is gone).
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_USER_PRESENT = "android.intent.action.USER_PRESENT";
+
+    /**
+     * Broadcast Action: The current time has changed.  Sent every
+     * minute.  You can <em>not</em> receive this through components declared
+     * in manifests, only by exlicitly registering for it with
+     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
+     * Context.registerReceiver()}.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_TIME_TICK = "android.intent.action.TIME_TICK";
+    /**
+     * Broadcast Action: The time was set.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_TIME_CHANGED = "android.intent.action.TIME_SET";
+    /**
+     * Broadcast Action: The date has changed.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DATE_CHANGED = "android.intent.action.DATE_CHANGED";
+    /**
+     * Broadcast Action: The timezone has changed. The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>time-zone</em> - The java.util.TimeZone.getID() value identifying the new time zone.</li>
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_TIMEZONE_CHANGED = "android.intent.action.TIMEZONE_CHANGED";
+    /**
+     * Clear DNS Cache Action: This is broadcast when networks have changed and old
+     * DNS entries should be tossed.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CLEAR_DNS_CACHE = "android.intent.action.CLEAR_DNS_CACHE";
+    /**
+     * Alarm Changed Action: This is broadcast when the AlarmClock
+     * application's alarm is set or unset.  It is used by the
+     * AlarmClock application and the StatusBar service.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_ALARM_CHANGED = "android.intent.action.ALARM_CHANGED";
+    /**
+     * Sync State Changed Action: This is broadcast when the sync starts or stops or when one has
+     * been failing for a long time.  It is used by the SyncManager and the StatusBar service.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_SYNC_STATE_CHANGED
+            = "android.intent.action.SYNC_STATE_CHANGED";
+    /**
+     * Broadcast Action: This is broadcast once, after the system has finished
+     * booting.  It can be used to perform application-specific initialization,
+     * such as installing alarms.  You must hold the
+     * {@link android.Manifest.permission#RECEIVE_BOOT_COMPLETED} permission
+     * in order to receive this broadcast.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_BOOT_COMPLETED = "android.intent.action.BOOT_COMPLETED";
+    /**
+     * Broadcast Action: This is broadcast when a user action should request a
+     * temporary system dialog to dismiss.  Some examples of temporary system
+     * dialogs are the notification window-shade and the recent tasks dialog.
+     */
+    public static final String ACTION_CLOSE_SYSTEM_DIALOGS = "android.intent.action.CLOSE_SYSTEM_DIALOGS";
+    /**
+     * Broadcast Action: Trigger the download and eventual installation
+     * of a package.
+     * <p>Input: {@link #getData} is the URI of the package file to download.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     *
+     * @deprecated This constant has never been used.
+     */
+    @Deprecated
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_INSTALL = "android.intent.action.PACKAGE_INSTALL";
+    /**
+     * Broadcast Action: A new application package has been installed on the
+     * device. The data contains the name of the package.  Note that the
+     * newly installed package does <em>not</em> receive this broadcast.
+     * <p>May include the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
+     * <li> {@link #EXTRA_REPLACING} is set to true if this is following
+     * an {@link #ACTION_PACKAGE_REMOVED} broadcast for the same package.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_ADDED = "android.intent.action.PACKAGE_ADDED";
+    /**
+     * Broadcast Action: A new version of an application package has been
+     * installed, replacing an existing version that was previously installed.
+     * The data contains the name of the package.
+     * <p>May include the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the new package.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_REPLACED = "android.intent.action.PACKAGE_REPLACED";
+    /**
+     * Broadcast Action: A new version of your application has been installed
+     * over an existing one.  This is only sent to the application that was
+     * replaced.  It does not contain any additional data; to receive it, just
+     * use an intent filter for this action.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MY_PACKAGE_REPLACED = "android.intent.action.MY_PACKAGE_REPLACED";
+    /**
+     * Broadcast Action: An existing application package has been removed from
+     * the device.  The data contains the name of the package.  The package
+     * that is being installed does <em>not</em> receive this Intent.
+     * <ul>
+     * <li> {@link #EXTRA_UID} containing the integer uid previously assigned
+     * to the package.
+     * <li> {@link #EXTRA_DATA_REMOVED} is set to true if the entire
+     * application -- data and code -- is being removed.
+     * <li> {@link #EXTRA_REPLACING} is set to true if this will be followed
+     * by an {@link #ACTION_PACKAGE_ADDED} broadcast for the same package.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_REMOVED = "android.intent.action.PACKAGE_REMOVED";
+    /**
+     * Broadcast Action: An existing application package has been completely
+     * removed from the device.  The data contains the name of the package.
+     * This is like {@link #ACTION_PACKAGE_REMOVED}, but only set when
+     * {@link #EXTRA_DATA_REMOVED} is true and
+     * {@link #EXTRA_REPLACING} is false of that broadcast.
+     *
+     * <ul>
+     * <li> {@link #EXTRA_UID} containing the integer uid previously assigned
+     * to the package.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_FULLY_REMOVED
+            = "android.intent.action.PACKAGE_FULLY_REMOVED";
+    /**
+     * Broadcast Action: An existing application package has been changed (e.g.
+     * a component has been enabled or disabled).  The data contains the name of
+     * the package.
+     * <ul>
+     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
+     * <li> {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST} containing the class name
+     * of the changed components.
+     * <li> {@link #EXTRA_DONT_KILL_APP} containing boolean field to override the
+     * default action of restarting the application.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_CHANGED = "android.intent.action.PACKAGE_CHANGED";
+    /**
+     * @hide
+     * Broadcast Action: Ask system services if there is any reason to
+     * restart the given package.  The data contains the name of the
+     * package.
+     * <ul>
+     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
+     * <li> {@link #EXTRA_PACKAGES} String array of all packages to check.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_QUERY_PACKAGE_RESTART = "android.intent.action.QUERY_PACKAGE_RESTART";
+    /**
+     * Broadcast Action: The user has restarted a package, and all of its
+     * processes have been killed.  All runtime state
+     * associated with it (processes, alarms, notifications, etc) should
+     * be removed.  Note that the restarted package does <em>not</em>
+     * receive this broadcast.
+     * The data contains the name of the package.
+     * <ul>
+     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_RESTARTED = "android.intent.action.PACKAGE_RESTARTED";
+    /**
+     * Broadcast Action: The user has cleared the data of a package.  This should
+     * be preceded by {@link #ACTION_PACKAGE_RESTARTED}, after which all of
+     * its persistent data is erased and this broadcast sent.
+     * Note that the cleared package does <em>not</em>
+     * receive this broadcast. The data contains the name of the package.
+     * <ul>
+     * <li> {@link #EXTRA_UID} containing the integer uid assigned to the package.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_DATA_CLEARED = "android.intent.action.PACKAGE_DATA_CLEARED";
+    /**
+     * Broadcast Action: A user ID has been removed from the system.  The user
+     * ID number is stored in the extra data under {@link #EXTRA_UID}.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_UID_REMOVED = "android.intent.action.UID_REMOVED";
+
+    /**
+     * Broadcast Action: Sent to the installer package of an application
+     * when that application is first launched (that is the first time it
+     * is moved out of the stopped state).  The data contains the name of the package.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_FIRST_LAUNCH = "android.intent.action.PACKAGE_FIRST_LAUNCH";
+
+    /**
+     * Broadcast Action: Sent to the system package verifier when a package
+     * needs to be verified. The data contains the package URI.
+     * <p class="note">
+     * This is a protected intent that can only be sent by the system.
+     * </p>
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_NEEDS_VERIFICATION = "android.intent.action.PACKAGE_NEEDS_VERIFICATION";
+
+    /**
+     * Broadcast Action: Sent to the system package verifier when a package is
+     * verified. The data contains the package URI.
+     * <p class="note">
+     * This is a protected intent that can only be sent by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PACKAGE_VERIFIED = "android.intent.action.PACKAGE_VERIFIED";
+
+    /**
+     * Broadcast Action: Resources for a set of packages (which were
+     * previously unavailable) are currently
+     * available since the media on which they exist is available.
+     * The extra data {@link #EXTRA_CHANGED_PACKAGE_LIST} contains a
+     * list of packages whose availability changed.
+     * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
+     * list of uids of packages whose availability changed.
+     * Note that the
+     * packages in this list do <em>not</em> receive this broadcast.
+     * The specified set of packages are now available on the system.
+     * <p>Includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CHANGED_PACKAGE_LIST} is the set of packages
+     * whose resources(were previously unavailable) are currently available.
+     * {@link #EXTRA_CHANGED_UID_LIST} is the set of uids of the
+     * packages whose resources(were previously unavailable)
+     * are  currently available.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_EXTERNAL_APPLICATIONS_AVAILABLE =
+        "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
+
+    /**
+     * Broadcast Action: Resources for a set of packages are currently
+     * unavailable since the media on which they exist is unavailable.
+     * The extra data {@link #EXTRA_CHANGED_PACKAGE_LIST} contains a
+     * list of packages whose availability changed.
+     * The extra data {@link #EXTRA_CHANGED_UID_LIST} contains a
+     * list of uids of packages whose availability changed.
+     * The specified set of packages can no longer be
+     * launched and are practically unavailable on the system.
+     * <p>Inclues the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CHANGED_PACKAGE_LIST} is the set of packages
+     * whose resources are no longer available.
+     * {@link #EXTRA_CHANGED_UID_LIST} is the set of packages
+     * whose resources are no longer available.
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE =
+        "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
+
+    /**
+     * Broadcast Action:  The current system wallpaper has changed.  See
+     * {@link android.app.WallpaperManager} for retrieving the new wallpaper.
+     * This should <em>only</em> be used to determine when the wallpaper
+     * has changed to show the new wallpaper to the user.  You should certainly
+     * never, in response to this, change the wallpaper or other attributes of
+     * it such as the suggested size.  That would be crazy, right?  You'd cause
+     * all kinds of loops, especially if other apps are doing similar things,
+     * right?  Of course.  So please don't do this.
+     *
+     * @deprecated Modern applications should use
+     * {@link android.view.WindowManager.LayoutParams#FLAG_SHOW_WALLPAPER
+     * WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER} to have the wallpaper
+     * shown behind their UI, rather than watching for this broadcast and
+     * rendering the wallpaper on their own.
+     */
+    @Deprecated @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_WALLPAPER_CHANGED = "android.intent.action.WALLPAPER_CHANGED";
+    /**
+     * Broadcast Action: The current device {@link android.content.res.Configuration}
+     * (orientation, locale, etc) has changed.  When such a change happens, the
+     * UIs (view hierarchy) will need to be rebuilt based on this new
+     * information; for the most part, applications don't need to worry about
+     * this, because the system will take care of stopping and restarting the
+     * application to make sure it sees the new changes.  Some system code that
+     * can not be restarted will need to watch for this action and handle it
+     * appropriately.
+     *
+     * <p class="note">
+     * You can <em>not</em> receive this through components declared
+     * in manifests, only by explicitly registering for it with
+     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
+     * Context.registerReceiver()}.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     *
+     * @see android.content.res.Configuration
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CONFIGURATION_CHANGED = "android.intent.action.CONFIGURATION_CHANGED";
+    /**
+     * Broadcast Action: The current device's locale has changed.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_LOCALE_CHANGED = "android.intent.action.LOCALE_CHANGED";
+    /**
+     * Broadcast Action:  This is a <em>sticky broadcast</em> containing the
+     * charging state, level, and other information about the battery.
+     * See {@link android.os.BatteryManager} for documentation on the
+     * contents of the Intent.
+     *
+     * <p class="note">
+     * You can <em>not</em> receive this through components declared
+     * in manifests, only by explicitly registering for it with
+     * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
+     * Context.registerReceiver()}.  See {@link #ACTION_BATTERY_LOW},
+     * {@link #ACTION_BATTERY_OKAY}, {@link #ACTION_POWER_CONNECTED},
+     * and {@link #ACTION_POWER_DISCONNECTED} for distinct battery-related
+     * broadcasts that are sent and can be received through manifest
+     * receivers.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_BATTERY_CHANGED = "android.intent.action.BATTERY_CHANGED";
+    /**
+     * Broadcast Action:  Indicates low battery condition on the device.
+     * This broadcast corresponds to the "Low battery warning" system dialog.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_BATTERY_LOW = "android.intent.action.BATTERY_LOW";
+    /**
+     * Broadcast Action:  Indicates the battery is now okay after being low.
+     * This will be sent after {@link #ACTION_BATTERY_LOW} once the battery has
+     * gone back up to an okay state.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_BATTERY_OKAY = "android.intent.action.BATTERY_OKAY";
+    /**
+     * Broadcast Action:  External power has been connected to the device.
+     * This is intended for applications that wish to register specifically to this notification.
+     * Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
+     * stay active to receive this notification.  This action can be used to implement actions
+     * that wait until power is available to trigger.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_POWER_CONNECTED = "android.intent.action.ACTION_POWER_CONNECTED";
+    /**
+     * Broadcast Action:  External power has been removed from the device.
+     * This is intended for applications that wish to register specifically to this notification.
+     * Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
+     * stay active to receive this notification.  This action can be used to implement actions
+     * that wait until power is available to trigger.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_POWER_DISCONNECTED =
+            "android.intent.action.ACTION_POWER_DISCONNECTED";
+    /**
+     * Broadcast Action:  Device is shutting down.
+     * This is broadcast when the device is being shut down (completely turned
+     * off, not sleeping).  Once the broadcast is complete, the final shutdown
+     * will proceed and all unsaved data lost.  Apps will not normally need
+     * to handle this, since the foreground activity will be paused as well.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_SHUTDOWN = "android.intent.action.ACTION_SHUTDOWN";
+    /**
+     * Activity Action:  Start this activity to request system shutdown.
+     * The optional boolean extra field {@link #EXTRA_KEY_CONFIRM} can be set to true
+     * to request confirmation from the user before shutting down.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     *
+     * {@hide}
+     */
+    public static final String ACTION_REQUEST_SHUTDOWN = "android.intent.action.ACTION_REQUEST_SHUTDOWN";
+    /**
+     * Broadcast Action:  A sticky broadcast that indicates low memory
+     * condition on the device
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DEVICE_STORAGE_LOW = "android.intent.action.DEVICE_STORAGE_LOW";
+    /**
+     * Broadcast Action:  Indicates low memory condition on the device no longer exists
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DEVICE_STORAGE_OK = "android.intent.action.DEVICE_STORAGE_OK";
+    /**
+     * Broadcast Action:  A sticky broadcast that indicates a memory full
+     * condition on the device. This is intended for activities that want
+     * to be able to fill the data partition completely, leaving only
+     * enough free space to prevent system-wide SQLite failures.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     *
+     * {@hide}
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DEVICE_STORAGE_FULL = "android.intent.action.DEVICE_STORAGE_FULL";
+    /**
+     * Broadcast Action:  Indicates memory full condition on the device
+     * no longer exists.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     *
+     * {@hide}
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DEVICE_STORAGE_NOT_FULL = "android.intent.action.DEVICE_STORAGE_NOT_FULL";
+    /**
+     * Broadcast Action:  Indicates low memory condition notification acknowledged by user
+     * and package management should be started.
+     * This is triggered by the user from the ACTION_DEVICE_STORAGE_LOW
+     * notification.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MANAGE_PACKAGE_STORAGE = "android.intent.action.MANAGE_PACKAGE_STORAGE";
+    /**
+     * Broadcast Action:  The device has entered USB Mass Storage mode.
+     * This is used mainly for the USB Settings panel.
+     * Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
+     * when the SD card file system is mounted or unmounted
+     * @deprecated replaced by android.os.storage.StorageEventListener
+     */
+    @Deprecated
+    public static final String ACTION_UMS_CONNECTED = "android.intent.action.UMS_CONNECTED";
+
+    /**
+     * Broadcast Action:  The device has exited USB Mass Storage mode.
+     * This is used mainly for the USB Settings panel.
+     * Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
+     * when the SD card file system is mounted or unmounted
+     * @deprecated replaced by android.os.storage.StorageEventListener
+     */
+    @Deprecated
+    public static final String ACTION_UMS_DISCONNECTED = "android.intent.action.UMS_DISCONNECTED";
+
+    /**
+     * Broadcast Action:  External media has been removed.
+     * The path to the mount point for the removed media is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_REMOVED = "android.intent.action.MEDIA_REMOVED";
+
+    /**
+     * Broadcast Action:  External media is present, but not mounted at its mount point.
+     * The path to the mount point for the removed media is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_UNMOUNTED = "android.intent.action.MEDIA_UNMOUNTED";
+
+    /**
+     * Broadcast Action:  External media is present, and being disk-checked
+     * The path to the mount point for the checking media is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_CHECKING = "android.intent.action.MEDIA_CHECKING";
+
+    /**
+     * Broadcast Action:  External media is present, but is using an incompatible fs (or is blank)
+     * The path to the mount point for the checking media is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_NOFS = "android.intent.action.MEDIA_NOFS";
+
+    /**
+     * Broadcast Action:  External media is present and mounted at its mount point.
+     * The path to the mount point for the removed media is contained in the Intent.mData field.
+     * The Intent contains an extra with name "read-only" and Boolean value to indicate if the
+     * media was mounted read only.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_MOUNTED = "android.intent.action.MEDIA_MOUNTED";
+
+    /**
+     * Broadcast Action:  External media is unmounted because it is being shared via USB mass storage.
+     * The path to the mount point for the shared media is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_SHARED = "android.intent.action.MEDIA_SHARED";
+
+    /**
+     * Broadcast Action:  External media is no longer being shared via USB mass storage.
+     * The path to the mount point for the previously shared media is contained in the Intent.mData field.
+     *
+     * @hide
+     */
+    public static final String ACTION_MEDIA_UNSHARED = "android.intent.action.MEDIA_UNSHARED";
+
+    /**
+     * Broadcast Action:  External media was removed from SD card slot, but mount point was not unmounted.
+     * The path to the mount point for the removed media is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_BAD_REMOVAL = "android.intent.action.MEDIA_BAD_REMOVAL";
+
+    /**
+     * Broadcast Action:  External media is present but cannot be mounted.
+     * The path to the mount point for the removed media is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_UNMOUNTABLE = "android.intent.action.MEDIA_UNMOUNTABLE";
+
+   /**
+     * Broadcast Action:  User has expressed the desire to remove the external storage media.
+     * Applications should close all files they have open within the mount point when they receive this intent.
+     * The path to the mount point for the media to be ejected is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_EJECT = "android.intent.action.MEDIA_EJECT";
+
+    /**
+     * Broadcast Action:  The media scanner has started scanning a directory.
+     * The path to the directory being scanned is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_SCANNER_STARTED = "android.intent.action.MEDIA_SCANNER_STARTED";
+
+   /**
+     * Broadcast Action:  The media scanner has finished scanning a directory.
+     * The path to the scanned directory is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_SCANNER_FINISHED = "android.intent.action.MEDIA_SCANNER_FINISHED";
+
+   /**
+     * Broadcast Action:  Request the media scanner to scan a file and add it to the media database.
+     * The path to the file is contained in the Intent.mData field.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_SCANNER_SCAN_FILE = "android.intent.action.MEDIA_SCANNER_SCAN_FILE";
+
+   /**
+     * Broadcast Action:  The "Media Button" was pressed.  Includes a single
+     * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
+     * caused the broadcast.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_MEDIA_BUTTON = "android.intent.action.MEDIA_BUTTON";
+
+    /**
+     * Broadcast Action:  The "Camera Button" was pressed.  Includes a single
+     * extra field, {@link #EXTRA_KEY_EVENT}, containing the key event that
+     * caused the broadcast.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_CAMERA_BUTTON = "android.intent.action.CAMERA_BUTTON";
+
+    // *** NOTE: @todo(*) The following really should go into a more domain-specific
+    // location; they are not general-purpose actions.
+
+    /**
+     * Broadcast Action: A GTalk connection has been established.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_GTALK_SERVICE_CONNECTED =
+            "android.intent.action.GTALK_CONNECTED";
+
+    /**
+     * Broadcast Action: A GTalk connection has been disconnected.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_GTALK_SERVICE_DISCONNECTED =
+            "android.intent.action.GTALK_DISCONNECTED";
+
+    /**
+     * Broadcast Action: An input method has been changed.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_INPUT_METHOD_CHANGED =
+            "android.intent.action.INPUT_METHOD_CHANGED";
+
+    /**
+     * <p>Broadcast Action: The user has switched the phone into or out of Airplane Mode. One or
+     * more radios have been turned off or on. The intent will have the following extra value:</p>
+     * <ul>
+     *   <li><em>state</em> - A boolean value indicating whether Airplane Mode is on. If true,
+     *   then cell radio and possibly other radios such as bluetooth or WiFi may have also been
+     *   turned off</li>
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_AIRPLANE_MODE_CHANGED = "android.intent.action.AIRPLANE_MODE";
+
+    /**
+     * Broadcast Action: Some content providers have parts of their namespace
+     * where they publish new events or items that the user may be especially
+     * interested in. For these things, they may broadcast this action when the
+     * set of interesting items change.
+     *
+     * For example, GmailProvider sends this notification when the set of unread
+     * mail in the inbox changes.
+     *
+     * <p>The data of the intent identifies which part of which provider
+     * changed. When queried through the content resolver, the data URI will
+     * return the data set in question.
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>count</em> - The number of items in the data set. This is the
+     *       same as the number of items in the cursor returned by querying the
+     *       data URI. </li>
+     * </ul>
+     *
+     * This intent will be sent at boot (if the count is non-zero) and when the
+     * data set changes. It is possible for the data set to change without the
+     * count changing (for example, if a new unread message arrives in the same
+     * sync operation in which a message is archived). The phone should still
+     * ring/vibrate/etc as normal in this case.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_PROVIDER_CHANGED =
+            "android.intent.action.PROVIDER_CHANGED";
+
+    /**
+     * Broadcast Action: Wired Headset plugged in or unplugged.
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
+     *   <li><em>name</em> - Headset type, human readable string </li>
+     *   <li><em>microphone</em> - 1 if headset has a microphone, 0 otherwise </li>
+     * </ul>
+     * </ul>
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_HEADSET_PLUG =
+            "android.intent.action.HEADSET_PLUG";
+
+    /**
+     * Intents indicating the FM Rx switching on or off
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for switched off, 1 for switched on. </li>
+     * </ul>
+     * </ul>
+     * @hide
+     */
+    public static final String ACTION_FM =
+            "qualcomm.intent.action.FM";
+
+    /**
+     * Intents indicating the FM Tx switching on or off
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for switched off, 1 for switched on. </li>
+     * </ul>
+     * </ul>
+     * @hide
+     */
+    public static final String ACTION_FM_TX =
+            "qualcomm.intent.action.FMTX";
+
+    /**
+     * Broadcast Action: WiFi Display audio is enabled or disabled
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
+     * </ul>
+     * @hide
+     */
+    public static final String ACTION_WIFI_DISPLAY_AUDIO =
+            "qualcomm.intent.action.WIFI_DISPLAY_AUDIO";
+
+    /**
+     * Broadcast Action: WiFi Display video is enabled or disabled
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
+     * </ul>
+     * @hide
+     */
+
+    public static final String ACTION_WIFI_DISPLAY_VIDEO =
+            "qualcomm.intent.action.WIFI_DISPLAY_VIDEO";
+
+    /**
+     * Broadcast Action: An analog audio speaker/headset plugged in or unplugged.
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
+     *   <li><em>name</em> - Headset type, human readable string </li>
+     * </ul>
+     * </ul>
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_ANALOG_AUDIO_DOCK_PLUG =
+            "android.intent.action.ANALOG_AUDIO_DOCK_PLUG";
+
+    /**
+     * Broadcast Action: A digital audio speaker/headset plugged in or unplugged.
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
+     *   <li><em>name</em> - Headset type, human readable string </li>
+     * </ul>
+     * </ul>
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DIGITAL_AUDIO_DOCK_PLUG =
+            "android.intent.action.DIGITAL_AUDIO_DOCK_PLUG";
+
+    /**
+     * Broadcast Action: A HMDI cable was plugged or unplugged
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
+     *   <li><em>name</em> - HDMI cable, human readable string </li>
+     * </ul>
+     * </ul>
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_HDMI_AUDIO_PLUG =
+            "android.intent.action.HDMI_AUDIO_PLUG";
+
+    /**
+     * Broadcast Action: A USB audio accessory was plugged in or unplugged.
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
+     *   <li><em>card</em> - ALSA card number (integer) </li>
+     *   <li><em>device</em> - ALSA device number (integer) </li>
+     * </ul>
+     * </ul>
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_USB_AUDIO_ACCESSORY_PLUG =
+            "android.intent.action.USB_AUDIO_ACCESSORY_PLUG";
+
+    /**
+     * Broadcast Action: A USB audio device was plugged in or unplugged.
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>state</em> - 0 for unplugged, 1 for plugged. </li>
+     *   <li><em>card</em> - ALSA card number (integer) </li>
+     *   <li><em>device</em> - ALSA device number (integer) </li>
+     * </ul>
+     * </ul>
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_USB_AUDIO_DEVICE_PLUG =
+            "android.intent.action.USB_AUDIO_DEVICE_PLUG";
+
+    /**
+     * <p>Broadcast Action: The user has switched on advanced settings in the settings app:</p>
+     * <ul>
+     *   <li><em>state</em> - A boolean value indicating whether the settings is on or off.</li>
+     * </ul>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     *
+     * @hide
+     */
+    //@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_ADVANCED_SETTINGS_CHANGED
+            = "android.intent.action.ADVANCED_SETTINGS";
+
+    /**
+     * Broadcast Action: An outgoing call is about to be placed.
+     *
+     * <p>The Intent will have the following extra value:
+     * <ul>
+     *   <li><em>{@link android.content.Intent#EXTRA_PHONE_NUMBER}</em> -
+     *       the phone number originally intended to be dialed.</li>
+     * </ul>
+     * <p>Once the broadcast is finished, the resultData is used as the actual
+     * number to call.  If  <code>null</code>, no call will be placed.</p>
+     * <p>It is perfectly acceptable for multiple receivers to process the
+     * outgoing call in turn: for example, a parental control application
+     * might verify that the user is authorized to place the call at that
+     * time, then a number-rewriting application might add an area code if
+     * one was not specified.</p>
+     * <p>For consistency, any receiver whose purpose is to prohibit phone
+     * calls should have a priority of 0, to ensure it will see the final
+     * phone number to be dialed.
+     * Any receiver whose purpose is to rewrite phone numbers to be called
+     * should have a positive priority.
+     * Negative priorities are reserved for the system for this broadcast;
+     * using them may cause problems.</p>
+     * <p>Any BroadcastReceiver receiving this Intent <em>must not</em>
+     * abort the broadcast.</p>
+     * <p>Emergency calls cannot be intercepted using this mechanism, and
+     * other calls cannot be modified to call emergency numbers using this
+     * mechanism.
+     * <p>You must hold the
+     * {@link android.Manifest.permission#PROCESS_OUTGOING_CALLS}
+     * permission to receive this Intent.</p>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_NEW_OUTGOING_CALL =
+            "android.intent.action.NEW_OUTGOING_CALL";
+
+    /**
+     * Broadcast Action: An outgoing sms is about to be sent.
+     *
+     * The Intent will have the following extras:
+     * destAddr - the phone number originally intended to be dialled
+     * scAddr - the service center address
+     * multipart - indicate whether this is a multipart or single message
+     * parts - ArrayList<String> of text parts (one item if multipart=false)
+     * sentIntents - ArrayList<PendingIntent> to send on send
+     * deliveryIntents - ArrayList<PendingIntent> to send on delivery
+     *
+     * Once the broadcast is finished, resultData is used as the actual
+     * number to text.
+     *
+     * @hide
+     */
+    public static final String ACTION_NEW_OUTGOING_SMS =
+            "android.intent.action.NEW_OUTGOING_SMS";
+
+    /**
+     * Broadcast Action: Have the device reboot.  This is only for use by
+     * system code.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_REBOOT =
+            "android.intent.action.REBOOT";
+
+    /**
+     * Broadcast Action:  A sticky broadcast for changes in the physical
+     * docking state of the device.
+     *
+     * <p>The intent will have the following extra values:
+     * <ul>
+     *   <li><em>{@link #EXTRA_DOCK_STATE}</em> - the current dock
+     *       state, indicating which dock the device is physically in.</li>
+     * </ul>
+     * <p>This is intended for monitoring the current physical dock state.
+     * See {@link android.app.UiModeManager} for the normal API dealing with
+     * dock mode changes.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_DOCK_EVENT =
+            "android.intent.action.DOCK_EVENT";
+
+    /**
+     * Broadcast Action: a remote intent is to be broadcasted.
+     *
+     * A remote intent is used for remote RPC between devices. The remote intent
+     * is serialized and sent from one device to another device. The receiving
+     * device parses the remote intent and broadcasts it. Note that anyone can
+     * broadcast a remote intent. However, if the intent receiver of the remote intent
+     * does not trust intent broadcasts from arbitrary intent senders, it should require
+     * the sender to hold certain permissions so only trusted sender's broadcast will be
+     * let through.
+     * @hide
+     */
+    public static final String ACTION_REMOTE_INTENT =
+            "com.google.android.c2dm.intent.RECEIVE";
+
+    /**
+     * Broadcast Action: hook for permforming cleanup after a system update.
+     *
+     * The broadcast is sent when the system is booting, before the
+     * BOOT_COMPLETED broadcast.  It is only sent to receivers in the system
+     * image.  A receiver for this should do its work and then disable itself
+     * so that it does not get run again at the next boot.
+     * @hide
+     */
+    public static final String ACTION_PRE_BOOT_COMPLETED =
+            "android.intent.action.PRE_BOOT_COMPLETED";
+
+    /**
+     * Sent the first time a user is starting, to allow system apps to
+     * perform one time initialization.  (This will not be seen by third
+     * party applications because a newly initialized user does not have any
+     * third party applications installed for it.)  This is sent early in
+     * starting the user, around the time the home app is started, before
+     * {@link #ACTION_BOOT_COMPLETED} is sent.  This is sent as a foreground
+     * broadcast, since it is part of a visible user interaction; be as quick
+     * as possible when handling it.
+     */
+    public static final String ACTION_USER_INITIALIZE =
+            "android.intent.action.USER_INITIALIZE";
+
+    /**
+     * Sent when a user switch is happening, causing the process's user to be
+     * brought to the foreground.  This is only sent to receivers registered
+     * through {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
+     * Context.registerReceiver}.  It is sent to the user that is going to the
+     * foreground.  This is sent as a foreground
+     * broadcast, since it is part of a visible user interaction; be as quick
+     * as possible when handling it.
+     */
+    public static final String ACTION_USER_FOREGROUND =
+            "android.intent.action.USER_FOREGROUND";
+
+    /**
+     * Sent when a user switch is happening, causing the process's user to be
+     * sent to the background.  This is only sent to receivers registered
+     * through {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
+     * Context.registerReceiver}.  It is sent to the user that is going to the
+     * background.  This is sent as a foreground
+     * broadcast, since it is part of a visible user interaction; be as quick
+     * as possible when handling it.
+     */
+    public static final String ACTION_USER_BACKGROUND =
+            "android.intent.action.USER_BACKGROUND";
+
+    /**
+     * Broadcast sent to the system when a user is added. Carries an extra
+     * EXTRA_USER_HANDLE that has the userHandle of the new user.  It is sent to
+     * all running users.  You must hold
+     * {@link android.Manifest.permission#MANAGE_USERS} to receive this broadcast.
+     * @hide
+     */
+    public static final String ACTION_USER_ADDED =
+            "android.intent.action.USER_ADDED";
+
+    /**
+     * Broadcast sent by the system when a user is started. Carries an extra
+     * EXTRA_USER_HANDLE that has the userHandle of the user.  This is only sent to
+     * registered receivers, not manifest receivers.  It is sent to the user
+     * that has been started.  This is sent as a foreground
+     * broadcast, since it is part of a visible user interaction; be as quick
+     * as possible when handling it.
+     * @hide
+     */
+    public static final String ACTION_USER_STARTED =
+            "android.intent.action.USER_STARTED";
+
+    /**
+     * Broadcast sent when a user is in the process of starting.  Carries an extra
+     * EXTRA_USER_HANDLE that has the userHandle of the user.  This is only
+     * sent to registered receivers, not manifest receivers.  It is sent to all
+     * users (including the one that is being started).  You must hold
+     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} to receive
+     * this broadcast.  This is sent as a background broadcast, since
+     * its result is not part of the primary UX flow; to safely keep track of
+     * started/stopped state of a user you can use this in conjunction with
+     * {@link #ACTION_USER_STOPPING}.  It is <b>not</b> generally safe to use with
+     * other user state broadcasts since those are foreground broadcasts so can
+     * execute in a different order.
+     * @hide
+     */
+    public static final String ACTION_USER_STARTING =
+            "android.intent.action.USER_STARTING";
+
+    /**
+     * Broadcast sent when a user is going to be stopped.  Carries an extra
+     * EXTRA_USER_HANDLE that has the userHandle of the user.  This is only
+     * sent to registered receivers, not manifest receivers.  It is sent to all
+     * users (including the one that is being stopped).  You must hold
+     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} to receive
+     * this broadcast.  The user will not stop until all receivers have
+     * handled the broadcast.  This is sent as a background broadcast, since
+     * its result is not part of the primary UX flow; to safely keep track of
+     * started/stopped state of a user you can use this in conjunction with
+     * {@link #ACTION_USER_STARTING}.  It is <b>not</b> generally safe to use with
+     * other user state broadcasts since those are foreground broadcasts so can
+     * execute in a different order.
+     * @hide
+     */
+    public static final String ACTION_USER_STOPPING =
+            "android.intent.action.USER_STOPPING";
+
+    /**
+     * Broadcast sent to the system when a user is stopped. Carries an extra
+     * EXTRA_USER_HANDLE that has the userHandle of the user.  This is similar to
+     * {@link #ACTION_PACKAGE_RESTARTED}, but for an entire user instead of a
+     * specific package.  This is only sent to registered receivers, not manifest
+     * receivers.  It is sent to all running users <em>except</em> the one that
+     * has just been stopped (which is no longer running).
+     * @hide
+     */
+    public static final String ACTION_USER_STOPPED =
+            "android.intent.action.USER_STOPPED";
+
+    /**
+     * Broadcast sent to the system when a user is removed. Carries an extra EXTRA_USER_HANDLE that has
+     * the userHandle of the user.  It is sent to all running users except the
+     * one that has been removed. The user will not be completely removed until all receivers have
+     * handled the broadcast. You must hold
+     * {@link android.Manifest.permission#MANAGE_USERS} to receive this broadcast.
+     * @hide
+     */
+    public static final String ACTION_USER_REMOVED =
+            "android.intent.action.USER_REMOVED";
+
+    /**
+     * Broadcast sent to the system when the user switches. Carries an extra EXTRA_USER_HANDLE that has
+     * the userHandle of the user to become the current one. This is only sent to
+     * registered receivers, not manifest receivers.  It is sent to all running users.
+     * You must hold
+     * {@link android.Manifest.permission#MANAGE_USERS} to receive this broadcast.
+     * @hide
+     */
+    public static final String ACTION_USER_SWITCHED =
+            "android.intent.action.USER_SWITCHED";
+
+    /**
+     * Broadcast sent to the system when a user's information changes. Carries an extra
+     * {@link #EXTRA_USER_HANDLE} to indicate which user's information changed.
+     * This is only sent to registered receivers, not manifest receivers. It is sent to the user
+     * whose information has changed.
+     * @hide
+     */
+    public static final String ACTION_USER_INFO_CHANGED =
+            "android.intent.action.USER_INFO_CHANGED";
+
+    /**
+     * Sent when the user taps on the clock widget in the system's "quick settings" area.
+     */
+    public static final String ACTION_QUICK_CLOCK =
+            "android.intent.action.QUICK_CLOCK";
+
+    /**
+     * Broadcast Action: Indicate that unrecoverable error happened during app launch.
+     * Could indicate that curently applied theme is malicious.
+     * @hide
+     */
+    public static final String ACTION_APP_LAUNCH_FAILURE = "com.tmobile.intent.action.APP_LAUNCH_FAILURE";
+
+    /**
+     * Broadcast Action: Request to reset the unrecoverable errors count to 0.
+     * @hide
+     */
+    public static final String ACTION_APP_LAUNCH_FAILURE_RESET = "com.tmobile.intent.action.APP_LAUNCH_FAILURE_RESET";
+
+    // ---------------------------------------------------------------------
+    // ---------------------------------------------------------------------
+    // Standard intent categories (see addCategory()).
+
+    /**
+     * Set if the activity should be an option for the default action
+     * (center press) to perform on a piece of data.  Setting this will
+     * hide from the user any activities without it set when performing an
+     * action on some data.  Note that this is normal -not- set in the
+     * Intent when initiating an action -- it is for use in intent filters
+     * specified in packages.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_DEFAULT = "android.intent.category.DEFAULT";
+    /**
+     * Activities that can be safely invoked from a browser must support this
+     * category.  For example, if the user is viewing a web page or an e-mail
+     * and clicks on a link in the text, the Intent generated execute that
+     * link will require the BROWSABLE category, so that only activities
+     * supporting this category will be considered as possible actions.  By
+     * supporting this category, you are promising that there is nothing
+     * damaging (without user intervention) that can happen by invoking any
+     * matching Intent.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_BROWSABLE = "android.intent.category.BROWSABLE";
+    /**
+     * Set if the activity should be considered as an alternative action to
+     * the data the user is currently viewing.  See also
+     * {@link #CATEGORY_SELECTED_ALTERNATIVE} for an alternative action that
+     * applies to the selection in a list of items.
+     *
+     * <p>Supporting this category means that you would like your activity to be
+     * displayed in the set of alternative things the user can do, usually as
+     * part of the current activity's options menu.  You will usually want to
+     * include a specific label in the &lt;intent-filter&gt; of this action
+     * describing to the user what it does.
+     *
+     * <p>The action of IntentFilter with this category is important in that it
+     * describes the specific action the target will perform.  This generally
+     * should not be a generic action (such as {@link #ACTION_VIEW}, but rather
+     * a specific name such as "com.android.camera.action.CROP.  Only one
+     * alternative of any particular action will be shown to the user, so using
+     * a specific action like this makes sure that your alternative will be
+     * displayed while also allowing other applications to provide their own
+     * overrides of that particular action.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_ALTERNATIVE = "android.intent.category.ALTERNATIVE";
+    /**
+     * Set if the activity should be considered as an alternative selection
+     * action to the data the user has currently selected.  This is like
+     * {@link #CATEGORY_ALTERNATIVE}, but is used in activities showing a list
+     * of items from which the user can select, giving them alternatives to the
+     * default action that will be performed on it.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_SELECTED_ALTERNATIVE = "android.intent.category.SELECTED_ALTERNATIVE";
+    /**
+     * Intended to be used as a tab inside of a containing TabActivity.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_TAB = "android.intent.category.TAB";
+    /**
+     * Should be displayed in the top-level launcher.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_LAUNCHER = "android.intent.category.LAUNCHER";
+    /**
+     * Provides information about the package it is in; typically used if
+     * a package does not contain a {@link #CATEGORY_LAUNCHER} to provide
+     * a front-door to the user without having to be shown in the all apps list.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_INFO = "android.intent.category.INFO";
+    /**
+     * This is the home activity, that is the first activity that is displayed
+     * when the device boots.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_HOME = "android.intent.category.HOME";
+    /**
+     * This activity is a preference panel.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_PREFERENCE = "android.intent.category.PREFERENCE";
+    /**
+     * This activity is a development preference panel.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_DEVELOPMENT_PREFERENCE = "android.intent.category.DEVELOPMENT_PREFERENCE";
+    /**
+     * Capable of running inside a parent activity container.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_EMBED = "android.intent.category.EMBED";
+    /**
+     * This activity allows the user to browse and download new applications.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_MARKET = "android.intent.category.APP_MARKET";
+    /**
+     * This activity may be exercised by the monkey or other automated test tools.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_MONKEY = "android.intent.category.MONKEY";
+    /**
+     * To be used as a test (not part of the normal user experience).
+     */
+    public static final String CATEGORY_TEST = "android.intent.category.TEST";
+    /**
+     * To be used as a unit test (run through the Test Harness).
+     */
+    public static final String CATEGORY_UNIT_TEST = "android.intent.category.UNIT_TEST";
+    /**
+     * To be used as a sample code example (not part of the normal user
+     * experience).
+     */
+    public static final String CATEGORY_SAMPLE_CODE = "android.intent.category.SAMPLE_CODE";
+    /**
+     * Used to indicate that a GET_CONTENT intent only wants URIs that can be opened with
+     * ContentResolver.openInputStream. Openable URIs must support the columns in OpenableColumns
+     * when queried, though it is allowable for those columns to be blank.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_OPENABLE = "android.intent.category.OPENABLE";
+
+    /**
+     * To be used as code under test for framework instrumentation tests.
+     */
+    public static final String CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST =
+            "android.intent.category.FRAMEWORK_INSTRUMENTATION_TEST";
+
+    /**
+     * An activity to run when device is inserted into a car dock.
+     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
+     * information, see {@link android.app.UiModeManager}.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_CAR_DOCK = "android.intent.category.CAR_DOCK";
+    /**
+     * An activity to run when device is inserted into a car dock.
+     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
+     * information, see {@link android.app.UiModeManager}.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_DESK_DOCK = "android.intent.category.DESK_DOCK";
+    /**
+     * An activity to run when device is inserted into a analog (low end) dock.
+     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
+     * information, see {@link android.app.UiModeManager}.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_LE_DESK_DOCK = "android.intent.category.LE_DESK_DOCK";
+
+    /**
+     * An activity to run when device is inserted into a digital (high end) dock.
+     * Used with {@link #ACTION_MAIN} to launch an activity.  For more
+     * information, see {@link android.app.UiModeManager}.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_HE_DESK_DOCK = "android.intent.category.HE_DESK_DOCK";
+
+    /**
+     * Used to indicate that the activity can be used in a car environment.
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_CAR_MODE = "android.intent.category.CAR_MODE";
+
+    /**
+     * Used to indicate that a theme package has been installed or un-installed.
+     *
+     * @hide
+     */
+    public static final String CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE =
+            "com.tmobile.intent.category.THEME_PACKAGE_INSTALL_STATE_CHANGE";
+
+    // ---------------------------------------------------------------------
+    // ---------------------------------------------------------------------
+    // Application launch intent categories (see addCategory()).
+
+    /**
+     * Used with {@link #ACTION_MAIN} to launch the browser application.
+     * The activity should be able to browse the Internet.
+     * <p>NOTE: This should not be used as the primary key of an Intent,
+     * since it will not result in the app launching with the correct
+     * action and category.  Instead, use this with
+     * {@link #makeMainSelectorActivity(String, String)} to generate a main
+     * Intent with this category in the selector.</p>
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_BROWSER = "android.intent.category.APP_BROWSER";
+
+    /**
+     * Used with {@link #ACTION_MAIN} to launch the calculator application.
+     * The activity should be able to perform standard arithmetic operations.
+     * <p>NOTE: This should not be used as the primary key of an Intent,
+     * since it will not result in the app launching with the correct
+     * action and category.  Instead, use this with
+     * {@link #makeMainSelectorActivity(String, String)} to generate a main
+     * Intent with this category in the selector.</p>
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_CALCULATOR = "android.intent.category.APP_CALCULATOR";
+
+    /**
+     * Used with {@link #ACTION_MAIN} to launch the calendar application.
+     * The activity should be able to view and manipulate calendar entries.
+     * <p>NOTE: This should not be used as the primary key of an Intent,
+     * since it will not result in the app launching with the correct
+     * action and category.  Instead, use this with
+     * {@link #makeMainSelectorActivity(String, String)} to generate a main
+     * Intent with this category in the selector.</p>
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_CALENDAR = "android.intent.category.APP_CALENDAR";
+
+    /**
+     * Used with {@link #ACTION_MAIN} to launch the contacts application.
+     * The activity should be able to view and manipulate address book entries.
+     * <p>NOTE: This should not be used as the primary key of an Intent,
+     * since it will not result in the app launching with the correct
+     * action and category.  Instead, use this with
+     * {@link #makeMainSelectorActivity(String, String)} to generate a main
+     * Intent with this category in the selector.</p>
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_CONTACTS = "android.intent.category.APP_CONTACTS";
+
+    /**
+     * Used with {@link #ACTION_MAIN} to launch the email application.
+     * The activity should be able to send and receive email.
+     * <p>NOTE: This should not be used as the primary key of an Intent,
+     * since it will not result in the app launching with the correct
+     * action and category.  Instead, use this with
+     * {@link #makeMainSelectorActivity(String, String)} to generate a main
+     * Intent with this category in the selector.</p>
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_EMAIL = "android.intent.category.APP_EMAIL";
+
+    /**
+     * Used with {@link #ACTION_MAIN} to launch the gallery application.
+     * The activity should be able to view and manipulate image and video files
+     * stored on the device.
+     * <p>NOTE: This should not be used as the primary key of an Intent,
+     * since it will not result in the app launching with the correct
+     * action and category.  Instead, use this with
+     * {@link #makeMainSelectorActivity(String, String)} to generate a main
+     * Intent with this category in the selector.</p>
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_GALLERY = "android.intent.category.APP_GALLERY";
+
+    /**
+     * Used with {@link #ACTION_MAIN} to launch the maps application.
+     * The activity should be able to show the user's current location and surroundings.
+     * <p>NOTE: This should not be used as the primary key of an Intent,
+     * since it will not result in the app launching with the correct
+     * action and category.  Instead, use this with
+     * {@link #makeMainSelectorActivity(String, String)} to generate a main
+     * Intent with this category in the selector.</p>
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_MAPS = "android.intent.category.APP_MAPS";
+
+    /**
+     * Used with {@link #ACTION_MAIN} to launch the messaging application.
+     * The activity should be able to send and receive text messages.
+     * <p>NOTE: This should not be used as the primary key of an Intent,
+     * since it will not result in the app launching with the correct
+     * action and category.  Instead, use this with
+     * {@link #makeMainSelectorActivity(String, String)} to generate a main
+     * Intent with this category in the selector.</p>
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_MESSAGING = "android.intent.category.APP_MESSAGING";
+
+    /**
+     * Used with {@link #ACTION_MAIN} to launch the music application.
+     * The activity should be able to play, browse, or manipulate music files
+     * stored on the device.
+     * <p>NOTE: This should not be used as the primary key of an Intent,
+     * since it will not result in the app launching with the correct
+     * action and category.  Instead, use this with
+     * {@link #makeMainSelectorActivity(String, String)} to generate a main
+     * Intent with this category in the selector.</p>
+     */
+    @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+    public static final String CATEGORY_APP_MUSIC = "android.intent.category.APP_MUSIC";
+
+    // ---------------------------------------------------------------------
+    // ---------------------------------------------------------------------
+    // Standard extra data keys.
+
+    /**
+     * The initial data to place in a newly created record.  Use with
+     * {@link #ACTION_INSERT}.  The data here is a Map containing the same
+     * fields as would be given to the underlying ContentProvider.insert()
+     * call.
+     */
+    public static final String EXTRA_TEMPLATE = "android.intent.extra.TEMPLATE";
+
+    /**
+     * A constant CharSequence that is associated with the Intent, used with
+     * {@link #ACTION_SEND} to supply the literal data to be sent.  Note that
+     * this may be a styled CharSequence, so you must use
+     * {@link Bundle#getCharSequence(String) Bundle.getCharSequence()} to
+     * retrieve it.
+     */
+    public static final String EXTRA_TEXT = "android.intent.extra.TEXT";
+
+    /**
+     * A constant String that is associated with the Intent, used with
+     * {@link #ACTION_SEND} to supply an alternative to {@link #EXTRA_TEXT}
+     * as HTML formatted text.  Note that you <em>must</em> also supply
+     * {@link #EXTRA_TEXT}.
+     */
+    public static final String EXTRA_HTML_TEXT = "android.intent.extra.HTML_TEXT";
+
+    /**
+     * A content: URI holding a stream of data associated with the Intent,
+     * used with {@link #ACTION_SEND} to supply the data being sent.
+     */
+    public static final String EXTRA_STREAM = "android.intent.extra.STREAM";
+
+    /**
+     * A String[] holding e-mail addresses that should be delivered to.
+     */
+    public static final String EXTRA_EMAIL       = "android.intent.extra.EMAIL";
+
+    /**
+     * A String[] holding e-mail addresses that should be carbon copied.
+     */
+    public static final String EXTRA_CC       = "android.intent.extra.CC";
+
+    /**
+     * A String[] holding e-mail addresses that should be blind carbon copied.
+     */
+    public static final String EXTRA_BCC      = "android.intent.extra.BCC";
+
+    /**
+     * A constant string holding the desired subject line of a message.
+     */
+    public static final String EXTRA_SUBJECT  = "android.intent.extra.SUBJECT";
+
+    /**
+     * An Intent describing the choices you would like shown with
+     * {@link #ACTION_PICK_ACTIVITY}.
+     */
+    public static final String EXTRA_INTENT = "android.intent.extra.INTENT";
+
+    /**
+     * A CharSequence dialog title to provide to the user when used with a
+     * {@link #ACTION_CHOOSER}.
+     */
+    public static final String EXTRA_TITLE = "android.intent.extra.TITLE";
+
+    /**
+     * A Parcelable[] of {@link Intent} or
+     * {@link android.content.pm.LabeledIntent} objects as set with
+     * {@link #putExtra(String, Parcelable[])} of additional activities to place
+     * a the front of the list of choices, when shown to the user with a
+     * {@link #ACTION_CHOOSER}.
+     */
+    public static final String EXTRA_INITIAL_INTENTS = "android.intent.extra.INITIAL_INTENTS";
+
+    /**
+     * A {@link android.view.KeyEvent} object containing the event that
+     * triggered the creation of the Intent it is in.
+     */
+    public static final String EXTRA_KEY_EVENT = "android.intent.extra.KEY_EVENT";
+
+    /**
+     * Set to true in {@link #ACTION_REQUEST_SHUTDOWN} to request confirmation from the user
+     * before shutting down.
+     *
+     * {@hide}
+     */
+    public static final String EXTRA_KEY_CONFIRM = "android.intent.extra.KEY_CONFIRM";
+
+    /**
+     * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED} or
+     * {@link android.content.Intent#ACTION_PACKAGE_CHANGED} intents to override the default action
+     * of restarting the application.
+     */
+    public static final String EXTRA_DONT_KILL_APP = "android.intent.extra.DONT_KILL_APP";
+
+    /**
+     * A String holding the phone number originally entered in
+     * {@link android.content.Intent#ACTION_NEW_OUTGOING_CALL}, or the actual
+     * number to call in a {@link android.content.Intent#ACTION_CALL}.
+     */
+    public static final String EXTRA_PHONE_NUMBER = "android.intent.extra.PHONE_NUMBER";
+
+    /**
+     * Used as an int extra field in {@link android.content.Intent#ACTION_UID_REMOVED}
+     * intents to supply the uid the package had been assigned.  Also an optional
+     * extra in {@link android.content.Intent#ACTION_PACKAGE_REMOVED} or
+     * {@link android.content.Intent#ACTION_PACKAGE_CHANGED} for the same
+     * purpose.
+     */
+    public static final String EXTRA_UID = "android.intent.extra.UID";
+
+    /**
+     * @hide String array of package names.
+     */
+    public static final String EXTRA_PACKAGES = "android.intent.extra.PACKAGES";
+
+    /**
+     * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED}
+     * intents to indicate whether this represents a full uninstall (removing
+     * both the code and its data) or a partial uninstall (leaving its data,
+     * implying that this is an update).
+     */
+    public static final String EXTRA_DATA_REMOVED = "android.intent.extra.DATA_REMOVED";
+
+    /**
+     * @hide
+     * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED}
+     * intents to indicate that at this point the package has been removed for
+     * all users on the device.
+     */
+    public static final String EXTRA_REMOVED_FOR_ALL_USERS
+            = "android.intent.extra.REMOVED_FOR_ALL_USERS";
+
+    /**
+     * Used as a boolean extra field in {@link android.content.Intent#ACTION_PACKAGE_REMOVED}
+     * intents to indicate that this is a replacement of the package, so this
+     * broadcast will immediately be followed by an add broadcast for a
+     * different version of the same package.
+     */
+    public static final String EXTRA_REPLACING = "android.intent.extra.REPLACING";
+
+    /**
+     * Used as an int extra field in {@link android.app.AlarmManager} intents
+     * to tell the application being invoked how many pending alarms are being
+     * delievered with the intent.  For one-shot alarms this will always be 1.
+     * For recurring alarms, this might be greater than 1 if the device was
+     * asleep or powered off at the time an earlier alarm would have been
+     * delivered.
+     */
+    public static final String EXTRA_ALARM_COUNT = "android.intent.extra.ALARM_COUNT";
+
+    /**
+     * Used as an int extra field in {@link android.content.Intent#ACTION_DOCK_EVENT}
+     * intents to request the dock state.  Possible values are
+     * {@link android.content.Intent#EXTRA_DOCK_STATE_UNDOCKED},
+     * {@link android.content.Intent#EXTRA_DOCK_STATE_DESK}, or
+     * {@link android.content.Intent#EXTRA_DOCK_STATE_CAR}, or
+     * {@link android.content.Intent#EXTRA_DOCK_STATE_LE_DESK}, or
+     * {@link android.content.Intent#EXTRA_DOCK_STATE_HE_DESK}.
+     */
+    public static final String EXTRA_DOCK_STATE = "android.intent.extra.DOCK_STATE";
+
+    /**
+     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
+     * to represent that the phone is not in any dock.
+     */
+    public static final int EXTRA_DOCK_STATE_UNDOCKED = 0;
+
+    /**
+     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
+     * to represent that the phone is in a desk dock.
+     */
+    public static final int EXTRA_DOCK_STATE_DESK = 1;
+
+    /**
+     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
+     * to represent that the phone is in a car dock.
+     */
+    public static final int EXTRA_DOCK_STATE_CAR = 2;
+
+    /**
+     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
+     * to represent that the phone is in a analog (low end) dock.
+     */
+    public static final int EXTRA_DOCK_STATE_LE_DESK = 3;
+
+    /**
+     * Used as an int value for {@link android.content.Intent#EXTRA_DOCK_STATE}
+     * to represent that the phone is in a digital (high end) dock.
+     */
+    public static final int EXTRA_DOCK_STATE_HE_DESK = 4;
+
+    /**
+     * Boolean that can be supplied as meta-data with a dock activity, to
+     * indicate that the dock should take over the home key when it is active.
+     */
+    public static final String METADATA_DOCK_HOME = "android.dock_home";
+
+    /**
+     * Used as a parcelable extra field in {@link #ACTION_APP_ERROR}, containing
+     * the bug report.
+     */
+    public static final String EXTRA_BUG_REPORT = "android.intent.extra.BUG_REPORT";
+
+    /**
+     * Used in the extra field in the remote intent. It's astring token passed with the
+     * remote intent.
+     */
+    public static final String EXTRA_REMOTE_INTENT_TOKEN =
+            "android.intent.extra.remote_intent_token";
+
+    /**
+     * @deprecated See {@link #EXTRA_CHANGED_COMPONENT_NAME_LIST}; this field
+     * will contain only the first name in the list.
+     */
+    @Deprecated public static final String EXTRA_CHANGED_COMPONENT_NAME =
+            "android.intent.extra.changed_component_name";
+
+    /**
+     * This field is part of {@link android.content.Intent#ACTION_PACKAGE_CHANGED},
+     * and contains a string array of all of the components that have changed.
+     */
+    public static final String EXTRA_CHANGED_COMPONENT_NAME_LIST =
+            "android.intent.extra.changed_component_name_list";
+
+    /**
+     * This field is part of
+     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
+     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
+     * and contains a string array of all of the components that have changed.
+     */
+    public static final String EXTRA_CHANGED_PACKAGE_LIST =
+            "android.intent.extra.changed_package_list";
+
+    /**
+     * This field is part of
+     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE},
+     * {@link android.content.Intent#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE}
+     * and contains an integer array of uids of all of the components
+     * that have changed.
+     */
+    public static final String EXTRA_CHANGED_UID_LIST =
+            "android.intent.extra.changed_uid_list";
+
+    /**
+     * @hide
+     * Magic extra system code can use when binding, to give a label for
+     * who it is that has bound to a service.  This is an integer giving
+     * a framework string resource that can be displayed to the user.
+     */
+    public static final String EXTRA_CLIENT_LABEL =
+            "android.intent.extra.client_label";
+
+    /**
+     * @hide
+     * Magic extra system code can use when binding, to give a PendingIntent object
+     * that can be launched for the user to disable the system's use of this
+     * service.
+     */
+    public static final String EXTRA_CLIENT_INTENT =
+            "android.intent.extra.client_intent";
+
+    /**
+     * Used to indicate that a {@link #ACTION_GET_CONTENT} intent should only return
+     * data that is on the local device.  This is a boolean extra; the default
+     * is false.  If true, an implementation of ACTION_GET_CONTENT should only allow
+     * the user to select media that is already on the device, not requiring it
+     * be downloaded from a remote service when opened.  Another way to look
+     * at it is that such content should generally have a "_data" column to the
+     * path of the content on local external storage.
+     */
+    public static final String EXTRA_LOCAL_ONLY =
+        "android.intent.extra.LOCAL_ONLY";
+
+    /**
+     * The userHandle carried with broadcast intents related to addition, removal and switching of users
+     * - {@link #ACTION_USER_ADDED}, {@link #ACTION_USER_REMOVED} and {@link #ACTION_USER_SWITCHED}.
+     * @hide
+     */
+    public static final String EXTRA_USER_HANDLE =
+            "android.intent.extra.user_handle";
+
+    // ---------------------------------------------------------------------
+    // ---------------------------------------------------------------------
+    // Intent flags (see mFlags variable).
+
+    /**
+     * If set, the recipient of this Intent will be granted permission to
+     * perform read operations on the Uri in the Intent's data and any URIs
+     * specified in its ClipData.  When applying to an Intent's ClipData,
+     * all URIs as well as recursive traversals through data or other ClipData
+     * in Intent items will be granted; only the grant flags of the top-level
+     * Intent are used.
+     */
+    public static final int FLAG_GRANT_READ_URI_PERMISSION = 0x00000001;
+    /**
+     * If set, the recipient of this Intent will be granted permission to
+     * perform write operations on the Uri in the Intent's data and any URIs
+     * specified in its ClipData.  When applying to an Intent's ClipData,
+     * all URIs as well as recursive traversals through data or other ClipData
+     * in Intent items will be granted; only the grant flags of the top-level
+     * Intent are used.
+     */
+    public static final int FLAG_GRANT_WRITE_URI_PERMISSION = 0x00000002;
+    /**
+     * Can be set by the caller to indicate that this Intent is coming from
+     * a background operation, not from direct user interaction.
+     */
+    public static final int FLAG_FROM_BACKGROUND = 0x00000004;
+    /**
+     * A flag you can enable for debugging: when set, log messages will be
+     * printed during the resolution of this intent to show you what has
+     * been found to create the final resolved list.
+     */
+    public static final int FLAG_DEBUG_LOG_RESOLUTION = 0x00000008;
+    /**
+     * If set, this intent will not match any components in packages that
+     * are currently stopped.  If this is not set, then the default behavior
+     * is to include such applications in the result.
+     */
+    public static final int FLAG_EXCLUDE_STOPPED_PACKAGES = 0x00000010;
+    /**
+     * If set, this intent will always match any components in packages that
+     * are currently stopped.  This is the default behavior when
+     * {@link #FLAG_EXCLUDE_STOPPED_PACKAGES} is not set.  If both of these
+     * flags are set, this one wins (it allows overriding of exclude for
+     * places where the framework may automatically set the exclude flag).
+     */
+    public static final int FLAG_INCLUDE_STOPPED_PACKAGES = 0x00000020;
+
+    /**
+     * If set, this intent will always match start up as a floating window
+     * in mutil window scenarios.
+     */
+    public static final int FLAG_MULTI_WINDOW = 0x00000040;
+
+    /**
+     * If set, the new activity is not kept in the history stack.  As soon as
+     * the user navigates away from it, the activity is finished.  This may also
+     * be set with the {@link android.R.styleable#AndroidManifestActivity_noHistory
+     * noHistory} attribute.
+     */
+    public static final int FLAG_ACTIVITY_NO_HISTORY = 0x40000000;
+    /**
+     * If set, the activity will not be launched if it is already running
+     * at the top of the history stack.
+     */
+    public static final int FLAG_ACTIVITY_SINGLE_TOP = 0x20000000;
+    /**
+     * If set, this activity will become the start of a new task on this
+     * history stack.  A task (from the activity that started it to the
+     * next task activity) defines an atomic group of activities that the
+     * user can move to.  Tasks can be moved to the foreground and background;
+     * all of the activities inside of a particular task always remain in
+     * the same order.  See
+     * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
+     * Stack</a> for more information about tasks.
+     *
+     * <p>This flag is generally used by activities that want
+     * to present a "launcher" style behavior: they give the user a list of
+     * separate things that can be done, which otherwise run completely
+     * independently of the activity launching them.
+     *
+     * <p>When using this flag, if a task is already running for the activity
+     * you are now starting, then a new activity will not be started; instead,
+     * the current task will simply be brought to the front of the screen with
+     * the state it was last in.  See {@link #FLAG_ACTIVITY_MULTIPLE_TASK} for a flag
+     * to disable this behavior.
+     *
+     * <p>This flag can not be used when the caller is requesting a result from
+     * the activity being launched.
+     */
+    public static final int FLAG_ACTIVITY_NEW_TASK = 0x10000000;
+    /**
+     * <strong>Do not use this flag unless you are implementing your own
+     * top-level application launcher.</strong>  Used in conjunction with
+     * {@link #FLAG_ACTIVITY_NEW_TASK} to disable the
+     * behavior of bringing an existing task to the foreground.  When set,
+     * a new task is <em>always</em> started to host the Activity for the
+     * Intent, regardless of whether there is already an existing task running
+     * the same thing.
+     *
+     * <p><strong>Because the default system does not include graphical task management,
+     * you should not use this flag unless you provide some way for a user to
+     * return back to the tasks you have launched.</strong>
+     *
+     * <p>This flag is ignored if
+     * {@link #FLAG_ACTIVITY_NEW_TASK} is not set.
+     *
+     * <p>See
+     * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
+     * Stack</a> for more information about tasks.
+     */
+    public static final int FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;
+    /**
+     * If set, and the activity being launched is already running in the
+     * current task, then instead of launching a new instance of that activity,
+     * all of the other activities on top of it will be closed and this Intent
+     * will be delivered to the (now on top) old activity as a new Intent.
+     *
+     * <p>For example, consider a task consisting of the activities: A, B, C, D.
+     * If D calls startActivity() with an Intent that resolves to the component
+     * of activity B, then C and D will be finished and B receive the given
+     * Intent, resulting in the stack now being: A, B.
+     *
+     * <p>The currently running instance of activity B in the above example will
+     * either receive the new intent you are starting here in its
+     * onNewIntent() method, or be itself finished and restarted with the
+     * new intent.  If it has declared its launch mode to be "multiple" (the
+     * default) and you have not set {@link #FLAG_ACTIVITY_SINGLE_TOP} in
+     * the same intent, then it will be finished and re-created; for all other
+     * launch modes or if {@link #FLAG_ACTIVITY_SINGLE_TOP} is set then this
+     * Intent will be delivered to the current instance's onNewIntent().
+     *
+     * <p>This launch mode can also be used to good effect in conjunction with
+     * {@link #FLAG_ACTIVITY_NEW_TASK}: if used to start the root activity
+     * of a task, it will bring any currently running instance of that task
+     * to the foreground, and then clear it to its root state.  This is
+     * especially useful, for example, when launching an activity from the
+     * notification manager.
+     *
+     * <p>See
+     * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
+     * Stack</a> for more information about tasks.
+     */
+    public static final int FLAG_ACTIVITY_CLEAR_TOP = 0x04000000;
+    /**
+     * If set and this intent is being used to launch a new activity from an
+     * existing one, then the reply target of the existing activity will be
+     * transfered to the new activity.  This way the new activity can call
+     * {@link android.app.Activity#setResult} and have that result sent back to
+     * the reply target of the original activity.
+     */
+    public static final int FLAG_ACTIVITY_FORWARD_RESULT = 0x02000000;
+    /**
+     * If set and this intent is being used to launch a new activity from an
+     * existing one, the current activity will not be counted as the top
+     * activity for deciding whether the new intent should be delivered to
+     * the top instead of starting a new one.  The previous activity will
+     * be used as the top, with the assumption being that the current activity
+     * will finish itself immediately.
+     */
+    public static final int FLAG_ACTIVITY_PREVIOUS_IS_TOP = 0x01000000;
+    /**
+     * If set, the new activity is not kept in the list of recently launched
+     * activities.
+     */
+    public static final int FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS = 0x00800000;
+    /**
+     * This flag is not normally set by application code, but set for you by
+     * the system as described in the
+     * {@link android.R.styleable#AndroidManifestActivity_launchMode
+     * launchMode} documentation for the singleTask mode.
+     */
+    public static final int FLAG_ACTIVITY_BROUGHT_TO_FRONT = 0x00400000;
+    /**
+     * If set, and this activity is either being started in a new task or
+     * bringing to the top an existing task, then it will be launched as
+     * the front door of the task.  This will result in the application of
+     * any affinities needed to have that task in the proper state (either
+     * moving activities to or from it), or simply resetting that task to
+     * its initial state if needed.
+     */
+    public static final int FLAG_ACTIVITY_RESET_TASK_IF_NEEDED = 0x00200000;
+    /**
+     * This flag is not normally set by application code, but set for you by
+     * the system if this activity is being launched from history
+     * (longpress home key).
+     */
+    public static final int FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY = 0x00100000;
+    /**
+     * If set, this marks a point in the task's activity stack that should
+     * be cleared when the task is reset.  That is, the next time the task
+     * is brought to the foreground with
+     * {@link #FLAG_ACTIVITY_RESET_TASK_IF_NEEDED} (typically as a result of
+     * the user re-launching it from home), this activity and all on top of
+     * it will be finished so that the user does not return to them, but
+     * instead returns to whatever activity preceeded it.
+     *
+     * <p>This is useful for cases where you have a logical break in your
+     * application.  For example, an e-mail application may have a command
+     * to view an attachment, which launches an image view activity to
+     * display it.  This activity should be part of the e-mail application's
+     * task, since it is a part of the task the user is involved in.  However,
+     * if the user leaves that task, and later selects the e-mail app from
+     * home, we may like them to return to the conversation they were
+     * viewing, not the picture attachment, since that is confusing.  By
+     * setting this flag when launching the image viewer, that viewer and
+     * any activities it starts will be removed the next time the user returns
+     * to mail.
+     */
+    public static final int FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET = 0x00080000;
+    /**
+     * If set, this flag will prevent the normal {@link android.app.Activity#onUserLeaveHint}
+     * callback from occurring on the current frontmost activity before it is
+     * paused as the newly-started activity is brought to the front.
+     *
+     * <p>Typically, an activity can rely on that callback to indicate that an
+     * explicit user action has caused their activity to be moved out of the
+     * foreground. The callback marks an appropriate point in the activity's
+     * lifecycle for it to dismiss any notifications that it intends to display
+     * "until the user has seen them," such as a blinking LED.
+     *
+     * <p>If an activity is ever started via any non-user-driven events such as
+     * phone-call receipt or an alarm handler, this flag should be passed to {@link
+     * Context#startActivity Context.startActivity}, ensuring that the pausing
+     * activity does not think the user has acknowledged its notification.
+     */
+    public static final int FLAG_ACTIVITY_NO_USER_ACTION = 0x00040000;
+    /**
+     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
+     * this flag will cause the launched activity to be brought to the front of its
+     * task's history stack if it is already running.
+     *
+     * <p>For example, consider a task consisting of four activities: A, B, C, D.
+     * If D calls startActivity() with an Intent that resolves to the component
+     * of activity B, then B will be brought to the front of the history stack,
+     * with this resulting order:  A, C, D, B.
+     *
+     * This flag will be ignored if {@link #FLAG_ACTIVITY_CLEAR_TOP} is also
+     * specified.
+     */
+    public static final int FLAG_ACTIVITY_REORDER_TO_FRONT = 0X00020000;
+    /**
+     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
+     * this flag will prevent the system from applying an activity transition
+     * animation to go to the next activity state.  This doesn't mean an
+     * animation will never run -- if another activity change happens that doesn't
+     * specify this flag before the activity started here is displayed, then
+     * that transition will be used.  This flag can be put to good use
+     * when you are going to do a series of activity operations but the
+     * animation seen by the user shouldn't be driven by the first activity
+     * change but rather a later one.
+     */
+    public static final int FLAG_ACTIVITY_NO_ANIMATION = 0X00010000;
+    /**
+     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
+     * this flag will cause any existing task that would be associated with the
+     * activity to be cleared before the activity is started.  That is, the activity
+     * becomes the new root of an otherwise empty task, and any old activities
+     * are finished.  This can only be used in conjunction with {@link #FLAG_ACTIVITY_NEW_TASK}.
+     */
+    public static final int FLAG_ACTIVITY_CLEAR_TASK = 0X00008000;
+    /**
+     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
+     * this flag will cause a newly launching task to be placed on top of the current
+     * home activity task (if there is one).  That is, pressing back from the task
+     * will always return the user to home even if that was not the last activity they
+     * saw.   This can only be used in conjunction with {@link #FLAG_ACTIVITY_NEW_TASK}.
+     */
+    public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;
+    /**
+     * If set, when sending a broadcast only registered receivers will be
+     * called -- no BroadcastReceiver components will be launched.
+     */
+    public static final int FLAG_RECEIVER_REGISTERED_ONLY = 0x40000000;
+    /**
+     * If set, when sending a broadcast the new broadcast will replace
+     * any existing pending broadcast that matches it.  Matching is defined
+     * by {@link Intent#filterEquals(Intent) Intent.filterEquals} returning
+     * true for the intents of the two broadcasts.  When a match is found,
+     * the new broadcast (and receivers associated with it) will replace the
+     * existing one in the pending broadcast list, remaining at the same
+     * position in the list.
+     *
+     * <p>This flag is most typically used with sticky broadcasts, which
+     * only care about delivering the most recent values of the broadcast
+     * to their receivers.
+     */
+    public static final int FLAG_RECEIVER_REPLACE_PENDING = 0x20000000;
+    /**
+     * If set, when sending a broadcast the recipient is allowed to run at
+     * foreground priority, with a shorter timeout interval.  During normal
+     * broadcasts the receivers are not automatically hoisted out of the
+     * background priority class.
+     */
+    public static final int FLAG_RECEIVER_FOREGROUND = 0x10000000;
+    /**
+     * If set, when sending a broadcast <i>before boot has completed</i> only
+     * registered receivers will be called -- no BroadcastReceiver components
+     * will be launched.  Sticky intent state will be recorded properly even
+     * if no receivers wind up being called.  If {@link #FLAG_RECEIVER_REGISTERED_ONLY}
+     * is specified in the broadcast intent, this flag is unnecessary.
+     *
+     * <p>This flag is only for use by system sevices as a convenience to
+     * avoid having to implement a more complex mechanism around detection
+     * of boot completion.
+     *
+     * @hide
+     */
+    public static final int FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT = 0x08000000;
+    /**
+     * Set when this broadcast is for a boot upgrade, a special mode that
+     * allows the broadcast to be sent before the system is ready and launches
+     * the app process with no providers running in it.
+     * @hide
+     */
+    public static final int FLAG_RECEIVER_BOOT_UPGRADE = 0x04000000;
+
+    /**
+     * @hide Flags that can't be changed with PendingIntent.
+     */
+    public static final int IMMUTABLE_FLAGS =
+            FLAG_GRANT_READ_URI_PERMISSION
+            | FLAG_GRANT_WRITE_URI_PERMISSION;
+
+    // ---------------------------------------------------------------------
+    // ---------------------------------------------------------------------
+    // toUri() and parseUri() options.
+
+    /**
+     * Flag for use with {@link #toUri} and {@link #parseUri}: the URI string
+     * always has the "intent:" scheme.  This syntax can be used when you want
+     * to later disambiguate between URIs that are intended to describe an
+     * Intent vs. all others that should be treated as raw URIs.  When used
+     * with {@link #parseUri}, any other scheme will result in a generic
+     * VIEW action for that raw URI.
+     */
+    public static final int URI_INTENT_SCHEME = 1<<0;
+
+    // ---------------------------------------------------------------------
+
+    private String mAction;
+    private Uri mData;
+    private String mType;
+    private String mPackage;
+    private ComponentName mComponent;
+    private int mFlags;
+    private HashSet<String> mCategories;
+    private Bundle mExtras;
+    private Rect mSourceBounds;
+    private Intent mSelector;
+    private ClipData mClipData;
+
+    // ---------------------------------------------------------------------
+
+    /**
+     * Create an empty intent.
+     */
+    public Intent() {
+    }
+
+    /**
+     * Copy constructor.
+     */
+    public Intent(Intent o) {
+        this.mAction = o.mAction;
+        this.mData = o.mData;
+        this.mType = o.mType;
+        this.mPackage = o.mPackage;
+        this.mComponent = o.mComponent;
+        this.mFlags = o.mFlags;
+        if (o.mCategories != null) {
+            this.mCategories = new HashSet<String>(o.mCategories);
+        }
+        if (o.mExtras != null) {
+            this.mExtras = new Bundle(o.mExtras);
+        }
+        if (o.mSourceBounds != null) {
+            this.mSourceBounds = new Rect(o.mSourceBounds);
+        }
+        if (o.mSelector != null) {
+            this.mSelector = new Intent(o.mSelector);
+        }
+        if (o.mClipData != null) {
+            this.mClipData = new ClipData(o.mClipData);
+        }
+    }
+
+    @Override
+    public Object clone() {
+        return new Intent(this);
+    }
+
+    private Intent(Intent o, boolean all) {
+        this.mAction = o.mAction;
+        this.mData = o.mData;
+        this.mType = o.mType;
+        this.mPackage = o.mPackage;
+        this.mComponent = o.mComponent;
+        if (o.mCategories != null) {
+            this.mCategories = new HashSet<String>(o.mCategories);
+        }
+    }
+
+    /**
+     * Make a clone of only the parts of the Intent that are relevant for
+     * filter matching: the action, data, type, component, and categories.
+     */
+    public Intent cloneFilter() {
+        return new Intent(this, false);
+    }
+
+    /**
+     * Create an intent with a given action.  All other fields (data, type,
+     * class) are null.  Note that the action <em>must</em> be in a
+     * namespace because Intents are used globally in the system -- for
+     * example the system VIEW action is android.intent.action.VIEW; an
+     * application's custom action would be something like
+     * com.google.app.myapp.CUSTOM_ACTION.
+     *
+     * @param action The Intent action, such as ACTION_VIEW.
+     */
+    public Intent(String action) {
+        setAction(action);
+    }
+
+    /**
+     * Create an intent with a given action and for a given data url.  Note
+     * that the action <em>must</em> be in a namespace because Intents are
+     * used globally in the system -- for example the system VIEW action is
+     * android.intent.action.VIEW; an application's custom action would be
+     * something like com.google.app.myapp.CUSTOM_ACTION.
+     *
+     * <p><em>Note: scheme and host name matching in the Android framework is
+     * case-sensitive, unlike the formal RFC.  As a result,
+     * you should always ensure that you write your Uri with these elements
+     * using lower case letters, and normalize any Uris you receive from
+     * outside of Android to ensure the scheme and host is lower case.</em></p>
+     *
+     * @param action The Intent action, such as ACTION_VIEW.
+     * @param uri The Intent data URI.
+     */
+    public Intent(String action, Uri uri) {
+        setAction(action);
+        mData = uri;
+    }
+
+    /**
+     * Create an intent for a specific component.  All other fields (action, data,
+     * type, class) are null, though they can be modified later with explicit
+     * calls.  This provides a convenient way to create an intent that is
+     * intended to execute a hard-coded class name, rather than relying on the
+     * system to find an appropriate class for you; see {@link #setComponent}
+     * for more information on the repercussions of this.
+     *
+     * @param packageContext A Context of the application package implementing
+     * this class.
+     * @param cls The component class that is to be used for the intent.
+     *
+     * @see #setClass
+     * @see #setComponent
+     * @see #Intent(String, android.net.Uri , Context, Class)
+     */
+    public Intent(Context packageContext, Class<?> cls) {
+        mComponent = new ComponentName(packageContext, cls);
+    }
+
+    /**
+     * Create an intent for a specific component with a specified action and data.
+     * This is equivalent using {@link #Intent(String, android.net.Uri)} to
+     * construct the Intent and then calling {@link #setClass} to set its
+     * class.
+     *
+     * <p><em>Note: scheme and host name matching in the Android framework is
+     * case-sensitive, unlike the formal RFC.  As a result,
+     * you should always ensure that you write your Uri with these elements
+     * using lower case letters, and normalize any Uris you receive from
+     * outside of Android to ensure the scheme and host is lower case.</em></p>
+     *
+     * @param action The Intent action, such as ACTION_VIEW.
+     * @param uri The Intent data URI.
+     * @param packageContext A Context of the application package implementing
+     * this class.
+     * @param cls The component class that is to be used for the intent.
+     *
+     * @see #Intent(String, android.net.Uri)
+     * @see #Intent(Context, Class)
+     * @see #setClass
+     * @see #setComponent
+     */
+    public Intent(String action, Uri uri,
+            Context packageContext, Class<?> cls) {
+        setAction(action);
+        mData = uri;
+        mComponent = new ComponentName(packageContext, cls);
+    }
+
+    /**
+     * Create an intent to launch the main (root) activity of a task.  This
+     * is the Intent that is started when the application's is launched from
+     * Home.  For anything else that wants to launch an application in the
+     * same way, it is important that they use an Intent structured the same
+     * way, and can use this function to ensure this is the case.
+     *
+     * <p>The returned Intent has the given Activity component as its explicit
+     * component, {@link #ACTION_MAIN} as its action, and includes the
+     * category {@link #CATEGORY_LAUNCHER}.  This does <em>not</em> have
+     * {@link #FLAG_ACTIVITY_NEW_TASK} set, though typically you will want
+     * to do that through {@link #addFlags(int)} on the returned Intent.
+     *
+     * @param mainActivity The main activity component that this Intent will
+     * launch.
+     * @return Returns a newly created Intent that can be used to launch the
+     * activity as a main application entry.
+     *
+     * @see #setClass
+     * @see #setComponent
+     */
+    public static Intent makeMainActivity(ComponentName mainActivity) {
+        Intent intent = new Intent(ACTION_MAIN);
+        intent.setComponent(mainActivity);
+        intent.addCategory(CATEGORY_LAUNCHER);
+        return intent;
+    }
+
+    /**
+     * Make an Intent for the main activity of an application, without
+     * specifying a specific activity to run but giving a selector to find
+     * the activity.  This results in a final Intent that is structured
+     * the same as when the application is launched from
+     * Home.  For anything else that wants to launch an application in the
+     * same way, it is important that they use an Intent structured the same
+     * way, and can use this function to ensure this is the case.
+     *
+     * <p>The returned Intent has {@link #ACTION_MAIN} as its action, and includes the
+     * category {@link #CATEGORY_LAUNCHER}.  This does <em>not</em> have
+     * {@link #FLAG_ACTIVITY_NEW_TASK} set, though typically you will want
+     * to do that through {@link #addFlags(int)} on the returned Intent.
+     *
+     * @param selectorAction The action name of the Intent's selector.
+     * @param selectorCategory The name of a category to add to the Intent's
+     * selector.
+     * @return Returns a newly created Intent that can be used to launch the
+     * activity as a main application entry.
+     *
+     * @see #setSelector(Intent)
+     */
+    public static Intent makeMainSelectorActivity(String selectorAction,
+            String selectorCategory) {
+        Intent intent = new Intent(ACTION_MAIN);
+        intent.addCategory(CATEGORY_LAUNCHER);
+        Intent selector = new Intent();
+        selector.setAction(selectorAction);
+        selector.addCategory(selectorCategory);
+        intent.setSelector(selector);
+        return intent;
+    }
+
+    /**
+     * Make an Intent that can be used to re-launch an application's task
+     * in its base state.  This is like {@link #makeMainActivity(ComponentName)},
+     * but also sets the flags {@link #FLAG_ACTIVITY_NEW_TASK} and
+     * {@link #FLAG_ACTIVITY_CLEAR_TASK}.
+     *
+     * @param mainActivity The activity component that is the root of the
+     * task; this is the activity that has been published in the application's
+     * manifest as the main launcher icon.
+     *
+     * @return Returns a newly created Intent that can be used to relaunch the
+     * activity's task in its root state.
+     */
+    public static Intent makeRestartActivityTask(ComponentName mainActivity) {
+        Intent intent = makeMainActivity(mainActivity);
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+        return intent;
+    }
+
+    /**
+     * Call {@link #parseUri} with 0 flags.
+     * @deprecated Use {@link #parseUri} instead.
+     */
+    @Deprecated
+    public static Intent getIntent(String uri) throws URISyntaxException {
+        return parseUri(uri, 0);
+    }
+
+    /**
+     * Create an intent from a URI.  This URI may encode the action,
+     * category, and other intent fields, if it was returned by
+     * {@link #toUri}.  If the Intent was not generate by toUri(), its data
+     * will be the entire URI and its action will be ACTION_VIEW.
+     *
+     * <p>The URI given here must not be relative -- that is, it must include
+     * the scheme and full path.
+     *
+     * @param uri The URI to turn into an Intent.
+     * @param flags Additional processing flags.  Either 0 or
+     * {@link #URI_INTENT_SCHEME}.
+     *
+     * @return Intent The newly created Intent object.
+     *
+     * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
+     * it bad (as parsed by the Uri class) or the Intent data within the
+     * URI is invalid.
+     *
+     * @see #toUri
+     */
+    public static Intent parseUri(String uri, int flags) throws URISyntaxException {
+        int i = 0;
+        try {
+            // Validate intent scheme for if requested.
+            if ((flags&URI_INTENT_SCHEME) != 0) {
+                if (!uri.startsWith("intent:")) {
+                    Intent intent = new Intent(ACTION_VIEW);
+                    try {
+                        intent.setData(Uri.parse(uri));
+                    } catch (IllegalArgumentException e) {
+                        throw new URISyntaxException(uri, e.getMessage());
+                    }
+                    return intent;
+                }
+            }
+
+            // simple case
+            i = uri.lastIndexOf("#");
+            if (i == -1) return new Intent(ACTION_VIEW, Uri.parse(uri));
+
+            // old format Intent URI
+            if (!uri.startsWith("#Intent;", i)) return getIntentOld(uri);
+
+            // new format
+            Intent intent = new Intent(ACTION_VIEW);
+            Intent baseIntent = intent;
+
+            // fetch data part, if present
+            String data = i >= 0 ? uri.substring(0, i) : null;
+            String scheme = null;
+            i += "#Intent;".length();
+
+            // loop over contents of Intent, all name=value;
+            while (!uri.startsWith("end", i)) {
+                int eq = uri.indexOf('=', i);
+                if (eq < 0) eq = i-1;
+                int semi = uri.indexOf(';', i);
+                String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : "";
+
+                // action
+                if (uri.startsWith("action=", i)) {
+                    intent.setAction(value);
+                }
+
+                // categories
+                else if (uri.startsWith("category=", i)) {
+                    intent.addCategory(value);
+                }
+
+                // type
+                else if (uri.startsWith("type=", i)) {
+                    intent.mType = value;
+                }
+
+                // launch flags
+                else if (uri.startsWith("launchFlags=", i)) {
+                    intent.mFlags = Integer.decode(value).intValue();
+                }
+
+                // package
+                else if (uri.startsWith("package=", i)) {
+                    intent.mPackage = value;
+                }
+
+                // component
+                else if (uri.startsWith("component=", i)) {
+                    intent.mComponent = ComponentName.unflattenFromString(value);
+                }
+
+                // scheme
+                else if (uri.startsWith("scheme=", i)) {
+                    scheme = value;
+                }
+
+                // source bounds
+                else if (uri.startsWith("sourceBounds=", i)) {
+                    intent.mSourceBounds = Rect.unflattenFromString(value);
+                }
+
+                // selector
+                else if (semi == (i+3) && uri.startsWith("SEL", i)) {
+                    intent = new Intent();
+                }
+
+                // extra
+                else {
+                    String key = Uri.decode(uri.substring(i + 2, eq));
+                    // create Bundle if it doesn't already exist
+                    if (intent.mExtras == null) intent.mExtras = new Bundle();
+                    Bundle b = intent.mExtras;
+                    // add EXTRA
+                    if      (uri.startsWith("S.", i)) b.putString(key, value);
+                    else if (uri.startsWith("B.", i)) b.putBoolean(key, Boolean.parseBoolean(value));
+                    else if (uri.startsWith("b.", i)) b.putByte(key, Byte.parseByte(value));
+                    else if (uri.startsWith("c.", i)) b.putChar(key, value.charAt(0));
+                    else if (uri.startsWith("d.", i)) b.putDouble(key, Double.parseDouble(value));
+                    else if (uri.startsWith("f.", i)) b.putFloat(key, Float.parseFloat(value));
+                    else if (uri.startsWith("i.", i)) b.putInt(key, Integer.parseInt(value));
+                    else if (uri.startsWith("l.", i)) b.putLong(key, Long.parseLong(value));
+                    else if (uri.startsWith("s.", i)) b.putShort(key, Short.parseShort(value));
+                    else throw new URISyntaxException(uri, "unknown EXTRA type", i);
+                }
+
+                // move to the next item
+                i = semi + 1;
+            }
+
+            if (intent != baseIntent) {
+                // The Intent had a selector; fix it up.
+                baseIntent.setSelector(intent);
+                intent = baseIntent;
+            }
+
+            if (data != null) {
+                if (data.startsWith("intent:")) {
+                    data = data.substring(7);
+                    if (scheme != null) {
+                        data = scheme + ':' + data;
+                    }
+                }
+
+                if (data.length() > 0) {
+                    try {
+                        intent.mData = Uri.parse(data);
+                    } catch (IllegalArgumentException e) {
+                        throw new URISyntaxException(uri, e.getMessage());
+                    }
+                }
+            }
+
+            return intent;
+
+        } catch (IndexOutOfBoundsException e) {
+            throw new URISyntaxException(uri, "illegal Intent URI format", i);
+        }
+    }
+
+    public static Intent getIntentOld(String uri) throws URISyntaxException {
+        Intent intent;
+
+        int i = uri.lastIndexOf('#');
+        if (i >= 0) {
+            String action = null;
+            final int intentFragmentStart = i;
+            boolean isIntentFragment = false;
+
+            i++;
+
+            if (uri.regionMatches(i, "action(", 0, 7)) {
+                isIntentFragment = true;
+                i += 7;
+                int j = uri.indexOf(')', i);
+                action = uri.substring(i, j);
+                i = j + 1;
+            }
+
+            intent = new Intent(action);
+
+            if (uri.regionMatches(i, "categories(", 0, 11)) {
+                isIntentFragment = true;
+                i += 11;
+                int j = uri.indexOf(')', i);
+                while (i < j) {
+                    int sep = uri.indexOf('!', i);
+                    if (sep < 0) sep = j;
+                    if (i < sep) {
+                        intent.addCategory(uri.substring(i, sep));
+                    }
+                    i = sep + 1;
+                }
+                i = j + 1;
+            }
+
+            if (uri.regionMatches(i, "type(", 0, 5)) {
+                isIntentFragment = true;
+                i += 5;
+                int j = uri.indexOf(')', i);
+                intent.mType = uri.substring(i, j);
+                i = j + 1;
+            }
+
+            if (uri.regionMatches(i, "launchFlags(", 0, 12)) {
+                isIntentFragment = true;
+                i += 12;
+                int j = uri.indexOf(')', i);
+                intent.mFlags = Integer.decode(uri.substring(i, j)).intValue();
+                i = j + 1;
+            }
+
+            if (uri.regionMatches(i, "component(", 0, 10)) {
+                isIntentFragment = true;
+                i += 10;
+                int j = uri.indexOf(')', i);
+                int sep = uri.indexOf('!', i);
+                if (sep >= 0 && sep < j) {
+                    String pkg = uri.substring(i, sep);
+                    String cls = uri.substring(sep + 1, j);
+                    intent.mComponent = new ComponentName(pkg, cls);
+                }
+                i = j + 1;
+            }
+
+            if (uri.regionMatches(i, "extras(", 0, 7)) {
+                isIntentFragment = true;
+                i += 7;
+
+                final int closeParen = uri.indexOf(')', i);
+                if (closeParen == -1) throw new URISyntaxException(uri,
+                        "EXTRA missing trailing ')'", i);
+
+                while (i < closeParen) {
+                    // fetch the key value
+                    int j = uri.indexOf('=', i);
+                    if (j <= i + 1 || i >= closeParen) {
+                        throw new URISyntaxException(uri, "EXTRA missing '='", i);
+                    }
+                    char type = uri.charAt(i);
+                    i++;
+                    String key = uri.substring(i, j);
+                    i = j + 1;
+
+                    // get type-value
+                    j = uri.indexOf('!', i);
+                    if (j == -1 || j >= closeParen) j = closeParen;
+                    if (i >= j) throw new URISyntaxException(uri, "EXTRA missing '!'", i);
+                    String value = uri.substring(i, j);
+                    i = j;
+
+                    // create Bundle if it doesn't already exist
+                    if (intent.mExtras == null) intent.mExtras = new Bundle();
+
+                    // add item to bundle
+                    try {
+                        switch (type) {
+                            case 'S':
+                                intent.mExtras.putString(key, Uri.decode(value));
+                                break;
+                            case 'B':
+                                intent.mExtras.putBoolean(key, Boolean.parseBoolean(value));
+                                break;
+                            case 'b':
+                                intent.mExtras.putByte(key, Byte.parseByte(value));
+                                break;
+                            case 'c':
+                                intent.mExtras.putChar(key, Uri.decode(value).charAt(0));
+                                break;
+                            case 'd':
+                                intent.mExtras.putDouble(key, Double.parseDouble(value));
+                                break;
+                            case 'f':
+                                intent.mExtras.putFloat(key, Float.parseFloat(value));
+                                break;
+                            case 'i':
+                                intent.mExtras.putInt(key, Integer.parseInt(value));
+                                break;
+                            case 'l':
+                                intent.mExtras.putLong(key, Long.parseLong(value));
+                                break;
+                            case 's':
+                                intent.mExtras.putShort(key, Short.parseShort(value));
+                                break;
+                            default:
+                                throw new URISyntaxException(uri, "EXTRA has unknown type", i);
+                        }
+                    } catch (NumberFormatException e) {
+                        throw new URISyntaxException(uri, "EXTRA value can't be parsed", i);
+                    }
+
+                    char ch = uri.charAt(i);
+                    if (ch == ')') break;
+                    if (ch != '!') throw new URISyntaxException(uri, "EXTRA missing '!'", i);
+                    i++;
+                }
+            }
+
+            if (isIntentFragment) {
+                intent.mData = Uri.parse(uri.substring(0, intentFragmentStart));
+            } else {
+                intent.mData = Uri.parse(uri);
+            }
+
+            if (intent.mAction == null) {
+                // By default, if no action is specified, then use VIEW.
+                intent.mAction = ACTION_VIEW;
+            }
+
+        } else {
+            intent = new Intent(ACTION_VIEW, Uri.parse(uri));
+        }
+
+        return intent;
+    }
+
+    /**
+     * Retrieve the general action to be performed, such as
+     * {@link #ACTION_VIEW}.  The action describes the general way the rest of
+     * the information in the intent should be interpreted -- most importantly,
+     * what to do with the data returned by {@link #getData}.
+     *
+     * @return The action of this intent or null if none is specified.
+     *
+     * @see #setAction
+     */
+    public String getAction() {
+        return mAction;
+    }
+
+    /**
+     * Retrieve data this intent is operating on.  This URI specifies the name
+     * of the data; often it uses the content: scheme, specifying data in a
+     * content provider.  Other schemes may be handled by specific activities,
+     * such as http: by the web browser.
+     *
+     * @return The URI of the data this intent is targeting or null.
+     *
+     * @see #getScheme
+     * @see #setData
+     */
+    public Uri getData() {
+        return mData;
+    }
+
+    /**
+     * The same as {@link #getData()}, but returns the URI as an encoded
+     * String.
+     */
+    public String getDataString() {
+        return mData != null ? mData.toString() : null;
+    }
+
+    /**
+     * Return the scheme portion of the intent's data.  If the data is null or
+     * does not include a scheme, null is returned.  Otherwise, the scheme
+     * prefix without the final ':' is returned, i.e. "http".
+     *
+     * <p>This is the same as calling getData().getScheme() (and checking for
+     * null data).
+     *
+     * @return The scheme of this intent.
+     *
+     * @see #getData
+     */
+    public String getScheme() {
+        return mData != null ? mData.getScheme() : null;
+    }
+
+    /**
+     * Retrieve any explicit MIME type included in the intent.  This is usually
+     * null, as the type is determined by the intent data.
+     *
+     * @return If a type was manually set, it is returned; else null is
+     *         returned.
+     *
+     * @see #resolveType(ContentResolver)
+     * @see #setType
+     */
+    public String getType() {
+        return mType;
+    }
+
+    /**
+     * Return the MIME data type of this intent.  If the type field is
+     * explicitly set, that is simply returned.  Otherwise, if the data is set,
+     * the type of that data is returned.  If neither fields are set, a null is
+     * returned.
+     *
+     * @return The MIME type of this intent.
+     *
+     * @see #getType
+     * @see #resolveType(ContentResolver)
+     */
+    public String resolveType(Context context) {
+        return resolveType(context.getContentResolver());
+    }
+
+    /**
+     * Return the MIME data type of this intent.  If the type field is
+     * explicitly set, that is simply returned.  Otherwise, if the data is set,
+     * the type of that data is returned.  If neither fields are set, a null is
+     * returned.
+     *
+     * @param resolver A ContentResolver that can be used to determine the MIME
+     *                 type of the intent's data.
+     *
+     * @return The MIME type of this intent.
+     *
+     * @see #getType
+     * @see #resolveType(Context)
+     */
+    public String resolveType(ContentResolver resolver) {
+        if (mType != null) {
+            return mType;
+        }
+        if (mData != null) {
+            if ("content".equals(mData.getScheme())) {
+                return resolver.getType(mData);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Return the MIME data type of this intent, only if it will be needed for
+     * intent resolution.  This is not generally useful for application code;
+     * it is used by the frameworks for communicating with back-end system
+     * services.
+     *
+     * @param resolver A ContentResolver that can be used to determine the MIME
+     *                 type of the intent's data.
+     *
+     * @return The MIME type of this intent, or null if it is unknown or not
+     *         needed.
+     */
+    public String resolveTypeIfNeeded(ContentResolver resolver) {
+        if (mComponent != null) {
+            return mType;
+        }
+        return resolveType(resolver);
+    }
+
+    /**
+     * Check if a category exists in the intent.
+     *
+     * @param category The category to check.
+     *
+     * @return boolean True if the intent contains the category, else false.
+     *
+     * @see #getCategories
+     * @see #addCategory
+     */
+    public boolean hasCategory(String category) {
+        return mCategories != null && mCategories.contains(category);
+    }
+
+    /**
+     * Return the set of all categories in the intent.  If there are no categories,
+     * returns NULL.
+     *
+     * @return The set of categories you can examine.  Do not modify!
+     *
+     * @see #hasCategory
+     * @see #addCategory
+     */
+    public Set<String> getCategories() {
+        return mCategories;
+    }
+
+    /**
+     * Return the specific selector associated with this Intent.  If there is
+     * none, returns null.  See {@link #setSelector} for more information.
+     *
+     * @see #setSelector
+     */
+    public Intent getSelector() {
+        return mSelector;
+    }
+
+    /**
+     * Return the {@link ClipData} associated with this Intent.  If there is
+     * none, returns null.  See {@link #setClipData} for more information.
+     *
+     * @see #setClipData;
+     */
+    public ClipData getClipData() {
+        return mClipData;
+    }
+
+    /**
+     * Sets the ClassLoader that will be used when unmarshalling
+     * any Parcelable values from the extras of this Intent.
+     *
+     * @param loader a ClassLoader, or null to use the default loader
+     * at the time of unmarshalling.
+     */
+    public void setExtrasClassLoader(ClassLoader loader) {
+        if (mExtras != null) {
+            mExtras.setClassLoader(loader);
+        }
+    }
+
+    /**
+     * Returns true if an extra value is associated with the given name.
+     * @param name the extra's name
+     * @return true if the given extra is present.
+     */
+    public boolean hasExtra(String name) {
+        return mExtras != null && mExtras.containsKey(name);
+    }
+
+    /**
+     * Returns true if the Intent's extras contain a parcelled file descriptor.
+     * @return true if the Intent contains a parcelled file descriptor.
+     */
+    public boolean hasFileDescriptors() {
+        return mExtras != null && mExtras.hasFileDescriptors();
+    }
+
+    /** @hide */
+    public void setAllowFds(boolean allowFds) {
+        if (mExtras != null) {
+            mExtras.setAllowFds(allowFds);
+        }
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if none was found.
+     *
+     * @deprecated
+     * @hide
+     */
+    @Deprecated
+    public Object getExtra(String name) {
+        return getExtra(name, null);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     * @param defaultValue the value to be returned if no value of the desired
+     * type is stored with the given name.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or the default value if none was found.
+     *
+     * @see #putExtra(String, boolean)
+     */
+    public boolean getBooleanExtra(String name, boolean defaultValue) {
+        return mExtras == null ? defaultValue :
+            mExtras.getBoolean(name, defaultValue);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     * @param defaultValue the value to be returned if no value of the desired
+     * type is stored with the given name.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or the default value if none was found.
+     *
+     * @see #putExtra(String, byte)
+     */
+    public byte getByteExtra(String name, byte defaultValue) {
+        return mExtras == null ? defaultValue :
+            mExtras.getByte(name, defaultValue);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     * @param defaultValue the value to be returned if no value of the desired
+     * type is stored with the given name.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or the default value if none was found.
+     *
+     * @see #putExtra(String, short)
+     */
+    public short getShortExtra(String name, short defaultValue) {
+        return mExtras == null ? defaultValue :
+            mExtras.getShort(name, defaultValue);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     * @param defaultValue the value to be returned if no value of the desired
+     * type is stored with the given name.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or the default value if none was found.
+     *
+     * @see #putExtra(String, char)
+     */
+    public char getCharExtra(String name, char defaultValue) {
+        return mExtras == null ? defaultValue :
+            mExtras.getChar(name, defaultValue);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     * @param defaultValue the value to be returned if no value of the desired
+     * type is stored with the given name.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or the default value if none was found.
+     *
+     * @see #putExtra(String, int)
+     */
+    public int getIntExtra(String name, int defaultValue) {
+        return mExtras == null ? defaultValue :
+            mExtras.getInt(name, defaultValue);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     * @param defaultValue the value to be returned if no value of the desired
+     * type is stored with the given name.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or the default value if none was found.
+     *
+     * @see #putExtra(String, long)
+     */
+    public long getLongExtra(String name, long defaultValue) {
+        return mExtras == null ? defaultValue :
+            mExtras.getLong(name, defaultValue);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     * @param defaultValue the value to be returned if no value of the desired
+     * type is stored with the given name.
+     *
+     * @return the value of an item that previously added with putExtra(),
+     * or the default value if no such item is present
+     *
+     * @see #putExtra(String, float)
+     */
+    public float getFloatExtra(String name, float defaultValue) {
+        return mExtras == null ? defaultValue :
+            mExtras.getFloat(name, defaultValue);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     * @param defaultValue the value to be returned if no value of the desired
+     * type is stored with the given name.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or the default value if none was found.
+     *
+     * @see #putExtra(String, double)
+     */
+    public double getDoubleExtra(String name, double defaultValue) {
+        return mExtras == null ? defaultValue :
+            mExtras.getDouble(name, defaultValue);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no String value was found.
+     *
+     * @see #putExtra(String, String)
+     */
+    public String getStringExtra(String name) {
+        return mExtras == null ? null : mExtras.getString(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no CharSequence value was found.
+     *
+     * @see #putExtra(String, CharSequence)
+     */
+    public CharSequence getCharSequenceExtra(String name) {
+        return mExtras == null ? null : mExtras.getCharSequence(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no Parcelable value was found.
+     *
+     * @see #putExtra(String, Parcelable)
+     */
+    public <T extends Parcelable> T getParcelableExtra(String name) {
+        return mExtras == null ? null : mExtras.<T>getParcelable(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no Parcelable[] value was found.
+     *
+     * @see #putExtra(String, Parcelable[])
+     */
+    public Parcelable[] getParcelableArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getParcelableArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no ArrayList<Parcelable> value was found.
+     *
+     * @see #putParcelableArrayListExtra(String, ArrayList)
+     */
+    public <T extends Parcelable> ArrayList<T> getParcelableArrayListExtra(String name) {
+        return mExtras == null ? null : mExtras.<T>getParcelableArrayList(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no Serializable value was found.
+     *
+     * @see #putExtra(String, Serializable)
+     */
+    public Serializable getSerializableExtra(String name) {
+        return mExtras == null ? null : mExtras.getSerializable(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no ArrayList<Integer> value was found.
+     *
+     * @see #putIntegerArrayListExtra(String, ArrayList)
+     */
+    public ArrayList<Integer> getIntegerArrayListExtra(String name) {
+        return mExtras == null ? null : mExtras.getIntegerArrayList(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no ArrayList<String> value was found.
+     *
+     * @see #putStringArrayListExtra(String, ArrayList)
+     */
+    public ArrayList<String> getStringArrayListExtra(String name) {
+        return mExtras == null ? null : mExtras.getStringArrayList(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no ArrayList<CharSequence> value was found.
+     *
+     * @see #putCharSequenceArrayListExtra(String, ArrayList)
+     */
+    public ArrayList<CharSequence> getCharSequenceArrayListExtra(String name) {
+        return mExtras == null ? null : mExtras.getCharSequenceArrayList(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no boolean array value was found.
+     *
+     * @see #putExtra(String, boolean[])
+     */
+    public boolean[] getBooleanArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getBooleanArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no byte array value was found.
+     *
+     * @see #putExtra(String, byte[])
+     */
+    public byte[] getByteArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getByteArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no short array value was found.
+     *
+     * @see #putExtra(String, short[])
+     */
+    public short[] getShortArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getShortArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no char array value was found.
+     *
+     * @see #putExtra(String, char[])
+     */
+    public char[] getCharArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getCharArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no int array value was found.
+     *
+     * @see #putExtra(String, int[])
+     */
+    public int[] getIntArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getIntArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no long array value was found.
+     *
+     * @see #putExtra(String, long[])
+     */
+    public long[] getLongArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getLongArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no float array value was found.
+     *
+     * @see #putExtra(String, float[])
+     */
+    public float[] getFloatArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getFloatArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no double array value was found.
+     *
+     * @see #putExtra(String, double[])
+     */
+    public double[] getDoubleArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getDoubleArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no String array value was found.
+     *
+     * @see #putExtra(String, String[])
+     */
+    public String[] getStringArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getStringArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no CharSequence array value was found.
+     *
+     * @see #putExtra(String, CharSequence[])
+     */
+    public CharSequence[] getCharSequenceArrayExtra(String name) {
+        return mExtras == null ? null : mExtras.getCharSequenceArray(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no Bundle value was found.
+     *
+     * @see #putExtra(String, Bundle)
+     */
+    public Bundle getBundleExtra(String name) {
+        return mExtras == null ? null : mExtras.getBundle(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or null if no IBinder value was found.
+     *
+     * @see #putExtra(String, IBinder)
+     *
+     * @deprecated
+     * @hide
+     */
+    @Deprecated
+    public IBinder getIBinderExtra(String name) {
+        return mExtras == null ? null : mExtras.getIBinder(name);
+    }
+
+    /**
+     * Retrieve extended data from the intent.
+     *
+     * @param name The name of the desired item.
+     * @param defaultValue The default value to return in case no item is
+     * associated with the key 'name'
+     *
+     * @return the value of an item that previously added with putExtra()
+     * or defaultValue if none was found.
+     *
+     * @see #putExtra
+     *
+     * @deprecated
+     * @hide
+     */
+    @Deprecated
+    public Object getExtra(String name, Object defaultValue) {
+        Object result = defaultValue;
+        if (mExtras != null) {
+            Object result2 = mExtras.get(name);
+            if (result2 != null) {
+                result = result2;
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Retrieves a map of extended data from the intent.
+     *
+     * @return the map of all extras previously added with putExtra(),
+     * or null if none have been added.
+     */
+    public Bundle getExtras() {
+        return (mExtras != null)
+                ? new Bundle(mExtras)
+                : null;
+    }
+
+    /**
+     * Retrieve any special flags associated with this intent.  You will
+     * normally just set them with {@link #setFlags} and let the system
+     * take the appropriate action with them.
+     *
+     * @return int The currently set flags.
+     *
+     * @see #setFlags
+     */
+    public int getFlags() {
+        return mFlags;
+    }
+
+    /** @hide */
+    public boolean isExcludingStopped() {
+        return (mFlags&(FLAG_EXCLUDE_STOPPED_PACKAGES|FLAG_INCLUDE_STOPPED_PACKAGES))
+                == FLAG_EXCLUDE_STOPPED_PACKAGES;
+    }
+
+    /**
+     * Retrieve the application package name this Intent is limited to.  When
+     * resolving an Intent, if non-null this limits the resolution to only
+     * components in the given application package.
+     *
+     * @return The name of the application package for the Intent.
+     *
+     * @see #resolveActivity
+     * @see #setPackage
+     */
+    public String getPackage() {
+        return mPackage;
+    }
+
+    /**
+     * Retrieve the concrete component associated with the intent.  When receiving
+     * an intent, this is the component that was found to best handle it (that is,
+     * yourself) and will always be non-null; in all other cases it will be
+     * null unless explicitly set.
+     *
+     * @return The name of the application component to handle the intent.
+     *
+     * @see #resolveActivity
+     * @see #setComponent
+     */
+    public ComponentName getComponent() {
+        return mComponent;
+    }
+
+    /**
+     * Get the bounds of the sender of this intent, in screen coordinates.  This can be
+     * used as a hint to the receiver for animations and the like.  Null means that there
+     * is no source bounds.
+     */
+    public Rect getSourceBounds() {
+        return mSourceBounds;
+    }
+
+    /**
+     * Return the Activity component that should be used to handle this intent.
+     * The appropriate component is determined based on the information in the
+     * intent, evaluated as follows:
+     *
+     * <p>If {@link #getComponent} returns an explicit class, that is returned
+     * without any further consideration.
+     *
+     * <p>The activity must handle the {@link Intent#CATEGORY_DEFAULT} Intent
+     * category to be considered.
+     *
+     * <p>If {@link #getAction} is non-NULL, the activity must handle this
+     * action.
+     *
+     * <p>If {@link #resolveType} returns non-NULL, the activity must handle
+     * this type.
+     *
+     * <p>If {@link #addCategory} has added any categories, the activity must
+     * handle ALL of the categories specified.
+     *
+     * <p>If {@link #getPackage} is non-NULL, only activity components in
+     * that application package will be considered.
+     *
+     * <p>If there are no activities that satisfy all of these conditions, a
+     * null string is returned.
+     *
+     * <p>If multiple activities are found to satisfy the intent, the one with
+     * the highest priority will be used.  If there are multiple activities
+     * with the same priority, the system will either pick the best activity
+     * based on user preference, or resolve to a system class that will allow
+     * the user to pick an activity and forward from there.
+     *
+     * <p>This method is implemented simply by calling
+     * {@link PackageManager#resolveActivity} with the "defaultOnly" parameter
+     * true.</p>
+     * <p> This API is called for you as part of starting an activity from an
+     * intent.  You do not normally need to call it yourself.</p>
+     *
+     * @param pm The package manager with which to resolve the Intent.
+     *
+     * @return Name of the component implementing an activity that can
+     *         display the intent.
+     *
+     * @see #setComponent
+     * @see #getComponent
+     * @see #resolveActivityInfo
+     */
+    public ComponentName resolveActivity(PackageManager pm) {
+        if (mComponent != null) {
+            return mComponent;
+        }
+
+        ResolveInfo info = pm.resolveActivity(
+            this, PackageManager.MATCH_DEFAULT_ONLY);
+        if (info != null) {
+            return new ComponentName(
+                    info.activityInfo.applicationInfo.packageName,
+                    info.activityInfo.name);
+        }
+
+        return null;
+    }
+
+    /**
+     * Resolve the Intent into an {@link ActivityInfo}
+     * describing the activity that should execute the intent.  Resolution
+     * follows the same rules as described for {@link #resolveActivity}, but
+     * you get back the completely information about the resolved activity
+     * instead of just its class name.
+     *
+     * @param pm The package manager with which to resolve the Intent.
+     * @param flags Addition information to retrieve as per
+     * {@link PackageManager#getActivityInfo(ComponentName, int)
+     * PackageManager.getActivityInfo()}.
+     *
+     * @return PackageManager.ActivityInfo
+     *
+     * @see #resolveActivity
+     */
+    public ActivityInfo resolveActivityInfo(PackageManager pm, int flags) {
+        ActivityInfo ai = null;
+        if (mComponent != null) {
+            try {
+                ai = pm.getActivityInfo(mComponent, flags);
+            } catch (PackageManager.NameNotFoundException e) {
+                // ignore
+            }
+        } else {
+            ResolveInfo info = pm.resolveActivity(
+                this, PackageManager.MATCH_DEFAULT_ONLY | flags);
+            if (info != null) {
+                ai = info.activityInfo;
+            }
+        }
+
+        return ai;
+    }
+
+    /**
+     * Set the general action to be performed.
+     *
+     * @param action An action name, such as ACTION_VIEW.  Application-specific
+     *               actions should be prefixed with the vendor's package name.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #getAction
+     */
+    public Intent setAction(String action) {
+        mAction = action != null ? action.intern() : null;
+        return this;
+    }
+
+    /**
+     * Set the data this intent is operating on.  This method automatically
+     * clears any type that was previously set by {@link #setType} or
+     * {@link #setTypeAndNormalize}.
+     *
+     * <p><em>Note: scheme matching in the Android framework is
+     * case-sensitive, unlike the formal RFC. As a result,
+     * you should always write your Uri with a lower case scheme,
+     * or use {@link Uri#normalizeScheme} or
+     * {@link #setDataAndNormalize}
+     * to ensure that the scheme is converted to lower case.</em>
+     *
+     * @param data The Uri of the data this intent is now targeting.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #getData
+     * @see #setDataAndNormalize
+     * @see android.net.Intent#normalize
+     */
+    public Intent setData(Uri data) {
+        mData = data;
+        mType = null;
+        return this;
+    }
+
+    /**
+     * Normalize and set the data this intent is operating on.
+     *
+     * <p>This method automatically clears any type that was
+     * previously set (for example, by {@link #setType}).
+     *
+     * <p>The data Uri is normalized using
+     * {@link android.net.Uri#normalizeScheme} before it is set,
+     * so really this is just a convenience method for
+     * <pre>
+     * setData(data.normalize())
+     * </pre>
+     *
+     * @param data The Uri of the data this intent is now targeting.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #getData
+     * @see #setType
+     * @see android.net.Uri#normalizeScheme
+     */
+    public Intent setDataAndNormalize(Uri data) {
+        return setData(data.normalizeScheme());
+    }
+
+    /**
+     * Set an explicit MIME data type.
+     *
+     * <p>This is used to create intents that only specify a type and not data,
+     * for example to indicate the type of data to return.
+     *
+     * <p>This method automatically clears any data that was
+     * previously set (for example by {@link #setData}).
+     *
+     * <p><em>Note: MIME type matching in the Android framework is
+     * case-sensitive, unlike formal RFC MIME types.  As a result,
+     * you should always write your MIME types with lower case letters,
+     * or use {@link #normalizeMimeType} or {@link #setTypeAndNormalize}
+     * to ensure that it is converted to lower case.</em>
+     *
+     * @param type The MIME type of the data being handled by this intent.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #getType
+     * @see #setTypeAndNormalize
+     * @see #setDataAndType
+     * @see #normalizeMimeType
+     */
+    public Intent setType(String type) {
+        mData = null;
+        mType = type;
+        return this;
+    }
+
+    /**
+     * Normalize and set an explicit MIME data type.
+     *
+     * <p>This is used to create intents that only specify a type and not data,
+     * for example to indicate the type of data to return.
+     *
+     * <p>This method automatically clears any data that was
+     * previously set (for example by {@link #setData}).
+     *
+     * <p>The MIME type is normalized using
+     * {@link #normalizeMimeType} before it is set,
+     * so really this is just a convenience method for
+     * <pre>
+     * setType(Intent.normalizeMimeType(type))
+     * </pre>
+     *
+     * @param type The MIME type of the data being handled by this intent.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #getType
+     * @see #setData
+     * @see #normalizeMimeType
+     */
+    public Intent setTypeAndNormalize(String type) {
+        return setType(normalizeMimeType(type));
+    }
+
+    /**
+     * (Usually optional) Set the data for the intent along with an explicit
+     * MIME data type.  This method should very rarely be used -- it allows you
+     * to override the MIME type that would ordinarily be inferred from the
+     * data with your own type given here.
+     *
+     * <p><em>Note: MIME type and Uri scheme matching in the
+     * Android framework is case-sensitive, unlike the formal RFC definitions.
+     * As a result, you should always write these elements with lower case letters,
+     * or use {@link #normalizeMimeType} or {@link android.net.Uri#normalizeScheme} or
+     * {@link #setDataAndTypeAndNormalize}
+     * to ensure that they are converted to lower case.</em>
+     *
+     * @param data The Uri of the data this intent is now targeting.
+     * @param type The MIME type of the data being handled by this intent.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #setType
+     * @see #setData
+     * @see #normalizeMimeType
+     * @see android.net.Uri#normalizeScheme
+     * @see #setDataAndTypeAndNormalize
+     */
+    public Intent setDataAndType(Uri data, String type) {
+        mData = data;
+        mType = type;
+        return this;
+    }
+
+    /**
+     * (Usually optional) Normalize and set both the data Uri and an explicit
+     * MIME data type.  This method should very rarely be used -- it allows you
+     * to override the MIME type that would ordinarily be inferred from the
+     * data with your own type given here.
+     *
+     * <p>The data Uri and the MIME type are normalize using
+     * {@link android.net.Uri#normalizeScheme} and {@link #normalizeMimeType}
+     * before they are set, so really this is just a convenience method for
+     * <pre>
+     * setDataAndType(data.normalize(), Intent.normalizeMimeType(type))
+     * </pre>
+     *
+     * @param data The Uri of the data this intent is now targeting.
+     * @param type The MIME type of the data being handled by this intent.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #setType
+     * @see #setData
+     * @see #setDataAndType
+     * @see #normalizeMimeType
+     * @see android.net.Uri#normalizeScheme
+     */
+    public Intent setDataAndTypeAndNormalize(Uri data, String type) {
+        return setDataAndType(data.normalizeScheme(), normalizeMimeType(type));
+    }
+
+    /**
+     * Add a new category to the intent.  Categories provide additional detail
+     * about the action the intent performs.  When resolving an intent, only
+     * activities that provide <em>all</em> of the requested categories will be
+     * used.
+     *
+     * @param category The desired category.  This can be either one of the
+     *               predefined Intent categories, or a custom category in your own
+     *               namespace.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #hasCategory
+     * @see #removeCategory
+     */
+    public Intent addCategory(String category) {
+        if (mCategories == null) {
+            mCategories = new HashSet<String>();
+        }
+        mCategories.add(category.intern());
+        return this;
+    }
+
+    /**
+     * Remove a category from an intent.
+     *
+     * @param category The category to remove.
+     *
+     * @see #addCategory
+     */
+    public void removeCategory(String category) {
+        if (mCategories != null) {
+            mCategories.remove(category);
+            if (mCategories.size() == 0) {
+                mCategories = null;
+            }
+        }
+    }
+
+    /**
+     * Set a selector for this Intent.  This is a modification to the kinds of
+     * things the Intent will match.  If the selector is set, it will be used
+     * when trying to find entities that can handle the Intent, instead of the
+     * main contents of the Intent.  This allows you build an Intent containing
+     * a generic protocol while targeting it more specifically.
+     *
+     * <p>An example of where this may be used is with things like
+     * {@link #CATEGORY_APP_BROWSER}.  This category allows you to build an
+     * Intent that will launch the Browser application.  However, the correct
+     * main entry point of an application is actually {@link #ACTION_MAIN}
+     * {@link #CATEGORY_LAUNCHER} with {@link #setComponent(ComponentName)}
+     * used to specify the actual Activity to launch.  If you launch the browser
+     * with something different, undesired behavior may happen if the user has
+     * previously or later launches it the normal way, since they do not match.
+     * Instead, you can build an Intent with the MAIN action (but no ComponentName
+     * yet specified) and set a selector with {@link #ACTION_MAIN} and
+     * {@link #CATEGORY_APP_BROWSER} to point it specifically to the browser activity.
+     *
+     * <p>Setting a selector does not impact the behavior of
+     * {@link #filterEquals(Intent)} and {@link #filterHashCode()}.  This is part of the
+     * desired behavior of a selector -- it does not impact the base meaning
+     * of the Intent, just what kinds of things will be matched against it
+     * when determining who can handle it.</p>
+     *
+     * <p>You can not use both a selector and {@link #setPackage(String)} on
+     * the same base Intent.</p>
+     *
+     * @param selector The desired selector Intent; set to null to not use
+     * a special selector.
+     */
+    public void setSelector(Intent selector) {
+        if (selector == this) {
+            throw new IllegalArgumentException(
+                    "Intent being set as a selector of itself");
+        }
+        if (selector != null && mPackage != null) {
+            throw new IllegalArgumentException(
+                    "Can't set selector when package name is already set");
+        }
+        mSelector = selector;
+    }
+
+    /**
+     * Set a {@link ClipData} associated with this Intent.  This replaces any
+     * previously set ClipData.
+     *
+     * <p>The ClipData in an intent is not used for Intent matching or other
+     * such operations.  Semantically it is like extras, used to transmit
+     * additional data with the Intent.  The main feature of using this over
+     * the extras for data is that {@link #FLAG_GRANT_READ_URI_PERMISSION}
+     * and {@link #FLAG_GRANT_WRITE_URI_PERMISSION} will operate on any URI
+     * items included in the clip data.  This is useful, in particular, if
+     * you want to transmit an Intent containing multiple <code>content:</code>
+     * URIs for which the recipient may not have global permission to access the
+     * content provider.
+     *
+     * <p>If the ClipData contains items that are themselves Intents, any
+     * grant flags in those Intents will be ignored.  Only the top-level flags
+     * of the main Intent are respected, and will be applied to all Uri or
+     * Intent items in the clip (or sub-items of the clip).
+     *
+     * <p>The MIME type, label, and icon in the ClipData object are not
+     * directly used by Intent.  Applications should generally rely on the
+     * MIME type of the Intent itself, not what it may find in the ClipData.
+     * A common practice is to construct a ClipData for use with an Intent
+     * with a MIME type of "*\/*".
+     *
+     * @param clip The new clip to set.  May be null to clear the current clip.
+     */
+    public void setClipData(ClipData clip) {
+        mClipData = clip;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The boolean data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getBooleanExtra(String, boolean)
+     */
+    public Intent putExtra(String name, boolean value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putBoolean(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The byte data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getByteExtra(String, byte)
+     */
+    public Intent putExtra(String name, byte value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putByte(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The char data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getCharExtra(String, char)
+     */
+    public Intent putExtra(String name, char value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putChar(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The short data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getShortExtra(String, short)
+     */
+    public Intent putExtra(String name, short value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putShort(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The integer data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getIntExtra(String, int)
+     */
+    public Intent putExtra(String name, int value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putInt(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The long data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getLongExtra(String, long)
+     */
+    public Intent putExtra(String name, long value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putLong(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The float data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getFloatExtra(String, float)
+     */
+    public Intent putExtra(String name, float value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putFloat(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The double data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getDoubleExtra(String, double)
+     */
+    public Intent putExtra(String name, double value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putDouble(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The String data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getStringExtra(String)
+     */
+    public Intent putExtra(String name, String value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putString(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The CharSequence data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getCharSequenceExtra(String)
+     */
+    public Intent putExtra(String name, CharSequence value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putCharSequence(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The Parcelable data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getParcelableExtra(String)
+     */
+    public Intent putExtra(String name, Parcelable value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putParcelable(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The Parcelable[] data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getParcelableArrayExtra(String)
+     */
+    public Intent putExtra(String name, Parcelable[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putParcelableArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The ArrayList<Parcelable> data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getParcelableArrayListExtra(String)
+     */
+    public Intent putParcelableArrayListExtra(String name, ArrayList<? extends Parcelable> value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putParcelableArrayList(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The ArrayList<Integer> data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getIntegerArrayListExtra(String)
+     */
+    public Intent putIntegerArrayListExtra(String name, ArrayList<Integer> value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putIntegerArrayList(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The ArrayList<String> data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getStringArrayListExtra(String)
+     */
+    public Intent putStringArrayListExtra(String name, ArrayList<String> value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putStringArrayList(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The ArrayList<CharSequence> data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getCharSequenceArrayListExtra(String)
+     */
+    public Intent putCharSequenceArrayListExtra(String name, ArrayList<CharSequence> value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putCharSequenceArrayList(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The Serializable data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getSerializableExtra(String)
+     */
+    public Intent putExtra(String name, Serializable value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putSerializable(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The boolean array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getBooleanArrayExtra(String)
+     */
+    public Intent putExtra(String name, boolean[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putBooleanArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The byte array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getByteArrayExtra(String)
+     */
+    public Intent putExtra(String name, byte[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putByteArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The short array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getShortArrayExtra(String)
+     */
+    public Intent putExtra(String name, short[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putShortArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The char array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getCharArrayExtra(String)
+     */
+    public Intent putExtra(String name, char[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putCharArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The int array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getIntArrayExtra(String)
+     */
+    public Intent putExtra(String name, int[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putIntArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The byte array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getLongArrayExtra(String)
+     */
+    public Intent putExtra(String name, long[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putLongArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The float array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getFloatArrayExtra(String)
+     */
+    public Intent putExtra(String name, float[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putFloatArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The double array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getDoubleArrayExtra(String)
+     */
+    public Intent putExtra(String name, double[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putDoubleArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The String array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getStringArrayExtra(String)
+     */
+    public Intent putExtra(String name, String[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putStringArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The CharSequence array data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getCharSequenceArrayExtra(String)
+     */
+    public Intent putExtra(String name, CharSequence[] value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putCharSequenceArray(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The Bundle data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getBundleExtra(String)
+     */
+    public Intent putExtra(String name, Bundle value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putBundle(name, value);
+        return this;
+    }
+
+    /**
+     * Add extended data to the intent.  The name must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param name The name of the extra data, with package prefix.
+     * @param value The IBinder data value.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #putExtras
+     * @see #removeExtra
+     * @see #getIBinderExtra(String)
+     *
+     * @deprecated
+     * @hide
+     */
+    @Deprecated
+    public Intent putExtra(String name, IBinder value) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putIBinder(name, value);
+        return this;
+    }
+
+    /**
+     * Copy all extras in 'src' in to this intent.
+     *
+     * @param src Contains the extras to copy.
+     *
+     * @see #putExtra
+     */
+    public Intent putExtras(Intent src) {
+        if (src.mExtras != null) {
+            if (mExtras == null) {
+                mExtras = new Bundle(src.mExtras);
+            } else {
+                mExtras.putAll(src.mExtras);
+            }
+        }
+        return this;
+    }
+
+    /**
+     * Add a set of extended data to the intent.  The keys must include a package
+     * prefix, for example the app com.android.contacts would use names
+     * like "com.android.contacts.ShowAll".
+     *
+     * @param extras The Bundle of extras to add to this intent.
+     *
+     * @see #putExtra
+     * @see #removeExtra
+     */
+    public Intent putExtras(Bundle extras) {
+        if (mExtras == null) {
+            mExtras = new Bundle();
+        }
+        mExtras.putAll(extras);
+        return this;
+    }
+
+    /**
+     * Completely replace the extras in the Intent with the extras in the
+     * given Intent.
+     *
+     * @param src The exact extras contained in this Intent are copied
+     * into the target intent, replacing any that were previously there.
+     */
+    public Intent replaceExtras(Intent src) {
+        mExtras = src.mExtras != null ? new Bundle(src.mExtras) : null;
+        return this;
+    }
+
+    /**
+     * Completely replace the extras in the Intent with the given Bundle of
+     * extras.
+     *
+     * @param extras The new set of extras in the Intent, or null to erase
+     * all extras.
+     */
+    public Intent replaceExtras(Bundle extras) {
+        mExtras = extras != null ? new Bundle(extras) : null;
+        return this;
+    }
+
+    /**
+     * Remove extended data from the intent.
+     *
+     * @see #putExtra
+     */
+    public void removeExtra(String name) {
+        if (mExtras != null) {
+            mExtras.remove(name);
+            if (mExtras.size() == 0) {
+                mExtras = null;
+            }
+        }
+    }
+
+    /**
+     * Set special flags controlling how this intent is handled.  Most values
+     * here depend on the type of component being executed by the Intent,
+     * specifically the FLAG_ACTIVITY_* flags are all for use with
+     * {@link Context#startActivity Context.startActivity()} and the
+     * FLAG_RECEIVER_* flags are all for use with
+     * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
+     *
+     * <p>See the
+     * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
+     * Stack</a> documentation for important information on how some of these options impact
+     * the behavior of your application.
+     *
+     * @param flags The desired flags.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #getFlags
+     * @see #addFlags
+     *
+     * @see #FLAG_GRANT_READ_URI_PERMISSION
+     * @see #FLAG_GRANT_WRITE_URI_PERMISSION
+     * @see #FLAG_DEBUG_LOG_RESOLUTION
+     * @see #FLAG_FROM_BACKGROUND
+     * @see #FLAG_ACTIVITY_BROUGHT_TO_FRONT
+     * @see #FLAG_ACTIVITY_CLEAR_TASK
+     * @see #FLAG_ACTIVITY_CLEAR_TOP
+     * @see #FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET
+     * @see #FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
+     * @see #FLAG_ACTIVITY_FORWARD_RESULT
+     * @see #FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
+     * @see #FLAG_ACTIVITY_MULTIPLE_TASK
+     * @see #FLAG_ACTIVITY_NEW_TASK
+     * @see #FLAG_ACTIVITY_NO_ANIMATION
+     * @see #FLAG_ACTIVITY_NO_HISTORY
+     * @see #FLAG_ACTIVITY_NO_USER_ACTION
+     * @see #FLAG_ACTIVITY_PREVIOUS_IS_TOP
+     * @see #FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
+     * @see #FLAG_ACTIVITY_REORDER_TO_FRONT
+     * @see #FLAG_ACTIVITY_SINGLE_TOP
+     * @see #FLAG_ACTIVITY_TASK_ON_HOME
+     * @see #FLAG_RECEIVER_REGISTERED_ONLY
+     */
+    public Intent setFlags(int flags) {
+        mFlags = flags;
+        return this;
+    }
+
+    /**
+     * Add additional flags to the intent (or with existing flags
+     * value).
+     *
+     * @param flags The new flags to set.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #setFlags
+     */
+    public Intent addFlags(int flags) {
+        mFlags |= flags;
+        return this;
+    }
+
+    /**
+     * (Usually optional) Set an explicit application package name that limits
+     * the components this Intent will resolve to.  If left to the default
+     * value of null, all components in all applications will considered.
+     * If non-null, the Intent can only match the components in the given
+     * application package.
+     *
+     * @param packageName The name of the application package to handle the
+     * intent, or null to allow any application package.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #getPackage
+     * @see #resolveActivity
+     */
+    public Intent setPackage(String packageName) {
+        if (packageName != null && mSelector != null) {
+            throw new IllegalArgumentException(
+                    "Can't set package name when selector is already set");
+        }
+        mPackage = packageName;
+        return this;
+    }
+
+    /**
+     * (Usually optional) Explicitly set the component to handle the intent.
+     * If left with the default value of null, the system will determine the
+     * appropriate class to use based on the other fields (action, data,
+     * type, categories) in the Intent.  If this class is defined, the
+     * specified class will always be used regardless of the other fields.  You
+     * should only set this value when you know you absolutely want a specific
+     * class to be used; otherwise it is better to let the system find the
+     * appropriate class so that you will respect the installed applications
+     * and user preferences.
+     *
+     * @param component The name of the application component to handle the
+     * intent, or null to let the system find one for you.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #setClass
+     * @see #setClassName(Context, String)
+     * @see #setClassName(String, String)
+     * @see #getComponent
+     * @see #resolveActivity
+     */
+    public Intent setComponent(ComponentName component) {
+        mComponent = component;
+        return this;
+    }
+
+    /**
+     * Convenience for calling {@link #setComponent} with an
+     * explicit class name.
+     *
+     * @param packageContext A Context of the application package implementing
+     * this class.
+     * @param className The name of a class inside of the application package
+     * that will be used as the component for this Intent.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #setComponent
+     * @see #setClass
+     */
+    public Intent setClassName(Context packageContext, String className) {
+        mComponent = new ComponentName(packageContext, className);
+        return this;
+    }
+
+    /**
+     * Convenience for calling {@link #setComponent} with an
+     * explicit application package name and class name.
+     *
+     * @param packageName The name of the package implementing the desired
+     * component.
+     * @param className The name of a class inside of the application package
+     * that will be used as the component for this Intent.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #setComponent
+     * @see #setClass
+     */
+    public Intent setClassName(String packageName, String className) {
+        mComponent = new ComponentName(packageName, className);
+        return this;
+    }
+
+    /**
+     * Convenience for calling {@link #setComponent(ComponentName)} with the
+     * name returned by a {@link Class} object.
+     *
+     * @param packageContext A Context of the application package implementing
+     * this class.
+     * @param cls The class name to set, equivalent to
+     *            <code>setClassName(context, cls.getName())</code>.
+     *
+     * @return Returns the same Intent object, for chaining multiple calls
+     * into a single statement.
+     *
+     * @see #setComponent
+     */
+    public Intent setClass(Context packageContext, Class<?> cls) {
+        mComponent = new ComponentName(packageContext, cls);
+        return this;
+    }
+
+    /**
+     * Set the bounds of the sender of this intent, in screen coordinates.  This can be
+     * used as a hint to the receiver for animations and the like.  Null means that there
+     * is no source bounds.
+     */
+    public void setSourceBounds(Rect r) {
+        if (r != null) {
+            mSourceBounds = new Rect(r);
+        } else {
+            mSourceBounds = null;
+        }
+    }
+
+    /**
+     * Use with {@link #fillIn} to allow the current action value to be
+     * overwritten, even if it is already set.
+     */
+    public static final int FILL_IN_ACTION = 1<<0;
+
+    /**
+     * Use with {@link #fillIn} to allow the current data or type value
+     * overwritten, even if it is already set.
+     */
+    public static final int FILL_IN_DATA = 1<<1;
+
+    /**
+     * Use with {@link #fillIn} to allow the current categories to be
+     * overwritten, even if they are already set.
+     */
+    public static final int FILL_IN_CATEGORIES = 1<<2;
+
+    /**
+     * Use with {@link #fillIn} to allow the current component value to be
+     * overwritten, even if it is already set.
+     */
+    public static final int FILL_IN_COMPONENT = 1<<3;
+
+    /**
+     * Use with {@link #fillIn} to allow the current package value to be
+     * overwritten, even if it is already set.
+     */
+    public static final int FILL_IN_PACKAGE = 1<<4;
+
+    /**
+     * Use with {@link #fillIn} to allow the current bounds rectangle to be
+     * overwritten, even if it is already set.
+     */
+    public static final int FILL_IN_SOURCE_BOUNDS = 1<<5;
+
+    /**
+     * Use with {@link #fillIn} to allow the current selector to be
+     * overwritten, even if it is already set.
+     */
+    public static final int FILL_IN_SELECTOR = 1<<6;
+
+    /**
+     * Use with {@link #fillIn} to allow the current ClipData to be
+     * overwritten, even if it is already set.
+     */
+    public static final int FILL_IN_CLIP_DATA = 1<<7;
+
+    /**
+     * Copy the contents of <var>other</var> in to this object, but only
+     * where fields are not defined by this object.  For purposes of a field
+     * being defined, the following pieces of data in the Intent are
+     * considered to be separate fields:
+     *
+     * <ul>
+     * <li> action, as set by {@link #setAction}.
+     * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
+     * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
+     * <li> categories, as set by {@link #addCategory}.
+     * <li> package, as set by {@link #setPackage}.
+     * <li> component, as set by {@link #setComponent(ComponentName)} or
+     * related methods.
+     * <li> source bounds, as set by {@link #setSourceBounds}.
+     * <li> selector, as set by {@link #setSelector(Intent)}.
+     * <li> clip data, as set by {@link #setClipData(ClipData)}.
+     * <li> each top-level name in the associated extras.
+     * </ul>
+     *
+     * <p>In addition, you can use the {@link #FILL_IN_ACTION},
+     * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
+     * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
+     * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
+     * the restriction where the corresponding field will not be replaced if
+     * it is already set.
+     *
+     * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
+     * is explicitly specified.  The selector will only be copied if
+     * {@link #FILL_IN_SELECTOR} is explicitly specified.
+     *
+     * <p>For example, consider Intent A with {data="foo", categories="bar"}
+     * and Intent B with {action="gotit", data-type="some/thing",
+     * categories="one","two"}.
+     *
+     * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
+     * containing: {action="gotit", data-type="some/thing",
+     * categories="bar"}.
+     *
+     * @param other Another Intent whose values are to be used to fill in
+     * the current one.
+     * @param flags Options to control which fields can be filled in.
+     *
+     * @return Returns a bit mask of {@link #FILL_IN_ACTION},
+     * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
+     * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
+     * {@link #FILL_IN_SELECTOR} indicating which fields were changed.
+     */
+    public int fillIn(Intent other, int flags) {
+        int changes = 0;
+        if (other.mAction != null
+                && (mAction == null || (flags&FILL_IN_ACTION) != 0)) {
+            mAction = other.mAction;
+            changes |= FILL_IN_ACTION;
+        }
+        if ((other.mData != null || other.mType != null)
+                && ((mData == null && mType == null)
+                        || (flags&FILL_IN_DATA) != 0)) {
+            mData = other.mData;
+            mType = other.mType;
+            changes |= FILL_IN_DATA;
+        }
+        if (other.mCategories != null
+                && (mCategories == null || (flags&FILL_IN_CATEGORIES) != 0)) {
+            if (other.mCategories != null) {
+                mCategories = new HashSet<String>(other.mCategories);
+            }
+            changes |= FILL_IN_CATEGORIES;
+        }
+        if (other.mPackage != null
+                && (mPackage == null || (flags&FILL_IN_PACKAGE) != 0)) {
+            // Only do this if mSelector is not set.
+            if (mSelector == null) {
+                mPackage = other.mPackage;
+                changes |= FILL_IN_PACKAGE;
+            }
+        }
+        // Selector is special: it can only be set if explicitly allowed,
+        // for the same reason as the component name.
+        if (other.mSelector != null && (flags&FILL_IN_SELECTOR) != 0) {
+            if (mPackage == null) {
+                mSelector = new Intent(other.mSelector);
+                mPackage = null;
+                changes |= FILL_IN_SELECTOR;
+            }
+        }
+        if (other.mClipData != null
+                && (mClipData == null || (flags&FILL_IN_CLIP_DATA) != 0)) {
+            mClipData = other.mClipData;
+            changes |= FILL_IN_CLIP_DATA;
+        }
+        // Component is special: it can -only- be set if explicitly allowed,
+        // since otherwise the sender could force the intent somewhere the
+        // originator didn't intend.
+        if (other.mComponent != null && (flags&FILL_IN_COMPONENT) != 0) {
+            mComponent = other.mComponent;
+            changes |= FILL_IN_COMPONENT;
+        }
+        mFlags |= other.mFlags;
+        if (other.mSourceBounds != null
+                && (mSourceBounds == null || (flags&FILL_IN_SOURCE_BOUNDS) != 0)) {
+            mSourceBounds = new Rect(other.mSourceBounds);
+            changes |= FILL_IN_SOURCE_BOUNDS;
+        }
+        if (mExtras == null) {
+            if (other.mExtras != null) {
+                mExtras = new Bundle(other.mExtras);
+            }
+        } else if (other.mExtras != null) {
+            try {
+                Bundle newb = new Bundle(other.mExtras);
+                newb.putAll(mExtras);
+                mExtras = newb;
+            } catch (RuntimeException e) {
+                // Modifying the extras can cause us to unparcel the contents
+                // of the bundle, and if we do this in the system process that
+                // may fail.  We really should handle this (i.e., the Bundle
+                // impl shouldn't be on top of a plain map), but for now just
+                // ignore it and keep the original contents. :(
+                Log.w("Intent", "Failure filling in extras", e);
+            }
+        }
+        return changes;
+    }
+
+    /**
+     * Wrapper class holding an Intent and implementing comparisons on it for
+     * the purpose of filtering.  The class implements its
+     * {@link #equals equals()} and {@link #hashCode hashCode()} methods as
+     * simple calls to {@link Intent#filterEquals(Intent)}  filterEquals()} and
+     * {@link android.content.Intent#filterHashCode()}  filterHashCode()}
+     * on the wrapped Intent.
+     */
+    public static final class FilterComparison {
+        private final Intent mIntent;
+        private final int mHashCode;
+
+        public FilterComparison(Intent intent) {
+            mIntent = intent;
+            mHashCode = intent.filterHashCode();
+        }
+
+        /**
+         * Return the Intent that this FilterComparison represents.
+         * @return Returns the Intent held by the FilterComparison.  Do
+         * not modify!
+         */
+        public Intent getIntent() {
+            return mIntent;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj instanceof FilterComparison) {
+                Intent other = ((FilterComparison)obj).mIntent;
+                return mIntent.filterEquals(other);
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            return mHashCode;
+        }
+    }
+
+    /**
+     * Determine if two intents are the same for the purposes of intent
+     * resolution (filtering). That is, if their action, data, type,
+     * class, and categories are the same.  This does <em>not</em> compare
+     * any extra data included in the intents.
+     *
+     * @param other The other Intent to compare against.
+     *
+     * @return Returns true if action, data, type, class, and categories
+     *         are the same.
+     */
+    public boolean filterEquals(Intent other) {
+        if (other == null) {
+            return false;
+        }
+        if (mAction != other.mAction) {
+            if (mAction != null) {
+                if (!mAction.equals(other.mAction)) {
+                    return false;
+                }
+            } else {
+                if (!other.mAction.equals(mAction)) {
+                    return false;
+                }
+            }
+        }
+        if (mData != other.mData) {
+            if (mData != null) {
+                if (!mData.equals(other.mData)) {
+                    return false;
+                }
+            } else {
+                if (!other.mData.equals(mData)) {
+                    return false;
+                }
+            }
+        }
+        if (mType != other.mType) {
+            if (mType != null) {
+                if (!mType.equals(other.mType)) {
+                    return false;
+                }
+            } else {
+                if (!other.mType.equals(mType)) {
+                    return false;
+                }
+            }
+        }
+        if (mPackage != other.mPackage) {
+            if (mPackage != null) {
+                if (!mPackage.equals(other.mPackage)) {
+                    return false;
+                }
+            } else {
+                if (!other.mPackage.equals(mPackage)) {
+                    return false;
+                }
+            }
+        }
+        if (mComponent != other.mComponent) {
+            if (mComponent != null) {
+                if (!mComponent.equals(other.mComponent)) {
+                    return false;
+                }
+            } else {
+                if (!other.mComponent.equals(mComponent)) {
+                    return false;
+                }
+            }
+        }
+        if (mCategories != other.mCategories) {
+            if (mCategories != null) {
+                if (!mCategories.equals(other.mCategories)) {
+                    return false;
+                }
+            } else {
+                if (!other.mCategories.equals(mCategories)) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Generate hash code that matches semantics of filterEquals().
+     *
+     * @return Returns the hash value of the action, data, type, class, and
+     *         categories.
+     *
+     * @see #filterEquals
+     */
+    public int filterHashCode() {
+        int code = 0;
+        if (mAction != null) {
+            code += mAction.hashCode();
+        }
+        if (mData != null) {
+            code += mData.hashCode();
+        }
+        if (mType != null) {
+            code += mType.hashCode();
+        }
+        if (mPackage != null) {
+            code += mPackage.hashCode();
+        }
+        if (mComponent != null) {
+            code += mComponent.hashCode();
+        }
+        if (mCategories != null) {
+            code += mCategories.hashCode();
+        }
+        return code;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder b = new StringBuilder(128);
+
+        b.append("Intent { ");
+        toShortString(b, true, true, true, false);
+        b.append(" }");
+
+        return b.toString();
+    }
+
+    /** @hide */
+    public String toInsecureString() {
+        StringBuilder b = new StringBuilder(128);
+
+        b.append("Intent { ");
+        toShortString(b, false, true, true, false);
+        b.append(" }");
+
+        return b.toString();
+    }
+
+    /** @hide */
+    public String toInsecureStringWithClip() {
+        StringBuilder b = new StringBuilder(128);
+
+        b.append("Intent { ");
+        toShortString(b, false, true, true, true);
+        b.append(" }");
+
+        return b.toString();
+    }
+
+    /** @hide */
+    public String toShortString(boolean secure, boolean comp, boolean extras, boolean clip) {
+        StringBuilder b = new StringBuilder(128);
+        toShortString(b, secure, comp, extras, clip);
+        return b.toString();
+    }
+
+    /** @hide */
+    public void toShortString(StringBuilder b, boolean secure, boolean comp, boolean extras,
+            boolean clip) {
+        boolean first = true;
+        if (mAction != null) {
+            b.append("act=").append(mAction);
+            first = false;
+        }
+        if (mCategories != null) {
+            if (!first) {
+                b.append(' ');
+            }
+            first = false;
+            b.append("cat=[");
+            Iterator<String> i = mCategories.iterator();
+            boolean didone = false;
+            while (i.hasNext()) {
+                if (didone) b.append(",");
+                didone = true;
+                b.append(i.next());
+            }
+            b.append("]");
+        }
+        if (mData != null) {
+            if (!first) {
+                b.append(' ');
+            }
+            first = false;
+            b.append("dat=");
+            if (secure) {
+                b.append(mData.toSafeString());
+            } else {
+                b.append(mData);
+            }
+        }
+        if (mType != null) {
+            if (!first) {
+                b.append(' ');
+            }
+            first = false;
+            b.append("typ=").append(mType);
+        }
+        if (mFlags != 0) {
+            if (!first) {
+                b.append(' ');
+            }
+            first = false;
+            b.append("flg=0x").append(Integer.toHexString(mFlags));
+        }
+        if (mPackage != null) {
+            if (!first) {
+                b.append(' ');
+            }
+            first = false;
+            b.append("pkg=").append(mPackage);
+        }
+        if (comp && mComponent != null) {
+            if (!first) {
+                b.append(' ');
+            }
+            first = false;
+            b.append("cmp=").append(mComponent.flattenToShortString());
+        }
+        if (mSourceBounds != null) {
+            if (!first) {
+                b.append(' ');
+            }
+            first = false;
+            b.append("bnds=").append(mSourceBounds.toShortString());
+        }
+        if (mClipData != null) {
+            if (!first) {
+                b.append(' ');
+            }
+            first = false;
+            if (clip) {
+                b.append("clip={");
+                mClipData.toShortString(b);
+                b.append('}');
+            } else {
+                b.append("(has clip)");
+            }
+        }
+        if (extras && mExtras != null) {
+            if (!first) {
+                b.append(' ');
+            }
+            first = false;
+            b.append("(has extras)");
+        }
+        if (mSelector != null) {
+            b.append(" sel={");
+            mSelector.toShortString(b, secure, comp, extras, clip);
+            b.append("}");
+        }
+    }
+
+    /**
+     * Call {@link #toUri} with 0 flags.
+     * @deprecated Use {@link #toUri} instead.
+     */
+    @Deprecated
+    public String toURI() {
+        return toUri(0);
+    }
+
+    /**
+     * Convert this Intent into a String holding a URI representation of it.
+     * The returned URI string has been properly URI encoded, so it can be
+     * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
+     * Intent's data as the base URI, with an additional fragment describing
+     * the action, categories, type, flags, package, component, and extras.
+     *
+     * <p>You can convert the returned string back to an Intent with
+     * {@link #getIntent}.
+     *
+     * @param flags Additional operating flags.  Either 0 or
+     * {@link #URI_INTENT_SCHEME}.
+     *
+     * @return Returns a URI encoding URI string describing the entire contents
+     * of the Intent.
+     */
+    public String toUri(int flags) {
+        StringBuilder uri = new StringBuilder(128);
+        String scheme = null;
+        if (mData != null) {
+            String data = mData.toString();
+            if ((flags&URI_INTENT_SCHEME) != 0) {
+                final int N = data.length();
+                for (int i=0; i<N; i++) {
+                    char c = data.charAt(i);
+                    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
+                            || c == '.' || c == '-') {
+                        continue;
+                    }
+                    if (c == ':' && i > 0) {
+                        // Valid scheme.
+                        scheme = data.substring(0, i);
+                        uri.append("intent:");
+                        data = data.substring(i+1);
+                        break;
+                    }
+
+                    // No scheme.
+                    break;
+                }
+            }
+            uri.append(data);
+
+        } else if ((flags&URI_INTENT_SCHEME) != 0) {
+            uri.append("intent:");
+        }
+
+        uri.append("#Intent;");
+
+        toUriInner(uri, scheme, flags);
+        if (mSelector != null) {
+            uri.append("SEL;");
+            // Note that for now we are not going to try to handle the
+            // data part; not clear how to represent this as a URI, and
+            // not much utility in it.
+            mSelector.toUriInner(uri, null, flags);
+        }
+
+        uri.append("end");
+
+        return uri.toString();
+    }
+
+    private void toUriInner(StringBuilder uri, String scheme, int flags) {
+        if (scheme != null) {
+            uri.append("scheme=").append(scheme).append(';');
+        }
+        if (mAction != null) {
+            uri.append("action=").append(Uri.encode(mAction)).append(';');
+        }
+        if (mCategories != null) {
+            for (String category : mCategories) {
+                uri.append("category=").append(Uri.encode(category)).append(';');
+            }
+        }
+        if (mType != null) {
+            uri.append("type=").append(Uri.encode(mType, "/")).append(';');
+        }
+        if (mFlags != 0) {
+            uri.append("launchFlags=0x").append(Integer.toHexString(mFlags)).append(';');
+        }
+        if (mPackage != null) {
+            uri.append("package=").append(Uri.encode(mPackage)).append(';');
+        }
+        if (mComponent != null) {
+            uri.append("component=").append(Uri.encode(
+                    mComponent.flattenToShortString(), "/")).append(';');
+        }
+        if (mSourceBounds != null) {
+            uri.append("sourceBounds=")
+                    .append(Uri.encode(mSourceBounds.flattenToString()))
+                    .append(';');
+        }
+        if (mExtras != null) {
+            for (String key : mExtras.keySet()) {
+                final Object value = mExtras.get(key);
+                char entryType =
+                        value instanceof String    ? 'S' :
+                        value instanceof Boolean   ? 'B' :
+                        value instanceof Byte      ? 'b' :
+                        value instanceof Character ? 'c' :
+                        value instanceof Double    ? 'd' :
+                        value instanceof Float     ? 'f' :
+                        value instanceof Integer   ? 'i' :
+                        value instanceof Long      ? 'l' :
+                        value instanceof Short     ? 's' :
+                        '\0';
+
+                if (entryType != '\0') {
+                    uri.append(entryType);
+                    uri.append('.');
+                    uri.append(Uri.encode(key));
+                    uri.append('=');
+                    uri.append(Uri.encode(value.toString()));
+                    uri.append(';');
+                }
+            }
+        }
+    }
+
+    public int describeContents() {
+        return (mExtras != null) ? mExtras.describeContents() : 0;
+    }
+
+    public void writeToParcel(Parcel out, int flags) {
+        out.writeString(mAction);
+        Uri.writeToParcel(out, mData);
+        out.writeString(mType);
+        out.writeInt(mFlags);
+        out.writeString(mPackage);
+        ComponentName.writeToParcel(mComponent, out);
+
+        if (mSourceBounds != null) {
+            out.writeInt(1);
+            mSourceBounds.writeToParcel(out, flags);
+        } else {
+            out.writeInt(0);
+        }
+
+        if (mCategories != null) {
+            out.writeInt(mCategories.size());
+            for (String category : mCategories) {
+                out.writeString(category);
+            }
+        } else {
+            out.writeInt(0);
+        }
+
+        if (mSelector != null) {
+            out.writeInt(1);
+            mSelector.writeToParcel(out, flags);
+        } else {
+            out.writeInt(0);
+        }
+
+        if (mClipData != null) {
+            out.writeInt(1);
+            mClipData.writeToParcel(out, flags);
+        } else {
+            out.writeInt(0);
+        }
+
+        out.writeBundle(mExtras);
+    }
+
+    public static final Parcelable.Creator<Intent> CREATOR
+            = new Parcelable.Creator<Intent>() {
+        public Intent createFromParcel(Parcel in) {
+            return new Intent(in);
+        }
+        public Intent[] newArray(int size) {
+            return new Intent[size];
+        }
+    };
+
+    /** @hide */
+    protected Intent(Parcel in) {
+        readFromParcel(in);
+    }
+
+    public void readFromParcel(Parcel in) {
+        setAction(in.readString());
+        mData = Uri.CREATOR.createFromParcel(in);
+        mType = in.readString();
+        mFlags = in.readInt();
+        mPackage = in.readString();
+        mComponent = ComponentName.readFromParcel(in);
+
+        if (in.readInt() != 0) {
+            mSourceBounds = Rect.CREATOR.createFromParcel(in);
+        }
+
+        int N = in.readInt();
+        if (N > 0) {
+            mCategories = new HashSet<String>();
+            int i;
+            for (i=0; i<N; i++) {
+                mCategories.add(in.readString().intern());
+            }
+        } else {
+            mCategories = null;
+        }
+
+        if (in.readInt() != 0) {
+            mSelector = new Intent(in);
+        }
+
+        if (in.readInt() != 0) {
+            mClipData = new ClipData(in);
+        }
+
+        mExtras = in.readBundle();
+    }
+
+    /**
+     * Parses the "intent" element (and its children) from XML and instantiates
+     * an Intent object.  The given XML parser should be located at the tag
+     * where parsing should start (often named "intent"), from which the
+     * basic action, data, type, and package and class name will be
+     * retrieved.  The function will then parse in to any child elements,
+     * looking for <category android:name="xxx"> tags to add categories and
+     * <extra android:name="xxx" android:value="yyy"> to attach extra data
+     * to the intent.
+     *
+     * @param resources The Resources to use when inflating resources.
+     * @param parser The XML parser pointing at an "intent" tag.
+     * @param attrs The AttributeSet interface for retrieving extended
+     * attribute data at the current <var>parser</var> location.
+     * @return An Intent object matching the XML data.
+     * @throws XmlPullParserException If there was an XML parsing error.
+     * @throws IOException If there was an I/O error.
+     */
+    public static Intent parseIntent(Resources resources, XmlPullParser parser, AttributeSet attrs)
+            throws XmlPullParserException, IOException {
+        Intent intent = new Intent();
+
+        TypedArray sa = resources.obtainAttributes(attrs,
+                com.android.internal.R.styleable.Intent);
+
+        intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
+
+        String data = sa.getString(com.android.internal.R.styleable.Intent_data);
+        String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
+        intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
+
+        String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
+        String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
+        if (packageName != null && className != null) {
+            intent.setComponent(new ComponentName(packageName, className));
+        }
+
+        sa.recycle();
+
+        int outerDepth = parser.getDepth();
+        int type;
+        while ((type=parser.next()) != XmlPullParser.END_DOCUMENT
+               && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
+            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
+                continue;
+            }
+
+            String nodeName = parser.getName();
+            if (nodeName.equals("category")) {
+                sa = resources.obtainAttributes(attrs,
+                        com.android.internal.R.styleable.IntentCategory);
+                String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
+                sa.recycle();
+
+                if (cat != null) {
+                    intent.addCategory(cat);
+                }
+                XmlUtils.skipCurrentTag(parser);
+
+            } else if (nodeName.equals("extra")) {
+                if (intent.mExtras == null) {
+                    intent.mExtras = new Bundle();
+                }
+                resources.parseBundleExtra("extra", attrs, intent.mExtras);
+                XmlUtils.skipCurrentTag(parser);
+
+            } else {
+                XmlUtils.skipCurrentTag(parser);
+            }
+        }
+
+        return intent;
+    }
+
+    /**
+     * Normalize a MIME data type.
+     *
+     * <p>A normalized MIME type has white-space trimmed,
+     * content-type parameters removed, and is lower-case.
+     * This aligns the type with Android best practices for
+     * intent filtering.
+     *
+     * <p>For example, "text/plain; charset=utf-8" becomes "text/plain".
+     * "text/x-vCard" becomes "text/x-vcard".
+     *
+     * <p>All MIME types received from outside Android (such as user input,
+     * or external sources like Bluetooth, NFC, or the Internet) should
+     * be normalized before they are used to create an Intent.
+     *
+     * @param type MIME data type to normalize
+     * @return normalized MIME data type, or null if the input was null
+     * @see {@link #setType}
+     * @see {@link #setTypeAndNormalize}
+     */
+    public static String normalizeMimeType(String type) {
+        if (type == null) {
+            return null;
+        }
+
+        type = type.trim().toLowerCase(Locale.US);
+
+        final int semicolonIndex = type.indexOf(';');
+        if (semicolonIndex != -1) {
+            type = type.substring(0, semicolonIndex);
+        }
+        return type;
+    }
+
+    /**
+     * Migrate any {@link #EXTRA_STREAM} in {@link #ACTION_SEND} and
+     * {@link #ACTION_SEND_MULTIPLE} to {@link ClipData}. Also inspects nested
+     * intents in {@link #ACTION_CHOOSER}.
+     *
+     * @return Whether any contents were migrated.
+     * @hide
+     */
+    public boolean migrateExtraStreamToClipData() {
+        // Refuse to touch if extras already parcelled
+        if (mExtras != null && mExtras.isParcelled()) return false;
+
+        // Bail when someone already gave us ClipData
+        if (getClipData() != null) return false;
+
+        final String action = getAction();
+        if (ACTION_CHOOSER.equals(action)) {
+            try {
+                // Inspect target intent to see if we need to migrate
+                final Intent target = getParcelableExtra(EXTRA_INTENT);
+                if (target != null && target.migrateExtraStreamToClipData()) {
+                    // Since we migrated in child, we need to promote ClipData
+                    // and flags to ourselves to grant.
+                    setClipData(target.getClipData());
+                    addFlags(target.getFlags()
+                            & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION));
+                    return true;
+                } else {
+                    return false;
+                }
+            } catch (ClassCastException e) {
+            }
+
+        } else if (ACTION_SEND.equals(action)) {
+            try {
+                final Uri stream = getParcelableExtra(EXTRA_STREAM);
+                final CharSequence text = getCharSequenceExtra(EXTRA_TEXT);
+                final String htmlText = getStringExtra(EXTRA_HTML_TEXT);
+                if (stream != null || text != null || htmlText != null) {
+                    final ClipData clipData = new ClipData(
+                            null, new String[] { getType() },
+                            new ClipData.Item(text, htmlText, null, stream));
+                    setClipData(clipData);
+                    addFlags(FLAG_GRANT_READ_URI_PERMISSION);
+                    return true;
+                }
+            } catch (ClassCastException e) {
+            }
+
+        } else if (ACTION_SEND_MULTIPLE.equals(action)) {
+            try {
+                final ArrayList<Uri> streams = getParcelableArrayListExtra(EXTRA_STREAM);
+                final ArrayList<CharSequence> texts = getCharSequenceArrayListExtra(EXTRA_TEXT);
+                final ArrayList<String> htmlTexts = getStringArrayListExtra(EXTRA_HTML_TEXT);
+                int num = -1;
+                if (streams != null) {
+                    num = streams.size();
+                }
+                if (texts != null) {
+                    if (num >= 0 && num != texts.size()) {
+                        // Wha...!  F- you.
+                        return false;
+                    }
+                    num = texts.size();
+                }
+                if (htmlTexts != null) {
+                    if (num >= 0 && num != htmlTexts.size()) {
+                        // Wha...!  F- you.
+                        return false;
+                    }
+                    num = htmlTexts.size();
+                }
+                if (num > 0) {
+                    final ClipData clipData = new ClipData(
+                            null, new String[] { getType() },
+                            makeClipItem(streams, texts, htmlTexts, 0));
+
+                    for (int i = 1; i < num; i++) {
+                        clipData.addItem(makeClipItem(streams, texts, htmlTexts, i));
+                    }
+
+                    setClipData(clipData);
+                    addFlags(FLAG_GRANT_READ_URI_PERMISSION);
+                    return true;
+                }
+            } catch (ClassCastException e) {
+            }
+        }
+
+        return false;
+    }
+
+    private static ClipData.Item makeClipItem(ArrayList<Uri> streams, ArrayList<CharSequence> texts,
+            ArrayList<String> htmlTexts, int which) {
+        Uri uri = streams != null ? streams.get(which) : null;
+        CharSequence text = texts != null ? texts.get(which) : null;
+        String htmlText = htmlTexts != null ? htmlTexts.get(which) : null;
+        return new ClipData.Item(text, htmlText, null, uri);
+    }
+}
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index d65892e..e6b58ee 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -1,7520 +1,7536 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- * Copyright (C) 2012 ParanoidAndroid Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.provider;
-
-import android.annotation.SdkConstant;
-import android.annotation.SdkConstant.SdkConstantType;
-import android.app.ActivityManagerNative;
-import android.app.SearchManager;
-import android.app.WallpaperManager;
-import android.content.ComponentName;
-import android.content.ContentResolver;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.IContentProvider;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.database.Cursor;
-import android.database.SQLException;
-import android.net.ConnectivityManager;
-import android.net.Uri;
-import android.net.wifi.WifiManager;
-import android.os.BatteryManager;
-import android.os.Binder;
-import android.os.Bundle;
-import android.os.DropBoxManager;
-import android.os.IBinder;
-import android.os.Process;
-import android.os.RemoteException;
-import android.os.ServiceManager;
-import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.os.Build.VERSION_CODES;
-import android.speech.tts.TextToSpeech;
-import android.text.TextUtils;
-import android.util.AndroidException;
-import android.util.Log;
-import android.view.WindowOrientationListener;
-
-import com.android.internal.widget.ILockSettings;
-
-import java.net.URISyntaxException;
-import java.util.HashMap;
-import java.util.HashSet;
-
-/**
- * The Settings provider contains global system-level device preferences.
- */
-public final class Settings {
-
-    // Intent actions for Settings
-
-    /**
-     * Activity Action: Show system settings.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SETTINGS = "android.settings.SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of APNs.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_APN_SETTINGS = "android.settings.APN_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of current location
-     * sources.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_LOCATION_SOURCE_SETTINGS =
-            "android.settings.LOCATION_SOURCE_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of wireless controls
-     * such as Wi-Fi, Bluetooth and Mobile networks.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_WIRELESS_SETTINGS =
-            "android.settings.WIRELESS_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow entering/exiting airplane mode.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_AIRPLANE_MODE_SETTINGS =
-            "android.settings.AIRPLANE_MODE_SETTINGS";
-
-    /**
-     * Activity Action: Show settings for accessibility modules.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_ACCESSIBILITY_SETTINGS =
-            "android.settings.ACCESSIBILITY_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of security and
-     * location privacy.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SECURITY_SETTINGS =
-            "android.settings.SECURITY_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of privacy options.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_PRIVACY_SETTINGS =
-            "android.settings.PRIVACY_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of Wi-Fi.
-
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_WIFI_SETTINGS =
-            "android.settings.WIFI_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of a static IP
-     * address for Wi-Fi.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you safeguard
-     * against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_WIFI_IP_SETTINGS =
-            "android.settings.WIFI_IP_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of Bluetooth.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_BLUETOOTH_SETTINGS =
-            "android.settings.BLUETOOTH_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of Wifi Displays.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_WIFI_DISPLAY_SETTINGS =
-            "android.settings.WIFI_DISPLAY_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of date and time.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_DATE_SETTINGS =
-            "android.settings.DATE_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of sound and volume.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SOUND_SETTINGS =
-            "android.settings.SOUND_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of display.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_DISPLAY_SETTINGS =
-            "android.settings.DISPLAY_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of locale.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_LOCALE_SETTINGS =
-            "android.settings.LOCALE_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to configure input methods, in particular
-     * allowing the user to enable input methods.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_INPUT_METHOD_SETTINGS =
-            "android.settings.INPUT_METHOD_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to enable/disable input method subtypes.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * To tell which input method's subtypes are displayed in the settings, add
-     * {@link #EXTRA_INPUT_METHOD_ID} extra to this Intent with the input method id.
-     * If there is no extra in this Intent, subtypes from all installed input methods
-     * will be displayed in the settings.
-     *
-     * @see android.view.inputmethod.InputMethodInfo#getId
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_INPUT_METHOD_SUBTYPE_SETTINGS =
-            "android.settings.INPUT_METHOD_SUBTYPE_SETTINGS";
-
-    /**
-     * Activity Action: Show a dialog to select input method.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SHOW_INPUT_METHOD_PICKER =
-            "android.settings.SHOW_INPUT_METHOD_PICKER";
-
-    /**
-     * Activity Action: Show settings to manage the user input dictionary.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_USER_DICTIONARY_SETTINGS =
-            "android.settings.USER_DICTIONARY_SETTINGS";
-
-    /**
-     * Activity Action: Adds a word to the user dictionary.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: An extra with key <code>word</code> that contains the word
-     * that should be added to the dictionary.
-     * <p>
-     * Output: Nothing.
-     *
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_USER_DICTIONARY_INSERT =
-            "com.android.settings.USER_DICTIONARY_INSERT";
-
-    /**
-     * Activity Action: Show settings to allow configuration of application-related settings.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_APPLICATION_SETTINGS =
-            "android.settings.APPLICATION_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of application
-     * development-related settings.  As of
-     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} this action is
-     * a required part of the platform.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_APPLICATION_DEVELOPMENT_SETTINGS =
-            "android.settings.APPLICATION_DEVELOPMENT_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of quick launch shortcuts.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_QUICK_LAUNCH_SETTINGS =
-            "android.settings.QUICK_LAUNCH_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to manage installed applications.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_MANAGE_APPLICATIONS_SETTINGS =
-            "android.settings.MANAGE_APPLICATIONS_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to manage all applications.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_MANAGE_ALL_APPLICATIONS_SETTINGS =
-            "android.settings.MANAGE_ALL_APPLICATIONS_SETTINGS";
-
-    /**
-     * Activity Action: Show screen of details about a particular application.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: The Intent's data URI specifies the application package name
-     * to be shown, with the "package" scheme.  That is "package:com.my.app".
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_APPLICATION_DETAILS_SETTINGS =
-            "android.settings.APPLICATION_DETAILS_SETTINGS";
-
-    /**
-     * Activity Action: Show settings for system update functionality.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     *
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SYSTEM_UPDATE_SETTINGS =
-            "android.settings.SYSTEM_UPDATE_SETTINGS";
-
-    /**
-     * Activity Action: Show settings to allow configuration of sync settings.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * The account types available to add via the add account button may be restricted by adding an
-     * {@link #EXTRA_AUTHORITIES} extra to this Intent with one or more syncable content provider's
-     * authorities. Only account types which can sync with that content provider will be offered to
-     * the user.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SYNC_SETTINGS =
-            "android.settings.SYNC_SETTINGS";
-
-    /**
-     * Activity Action: Show add account screen for creating a new account.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * The account types available to add may be restricted by adding an {@link #EXTRA_AUTHORITIES}
-     * extra to the Intent with one or more syncable content provider's authorities.  Only account
-     * types which can sync with that content provider will be offered to the user.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_ADD_ACCOUNT =
-            "android.settings.ADD_ACCOUNT_SETTINGS";
-
-    /**
-     * Activity Action: Show settings for selecting the network operator.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_NETWORK_OPERATOR_SETTINGS =
-            "android.settings.NETWORK_OPERATOR_SETTINGS";
-
-    /**
-     * Activity Action: Show settings for selection of 2G/3G.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_DATA_ROAMING_SETTINGS =
-            "android.settings.DATA_ROAMING_SETTINGS";
-
-    /**
-     * Activity Action: Show settings for internal storage.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_INTERNAL_STORAGE_SETTINGS =
-            "android.settings.INTERNAL_STORAGE_SETTINGS";
-    /**
-     * Activity Action: Show settings for memory card storage.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_MEMORY_CARD_SETTINGS =
-            "android.settings.MEMORY_CARD_SETTINGS";
-
-    /**
-     * Activity Action: Show settings for global search.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_SEARCH_SETTINGS =
-        "android.search.action.SEARCH_SETTINGS";
-
-    /**
-     * Activity Action: Show general device information settings (serial
-     * number, software version, phone number, etc.).
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_DEVICE_INFO_SETTINGS =
-        "android.settings.DEVICE_INFO_SETTINGS";
-
-    /**
-     * Activity Action: Show NFC settings.
-     * <p>
-     * This shows UI that allows NFC to be turned on or off.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing
-     * @see android.nfc.NfcAdapter#isEnabled()
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_NFC_SETTINGS = "android.settings.NFC_SETTINGS";
-
-    /**
-     * Activity Action: Show NFC Sharing settings.
-     * <p>
-     * This shows UI that allows NDEF Push (Android Beam) to be turned on or
-     * off.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing
-     * @see android.nfc.NfcAdapter#isNdefPushEnabled()
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_NFCSHARING_SETTINGS =
-        "android.settings.NFCSHARING_SETTINGS";
-
-    /**
-     * Activity Action: Show Daydream settings.
-     * <p>
-     * In some cases, a matching Activity may not exist, so ensure you
-     * safeguard against this.
-     * <p>
-     * Input: Nothing.
-     * <p>
-     * Output: Nothing.
-     * @see android.service.dreams.DreamService
-     * @hide
-     */
-    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-    public static final String ACTION_DREAM_SETTINGS = "android.settings.DREAM_SETTINGS";
-
-    // End of Intent actions for Settings
-
-    /**
-     * @hide - Private call() method on SettingsProvider to read from 'system' table.
-     */
-    public static final String CALL_METHOD_GET_SYSTEM = "GET_system";
-
-    /**
-     * @hide - Private call() method on SettingsProvider to read from 'secure' table.
-     */
-    public static final String CALL_METHOD_GET_SECURE = "GET_secure";
-
-    /**
-     * @hide - Private call() method on SettingsProvider to read from 'global' table.
-     */
-    public static final String CALL_METHOD_GET_GLOBAL = "GET_global";
-
-    /**
-     * @hide - User handle argument extra to the fast-path call()-based requests
-     */
-    public static final String CALL_METHOD_USER_KEY = "_user";
-
-    /** @hide - Private call() method to write to 'system' table */
-    public static final String CALL_METHOD_PUT_SYSTEM = "PUT_system";
-
-    /** @hide - Private call() method to write to 'secure' table */
-    public static final String CALL_METHOD_PUT_SECURE = "PUT_secure";
-
-    /** @hide - Private call() method to write to 'global' table */
-    public static final String CALL_METHOD_PUT_GLOBAL= "PUT_global";
-
-    /**
-     * Activity Extra: Limit available options in launched activity based on the given authority.
-     * <p>
-     * This can be passed as an extra field in an Activity Intent with one or more syncable content
-     * provider's authorities as a String[]. This field is used by some intents to alter the
-     * behavior of the called activity.
-     * <p>
-     * Example: The {@link #ACTION_ADD_ACCOUNT} intent restricts the account types available based
-     * on the authority given.
-     */
-    public static final String EXTRA_AUTHORITIES =
-            "authorities";
-
-    public static final String EXTRA_INPUT_METHOD_ID = "input_method_id";
-
-    private static final String JID_RESOURCE_PREFIX = "android";
-
-    public static final String AUTHORITY = "settings";
-
-    private static final String TAG = "Settings";
-    private static final boolean LOCAL_LOGV = false;
-
-    public static class SettingNotFoundException extends AndroidException {
-        public SettingNotFoundException(String msg) {
-            super(msg);
-        }
-    }
-
-    /**
-     * Common base for tables of name/value settings.
-     */
-    public static class NameValueTable implements BaseColumns {
-        public static final String NAME = "name";
-        public static final String VALUE = "value";
-
-        protected static boolean putString(ContentResolver resolver, Uri uri,
-                String name, String value) {
-            // The database will take care of replacing duplicates.
-            try {
-                ContentValues values = new ContentValues();
-                values.put(NAME, name);
-                values.put(VALUE, value);
-                resolver.insert(uri, values);
-                return true;
-            } catch (SQLException e) {
-                Log.w(TAG, "Can't set key " + name + " in " + uri, e);
-                return false;
-            }
-        }
-
-        public static Uri getUriFor(Uri uri, String name) {
-            return Uri.withAppendedPath(uri, name);
-        }
-    }
-
-    // Thread-safe.
-    private static class NameValueCache {
-        private final String mVersionSystemProperty;
-        private final Uri mUri;
-
-        private static final String[] SELECT_VALUE =
-            new String[] { Settings.NameValueTable.VALUE };
-        private static final String NAME_EQ_PLACEHOLDER = "name=?";
-
-        // Must synchronize on 'this' to access mValues and mValuesVersion.
-        private final HashMap<String, String> mValues = new HashMap<String, String>();
-        private long mValuesVersion = 0;
-
-        // Initially null; set lazily and held forever.  Synchronized on 'this'.
-        private IContentProvider mContentProvider = null;
-
-        // The method we'll call (or null, to not use) on the provider
-        // for the fast path of retrieving settings.
-        private final String mCallGetCommand;
-        private final String mCallSetCommand;
-
-        public NameValueCache(String versionSystemProperty, Uri uri,
-                String getCommand, String setCommand) {
-            mVersionSystemProperty = versionSystemProperty;
-            mUri = uri;
-            mCallGetCommand = getCommand;
-            mCallSetCommand = setCommand;
-        }
-
-        private IContentProvider lazyGetProvider(ContentResolver cr) {
-            IContentProvider cp = null;
-            synchronized (this) {
-                cp = mContentProvider;
-                if (cp == null) {
-                    cp = mContentProvider = cr.acquireProvider(mUri.getAuthority());
-                }
-            }
-            return cp;
-        }
-
-        public boolean putStringForUser(ContentResolver cr, String name, String value,
-                final int userHandle) {
-            try {
-                Bundle arg = new Bundle();
-                arg.putString(Settings.NameValueTable.VALUE, value);
-                arg.putInt(CALL_METHOD_USER_KEY, userHandle);
-                IContentProvider cp = lazyGetProvider(cr);
-                cp.call(mCallSetCommand, name, arg);
-            } catch (RemoteException e) {
-                Log.w(TAG, "Can't set key " + name + " in " + mUri, e);
-                return false;
-            }
-            return true;
-        }
-
-        public String getStringForUser(ContentResolver cr, String name, final int userHandle) {
-            final boolean isSelf = (userHandle == UserHandle.myUserId());
-            if (isSelf) {
-                long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
-
-                // Our own user's settings data uses a client-side cache
-                synchronized (this) {
-                    if (mValuesVersion != newValuesVersion) {
-                        if (LOCAL_LOGV || false) {
-                            Log.v(TAG, "invalidate [" + mUri.getLastPathSegment() + "]: current "
-                                    + newValuesVersion + " != cached " + mValuesVersion);
-                        }
-
-                        mValues.clear();
-                        mValuesVersion = newValuesVersion;
-                    }
-
-                    if (mValues.containsKey(name)) {
-                        return mValues.get(name);  // Could be null, that's OK -- negative caching
-                    }
-                }
-            } else {
-                if (LOCAL_LOGV) Log.v(TAG, "get setting for user " + userHandle
-                        + " by user " + UserHandle.myUserId() + " so skipping cache");
-            }
-
-            IContentProvider cp = lazyGetProvider(cr);
-
-            // Try the fast path first, not using query().  If this
-            // fails (alternate Settings provider that doesn't support
-            // this interface?) then we fall back to the query/table
-            // interface.
-            if (mCallGetCommand != null) {
-                try {
-                    Bundle args = null;
-                    if (!isSelf) {
-                        args = new Bundle();
-                        args.putInt(CALL_METHOD_USER_KEY, userHandle);
-                    }
-                    Bundle b = cp.call(mCallGetCommand, name, args);
-                    if (b != null) {
-                        String value = b.getPairValue();
-                        // Don't update our cache for reads of other users' data
-                        if (isSelf) {
-                            synchronized (this) {
-                                mValues.put(name, value);
-                            }
-                        } else {
-                            if (LOCAL_LOGV) Log.i(TAG, "call-query of user " + userHandle
-                                    + " by " + UserHandle.myUserId()
-                                    + " so not updating cache");
-                        }
-                        return value;
-                    }
-                    // If the response Bundle is null, we fall through
-                    // to the query interface below.
-                } catch (RemoteException e) {
-                    // Not supported by the remote side?  Fall through
-                    // to query().
-                }
-            }
-
-            Cursor c = null;
-            try {
-                c = cp.query(mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER,
-                             new String[]{name}, null, null);
-                if (c == null) {
-                    Log.w(TAG, "Can't get key " + name + " from " + mUri);
-                    return null;
-                }
-
-                String value = c.moveToNext() ? c.getString(0) : null;
-                synchronized (this) {
-                    mValues.put(name, value);
-                }
-                if (LOCAL_LOGV) {
-                    Log.v(TAG, "cache miss [" + mUri.getLastPathSegment() + "]: " +
-                            name + " = " + (value == null ? "(null)" : value));
-                }
-                return value;
-            } catch (RemoteException e) {
-                Log.w(TAG, "Can't get key " + name + " from " + mUri, e);
-                return null;  // Return null, but don't cache it.
-            } finally {
-                if (c != null) c.close();
-            }
-        }
-    }
-
-    /**
-     * System settings, containing miscellaneous system preferences.  This
-     * table holds simple name/value pairs.  There are convenience
-     * functions for accessing individual settings entries.
-     */
-    public static final class System extends NameValueTable {
-        public static final String SYS_PROP_SETTING_VERSION = "sys.settings_system_version";
-
-        /**
-         * The content:// style URL for this table
-         */
-        public static final Uri CONTENT_URI =
-            Uri.parse("content://" + AUTHORITY + "/system");
-
-        private static final NameValueCache sNameValueCache = new NameValueCache(
-                SYS_PROP_SETTING_VERSION,
-                CONTENT_URI,
-                CALL_METHOD_GET_SYSTEM,
-                CALL_METHOD_PUT_SYSTEM);
-
-        private static final HashSet<String> MOVED_TO_SECURE;
-        static {
-            MOVED_TO_SECURE = new HashSet<String>(30);
-            MOVED_TO_SECURE.add(Secure.ANDROID_ID);
-            MOVED_TO_SECURE.add(Secure.HTTP_PROXY);
-            MOVED_TO_SECURE.add(Secure.LOCATION_PROVIDERS_ALLOWED);
-            MOVED_TO_SECURE.add(Secure.LOCK_BIOMETRIC_WEAK_FLAGS);
-            MOVED_TO_SECURE.add(Secure.LOCK_PATTERN_ENABLED);
-            MOVED_TO_SECURE.add(Secure.LOCK_PATTERN_VISIBLE);
-            MOVED_TO_SECURE.add(Secure.LOCK_SHOW_ERROR_PATH);
-            MOVED_TO_SECURE.add(Secure.LOCK_DOTS_VISIBLE);
-            MOVED_TO_SECURE.add(Secure.LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED);
-            MOVED_TO_SECURE.add(Secure.LOGGING_ID);
-            MOVED_TO_SECURE.add(Secure.PARENTAL_CONTROL_ENABLED);
-            MOVED_TO_SECURE.add(Secure.PARENTAL_CONTROL_LAST_UPDATE);
-            MOVED_TO_SECURE.add(Secure.PARENTAL_CONTROL_REDIRECT_URL);
-            MOVED_TO_SECURE.add(Secure.SETTINGS_CLASSNAME);
-            MOVED_TO_SECURE.add(Secure.USE_GOOGLE_MAIL);
-            MOVED_TO_SECURE.add(Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON);
-            MOVED_TO_SECURE.add(Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY);
-            MOVED_TO_SECURE.add(Secure.WIFI_NUM_OPEN_NETWORKS_KEPT);
-            MOVED_TO_SECURE.add(Secure.WIFI_ON);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_AP_COUNT);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_MAX_AP_CHECKS);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_ON);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_PING_COUNT);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_PING_DELAY_MS);
-            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS);
-        }
-
-        private static final HashSet<String> MOVED_TO_GLOBAL;
-        private static final HashSet<String> MOVED_TO_SECURE_THEN_GLOBAL;
-        static {
-            MOVED_TO_GLOBAL = new HashSet<String>();
-            MOVED_TO_SECURE_THEN_GLOBAL = new HashSet<String>();
-
-            // these were originally in system but migrated to secure in the past,
-            // so are duplicated in the Secure.* namespace
-            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.ADB_ENABLED);
-            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.BLUETOOTH_ON);
-            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.DATA_ROAMING);
-            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.DEVICE_PROVISIONED);
-            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.INSTALL_NON_MARKET_APPS);
-            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.USB_MASS_STORAGE_ENABLED);
-            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.HTTP_PROXY);
-
-            // these are moving directly from system to global
-            MOVED_TO_GLOBAL.add(Settings.Global.AIRPLANE_MODE_ON);
-            MOVED_TO_GLOBAL.add(Settings.Global.AIRPLANE_MODE_RADIOS);
-            MOVED_TO_GLOBAL.add(Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
-            MOVED_TO_GLOBAL.add(Settings.Global.AUTO_TIME);
-            MOVED_TO_GLOBAL.add(Settings.Global.AUTO_TIME_ZONE);
-            MOVED_TO_GLOBAL.add(Settings.Global.CAR_DOCK_SOUND);
-            MOVED_TO_GLOBAL.add(Settings.Global.CAR_UNDOCK_SOUND);
-            MOVED_TO_GLOBAL.add(Settings.Global.DESK_DOCK_SOUND);
-            MOVED_TO_GLOBAL.add(Settings.Global.DESK_UNDOCK_SOUND);
-            MOVED_TO_GLOBAL.add(Settings.Global.DOCK_SOUNDS_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.LOCK_SOUND);
-            MOVED_TO_GLOBAL.add(Settings.Global.UNLOCK_SOUND);
-            MOVED_TO_GLOBAL.add(Settings.Global.LOW_BATTERY_SOUND);
-            MOVED_TO_GLOBAL.add(Settings.Global.POWER_SOUNDS_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.STAY_ON_WHILE_PLUGGED_IN);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SLEEP_POLICY);
-            MOVED_TO_GLOBAL.add(Settings.Global.MODE_RINGER);
-            MOVED_TO_GLOBAL.add(Settings.Global.WINDOW_ANIMATION_SCALE);
-            MOVED_TO_GLOBAL.add(Settings.Global.TRANSITION_ANIMATION_SCALE);
-            MOVED_TO_GLOBAL.add(Settings.Global.ANIMATOR_DURATION_SCALE);
-            MOVED_TO_GLOBAL.add(Settings.Global.FANCY_IME_ANIMATIONS);
-            MOVED_TO_GLOBAL.add(Settings.Global.COMPATIBILITY_MODE);
-            MOVED_TO_GLOBAL.add(Settings.Global.EMERGENCY_TONE);
-            MOVED_TO_GLOBAL.add(Settings.Global.CALL_AUTO_RETRY);
-            MOVED_TO_GLOBAL.add(Settings.Global.DEBUG_APP);
-            MOVED_TO_GLOBAL.add(Settings.Global.WAIT_FOR_DEBUGGER);
-            MOVED_TO_GLOBAL.add(Settings.Global.SHOW_PROCESSES);
-            MOVED_TO_GLOBAL.add(Settings.Global.ALWAYS_FINISH_ACTIVITIES);
-        }
-
-        /** @hide */
-        public static void getMovedKeys(HashSet<String> outKeySet) {
-            outKeySet.addAll(MOVED_TO_GLOBAL);
-            outKeySet.addAll(MOVED_TO_SECURE_THEN_GLOBAL);
-        }
-
-        /** @hide */
-        public static void getNonLegacyMovedKeys(HashSet<String> outKeySet) {
-            outKeySet.addAll(MOVED_TO_GLOBAL);
-        }
-
-        /**
-         * Look up a boolean in the database.
-         * @param resolver to access the database with
-         * @param name to look up in the table
-         * @param def Value to return if the setting is not defined.
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid boolean.
-         */
-        public static boolean getBoolean(ContentResolver cr, String name, boolean def) {
-            String v = getString(cr, name);
-            try {
-                if(v != null)
-                    return "1".equals(v);
-                else
-                    return def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-        /**
-         * Convenience function for updating a single settings value as a
-         * boolean. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putBoolean(ContentResolver cr, String name, boolean value) {
-            return putString(cr, name, value ? "1" : "0");
-        }
-
-        /**
-         * Look up a name in the database.
-         * @param resolver to access the database with
-         * @param name to look up in the table
-         * @return the corresponding value, or null if not present
-         */
-        public static String getString(ContentResolver resolver, String name) {
-            return getStringForUser(resolver, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static String getStringForUser(ContentResolver resolver, String name,
-                int userHandle) {
-            if (MOVED_TO_SECURE.contains(name)) {
-                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
-                        + " to android.provider.Settings.Secure, returning read-only value.");
-                return Secure.getStringForUser(resolver, name, userHandle);
-            }
-            if (MOVED_TO_GLOBAL.contains(name) || MOVED_TO_SECURE_THEN_GLOBAL.contains(name)) {
-                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
-                        + " to android.provider.Settings.Global, returning read-only value.");
-                return Global.getStringForUser(resolver, name, userHandle);
-            }
-            return sNameValueCache.getStringForUser(resolver, name, userHandle);
-        }
-
-        /**
-         * Store a name/value pair into the database.
-         * @param resolver to access the database with
-         * @param name to store
-         * @param value to associate with the name
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putString(ContentResolver resolver, String name, String value) {
-            return putStringForUser(resolver, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putStringForUser(ContentResolver resolver, String name, String value,
-                int userHandle) {
-            if (MOVED_TO_SECURE.contains(name)) {
-                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
-                        + " to android.provider.Settings.Secure, value is unchanged.");
-                return false;
-            }
-            if (MOVED_TO_GLOBAL.contains(name) || MOVED_TO_SECURE_THEN_GLOBAL.contains(name)) {
-                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
-                        + " to android.provider.Settings.Global, value is unchanged.");
-                return false;
-            }
-            return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
-        }
-
-        /**
-         * Construct the content URI for a particular name/value pair,
-         * useful for monitoring changes with a ContentObserver.
-         * @param name to look up in the table
-         * @return the corresponding content URI, or null if not present
-         */
-        public static Uri getUriFor(String name) {
-            if (MOVED_TO_SECURE.contains(name)) {
-                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
-                    + " to android.provider.Settings.Secure, returning Secure URI.");
-                return Secure.getUriFor(Secure.CONTENT_URI, name);
-            }
-            if (MOVED_TO_GLOBAL.contains(name) || MOVED_TO_SECURE_THEN_GLOBAL.contains(name)) {
-                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
-                        + " to android.provider.Settings.Global, returning read-only global URI.");
-                return Global.getUriFor(Global.CONTENT_URI, name);
-            }
-            return getUriFor(CONTENT_URI, name);
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.  The default value will be returned if the setting is
-         * not defined or not an integer.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid integer.
-         */
-        public static int getInt(ContentResolver cr, String name, int def) {
-            return getIntForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static int getIntForUser(ContentResolver cr, String name, int def, int userHandle) {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return v != null ? Integer.parseInt(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         *
-         * @return The setting's current value.
-         */
-        public static int getInt(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getIntForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static int getIntForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return Integer.parseInt(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as an
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putInt(ContentResolver cr, String name, int value) {
-            return putIntForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putIntForUser(ContentResolver cr, String name, int value,
-                int userHandle) {
-            return putStringForUser(cr, name, Integer.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.  The default value will be returned if the setting is
-         * not defined or not a {@code long}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid {@code long}.
-         */
-        public static long getLong(ContentResolver cr, String name, long def) {
-            return getLongForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static long getLongForUser(ContentResolver cr, String name, long def,
-                int userHandle) {
-            String valString = getStringForUser(cr, name, userHandle);
-            long value;
-            try {
-                value = valString != null ? Long.parseLong(valString) : def;
-            } catch (NumberFormatException e) {
-                value = def;
-            }
-            return value;
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @return The setting's current value.
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         */
-        public static long getLong(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getLongForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static long getLongForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String valString = getStringForUser(cr, name, userHandle);
-            try {
-                return Long.parseLong(valString);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as a long
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putLong(ContentResolver cr, String name, long value) {
-            return putLongForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putLongForUser(ContentResolver cr, String name, long value,
-                int userHandle) {
-            return putStringForUser(cr, name, Long.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as a floating point number.  Note that internally setting values are
-         * always stored as strings; this function converts the string to an
-         * float for you. The default value will be returned if the setting
-         * is not defined or not a valid float.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid float.
-         */
-        public static float getFloat(ContentResolver cr, String name, float def) {
-            return getFloatForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static float getFloatForUser(ContentResolver cr, String name, float def,
-                int userHandle) {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return v != null ? Float.parseFloat(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as a float.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a float
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not a float.
-         *
-         * @return The setting's current value.
-         */
-        public static float getFloat(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getFloatForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static float getFloatForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String v = getStringForUser(cr, name, userHandle);
-            if (v == null) {
-                throw new SettingNotFoundException(name);
-            }
-            try {
-                return Float.parseFloat(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as a
-         * floating point number. This will either create a new entry in the
-         * table if the given name does not exist, or modify the value of the
-         * existing row with that name.  Note that internally setting values
-         * are always stored as strings, so this function converts the given
-         * value to a string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putFloat(ContentResolver cr, String name, float value) {
-            return putFloatForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putFloatForUser(ContentResolver cr, String name, float value,
-                int userHandle) {
-            return putStringForUser(cr, name, Float.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function to read all of the current
-         * configuration-related settings into a
-         * {@link Configuration} object.
-         *
-         * @param cr The ContentResolver to access.
-         * @param outConfig Where to place the configuration settings.
-         */
-        public static void getConfiguration(ContentResolver cr, Configuration outConfig) {
-            getConfigurationForUser(cr, outConfig, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static void getConfigurationForUser(ContentResolver cr, Configuration outConfig,
-                int userHandle) {
-            outConfig.fontScale = Settings.System.getFloatForUser(
-                cr, FONT_SCALE, outConfig.fontScale, userHandle);
-            if (outConfig.fontScale < 0) {
-                outConfig.fontScale = 1;
-            }
-        }
-
-        /**
-         * @hide Erase the fields in the Configuration that should be applied
-         * by the settings.
-         */
-        public static void clearConfiguration(Configuration inoutConfig) {
-            inoutConfig.fontScale = 0;
-        }
-
-        /**
-         * Convenience function to write a batch of configuration-related
-         * settings from a {@link Configuration} object.
-         *
-         * @param cr The ContentResolver to access.
-         * @param config The settings to write.
-         * @return true if the values were set, false on database errors
-         */
-        public static boolean putConfiguration(ContentResolver cr, Configuration config) {
-            return putConfigurationForUser(cr, config, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putConfigurationForUser(ContentResolver cr, Configuration config,
-                int userHandle) {
-            return Settings.System.putFloatForUser(cr, FONT_SCALE, config.fontScale, userHandle);
-        }
-
-        /** @hide */
-        public static boolean hasInterestingConfigurationChanges(int changes) {
-            return (changes&ActivityInfo.CONFIG_FONT_SCALE) != 0;
-        }
-
-        /** @deprecated - Do not use */
-        @Deprecated
-        public static boolean getShowGTalkServiceStatus(ContentResolver cr) {
-            return getShowGTalkServiceStatusForUser(cr, UserHandle.myUserId());
-        }
-
-        /**
-         * @hide
-         * @deprecated - Do not use
-         */
-        public static boolean getShowGTalkServiceStatusForUser(ContentResolver cr,
-                int userHandle) {
-            return getIntForUser(cr, SHOW_GTALK_SERVICE_STATUS, 0, userHandle) != 0;
-        }
-
-        /** @deprecated - Do not use */
-        @Deprecated
-        public static void setShowGTalkServiceStatus(ContentResolver cr, boolean flag) {
-            setShowGTalkServiceStatusForUser(cr, flag, UserHandle.myUserId());
-        }
-
-        /**
-         * @hide
-         * @deprecated - Do not use
-         */
-        @Deprecated
-        public static void setShowGTalkServiceStatusForUser(ContentResolver cr, boolean flag,
-                int userHandle) {
-            putIntForUser(cr, SHOW_GTALK_SERVICE_STATUS, flag ? 1 : 0, userHandle);
-        }
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#STAY_ON_WHILE_PLUGGED_IN} instead
-         */
-        @Deprecated
-        public static final String STAY_ON_WHILE_PLUGGED_IN = Global.STAY_ON_WHILE_PLUGGED_IN;
-
-        /**
-         * What happens when the user presses the end call button if they're not
-         * on a call.<br/>
-         * <b>Values:</b><br/>
-         * 0 - The end button does nothing.<br/>
-         * 1 - The end button goes to the home screen.<br/>
-         * 2 - The end button puts the device to sleep and locks the keyguard.<br/>
-         * 3 - The end button goes to the home screen.  If the user is already on the
-         * home screen, it puts the device to sleep.
-         */
-        public static final String END_BUTTON_BEHAVIOR = "end_button_behavior";
-
-        /**
-         * END_BUTTON_BEHAVIOR value for "go home".
-         * @hide
-         */
-        public static final int END_BUTTON_BEHAVIOR_HOME = 0x1;
-
-        /**
-         * END_BUTTON_BEHAVIOR value for "go to sleep".
-         * @hide
-         */
-        public static final int END_BUTTON_BEHAVIOR_SLEEP = 0x2;
-
-        /**
-         * END_BUTTON_BEHAVIOR default value.
-         * @hide
-         */
-        public static final int END_BUTTON_BEHAVIOR_DEFAULT = END_BUTTON_BEHAVIOR_SLEEP;
-
-        /**
-         * Is advanced settings mode turned on. 0 == no, 1 == yes
-         * @hide
-         */
-        public static final String ADVANCED_SETTINGS = "advanced_settings";
-
-        /**
-         * ADVANCED_SETTINGS default value.
-         * @hide
-         */
-        public static final int ADVANCED_SETTINGS_DEFAULT = 0;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#AIRPLANE_MODE_ON} instead
-         */
-        @Deprecated
-        public static final String AIRPLANE_MODE_ON = Global.AIRPLANE_MODE_ON;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#RADIO_BLUETOOTH} instead
-         */
-        @Deprecated
-        public static final String RADIO_BLUETOOTH = Global.RADIO_BLUETOOTH;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#RADIO_WIFI} instead
-         */
-        @Deprecated
-        public static final String RADIO_WIFI = Global.RADIO_WIFI;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#RADIO_WIMAX} instead
-         * {@hide}
-         */
-        @Deprecated
-        public static final String RADIO_WIMAX = Global.RADIO_WIMAX;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#RADIO_CELL} instead
-         */
-        @Deprecated
-        public static final String RADIO_CELL = Global.RADIO_CELL;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#RADIO_NFC} instead
-         */
-        @Deprecated
-        public static final String RADIO_NFC = Global.RADIO_NFC;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#AIRPLANE_MODE_RADIOS} instead
-         */
-        @Deprecated
-        public static final String AIRPLANE_MODE_RADIOS = Global.AIRPLANE_MODE_RADIOS;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#AIRPLANE_MODE_TOGGLEABLE_RADIOS} instead
-         *
-         * {@hide}
-         */
-        @Deprecated
-        public static final String AIRPLANE_MODE_TOGGLEABLE_RADIOS =
-                Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_SLEEP_POLICY} instead
-         */
-        @Deprecated
-        public static final String WIFI_SLEEP_POLICY = Global.WIFI_SLEEP_POLICY;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_SLEEP_POLICY_DEFAULT} instead
-         */
-        @Deprecated
-        public static final int WIFI_SLEEP_POLICY_DEFAULT = Global.WIFI_SLEEP_POLICY_DEFAULT;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED} instead
-         */
-        @Deprecated
-        public static final int WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED =
-                Global.WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_SLEEP_POLICY_NEVER} instead
-         */
-        @Deprecated
-        public static final int WIFI_SLEEP_POLICY_NEVER = Global.WIFI_SLEEP_POLICY_NEVER;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#MODE_RINGER} instead
-         */
-        @Deprecated
-        public static final String MODE_RINGER = Global.MODE_RINGER;
-
-        /**
-         * Whether to use static IP and other static network attributes.
-         * <p>
-         * Set to 1 for true and 0 for false.
-         *
-         * @deprecated Use {@link WifiManager} instead
-         */
-        @Deprecated
-        public static final String WIFI_USE_STATIC_IP = "wifi_use_static_ip";
-
-        /**
-         * The static IP address.
-         * <p>
-         * Example: "192.168.1.51"
-         *
-         * @deprecated Use {@link WifiManager} instead
-         */
-        @Deprecated
-        public static final String WIFI_STATIC_IP = "wifi_static_ip";
-
-        /**
-         * If using static IP, the gateway's IP address.
-         * <p>
-         * Example: "192.168.1.1"
-         *
-         * @deprecated Use {@link WifiManager} instead
-         */
-        @Deprecated
-        public static final String WIFI_STATIC_GATEWAY = "wifi_static_gateway";
-
-        /**
-         * If using static IP, the net mask.
-         * <p>
-         * Example: "255.255.255.0"
-         *
-         * @deprecated Use {@link WifiManager} instead
-         */
-        @Deprecated
-        public static final String WIFI_STATIC_NETMASK = "wifi_static_netmask";
-
-        /**
-         * If using static IP, the primary DNS's IP address.
-         * <p>
-         * Example: "192.168.1.1"
-         *
-         * @deprecated Use {@link WifiManager} instead
-         */
-        @Deprecated
-        public static final String WIFI_STATIC_DNS1 = "wifi_static_dns1";
-
-        /**
-         * If using static IP, the secondary DNS's IP address.
-         * <p>
-         * Example: "192.168.1.2"
-         *
-         * @deprecated Use {@link WifiManager} instead
-         */
-        @Deprecated
-        public static final String WIFI_STATIC_DNS2 = "wifi_static_dns2";
-
-        /**
-         * Allows automatic retrieval of mms contents
-         * <p>Type: INT</p>
-         * 0 -- false
-         * 1 -- true
-         * @hide
-         */
-        public static final String MMS_AUTO_RETRIEVAL = "mms_auto_retrieval";
-
-        /**
-         * Allows automatic retrieval of mms contents during roaming
-         * <p>Type: INT</p>
-         * 0 -- false
-         * 1 -- true
-         * @hide
-         */
-        public static final String MMS_AUTO_RETRIEVAL_ON_ROAMING = "mms_auto_on_roaming";
-
-        /**
-         * Determines whether remote devices may discover and/or connect to
-         * this device.
-         * <P>Type: INT</P>
-         * 2 -- discoverable and connectable
-         * 1 -- connectable but not discoverable
-         * 0 -- neither connectable nor discoverable
-         */
-        public static final String BLUETOOTH_DISCOVERABILITY =
-            "bluetooth_discoverability";
-
-        /**
-         * Bluetooth discoverability timeout.  If this value is nonzero, then
-         * Bluetooth becomes discoverable for a certain number of seconds,
-         * after which is becomes simply connectable.  The value is in seconds.
-         */
-        public static final String BLUETOOTH_DISCOVERABILITY_TIMEOUT =
-            "bluetooth_discoverability_timeout";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#LOCK_PATTERN_ENABLED}
-         * instead
-         */
-        @Deprecated
-        public static final String LOCK_PATTERN_ENABLED = Secure.LOCK_PATTERN_ENABLED;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#LOCK_PATTERN_VISIBLE}
-         * instead
-         */
-        @Deprecated
-        public static final String LOCK_PATTERN_VISIBLE = "lock_pattern_visible_pattern";
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Secure#LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED}
-         * instead
-         */
-        @Deprecated
-        public static final String LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED =
-            "lock_pattern_tactile_feedback_enabled";
-
-
-        /**
-         * A formatted string of the next alarm that is set, or the empty string
-         * if there is no alarm set.
-         */
-        public static final String NEXT_ALARM_FORMATTED = "next_alarm_formatted";
-
-        /**
-         * Scaling factor for fonts, float.
-         */
-        public static final String FONT_SCALE = "font_scale";
-
-        /**
-         * Name of an application package to be debugged.
-         *
-         * @deprecated Use {@link Global#DEBUG_APP} instead
-         */
-        @Deprecated
-        public static final String DEBUG_APP = Global.DEBUG_APP;
-
-        /**
-         * If 1, when launching DEBUG_APP it will wait for the debugger before
-         * starting user code.  If 0, it will run normally.
-         *
-         * @deprecated Use {@link Global#WAIT_FOR_DEBUGGER} instead
-         */
-        @Deprecated
-        public static final String WAIT_FOR_DEBUGGER = Global.WAIT_FOR_DEBUGGER;
-
-        /**
-         * Whether or not to dim the screen. 0=no  1=yes
-         * @deprecated This setting is no longer used.
-         */
-        @Deprecated
-        public static final String DIM_SCREEN = "dim_screen";
-
-        /**
-         * The timeout before the screen turns off.
-         */
-        public static final String SCREEN_OFF_TIMEOUT = "screen_off_timeout";
-
-        /**
-         * The screen backlight brightness between 0 and 255.
-         */
-        public static final String SCREEN_BRIGHTNESS = "screen_brightness";
-
-        /**
-         * Control whether to enable automatic brightness mode.
-         */
-        public static final String SCREEN_BRIGHTNESS_MODE = "screen_brightness_mode";
-
-        /**
-         * Adjustment to auto-brightness to make it generally more (>0.0 <1.0)
-         * or less (<0.0 >-1.0) bright.
-         * @hide
-         */
-        public static final String SCREEN_AUTO_BRIGHTNESS_ADJ = "screen_auto_brightness_adj";
-
-        /**
-         * SCREEN_BRIGHTNESS_MODE value for manual mode.
-         */
-        public static final int SCREEN_BRIGHTNESS_MODE_MANUAL = 0;
-
-        /**
-         * SCREEN_BRIGHTNESS_MODE value for automatic mode.
-         */
-        public static final int SCREEN_BRIGHTNESS_MODE_AUTOMATIC = 1;
-
-        /**
-         * Custom automatic brightness light sensor levels.
-         * The value is a comma separated int array with length N.
-         * Example: "100,300,3000".
-         *
-         * @hide
-         */
-        public static final String AUTO_BRIGHTNESS_LUX = "auto_brightness_lux";
-
-        /**
-         * Custom automatic brightness display backlight brightness values.
-         * The value is a comma separated int array with length N+1.
-         * Example: "10,50,100,255".
-         *
-         * @hide
-         */
-        public static final String AUTO_BRIGHTNESS_BACKLIGHT = "auto_brightness_backlight";
-
-        /**
-         * Correction factor for auto-brightness adjustment light sensor
-         * debounce times.
-         * Smaller factors will make the adjustment more responsive, but might
-         * cause flicker and/or cause higher CPU usage.
-         * Valid range is 0.2 ... 3
-         *
-         * @hide
-         */
-        public static final String AUTO_BRIGHTNESS_RESPONSIVENESS = "auto_brightness_responsiveness";
-
-        /**
-         * Whether to enable the electron beam animation when turning screen on
-         *
-         * @hide */
-        public static final String ELECTRON_BEAM_ANIMATION_ON = "electron_beam_animation_on";
-
-        /**
-         * Whether to enable the electron beam animation when turning screen off
-         *
-         * @hide */
-        public static final String ELECTRON_BEAM_ANIMATION_OFF = "electron_beam_animation_off";
-
-        /**
-         * Control whether the process CPU usage meter should be shown.
-         *
-         * @deprecated Use {@link Global#SHOW_PROCESSES} instead
-         */
-        @Deprecated
-        public static final String SHOW_PROCESSES = Global.SHOW_PROCESSES;
-
-        /**
-         * If 1, the activity manager will aggressively finish activities and
-         * processes as soon as they are no longer needed.  If 0, the normal
-         * extended lifetime is used.
-         *
-         * @deprecated Use {@link Global#ALWAYS_FINISH_ACTIVITIES} instead
-         */
-        @Deprecated
-        public static final String ALWAYS_FINISH_ACTIVITIES = Global.ALWAYS_FINISH_ACTIVITIES;
-
-        /**
-         * Volume Overlay Mode, This is behaviour of the volume overlay panel
-         * Defaults to 0 - which is simple
-         * @hide
-         */
-        public static final String MODE_VOLUME_OVERLAY = "mode_volume_overlay";
-
-        /** @hide */
-        public static final int VOLUME_OVERLAY_SINGLE = 0;
-        /** @hide */
-        public static final int VOLUME_OVERLAY_EXPANDABLE = 1;
-        /** @hide */
-        public static final int VOLUME_OVERLAY_EXPANDED = 2;
-        /** @hide */
-        public static final int VOLUME_OVERLAY_NONE = 3;
-
-        /**
-         * Volume Adjust Sounds Enable, This is the noise made when using volume hard buttons
-         * Defaults to 1 - sounds enabled
-         * @hide
-         */
-        public static final String VOLUME_ADJUST_SOUNDS_ENABLED = "volume_adjust_sounds_enabled";
-
-        /**
-         * Determines which streams are affected by ringer mode changes. The
-         * stream type's bit should be set to 1 if it should be muted when going
-         * into an inaudible ringer mode.
-         */
-        public static final String MODE_RINGER_STREAMS_AFFECTED = "mode_ringer_streams_affected";
-
-         /**
-          * Determines which streams are affected by mute. The
-          * stream type's bit should be set to 1 if it should be muted when a mute request
-          * is received.
-          */
-         public static final String MUTE_STREAMS_AFFECTED = "mute_streams_affected";
-
-        /**
-         * Whether vibrate is on for different events. This is used internally,
-         * changing this value will not change the vibrate. See AudioManager.
-         */
-        public static final String VIBRATE_ON = "vibrate_on";
-
-        /**
-         * If 1, redirects the system vibrator to all currently attached input devices
-         * that support vibration.  If there are no such input devices, then the system
-         * vibrator is used instead.
-         * If 0, does not register the system vibrator.
-         *
-         * This setting is mainly intended to provide a compatibility mechanism for
-         * applications that only know about the system vibrator and do not use the
-         * input device vibrator API.
-         *
-         * @hide
-         */
-        public static final String VIBRATE_INPUT_DEVICES = "vibrate_input_devices";
-
-        /**
-         * Ringer volume. This is used internally, changing this value will not
-         * change the volume. See AudioManager.
-         */
-        public static final String VOLUME_RING = "volume_ring";
-
-        /**
-         * System/notifications volume. This is used internally, changing this
-         * value will not change the volume. See AudioManager.
-         */
-        public static final String VOLUME_SYSTEM = "volume_system";
-
-        /**
-         * Voice call volume. This is used internally, changing this value will
-         * not change the volume. See AudioManager.
-         */
-        public static final String VOLUME_VOICE = "volume_voice";
-
-        /**
-         * Music/media/gaming volume. This is used internally, changing this
-         * value will not change the volume. See AudioManager.
-         */
-        public static final String VOLUME_MUSIC = "volume_music";
-
-        /**
-         * Alarm volume. This is used internally, changing this
-         * value will not change the volume. See AudioManager.
-         */
-        public static final String VOLUME_ALARM = "volume_alarm";
-
-        /**
-         * Notification volume. This is used internally, changing this
-         * value will not change the volume. See AudioManager.
-         */
-        public static final String VOLUME_NOTIFICATION = "volume_notification";
-
-        /**
-         * Bluetooth Headset volume. This is used internally, changing this value will
-         * not change the volume. See AudioManager.
-         */
-        public static final String VOLUME_BLUETOOTH_SCO = "volume_bluetooth_sco";
-
-        /**
-         * Whether to prevent loud volume levels when headset is first plugged in.
-         * @hide
-         */
-        public static final String SAFE_HEADSET_VOLUME = "safe_headset_volume";
-
-        /**
-         * Master volume (float in the range 0.0f to 1.0f).
-         * @hide
-         */
-        public static final String VOLUME_MASTER = "volume_master";
-
-        /**
-         * Master volume mute (int 1 = mute, 0 = not muted).
-         *
-         * @hide
-         */
-        public static final String VOLUME_MASTER_MUTE = "volume_master_mute";
-
-        /**
-         * Whether the notifications should use the ring volume (value of 1) or
-         * a separate notification volume (value of 0). In most cases, users
-         * will have this enabled so the notification and ringer volumes will be
-         * the same. However, power users can disable this and use the separate
-         * notification volume control.
-         * <p>
-         * Note: This is a one-off setting that will be removed in the future
-         * when there is profile support. For this reason, it is kept hidden
-         * from the public APIs.
-         *
-         * @hide
-         * @deprecated
-         */
-        @Deprecated
-        public static final String NOTIFICATIONS_USE_RING_VOLUME =
-            "notifications_use_ring_volume";
-
-        /**
-         * Whether the blacklisting feature for phone calls is enabled
-         * @hide
-         */
-        public static final String PHONE_BLACKLIST_ENABLED = "phone_blacklist_enabled";
-
-        /**
-         * Whether the phone ringtone should be played in an increasing manner
-         * @hide
-         */
-        public static final String INCREASING_RING = "increasing_ring";
-
-        /**
-         * Minimum volume index for increasing ring volume
-         * @hide
-         */
-        public static final String INCREASING_RING_MIN_VOLUME = "increasing_ring_min_vol";
-
-        /**
-         * Time (in ms) between ringtone volume increases
-         * @hide
-         */
-        public static final String INCREASING_RING_INTERVAL = "increasing_ring_interval";
-
-        /**
-         * Whether silent mode should allow vibration feedback. This is used
-         * internally in AudioService and the Sound settings activity to
-         * coordinate decoupling of vibrate and silent modes. This setting
-         * will likely be removed in a future release with support for
-         * audio/vibe feedback profiles.
-         *
-         * Not used anymore. On devices with vibrator, the user explicitly selects
-         * silent or vibrate mode.
-         * Kept for use by legacy database upgrade code in DatabaseHelper.
-         * @hide
-         */
-        public static final String VIBRATE_IN_SILENT = "vibrate_in_silent";
-
-        /**
-         * wake up when plugged or unplugged
-         *
-         * @hide
-         */
-        public static final String WAKEUP_WHEN_PLUGGED_UNPLUGGED = "wakeup_when_plugged_unplugged";
-
-        /**
-         * The mapping of stream type (integer) to its setting.
-         */
-        public static final String[] VOLUME_SETTINGS = {
-            VOLUME_VOICE, VOLUME_SYSTEM, VOLUME_RING, VOLUME_MUSIC,
-            VOLUME_ALARM, VOLUME_NOTIFICATION, VOLUME_BLUETOOTH_SCO
-        };
-
-        /**
-         * Appended to various volume related settings to record the previous
-         * values before they the settings were affected by a silent/vibrate
-         * ringer mode change.
-         */
-        public static final String APPEND_FOR_LAST_AUDIBLE = "_last_audible";
-
-        /**
-         * Persistent store for the system-wide default ringtone URI.
-         * <p>
-         * If you need to play the default ringtone at any given time, it is recommended
-         * you give {@link #DEFAULT_RINGTONE_URI} to the media player.  It will resolve
-         * to the set default ringtone at the time of playing.
-         *
-         * @see #DEFAULT_RINGTONE_URI
-         */
-        public static final String RINGTONE = "ringtone";
-
-        /**
-         * A {@link Uri} that will point to the current default ringtone at any
-         * given time.
-         * <p>
-         * If the current default ringtone is in the DRM provider and the caller
-         * does not have permission, the exception will be a
-         * FileNotFoundException.
-         */
-        public static final Uri DEFAULT_RINGTONE_URI = getUriFor(RINGTONE);
-
-        /**
-         * Persistent store for the system-wide default notification sound.
-         *
-         * @see #RINGTONE
-         * @see #DEFAULT_NOTIFICATION_URI
-         */
-        public static final String NOTIFICATION_SOUND = "notification_sound";
-
-        /**
-         * A {@link Uri} that will point to the current default notification
-         * sound at any given time.
-         *
-         * @see #DEFAULT_RINGTONE_URI
-         */
-        public static final Uri DEFAULT_NOTIFICATION_URI = getUriFor(NOTIFICATION_SOUND);
-
-        /**
-         * Persistent store for the system-wide default alarm alert.
-         *
-         * @see #RINGTONE
-         * @see #DEFAULT_ALARM_ALERT_URI
-         */
-        public static final String ALARM_ALERT = "alarm_alert";
-
-        /**
-         * A {@link Uri} that will point to the current default alarm alert at
-         * any given time.
-         *
-         * @see #DEFAULT_ALARM_ALERT_URI
-         */
-        public static final Uri DEFAULT_ALARM_ALERT_URI = getUriFor(ALARM_ALERT);
-
-        /**
-         * Persistent store for the system default media button event receiver.
-         *
-         * @hide
-         */
-        public static final String MEDIA_BUTTON_RECEIVER = "media_button_receiver";
-
-        /**
-         * Setting to enable Auto Replace (AutoText) in text editors. 1 = On, 0 = Off
-         */
-        public static final String TEXT_AUTO_REPLACE = "auto_replace";
-
-        /**
-         * Setting to enable Auto Caps in text editors. 1 = On, 0 = Off
-         */
-        public static final String TEXT_AUTO_CAPS = "auto_caps";
-
-        /**
-         * Setting to enable Auto Punctuate in text editors. 1 = On, 0 = Off. This
-         * feature converts two spaces to a "." and space.
-         */
-        public static final String TEXT_AUTO_PUNCTUATE = "auto_punctuate";
-
-        /**
-         * Setting to showing password characters in text editors. 1 = On, 0 = Off
-         */
-        public static final String TEXT_SHOW_PASSWORD = "show_password";
-
-        public static final String SHOW_GTALK_SERVICE_STATUS =
-                "SHOW_GTALK_SERVICE_STATUS";
-
-        /**
-         * Name of activity to use for wallpaper on the home screen.
-         *
-         * @deprecated Use {@link WallpaperManager} instead.
-         */
-        @Deprecated
-        public static final String WALLPAPER_ACTIVITY = "wallpaper_activity";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#AUTO_TIME}
-         * instead
-         */
-        @Deprecated
-        public static final String AUTO_TIME = Global.AUTO_TIME;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#AUTO_TIME_ZONE}
-         * instead
-         */
-        @Deprecated
-        public static final String AUTO_TIME_ZONE = Global.AUTO_TIME_ZONE;
-
-        /**
-         * Display times as 12 or 24 hours
-         *   12
-         *   24
-         */
-        public static final String TIME_12_24 = "time_12_24";
-
-        /**
-         * Date format string
-         *   mm/dd/yyyy
-         *   dd/mm/yyyy
-         *   yyyy/mm/dd
-         */
-        public static final String DATE_FORMAT = "date_format";
-
-        /**
-         * Whether the setup wizard has been run before (on first boot), or if
-         * it still needs to be run.
-         *
-         * nonzero = it has been run in the past
-         * 0 = it has not been run in the past
-         */
-        public static final String SETUP_WIZARD_HAS_RUN = "setup_wizard_has_run";
-
-        /**
-         * Scaling factor for normal window animations. Setting to 0 will disable window
-         * animations.
-         *
-         * @deprecated Use {@link Global#WINDOW_ANIMATION_SCALE} instead
-         */
-        @Deprecated
-        public static final String WINDOW_ANIMATION_SCALE = Global.WINDOW_ANIMATION_SCALE;
-
-        /**
-         * Scaling factor for activity transition animations. Setting to 0 will disable window
-         * animations.
-         *
-         * @deprecated Use {@link Global#TRANSITION_ANIMATION_SCALE} instead
-         */
-        @Deprecated
-        public static final String TRANSITION_ANIMATION_SCALE = Global.TRANSITION_ANIMATION_SCALE;
-
-        /**
-         * Scaling factor for Animator-based animations. This affects both the start delay and
-         * duration of all such animations. Setting to 0 will cause animations to end immediately.
-         * The default value is 1.
-         *
-         * @deprecated Use {@link Global#ANIMATOR_DURATION_SCALE} instead
-         */
-        @Deprecated
-        public static final String ANIMATOR_DURATION_SCALE = Global.ANIMATOR_DURATION_SCALE;
-
-        /**
-         * Control whether the accelerometer will be used to change screen
-         * orientation.  If 0, it will not be used unless explicitly requested
-         * by the application; if 1, it will be used by default unless explicitly
-         * disabled by the application.
-         */
-        public static final String ACCELEROMETER_ROTATION = "accelerometer_rotation";
-
-        /**
-         * Control the type of rotation which can be performed using the accelerometer
-         * if ACCELEROMETER_ROTATION is enabled.
-         * Value is a bitwise combination of
-         * 1 = 0 degrees (portrait)
-         * 2 = 90 degrees (left)
-         * 4 = 180 degrees (inverted portrait)
-         * 8 = 270 degrees (right)
-         * Setting to 0 is effectively orientation lock
-         * @hide
-         */
-        public static final String ACCELEROMETER_ROTATION_ANGLES = "accelerometer_rotation_angles";
-
-        /**
-         * Default screen rotation when no other policy applies.
-         * When {@link #ACCELEROMETER_ROTATION} is zero and no on-screen Activity expresses a
-         * preference, this rotation value will be used. Must be one of the
-         * {@link android.view.Surface#ROTATION_0 Surface rotation constants}.
-         *
-         * @see Display#getRotation
-         */
-        public static final String USER_ROTATION = "user_rotation";
-
-        /**
-         * Control whether the rotation lock toggle in the System UI should be hidden.
-         * Typically this is done for accessibility purposes to make it harder for
-         * the user to accidentally toggle the rotation lock while the display rotation
-         * has been locked for accessibility.
-         *
-         * If 0, then rotation lock toggle is not hidden for accessibility (although it may be
-         * unavailable for other reasons).  If 1, then the rotation lock toggle is hidden.
-         *
-         * @hide
-         */
-        public static final String HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY =
-                "hide_rotation_lock_toggle_for_accessibility";
-
-        /**
-         * Whether the phone vibrates when it is ringing due to an incoming call. This will
-         * be used by Phone and Setting apps; it shouldn't affect other apps.
-         * The value is boolean (1 or 0).
-         *
-         * Note: this is not same as "vibrate on ring", which had been available until ICS.
-         * It was about AudioManager's setting and thus affected all the applications which
-         * relied on the setting, while this is purely about the vibration setting for incoming
-         * calls.
-         *
-         * @hide
-         */
-        public static final String VIBRATE_WHEN_RINGING = "vibrate_when_ringing";
-
-        /**
-         * Whether the audible DTMF tones are played by the dialer when dialing. The value is
-         * boolean (1 or 0).
-         */
-        public static final String DTMF_TONE_WHEN_DIALING = "dtmf_tone";
-
-        /**
-         * CDMA only settings
-         * DTMF tone type played by the dialer when dialing.
-         *                 0 = Normal
-         *                 1 = Long
-         * @hide
-         */
-        public static final String DTMF_TONE_TYPE_WHEN_DIALING = "dtmf_tone_type";
-
-        /**
-         * Whether the hearing aid is enabled. The value is
-         * boolean (1 or 0).
-         * @hide
-         */
-        public static final String HEARING_AID = "hearing_aid";
-
-        /**
-         * CDMA only settings
-         * TTY Mode
-         * 0 = OFF
-         * 1 = FULL
-         * 2 = VCO
-         * 3 = HCO
-         * @hide
-         */
-        public static final String TTY_MODE = "tty_mode";
-
-        /**
-         * Whether noise suppression is enabled. The value is
-         * boolean (1 or 0).
-         * @hide
-         */
-        public static final String NOISE_SUPPRESSION = "noise_suppression";
-
-        /**
-         * Whether the sounds effects (key clicks, lid open ...) are enabled. The value is
-         * boolean (1 or 0).
-         */
-        public static final String SOUND_EFFECTS_ENABLED = "sound_effects_enabled";
-
-        /**
-         * Whether the haptic feedback (long presses, ...) are enabled. The value is
-         * boolean (1 or 0).
-         */
-        public static final String HAPTIC_FEEDBACK_ENABLED = "haptic_feedback_enabled";
-
-        /**
-         * @deprecated Each application that shows web suggestions should have its own
-         * setting for this.
-         */
-        @Deprecated
-        public static final String SHOW_WEB_SUGGESTIONS = "show_web_suggestions";
-
-        /**
-         * Whether the notification LED should repeatedly flash when a notification is
-         * pending. The value is boolean (1 or 0).
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE = "notification_light_pulse";
-
-        /**
-         * What color to use for the notification LED by default
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR = "notification_light_pulse_default_color";
-
-        /**
-         * How long to flash the notification LED by default
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON = "notification_light_pulse_default_led_on";
-
-        /**
-         * How long to wait between flashes for the notification LED by default
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF = "notification_light_pulse_default_led_off";
-
-        /**
-         * What color to use for the missed call notification LED
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_CALL_COLOR = "notification_light_pulse_call_color";
-
-        /**
-         * How long to flash the missed call notification LED
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_CALL_LED_ON = "notification_light_pulse_call_led_on";
-
-        /**
-         * How long to wait between flashes for the missed call notification LED
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_CALL_LED_OFF = "notification_light_pulse_call_led_off";
-
-        /**
-         * What color to use for the voicemail notification LED
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_VMAIL_COLOR = "notification_light_pulse_vmail_color";
-
-        /**
-         * How long to flash the voicemail notification LED
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_VMAIL_LED_ON = "notification_light_pulse_vmail_led_on";
-
-        /**
-         * How long to wait between flashes for the voicemail notification LED
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_VMAIL_LED_OFF = "notification_light_pulse_vmail_led_off";
-
-        /**
-         * Whether to use the custom LED values for the notification pulse LED.
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE = "notification_light_pulse_custom_enable";
-
-        /**
-         * Which custom LED values to use for the notification pulse LED.
-         * @hide
-         */
-        public static final String NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES = "notification_light_pulse_custom_values";
-
-        /**
-         * Whether the battery light should be enabled (if hardware supports it)
-         * The value is boolean (1 or 0).
-         * @hide
-         */
-        public static final String BATTERY_LIGHT_ENABLED = "battery_light_enabled";
-
-        /**
-         * Whether the battery LED should repeatedly flash when the battery is low
-         * on charge. The value is boolean (1 or 0).
-         * @hide
-         */
-        public static final String BATTERY_LIGHT_PULSE = "battery_light_pulse";
-
-        /**
-         * What color to use for the battery LED while charging - low
-         * @hide
-         */
-        public static final String BATTERY_LIGHT_LOW_COLOR = "battery_light_low_color";
-
-        /**
-         * What color to use for the battery LED while charging - medium
-         * @hide
-         */
-        public static final String BATTERY_LIGHT_MEDIUM_COLOR = "battery_light_medium_color";
-
-        /**
-         * What color to use for the battery LED while charging - full
-         * @hide
-         */
-        public static final String BATTERY_LIGHT_FULL_COLOR = "battery_light_full_color";
-
-        /** Sprint MWI Quirk: Show message wait indicator notifications
-         * @hide
-         */
-        public static final String ENABLE_MWI_NOTIFICATION = "enable_mwi_notification";
-
-        /**
-         * Show pointer location on screen?
-         * 0 = no
-         * 1 = yes
-         * @hide
-         */
-        public static final String POINTER_LOCATION = "pointer_location";
-
-        /**
-         * Show icon when stylus is used?
-         * 0 = no
-         * 1 = yes
-         * @hide
-         */
-        public static final String STYLUS_ICON_ENABLED = "stylus_icon_enabled";
-
-        /**
-         * Show touch positions on screen?
-         * 0 = no
-         * 1 = yes
-         * @hide
-         */
-        public static final String SHOW_TOUCHES = "show_touches";
-
-        /**
-         * Log raw orientation data from {@link WindowOrientationListener} for use with the
-         * orientationplot.py tool.
-         * 0 = no
-         * 1 = yes
-         * @hide
-         */
-        public static final String WINDOW_ORIENTATION_LISTENER_LOG =
-                "window_orientation_listener_log";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#POWER_SOUNDS_ENABLED}
-         * instead
-         * @hide
-         */
-        @Deprecated
-        public static final String POWER_SOUNDS_ENABLED = Global.POWER_SOUNDS_ENABLED;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#DOCK_SOUNDS_ENABLED}
-         * instead
-         * @hide
-         */
-        @Deprecated
-        public static final String DOCK_SOUNDS_ENABLED = Global.DOCK_SOUNDS_ENABLED;
-
-        /**
-         * Whether to play sounds when the keyguard is shown and dismissed.
-         * @hide
-         */
-        public static final String LOCKSCREEN_SOUNDS_ENABLED = "lockscreen_sounds_enabled";
-
-        /**
-         * Whether the lockscreen should be completely disabled.
-         * @hide
-         */
-        public static final String LOCKSCREEN_DISABLED = "lockscreen.disabled";
-
-        /**
-         * Stores values for custom lockscreen targets
-         * @hide
-         */
-        public static final String LOCKSCREEN_TARGETS = "lockscreen_targets";
-
-        /**
-         * Whether music controls should be shown on the lockscreen if a supporting
-         * music player is active.
-         * @hide
-         */
-        public static final String LOCKSCREEN_MUSIC_CONTROLS = "lockscreen_music_controls";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#LOW_BATTERY_SOUND}
-         * instead
-         * @hide
-         */
-        @Deprecated
-        public static final String LOW_BATTERY_SOUND = Global.LOW_BATTERY_SOUND;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#DESK_DOCK_SOUND}
-         * instead
-         * @hide
-         */
-        @Deprecated
-        public static final String DESK_DOCK_SOUND = Global.DESK_DOCK_SOUND;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#DESK_UNDOCK_SOUND}
-         * instead
-         * @hide
-         */
-        @Deprecated
-        public static final String DESK_UNDOCK_SOUND = Global.DESK_UNDOCK_SOUND;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#CAR_DOCK_SOUND}
-         * instead
-         * @hide
-         */
-        @Deprecated
-        public static final String CAR_DOCK_SOUND = Global.CAR_DOCK_SOUND;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#CAR_UNDOCK_SOUND}
-         * instead
-         * @hide
-         */
-        @Deprecated
-        public static final String CAR_UNDOCK_SOUND = Global.CAR_UNDOCK_SOUND;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#LOCK_SOUND}
-         * instead
-         * @hide
-         */
-        @Deprecated
-        public static final String LOCK_SOUND = Global.LOCK_SOUND;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#UNLOCK_SOUND}
-         * instead
-         * @hide
-         */
-        @Deprecated
-        public static final String UNLOCK_SOUND = Global.UNLOCK_SOUND;
-
-        /**
-         * Receive incoming SIP calls?
-         * 0 = no
-         * 1 = yes
-         * @hide
-         */
-        public static final String SIP_RECEIVE_CALLS = "sip_receive_calls";
-
-        /**
-         * Call Preference String.
-         * "SIP_ALWAYS" : Always use SIP with network access
-         * "SIP_ADDRESS_ONLY" : Only if destination is a SIP address
-         * "SIP_ASK_ME_EACH_TIME" : Always ask me each time
-         * @hide
-         */
-        public static final String SIP_CALL_OPTIONS = "sip_call_options";
-
-        /**
-         * One of the sip call options: Always use SIP with network access.
-         * @hide
-         */
-        public static final String SIP_ALWAYS = "SIP_ALWAYS";
-
-        /**
-         * One of the sip call options: Only if destination is a SIP address.
-         * @hide
-         */
-        public static final String SIP_ADDRESS_ONLY = "SIP_ADDRESS_ONLY";
-
-        /**
-         * One of the sip call options: Always ask me each time.
-         * @hide
-         */
-        public static final String SIP_ASK_ME_EACH_TIME = "SIP_ASK_ME_EACH_TIME";
-
-        /**
-         * Torch state (flashlight)
-         * @hide
-         */
-        public static final String TORCH_STATE = "torch_state";
-        /**
-         * Pointer speed setting.
-         * This is an integer value in a range between -7 and +7, so there are 15 possible values.
-         *   -7 = slowest
-         *    0 = default speed
-         *   +7 = fastest
-         * @hide
-         */
-        public static final String POINTER_SPEED = "pointer_speed";
-
-        /**
-         * Quick Settings Panel Tiles to Use
-         *
-         * @hide
-         */
-        public static final String QUICK_SETTINGS_TILES = "quick_settings_tiles";
-
-        /**
-         * Quick Settings Panel Dynamic Tiles
-         * number of tiles per row in quick settings
-         *
-         * @hide
-         */
-        public static final String QUICK_TILES_PER_ROW = "quick_tiles_per_row";
-
-        /**
-         * number of tiles per row in quick settings
-         *
-         * @hide
-         */
-        public static final String QUICK_TILES_PER_ROW_DUPLICATE_LANDSCAPE = "quick_tiles_per_row_duplicate_landscape";
-
-        /**
-         * text color on qs tiles
-         *
-         * @hide
-         */
-        public static final String QUICK_TILES_TEXT_COLOR = "quick_tiles_text_color";
-
-        /**
-         * qs tiles background color
-         *
-         * @hide
-         */
-        public static final String QUICK_TILES_BG_COLOR = "quick_tiles_bg_color";
-
-        /**
-         * Animate-flip Quick Settings Panel Tiles on click
-         *
-         * @hide
-         */
-        public static final String QUICK_SETTINGS_TILES_FLIP = "quick_settings_tiles_flip";
-
-        /**
-         * Quick Settings Panel Tiles to Use
-         *
-         * @hide
-         */
-        public static final String QUICK_TILES_BG_PRESSED_COLOR = "quick_tiles_bg_pressed_color";
-
-        /**
-         * Quick Settings Tile Content
-         *
-         * @hide
-         */
-        public static final String QS_DYNAMIC_ALARM = "qs_dyanmic_alarm";
-
-        /**
-         * Quick Settings Panel Dynamic Tiles
-         *
-         * @hide
-         */
-        public static final String QS_DYNAMIC_BUGREPORT = "qs_dyanmic_bugreport";
-
-        /**
-         * Quick Settings Panel Dynamic Tiles
-         *
-         * @hide
-         */
-        public static final String QS_DYNAMIC_IME = "qs_dyanmic_ime";
-
-        /**
-         * Quick Settings Panel Dynamic Tiles
-         *
-         * @hide
-         */
-        public static final String QS_DYNAMIC_USBTETHER = "qs_dyanmic_usbtether";
-
-        /**
-         * Quick Settings Panel Dynamic Tiles
-         *
-         * @hide
-         */
-        public static final String QS_DYNAMIC_DOCK_BATTERY = "qs_dyanmic_dock_battery";
-
-       /**
-        * Override and forcefully disable the fullscreen keyboard
-        * @hide
-        */
-        public static final String DISABLE_FULLSCREEN_KEYBOARD = "disable_fullscreen_keyboard";
-
-        /**
-         * Quick Settings Panel Dynamic Tiles
-         * @hide
-         */
-        public static final String QS_DYNAMIC_WIFI = "qs_dyanmic_wifi";
-
-        /**
-         * Quick Settings Quick Pulldown
-         *
-         * @hide
-         */
-        public static final String QS_QUICK_PULLDOWN = "qs_quick_pulldown";
-
-        /**
-         * Quick Settings Collapse Pane
-         *
-         * @hide
-         */
-        public static final String QS_COLLAPSE_PANEL = "qs_collapse_panel";
-
-        /**
-         * Use the Notification Power Widget? (Who wouldn't!)
-         *
-         * @hide
-         */
-        public static final String EXPANDED_VIEW_WIDGET = "expanded_view_widget";
-
-        /**
-         * Whether to hide the notification screen after clicking on a widget
-         * button
-         *
-         * @hide
-         */
-        public static final String EXPANDED_HIDE_ONCHANGE = "expanded_hide_onchange";
-
-        /**
-         * Hide scroll bar in power widget
-         *
-         * @hide
-         */
-        public static final String EXPANDED_HIDE_SCROLLBAR = "expanded_hide_scrollbar";
-
-        /**
-         * Haptic feedback in power widget
-         *
-         * @hide
-         */
-        public static final String EXPANDED_HAPTIC_FEEDBACK = "expanded_haptic_feedback";
-
-        /**
-         * Widget Buttons to Use
-         *
-         * @hide
-         */
-        public static final String WIDGET_BUTTONS = "expanded_widget_buttons";
-
-        /**
-         * Widget Buttons to Use - Tablet
-         *
-         * @hide
-         */
-        public static final String WIDGET_BUTTONS_TABLET = "expanded_widget_buttons_tablet";
-
-        /**
-         * Navigation controls to Use
-         *
-         * @hide
-         */
-        public static final String NAV_BUTTONS = "nav_buttons";
-
-        /**
-        * Notification Power Widget - Custom Brightness Mode
-        * @hide
-        */
-        public static final String EXPANDED_BRIGHTNESS_MODE = "expanded_brightness_mode";
-
-        /**
-        * Notification Power Widget - Custom Network Mode
-        * @hide
-        */
-        public static final String EXPANDED_NETWORK_MODE = "expanded_network_mode";
-
-        /**
-        * Notification Power Widget - Custom Screen Timeout
-        * @hide
-        */
-        public static final String EXPANDED_SCREENTIMEOUT_MODE = "expanded_screentimeout_mode";
-
-        /**
-        * Notification Power Widget - Custom Ring Mode
-        * @hide
-        */
-        public static final String EXPANDED_RING_MODE = "expanded_ring_mode";
-
-        /**
-        * Notification Power Widget - Custom Torch Mode
-        * @hide
-        */
-        public static final String EXPANDED_FLASH_MODE = "expanded_flash_mode";
-
-        /**
-        * AutoHide CombinedBar on tablets.
-        * @hide
-        */
-        public static final String COMBINED_BAR_AUTO_HIDE = "combined_bar_auto_hide";
-
-        /**
-         * Display style of AM/PM next to clock in status bar
-         * 0: Normal display (Eclair stock)
-         * 1: Small display (Froyo stock)
-         * 2: No display (Gingerbread/ICS stock)
-         * default: 2
-         * @hide
-         */
-        public static final String STATUS_BAR_AM_PM = "status_bar_am_pm";
-
-        /**
-         * Display style of the status bar battery information
-         * 0: Display the stock battery information
-         * 1: Display cm battery percentage implementation / dont show stock icon
-         * 2: Display cm circle battery implementation without percentage
-         * 3: Display cm circle battery implementation with percentage
-         * 4: Hide the battery information
-         * default: 0
-         * @hide
-         */
-        public static final String STATUS_BAR_BATTERY = "status_bar_battery";
-
-        /**
-         * Whether to show the clock in status bar
-         * of the stock battery icon
-         * 0: don't show the clock
-         * 1: show the clock
-         * default: 1
-         * @hide
-         */
-        public static final String STATUS_BAR_CLOCK = "status_bar_clock";
-
-        /**
-         * Whether to show the signal text or signal bars.
-         * default: 0
-         * 0: show signal bars
-         * 1: show signal text numbers
-         * 2: show signal text numbers w/small dBm appended
-         * @hide
-         */
-        public static final String STATUS_BAR_SIGNAL_TEXT = "status_bar_signal";
-
-        /**
-         * Circle battery icon color
-         * in statusbar
-         */
-        public static final String STATUS_BAR_CIRCLE_BATTERY_COLOR = "status_bar_circle_battery_color";
-
-        /**
-         * Circle battery icon text color
-         * in statusbar
-         */
-        public static final String STATUS_BAR_CIRCLE_BATTERY_TEXT_COLOR = "status_bar_circle_battery_text_color";
-
-        /**
-         * Circle battery animation speed during charge
-         * in statusbar
-         */
-        public static final String STATUS_BAR_CIRCLE_BATTERY_ANIMATIONSPEED = "status_bar_circle_battery_animationspeed";
-
-        /**
-         * Circle battery icon reset helper
-         * in statusbar
-         */
-        public static final String STATUS_BAR_CIRCLE_BATTERY_RESET = "status_bar_circle_battery_reset";
-
-        /**
-         * AM/PM Style for clock options
-         * 0 - Normal AM/PM
-         * 1 - Small AM/PM
-         * 2 - No AM/PM
-         * @hide
-         */
-        public static final String STATUSBAR_CLOCK_AM_PM_STYLE = "statusbar_clock_am_pm_style";
-
-        /**
-         * Style of clock
-         * 0 - Hide Clock
-         * 1 - Right Clock
-         * 2 - Center Clock
-         * @hide
-         */
-        public static final String STATUSBAR_CLOCK_STYLE = "statusbar_clock_style";
-
-        /**
-         * Setting for clock color
-         * @hide
-         */
-        public static final String STATUSBAR_CLOCK_COLOR = "statusbar_clock_color";
-
-        /**
-        * @hide
-        * Shows custom date before clock time
-        * 0 - No Date
-        * 1 - Small Date
-        * 2 - Normal Date
-        */
-        public static final String STATUSBAR_CLOCK_DATE_DISPLAY = "statusbar_clock_date_display";
-
-        /**
-        * @hide
-        * Sets the date string style
-        * 0 - Regular style
-        * 1 - Lowercase
-        * 2 - Uppercase
-        */
-        public static final String STATUSBAR_CLOCK_DATE_STYLE = "statusbar_clock_date_style";
-
-        /**
-        * @hide
-        * Stores the java DateFormat string for the date
-        */
-        public static final String STATUSBAR_CLOCK_DATE_FORMAT = "statusbar_clock_date_format";
-
-
-         /**
-         * Whether to control brightness from status bar
-         *
-         * @hide
-         */
-        public static final String STATUS_BAR_BRIGHTNESS_CONTROL = "status_bar_brightness_control";
-
-        /**
-         * Whether to show the IME switcher in the status bar
-         * @hide
-         */
-        public static final String STATUS_BAR_IME_SWITCHER = "status_bar_ime_switcher";
-
-         /**
-         * Expanded desktop on/off state
-         * @hide
-         */
-        public static final String EXPANDED_DESKTOP_STATE = "expanded_desktop_state";
-
-        /**
-         * Expanded desktop style (with status bar or without status bar)
-         * @hide
-         */
-        public static final String EXPANDED_DESKTOP_STYLE = "expanded_desktop_style";
-        
-        /*
-         * This will hide tabUI extras; compatibility button etc.
-         * @ hide
-         */
-        public static final String HIDE_EXTRAS_SYSTEM_BAR = "hide_extras_system_bar";
-        
-        /**
-         * Whether Status bar should be hiidden when there are no
-         * notifications
-         * @hide
-         */
-        public static final String AUTO_HIDE_STATUSBAR = "auto_hide_statusbar";
-        
-        /**
-         * Whether Status bar can be shown by swiping down in fullscreen apps
-         * @hide
-         */
-        public static final String FULLSCREEN_STATUSBAR = "fullscreen_statusbar"; 
-
-        /**
-         * Timeout of fullscreen Status bar
-         * @hide
-         */
-        public static final String FULLSCREEN_STATUSBAR_TIMEOUT = "fullscreen_statusbar_timeout"; 
-
-        /**
-         * Whether Status Bar is currently hidden or not
-         * @hide
-         */
-        public static final String HIDE_STATUSBAR = "hide_statusbar";
-
-        /**
-         * whether which Ram Usage Bar mode is used on recent switcher
-         * 0 = none, 1 = only app use, 2 = app and cache use, 3 = app, cache and system use
-         * @hide
-         */
-        public static final String RECENTS_RAM_BAR_MODE = "recents_ram_bar_mode";
-
-        /**
-         * Ram Usage Bar system mem color
-         *
-         * @hide
-         */
-        public static final String RECENTS_RAM_BAR_MEM_COLOR = "recents_ram_bar_mem_color";
-
-        /**
-         * Ram Usage Bar cached mem color
-         *
-         * @hide
-         */
-        public static final String RECENTS_RAM_BAR_CACHE_COLOR = "recents_ram_bar_cache_color";
-
-        /**
-         * Ram Usage Bar app mem color
-         *
-         * @hide
-         */
-        public static final String RECENTS_RAM_BAR_ACTIVE_APPS_COLOR = "recents_ram_bar_active_apps_color";
-
-        /**
-         * User Interface State
-         * 1 = Rebuild UI, resets to 0 automatically
-         * @hide
-         */
-        public static final String USER_INTERFACE_STATE = "user_interface_state";
-
-       /**
-        * Whether fcharge is enabled or not if kernel supports it
-        * @hide
-        */
-        public static final String FCHARGE_ENABLED = "fcharge_enabled";
-
-        /**
-         * Whether to use a separate delay for "slide to unlock" and security
-         * lock
-         * @hide
-         */
-        public static final String SCREEN_LOCK_SLIDE_DELAY_TOGGLE = "screen_lock_slide_delay_toggle";
-
-        /**
-         * How many ms to delay before enabling the "slide to unlock" screen
-         * lock when the screen goes off due to timeout
-         * @hide
-         */
-        public static final String SCREEN_LOCK_SLIDE_TIMEOUT_DELAY = "screen_lock_slide_timeout_delay";
-
-        /**
-         * How many ms to delay before enabling the "slide to unlock" screen
-         * lock when the screen is turned off by the user
-         * @hide
-         */
-        public static final String SCREEN_LOCK_SLIDE_SCREENOFF_DELAY = "screen_lock_slide_screenoff_delay";
-
-        /**
-         * Whether to use the custom quick unlock screen control
-         * @hide
-         */
-        public static final String LOCKSCREEN_QUICK_UNLOCK_CONTROL = "lockscreen_quick_unlock_control";
-
-        /**
-         * Boolean value whether to link ringtone and notification volumes
-         *
-         * @hide
-         */
-        public static final String VOLUME_LINK_NOTIFICATION = "volume_link_notification";
-
-       
-        /**
-         * Whether to unlock the menu key.  The value is boolean (1 or 0).
-         * @hide
-         */
-        public static final String MENU_UNLOCK_SCREEN = "menu_unlock_screen";
-
-        /**
-         * Whether to wake the screen with the volume keys, the value is boolean.
-         * @hide
-         */
-        public static final String VOLUME_WAKE_SCREEN = "volume_wake_screen";
-
-        /**
-         * Whether or not volume button music controls should be enabled to seek media tracks
-         * @hide
-         */
-        public static final String VOLBTN_MUSIC_CONTROLS = "volbtn_music_controls";
-
-        /**
-         * Whether or not to launch default music player when headset is connected
-         * @hide
-         */
-        public static final String HEADSET_CONNECT_PLAYER = "headset_connect_player";
-
-        /**
-         * Whether national data roaming should be used.
-         * @hide
-         */
-        public static final String MVNO_ROAMING = "mvno_roaming";
-
-        /**
-         * Whether to enable quiet hours.
-         * @hide
-         */
-        public static final String QUIET_HOURS_ENABLED = "quiet_hours_enabled";
-
-        /**
-         * Sets when quiet hours starts. This is stored in minutes from the start of the day.
-         * @hide
-         */
-        public static final String QUIET_HOURS_START = "quiet_hours_start";
-
-        /**
-         * Sets when quiet hours end. This is stored in minutes from the start of the day.
-         * @hide
-         */
-        public static final String QUIET_HOURS_END = "quiet_hours_end";
-
-        /**
-         * Whether to remove the sound from outgoing notifications during quiet hours.
-         * @hide
-         */
-        public static final String QUIET_HOURS_MUTE = "quiet_hours_mute";
-
-        /**
-         * Whether to disable haptic feedback during quiet hours.
-         * @hide
-         */
-        public static final String QUIET_HOURS_HAPTIC = "quiet_hours_haptic";
-
-        /**
-         * Whether to remove the vibration from outgoing notifications during quiet hours.
-         * @hide
-         */
-        public static final String QUIET_HOURS_STILL = "quiet_hours_still";
-        
-        /**
-         * Whether to attempt to dim the LED color during quiet hours.
-         * @hide
-         */
-        public static final String QUIET_HOURS_DIM = "quiet_hours_dim";
-                
-        /**
-         * Do you want popups/floating windows?
-         * @hide
-         */
-        public static final String WE_WANT_POPUPS = "we_want_popups";
-
-        /**
-         * PA PIE Settings
-         */
-
-        /**
-         * On or off the Pie.
-         * @hide
-         */
-        public static final String PIE_CONTROLS = "pie_controls";
-
-        /**
-         * Pie menu, should default to 1 (yes, show)
-         * @hide
-         */
-        public static final String PIE_MENU = "pie_menu";
-
-        /**
-         * Pie search, should default to 1 (yes, show)
-         * @hide
-         */
-        public static final String PIE_SEARCH = "pie_search";
-
-        /**
-         * Pie will not rotate. Should default to 1 (yes, do not rotate)
-         * @hide
-         */
-        public static final String PIE_STICK = "pie_stick";
-
-        /**
-         * Pie last app, should default to 0 (no, show only when needed)
-         * @hide
-         */
-        public static final String PIE_LAST_APP = "pie_last_app";
-
-        /**
-         * Pie gap angle, should default to 3
-         * @hide
-         */
-        public static final String PIE_GAP = "pie_gap";
-
-        /**
-         * Pie trigger fraction, should default to 1
-         * @hide
-         */
-        public static final String PIE_TRIGGER = "pie_trigger";
-
-        /**
-         * Location of the pie in the screen
-         * @hide
-         */
-        public static final String PIE_GRAVITY = "pie_gravity";
-
-        /**
-         * Pie status report
-         * @hide
-         */
-        public static final String PIE_MODE = "pie_mode";
-
-        /**
-         * Pie size fraction
-         * @hide
-         */
-        public static final String PIE_SIZE = "pie_size";
-
-        /**
-         * Pie Notification Ability
-         * @hide
-         */
-        public static final String PIE_NOTIFICATIONS = "pie_notifications";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_ENABLE_COLOR = "pie_enable_color";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_JUICE = "pie_juice";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_BUTTON_COLOR = "pie_button_color";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_SNAP_BACKGROUND = "pie_snap_background";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_BACKGROUND = "pie_background";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_SELECT = "pie_select";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_OUTLINES = "pie_outlines";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_STATUS_CLOCK = "pie_status_clock";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_STATUS = "pie_status";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_CHEVRON_LEFT = "pie_chevron_left";
-
-        /**
-         * @hide
-         */
-        public static final String PIE_CHEVRON_RIGHT = "pie_chevron_right";
-
-        /**
-         * Center Pie? Should default to 1 (yes, center)
-         * @hide
-         */
-        public static final String PIE_CENTER = "pie_center";
-        
-        /**  
-         * Whether to enable lockscreen rotation
-         * @hide
-         */
-        public static final String LOCKSCREEN_AUTO_ROTATE = "lockscreen_auto_rotate";
-
-        /**
-         * Sets the lockscreen background style
-         * @hide
-         */
-        public static final String LOCKSCREEN_BACKGROUND = "lockscreen_background";
-
-         /**
-         * Action for long-pressing back button on lock screen
-         * @hide
-         */
-        public static final String LOCKSCREEN_LONG_BACK_ACTION = "lockscreen_long_back_action";
-
-        /**
-         * Action for long-pressing home button on lock screen
-         * @hide
-         */
-        public static final String LOCKSCREEN_LONG_HOME_ACTION = "lockscreen_long_home_action";
-
-        /**
-         * Action for long-pressing menu button on lock screen
-         * @hide
-         */
-        public static final String LOCKSCREEN_LONG_MENU_ACTION = "lockscreen_long_menu_action";
-
-         /**
-          * Always show the battery status on the lockscreen
-          * @hide
-          */
-        public static final String LOCKSCREEN_ALWAYS_SHOW_BATTERY = "lockscreen_always_show_battery";
-
-        /**
-         * Show the pending notification counts as overlays on the status bar
-         * @hide
-         */
-        public static final String STATUS_BAR_NOTIF_COUNT = "status_bar_notif_count";
-
-        /**
-         * Enable Stylus Gestures
-         *
-         * @hide
-         */
-        public static final String ENABLE_STYLUS_GESTURES = "enable_stylus_gestures";
-
-        /**
-         * Left Swipe Action
-         *
-         * @hide
-         */
-        public static final String GESTURES_LEFT_SWIPE = "gestures_left_swipe";
-
-        /**
-         * Right Swipe Action
-         *
-         * @hide
-         */
-        public static final String GESTURES_RIGHT_SWIPE = "gestures_right_swipe";
-
-        /**
-         * Up Swipe Action
-         *
-         * @hide
-         */
-        public static final String GESTURES_UP_SWIPE = "gestures_up_swipe";
-
-        /**
-         * down Swipe Action
-         *
-         * @hide
-         */
-        public static final String GESTURES_DOWN_SWIPE = "gestures_down_swipe";
-
-        /**
-         * Long press Action
-         *
-         * @hide
-         */
-        public static final String GESTURES_LONG_PRESS = "gestures_long_press";
-
-        /**
-         * double tap Action
-         *
-         * @hide
-         */
-        public static final String GESTURES_DOUBLE_TAP = "gestures_double_tap";
-
-        /**
-         * Whether to show the battery bar
-         * @hide
-         */
-        public static final String STATUSBAR_BATTERY_BAR = "statusbar_battery_bar";
-
-        /**
-         * @hide
-         */
-        public static final String STATUSBAR_BATTERY_BAR_COLOR = "statusbar_battery_bar_color";
-
-        /**
-         * @hide
-         */
-        public static final String STATUSBAR_BATTERY_BAR_THICKNESS = "statusbar_battery_bar_thickness";
-
-        /**
-         * @hide
-         */
-        public static final String STATUSBAR_BATTERY_BAR_STYLE = "statusbar_battery_bar_style";
-
-        /**
-         * @hide
-         */
-        public static final String STATUSBAR_BATTERY_BAR_ANIMATE = "statusbar_battery_bar_animate";
-
-        /**
-         * Show the pending notification counts as overlays on the status bar
-         * @hide
-         */
-        public static final String SYSTEM_PROFILES_ENABLED = "system_profiles_enabled";
-
-        /**
-         * Whether the power menu reboot menu is enabled
-         * @hide
-         */
-        public static final String POWER_MENU_REBOOT_ENABLED = "power_menu_reboot_enabled";
-
-        /**
-         * Whether power menu screenshot is enabled
-         * @hide
-         */
-        public static final String POWER_MENU_SCREENSHOT_ENABLED = "power_menu_screenshot_enabled";
-
-        /**
-         * Whether power menu expanded desktop is enabled
-         * @hide
-         */
-        public static final String POWER_MENU_EXPANDED_DESKTOP_ENABLED = "power_menu_expanded_desktop_enabled";
-
-        /**
-         * Whether power menu profiles switcher is enabled
-         * @hide
-         */
-        public static final String POWER_MENU_PROFILES_ENABLED = "power_menu_profiles_enabled";
-
-        /**
-         * Whether power menu airplane toggle is enabled
-         * @hide
-         */
-        public static final String POWER_MENU_AIRPLANE_ENABLED = "power_menu_airplane_enabled";
-
-        /**
-         * Whether power menu user switcher is enabled
-         * @hide
-         */
-        public static final String POWER_MENU_USER_ENABLED = "power_menu_user_enabled";
-
-        /**
-         * Whether power menu silent mode is enabled
-         * @hide
-         */
-        public static final String POWER_MENU_SOUND_ENABLED = "power_menu_silent_enabled";
-
-        /**
-         * Whether to unlock the screen with the home key.  The value is boolean (1 or 0).
-         * @hide
-         */
-        public static final String HOME_UNLOCK_SCREEN = "home_unlock_screen";
-
-        /**
-         * Whether the lockscreen vibrate should be enabled.
-         * @hide
-         */
-        public static final String LOCKSCREEN_VIBRATE_ENABLED = "lockscreen.vibrate_enabled";
-
-        /**
-         * Show the pending notification counts as overlays on the status bar
-         * Whether to enable custom rebindings of the actions performed on
-         * certain key press events.
-         * @hide
-         */
-        public static final String HARDWARE_KEY_REBINDING = "hardware_key_rebinding";
-
-         /**
-          * Action to perform when the home key is long-pressed. (Default is 2)
-          * 0 - Nothing
-          * 1 - Menu
-          * 2 - App-switch
-          * 3 - Search
-          * 4 - Voice search
-          * 5 - In-app search
-          * @hide
-          */
-         public static final String KEY_HOME_LONG_PRESS_ACTION = "key_home_long_press_action";
-
-         /**
-          * Action to perform when the menu key is pressed. (Default is 1)
-          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
-          * @hide
-          */
-         public static final String KEY_MENU_ACTION = "key_menu_action";
-
-         /**
-          * Action to perform when the menu key is long-pressed.
-          * (Default is 0 on devices with a search key, 3 on devices without)
-          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
-          * @hide
-          */
-         public static final String KEY_MENU_LONG_PRESS_ACTION = "key_menu_long_press_action";
-
-         /**
-          * Action to perform when the assistant (search) key is pressed. (Default is 3)
-          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
-          * @hide
-          */
-         public static final String KEY_ASSIST_ACTION = "key_assist_action";
-
-         /**
-          * Swap volume buttons when the screen is rotated
-          * 0 - Disabled
-          * 1 - Enabled (screen is rotated by 90 or 180 degrees: phone, hybrid)
-          * 2 - Enabled (screen is rotated by 180 or 270 degrees: tablet)
-          * @hide
-          */
-         public static final String SWAP_VOLUME_KEYS_ON_ROTATION = "swap_volume_keys_on_rotation";
-
-        /**
-         * Weather to minimize lockscreen challenge on screen turned on
-         * @hide
-         */
-        public static final String LOCKSCREEN_MAXIMIZE_WIDGETS = "lockscreen_maximize_widgets";
-
-         /**
-          * Action to perform when the assistant (search) key is long-pressed. (Default is 4)
-          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
-          * @hide
-          */
-         public static final String KEY_ASSIST_LONG_PRESS_ACTION = "key_assist_long_press_action";
-
-         /**
-          * Action to perform when the app switch key is pressed. (Default is 2)
-          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
-          * @hide
-          */
-         public static final String KEY_APP_SWITCH_ACTION = "key_app_switch_action";
-
-         /**
-          * Action to perform when the app switch key is long-pressed. (Default is 0)
-          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
-          * @hide
-          */
-         public static final String KEY_APP_SWITCH_LONG_PRESS_ACTION = "key_app_switch_long_press_action";
-
-        /**
-         * Control the display of the action overflow button within app UI.
-         * 0 = use system default
-         * 1 = force on
-         * @hide
-         */
-        public static final String UI_FORCE_OVERFLOW_BUTTON = "ui_force_overflow_button";
-
-         /**
-          * Volume keys control cursor in text fields (default is 0)
-          * 0 - Disabled
-          * 1 - Volume up/down moves cursor left/right
-          * 2 - Volume up/down moves cursor right/left
-          * @hide
-          */
-         public static final String VOLUME_KEY_CURSOR_CONTROL = "volume_key_cursor_control";
-
-        /**
-         * toggle to "fix" the following: (found in NotificationManagerService)
-         *  new in 4.2: if there was supposed to be a sound and we're in vibrate mode,
-         *  we always vibrate, even if no vibration was specified
-         * @hide
-         */
-        public static final String NOTIFICATION_CONVERT_SOUND_TO_VIBRATION = "convert_sound_to_vibration";
-
-        /**
-         * Use alternative application resolver
-         */
-        public static final String ACTIVITY_RESOLVER_USE_ALT = "activity_resolver_use_alt";
-        /**
-         * Custom navring actions
-         *
-
-         * Whether electronic beam animation is enabled or not
-         * @hide
-         */
-        public static final String SYSTEM_POWER_ENABLE_CRT_OFF = "system_power_enable_crt_off";
-
-        /**
-         * Electronic beam animation mode
-         * 0 = always horizontal, 1 = always vertical, 2 = dependent on orientation
-         * @hide
-         */
-        public static final String SYSTEM_POWER_CRT_MODE = "system_power_crt_mode";
-
-        /**
-         * Is current activity launcher or not
-         * @hide
-         */
-        public static final String IS_HOME = "is_home";
-
-        /**
-         * Sets transparency of statusbar
-         * @hide
-         */
-        public static final String STATUS_BAR_ALPHA = "status_bar_alpha";
-      
-        /**
-         * Sets color of statusbar
-         * @hide
-         */
-        public static final String STATUS_BAR_COLOR = "status_bar_color";
-        
-        /**
-         * Sets transparency mode of status and navigation bar
-         * 0 = only home, 1 = keyguard and home (default), 2 = always
-         * @hide
-         */
-        public static final String STATUS_NAV_BAR_ALPHA_MODE = "status_nav_bar_alpha_mode";
-
-        /**
-         * Whether to allow notification vibration while notification alerts are disabled
-         * (e.g. during phone calls). The vibration pattern to be used will be a subtle one;
-         * custom vibration is disabled at that point.
-         * @hide
-         */
-        public static final String NOTIFICATION_VIBRATE_DURING_ALERTS_DISABLED = "vibrate_while_no_alerts";
-
-        /**
-         * Custom navring actions
-         *
-         * @hide
-         */
-        public static final String[] NAVIGATION_RING_TARGETS = new String[] {
-            "navigation_ring_targets_0",
-            "navigation_ring_targets_1",
-            "navigation_ring_targets_2",
-        };
-
-        /**
-         * Holds the text for the Carrier label. An empty string
-         * will bring the default text back.
-         * @hide
-         */
-        public static final String CUSTOM_CARRIER_LABEL = "custom_carrier_label";
-
-        /**
-         * Notifications Expand Behavior
-         * @hide
-         */
-        public static final String NOTIFICATIONS_BEHAVIOUR = "notifications_behaviour";
-        
-        /**
-        * Sets the portrait background of notification drawer
-        * @hide
-        */
-        public static final String NOTIFICATION_BACKGROUND = "notification_background";
-
-        /**
-        * Sets the landscape background of notification drawer
-        * @hide
-        */
-        public static final String NOTIFICATION_BACKGROUND_LANDSCAPE = "notification_background_landscape";
-
-        /**
-        * Sets the alpha (transparency) of notification wallpaper
-        * @hide
-        */
-        public static final String NOTIF_WALLPAPER_ALPHA = "notif_wallpaper_alpha";
- 
-        /**
-        * Sets the alpha (transparency) of notifications
-        * @hide
-        */
-        public static final String NOTIF_ALPHA = "notif_alpha";
-
-        /**
-         * @hide
-         */
-        public static final String MENU_LOCATION = "menu_location";
-
-        /**
-         * @hide
-         */
-        public static final String MENU_VISIBILITY = "menu_visibility";
-
-        /**
-         * @hide
-         */
-        public static final String NAVIGATION_BAR_BUTTONS_QTY = "navigation_bar_buttons_qty";
-
-        /**
-         * @hide
-         */
-        public static final String[] NAVIGATION_CUSTOM_ACTIVITIES = new String[] {
-            "navigation_custom_app_intent_0",
-            "navigation_custom_app_intent_1",
-            "navigation_custom_app_intent_2",
-            "navigation_custom_app_intent_3",
-            "navigation_custom_app_intent_4",
-            "navigation_custom_app_intent_5",
-            "navigation_custom_app_intent_6",
-        };
-
-        /**
-         * @hide
-         */
-        public static final String[] NAVIGATION_LONGPRESS_ACTIVITIES = new String[] {
-            "navigation_longpress_app_intent_0",
-            "navigation_longpress_app_intent_1",
-            "navigation_longpress_app_intent_2",
-            "navigation_longpress_app_intent_3",
-            "navigation_longpress_app_intent_4",
-            "navigation_longpress_app_intent_5",
-            "navigation_longpress_app_intent_6",
-        };
-
-        /**
-         * @hide
-         */
-        public static final String[] NAVIGATION_CUSTOM_APP_ICONS = new String[] {
-            "navigation_custom_app_icon_0",
-            "navigation_custom_app_icon_1",
-            "navigation_custom_app_icon_2",
-            "navigation_custom_app_icon_3",
-            "navigation_custom_app_icon_4",
-            "navigation_custom_app_icon_5",
-            "navigation_custom_app_icon_6",
-        };
-
-        /**
-         * Widgets to show, should be separated by |
-         */
-        public static final String NAVIGATION_BAR_WIDGETS = "navigation_bar_widgets";
-
-        /**
-         * @hide
-         */
-        public static final String NAVIGATION_BAR_BUTTON_ALPHA = "navigation_bar_button_alpha";
-
-        /**
-         * @hide
-         */
-        public static final String NAVIGATION_BAR_TINT = "navigation_bar_tint";
-
-        /**
-         * @hide
-         */
-        public static final String NAVIGATION_BAR_GLOW_TINT = "navigation_bar_glow_tint";
-
-        /**
-         * @hide
-         */
-        public static final String[] NAVIGATION_BAR_GLOW_DURATION = new String[] {
-            "navigation_bar_glow_duration_off",
-            "navigation_bar_glow_duration_on",
-        };
-
-       /**
-        * Lefty mode
-        * @hide
-        */
-        public static final String NAVIGATION_BAR_LEFTY_MODE = "navigation_bar_lefty_mode";
-
-       /**
-        *
-        * @hide
-        */
-        public static final String SYSTEMUI_NAVRING_AMOUNT = "systemui_navring_amount";
-
-       /**
-        *
-        * @hide
-        */
-        public static final String SYSTEMUI_NAVRING_LONG_ENABLE = "systemui_navring_long_enable";
-
-        /**
-         * Custom navring actions
-         *
-         * @hide
-         */
-        public static final String[] SYSTEMUI_NAVRING = new String[] {
-                "navring_0",
-                "navring_1",
-                "navring_2",
-                "navring_3",
-                "navring_4",
-        };
-
-        /**  
-         * Give MMS Notifications a breathing effect
-         * @hide
-         */
-        public static final String MMS_BREATH = "mms_breath";
-
-        /**	
-         * Give MMS Notifications a breathing effect
-         * @hide
-         */
-        public static final String MISSED_CALL_BREATH = "missed_call_breath";
-
-        /**
-         * Custom navring long press actions
-         *
-         * @hide
-         */
-        public static final String[] SYSTEMUI_NAVRING_LONG = new String[] {
-                "navring_long_0",
-                "navring_long_1",
-                "navring_long_2",
-                "navring_long_3",
-                "navring_long_4",
-        };
-
-        /**
-         * Volume key controls ringtone or media sound stream
-         *
-         * @hide
-         */
-        public static final String VOLUME_KEYS_CONTROL_RING_STREAM = "volume_keys_control_ring_stream";
-
-        /**
-         * Settings to backup. This is here so that it's in the same place as the settings
-         * keys and easy to update.
-         *
-         * NOTE: Settings are backed up and restored in the order they appear
-         *       in this array. If you have one setting depending on another,
-         *       make sure that they are ordered appropriately.
-         *
-         * @hide
-         */
-        public static final String[] SETTINGS_TO_BACKUP = {
-            STAY_ON_WHILE_PLUGGED_IN,   // moved to global
-            WIFI_USE_STATIC_IP,
-            WIFI_STATIC_IP,
-            WIFI_STATIC_GATEWAY,
-            WIFI_STATIC_NETMASK,
-            WIFI_STATIC_DNS1,
-            WIFI_STATIC_DNS2,
-            MMS_AUTO_RETRIEVAL,
-            MMS_AUTO_RETRIEVAL_ON_ROAMING,
-            BLUETOOTH_DISCOVERABILITY,
-            BLUETOOTH_DISCOVERABILITY_TIMEOUT,
-            DIM_SCREEN,
-            SCREEN_OFF_TIMEOUT,
-            SCREEN_BRIGHTNESS,
-            SCREEN_BRIGHTNESS_MODE,
-            SCREEN_AUTO_BRIGHTNESS_ADJ,
-            VIBRATE_INPUT_DEVICES,
-            MODE_RINGER,                // moved to global
-            MODE_RINGER_STREAMS_AFFECTED,
-            MUTE_STREAMS_AFFECTED,
-            VOLUME_VOICE,
-            VOLUME_SYSTEM,
-            VOLUME_RING,
-            VOLUME_MUSIC,
-            VOLUME_ALARM,
-            VOLUME_NOTIFICATION,
-            VOLUME_BLUETOOTH_SCO,
-            VOLUME_VOICE + APPEND_FOR_LAST_AUDIBLE,
-            VOLUME_SYSTEM + APPEND_FOR_LAST_AUDIBLE,
-            VOLUME_RING + APPEND_FOR_LAST_AUDIBLE,
-            VOLUME_MUSIC + APPEND_FOR_LAST_AUDIBLE,
-            VOLUME_ALARM + APPEND_FOR_LAST_AUDIBLE,
-            VOLUME_NOTIFICATION + APPEND_FOR_LAST_AUDIBLE,
-            VOLUME_BLUETOOTH_SCO + APPEND_FOR_LAST_AUDIBLE,
-            TEXT_AUTO_REPLACE,
-            TEXT_AUTO_CAPS,
-            TEXT_AUTO_PUNCTUATE,
-            TEXT_SHOW_PASSWORD,
-            AUTO_TIME,                  // moved to global
-            AUTO_TIME_ZONE,             // moved to global
-            TIME_12_24,
-            DATE_FORMAT,
-            ACCELEROMETER_ROTATION,
-            USER_ROTATION,
-            DTMF_TONE_WHEN_DIALING,
-            DTMF_TONE_TYPE_WHEN_DIALING,
-            HEARING_AID,
-            TTY_MODE,
-            NOISE_SUPPRESSION,
-            SOUND_EFFECTS_ENABLED,
-            HAPTIC_FEEDBACK_ENABLED,
-            POWER_SOUNDS_ENABLED,       // moved to global
-            DOCK_SOUNDS_ENABLED,        // moved to global
-            LOCKSCREEN_SOUNDS_ENABLED,
-            SHOW_WEB_SUGGESTIONS,
-            NOTIFICATION_LIGHT_PULSE,
-            NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR,
-            NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON,
-            NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF,
-            NOTIFICATION_VIBRATE_DURING_ALERTS_DISABLED,
-            SIP_CALL_OPTIONS,
-            SIP_RECEIVE_CALLS,
-            POINTER_SPEED,
-            QUIET_HOURS_ENABLED,
-            QUIET_HOURS_START,
-            QUIET_HOURS_END,
-            QUIET_HOURS_MUTE,
-            QUIET_HOURS_STILL,
-            QUIET_HOURS_DIM,
-            SYSTEM_PROFILES_ENABLED,
-            POWER_MENU_SCREENSHOT_ENABLED,
-            POWER_MENU_REBOOT_ENABLED,
-            POWER_MENU_PROFILES_ENABLED,
-            POWER_MENU_AIRPLANE_ENABLED,
-            POWER_MENU_SOUND_ENABLED,
-            POWER_MENU_USER_ENABLED,
-            LOCKSCREEN_VIBRATE_ENABLED,
-            LOCKSCREEN_ALWAYS_SHOW_BATTERY,
-        };
-
-        // Settings moved to Settings.Secure
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#ADB_ENABLED}
-         * instead
-         */
-        @Deprecated
-        public static final String ADB_ENABLED = Global.ADB_ENABLED;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#ANDROID_ID} instead
-         */
-        @Deprecated
-        public static final String ANDROID_ID = Secure.ANDROID_ID;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_ON} instead
-         */
-        @Deprecated
-        public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
-         */
-        @Deprecated
-        public static final String DATA_ROAMING = Global.DATA_ROAMING;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#DEVICE_PROVISIONED} instead
-         */
-        @Deprecated
-        public static final String DEVICE_PROVISIONED = Global.DEVICE_PROVISIONED;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#HTTP_PROXY} instead
-         */
-        @Deprecated
-        public static final String HTTP_PROXY = Global.HTTP_PROXY;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#INSTALL_NON_MARKET_APPS} instead
-         */
-        @Deprecated
-        public static final String INSTALL_NON_MARKET_APPS = Global.INSTALL_NON_MARKET_APPS;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#LOCATION_PROVIDERS_ALLOWED}
-         * instead
-         */
-        @Deprecated
-        public static final String LOCATION_PROVIDERS_ALLOWED = Secure.LOCATION_PROVIDERS_ALLOWED;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#LOGGING_ID} instead
-         */
-        @Deprecated
-        public static final String LOGGING_ID = Secure.LOGGING_ID;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#NETWORK_PREFERENCE} instead
-         */
-        @Deprecated
-        public static final String NETWORK_PREFERENCE = Global.NETWORK_PREFERENCE;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#PARENTAL_CONTROL_ENABLED}
-         * instead
-         */
-        @Deprecated
-        public static final String PARENTAL_CONTROL_ENABLED = Secure.PARENTAL_CONTROL_ENABLED;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#PARENTAL_CONTROL_LAST_UPDATE}
-         * instead
-         */
-        @Deprecated
-        public static final String PARENTAL_CONTROL_LAST_UPDATE = Secure.PARENTAL_CONTROL_LAST_UPDATE;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#PARENTAL_CONTROL_REDIRECT_URL}
-         * instead
-         */
-        @Deprecated
-        public static final String PARENTAL_CONTROL_REDIRECT_URL =
-            Secure.PARENTAL_CONTROL_REDIRECT_URL;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#SETTINGS_CLASSNAME} instead
-         */
-        @Deprecated
-        public static final String SETTINGS_CLASSNAME = Secure.SETTINGS_CLASSNAME;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#USB_MASS_STORAGE_ENABLED} instead
-         */
-        @Deprecated
-        public static final String USB_MASS_STORAGE_ENABLED = Global.USB_MASS_STORAGE_ENABLED;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#USE_GOOGLE_MAIL} instead
-         */
-        @Deprecated
-        public static final String USE_GOOGLE_MAIL = Global.USE_GOOGLE_MAIL;
-
-       /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Global#WIFI_MAX_DHCP_RETRY_COUNT} instead
-         */
-        @Deprecated
-        public static final String WIFI_MAX_DHCP_RETRY_COUNT = Global.WIFI_MAX_DHCP_RETRY_COUNT;
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Global#WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS} instead
-         */
-        @Deprecated
-        public static final String WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS =
-                Global.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS;
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Global#WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON} instead
-         */
-        @Deprecated
-        public static final String WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON =
-                Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON;
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Global#WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY} instead
-         */
-        @Deprecated
-        public static final String WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY =
-                Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_NUM_OPEN_NETWORKS_KEPT}
-         * instead
-         */
-        @Deprecated
-        public static final String WIFI_NUM_OPEN_NETWORKS_KEPT = Global.WIFI_NUM_OPEN_NETWORKS_KEPT;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_ON} instead
-         */
-        @Deprecated
-        public static final String WIFI_ON = Global.WIFI_ON;
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE}
-         * instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE =
-                Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_AP_COUNT} instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_AP_COUNT = Secure.WIFI_WATCHDOG_AP_COUNT;
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS} instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS =
-                Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS;
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED} instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED =
-                Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED;
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS}
-         * instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS =
-                Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS;
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT} instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT =
-            Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_MAX_AP_CHECKS}
-         * instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_MAX_AP_CHECKS = Secure.WIFI_WATCHDOG_MAX_AP_CHECKS;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_WATCHDOG_ON} instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_ON = Global.WIFI_WATCHDOG_ON;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_PING_COUNT} instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_PING_COUNT = Secure.WIFI_WATCHDOG_PING_COUNT;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_PING_DELAY_MS}
-         * instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_PING_DELAY_MS = Secure.WIFI_WATCHDOG_PING_DELAY_MS;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_PING_TIMEOUT_MS}
-         * instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_PING_TIMEOUT_MS =
-            Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS;
-
-        /**
-         * boolean value. toggles using arrow key locations on nav bar
-         * as left and right dpad keys
-         * @hide
-         */
-        public static final String NAVIGATION_BAR_MENU_ARROW_KEYS = "navigation_bar_menu_arrow_keys";
-
-        /**
-         * Navigation bar alpha while in homescreen and lockscreen.
-         *
-         * @hide
-         */
-        public static final String NAVIGATION_BAR_ALPHA = "navigation_bar_alpha";
-
-        /**
-         * Navigation bar color.
-         *
-         * @hide
-         */
-        public static final String NAVIGATION_BAR_COLOR = "navigation_bar_color";
-
-    }
-
-    /**
-     * Secure system settings, containing system preferences that applications
-     * can read but are not allowed to write.  These are for preferences that
-     * the user must explicitly modify through the system UI or specialized
-     * APIs for those values, not modified directly by applications.
-     */
-    public static final class Secure extends NameValueTable {
-        public static final String SYS_PROP_SETTING_VERSION = "sys.settings_secure_version";
-
-        /**
-         * The content:// style URL for this table
-         */
-        public static final Uri CONTENT_URI =
-            Uri.parse("content://" + AUTHORITY + "/secure");
-
-        // Populated lazily, guarded by class object:
-        private static final NameValueCache sNameValueCache = new NameValueCache(
-                SYS_PROP_SETTING_VERSION,
-                CONTENT_URI,
-                CALL_METHOD_GET_SECURE,
-                CALL_METHOD_PUT_SECURE);
-
-        private static ILockSettings sLockSettings = null;
-
-        private static boolean sIsSystemProcess;
-        private static final HashSet<String> MOVED_TO_LOCK_SETTINGS;
-        private static final HashSet<String> MOVED_TO_GLOBAL;
-        static {
-            MOVED_TO_LOCK_SETTINGS = new HashSet<String>(3);
-            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_PATTERN_ENABLED);
-            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_PATTERN_VISIBLE);
-            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_SHOW_ERROR_PATH);
-            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_DOTS_VISIBLE);
-            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED);
-
-            MOVED_TO_GLOBAL = new HashSet<String>();
-            MOVED_TO_GLOBAL.add(Settings.Global.ADB_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.ASSISTED_GPS_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.BLUETOOTH_ON);
-            MOVED_TO_GLOBAL.add(Settings.Global.CDMA_CELL_BROADCAST_SMS);
-            MOVED_TO_GLOBAL.add(Settings.Global.CDMA_ROAMING_MODE);
-            MOVED_TO_GLOBAL.add(Settings.Global.CDMA_SUBSCRIPTION_MODE);
-            MOVED_TO_GLOBAL.add(Settings.Global.DATA_ACTIVITY_TIMEOUT_MOBILE);
-            MOVED_TO_GLOBAL.add(Settings.Global.DATA_ACTIVITY_TIMEOUT_WIFI);
-            MOVED_TO_GLOBAL.add(Settings.Global.DATA_ROAMING);
-            MOVED_TO_GLOBAL.add(Settings.Global.DEVELOPMENT_SETTINGS_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.DEVICE_PROVISIONED);
-            MOVED_TO_GLOBAL.add(Settings.Global.DISPLAY_DENSITY_FORCED);
-            MOVED_TO_GLOBAL.add(Settings.Global.DISPLAY_SIZE_FORCED);
-            MOVED_TO_GLOBAL.add(Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE);
-            MOVED_TO_GLOBAL.add(Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE);
-            MOVED_TO_GLOBAL.add(Settings.Global.INSTALL_NON_MARKET_APPS);
-            MOVED_TO_GLOBAL.add(Settings.Global.MOBILE_DATA);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_DEV_BUCKET_DURATION);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_DEV_DELETE_AGE);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_DEV_PERSIST_BYTES);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_DEV_ROTATE_AGE);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_GLOBAL_ALERT_BYTES);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_POLL_INTERVAL);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_REPORT_XT_OVER_DEV);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_SAMPLE_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_TIME_CACHE_MAX_AGE);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_BUCKET_DURATION);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_DELETE_AGE);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_PERSIST_BYTES);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_ROTATE_AGE);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_TAG_BUCKET_DURATION);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_TAG_DELETE_AGE);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_TAG_PERSIST_BYTES);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_TAG_ROTATE_AGE);
-            MOVED_TO_GLOBAL.add(Settings.Global.NETWORK_PREFERENCE);
-            MOVED_TO_GLOBAL.add(Settings.Global.NITZ_UPDATE_DIFF);
-            MOVED_TO_GLOBAL.add(Settings.Global.NITZ_UPDATE_SPACING);
-            MOVED_TO_GLOBAL.add(Settings.Global.NTP_SERVER);
-            MOVED_TO_GLOBAL.add(Settings.Global.NTP_TIMEOUT);
-            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_ERROR_POLL_COUNT);
-            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_LONG_POLL_INTERVAL_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_MAX_PDP_RESET_FAIL_COUNT);
-            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_POLL_INTERVAL_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_TRIGGER_PACKET_COUNT);
-            MOVED_TO_GLOBAL.add(Settings.Global.SAMPLING_PROFILER_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.SETUP_PREPAID_DATA_SERVICE_URL);
-            MOVED_TO_GLOBAL.add(Settings.Global.SETUP_PREPAID_DETECTION_REDIR_HOST);
-            MOVED_TO_GLOBAL.add(Settings.Global.SETUP_PREPAID_DETECTION_TARGET_URL);
-            MOVED_TO_GLOBAL.add(Settings.Global.TETHER_DUN_APN);
-            MOVED_TO_GLOBAL.add(Settings.Global.TETHER_DUN_REQUIRED);
-            MOVED_TO_GLOBAL.add(Settings.Global.TETHER_SUPPORTED);
-            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_HELP_URI);
-            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_MAX_NTP_CACHE_AGE_SEC);
-            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_NOTIFICATION_TYPE);
-            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_POLLING_SEC);
-            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_RESET_DAY);
-            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_THRESHOLD_BYTES);
-            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_VALUE_KBITSPS);
-            MOVED_TO_GLOBAL.add(Settings.Global.USB_MASS_STORAGE_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.USE_GOOGLE_MAIL);
-            MOVED_TO_GLOBAL.add(Settings.Global.WEB_AUTOFILL_QUERY_URL);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_COUNTRY_CODE);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_FRAMEWORK_SCAN_INTERVAL_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_FREQUENCY_BAND);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_IDLE_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_NUM_OPEN_NETWORKS_KEPT);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_ON);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_P2P_DEVICE_NAME);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SAVED_STATE);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_WATCHDOG_ON);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.WIMAX_NETWORKS_AVAILABLE_NOTIFICATION_ON);
-            MOVED_TO_GLOBAL.add(Settings.Global.PACKAGE_VERIFIER_ENABLE);
-            MOVED_TO_GLOBAL.add(Settings.Global.PACKAGE_VERIFIER_TIMEOUT);
-            MOVED_TO_GLOBAL.add(Settings.Global.PACKAGE_VERIFIER_DEFAULT_RESPONSE);
-            MOVED_TO_GLOBAL.add(Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS);
-            MOVED_TO_GLOBAL.add(Settings.Global.WTF_IS_FATAL);
-            MOVED_TO_GLOBAL.add(Settings.Global.BATTERY_DISCHARGE_DURATION_THRESHOLD);
-            MOVED_TO_GLOBAL.add(Settings.Global.BATTERY_DISCHARGE_THRESHOLD);
-            MOVED_TO_GLOBAL.add(Settings.Global.SEND_ACTION_APP_ERROR);
-            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_AGE_SECONDS);
-            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_MAX_FILES);
-            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_QUOTA_KB);
-            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_QUOTA_PERCENT);
-            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_RESERVE_PERCENT);
-            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_TAG_PREFIX);
-            MOVED_TO_GLOBAL.add(Settings.Global.ERROR_LOGCAT_PREFIX);
-            MOVED_TO_GLOBAL.add(Settings.Global.SYS_FREE_STORAGE_LOG_INTERVAL);
-            MOVED_TO_GLOBAL.add(Settings.Global.DISK_FREE_CHANGE_REPORTING_THRESHOLD);
-            MOVED_TO_GLOBAL.add(Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE);
-            MOVED_TO_GLOBAL.add(Settings.Global.SYS_STORAGE_THRESHOLD_MAX_BYTES);
-            MOVED_TO_GLOBAL.add(Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES);
-            MOVED_TO_GLOBAL.add(Settings.Global.SYNC_MAX_RETRY_DELAY_IN_SECONDS);
-            MOVED_TO_GLOBAL.add(Settings.Global.CONNECTIVITY_CHANGE_DELAY);
-            MOVED_TO_GLOBAL.add(Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED);
-            MOVED_TO_GLOBAL.add(Settings.Global.CAPTIVE_PORTAL_SERVER);
-            MOVED_TO_GLOBAL.add(Settings.Global.NSD_ON);
-            MOVED_TO_GLOBAL.add(Settings.Global.SET_INSTALL_LOCATION);
-            MOVED_TO_GLOBAL.add(Settings.Global.DEFAULT_INSTALL_LOCATION);
-            MOVED_TO_GLOBAL.add(Settings.Global.INET_CONDITION_DEBOUNCE_UP_DELAY);
-            MOVED_TO_GLOBAL.add(Settings.Global.INET_CONDITION_DEBOUNCE_DOWN_DELAY);
-            MOVED_TO_GLOBAL.add(Settings.Global.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT);
-            MOVED_TO_GLOBAL.add(Settings.Global.HTTP_PROXY);
-            MOVED_TO_GLOBAL.add(Settings.Global.GLOBAL_HTTP_PROXY_HOST);
-            MOVED_TO_GLOBAL.add(Settings.Global.GLOBAL_HTTP_PROXY_PORT);
-            MOVED_TO_GLOBAL.add(Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST);
-            MOVED_TO_GLOBAL.add(Settings.Global.SET_GLOBAL_HTTP_PROXY);
-            MOVED_TO_GLOBAL.add(Settings.Global.DEFAULT_DNS_SERVER);
-            MOVED_TO_GLOBAL.add(Settings.Global.PREFERRED_NETWORK_MODE);
-            MOVED_TO_GLOBAL.add(Settings.Global.PREFERRED_CDMA_SUBSCRIPTION);
-        }
-
-        /** @hide */
-        public static void getMovedKeys(HashSet<String> outKeySet) {
-            outKeySet.addAll(MOVED_TO_GLOBAL);
-        }
-
-        /**
-         * Look up a name in the database.
-         * @param resolver to access the database with
-         * @param name to look up in the table
-         * @return the corresponding value, or null if not present
-         */
-        public static String getString(ContentResolver resolver, String name) {
-            return getStringForUser(resolver, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static String getStringForUser(ContentResolver resolver, String name,
-                int userHandle) {
-            if (MOVED_TO_GLOBAL.contains(name)) {
-                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Secure"
-                        + " to android.provider.Settings.Global.");
-                return Global.getStringForUser(resolver, name, userHandle);
-            }
-
-            if (MOVED_TO_LOCK_SETTINGS.contains(name)) {
-                synchronized (Secure.class) {
-                    if (sLockSettings == null) {
-                        sLockSettings = ILockSettings.Stub.asInterface(
-                                (IBinder) ServiceManager.getService("lock_settings"));
-                        sIsSystemProcess = Process.myUid() == Process.SYSTEM_UID;
-                    }
-                }
-                if (sLockSettings != null && !sIsSystemProcess) {
-                    try {
-                        return sLockSettings.getString(name, "0", userHandle);
-                    } catch (RemoteException re) {
-                        // Fall through
-                    }
-                }
-            }
-
-            return sNameValueCache.getStringForUser(resolver, name, userHandle);
-        }
-
-        /**
-         * Store a name/value pair into the database.
-         * @param resolver to access the database with
-         * @param name to store
-         * @param value to associate with the name
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putString(ContentResolver resolver, String name, String value) {
-            return putStringForUser(resolver, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putStringForUser(ContentResolver resolver, String name, String value,
-                int userHandle) {
-            if (MOVED_TO_GLOBAL.contains(name)) {
-                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
-                        + " to android.provider.Settings.Global");
-                return Global.putStringForUser(resolver, name, value, userHandle);
-            }
-            return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
-        }
-
-        /**
-         * Construct the content URI for a particular name/value pair,
-         * useful for monitoring changes with a ContentObserver.
-         * @param name to look up in the table
-         * @return the corresponding content URI, or null if not present
-         */
-        public static Uri getUriFor(String name) {
-            if (MOVED_TO_GLOBAL.contains(name)) {
-                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Secure"
-                        + " to android.provider.Settings.Global, returning global URI.");
-                return Global.getUriFor(Global.CONTENT_URI, name);
-            }
-            return getUriFor(CONTENT_URI, name);
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.  The default value will be returned if the setting is
-         * not defined or not an integer.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid integer.
-         */
-        public static int getInt(ContentResolver cr, String name, int def) {
-            return getIntForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static int getIntForUser(ContentResolver cr, String name, int def, int userHandle) {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return v != null ? Integer.parseInt(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         *
-         * @return The setting's current value.
-         */
-        public static int getInt(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getIntForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static int getIntForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return Integer.parseInt(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as an
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putInt(ContentResolver cr, String name, int value) {
-            return putIntForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putIntForUser(ContentResolver cr, String name, int value,
-                int userHandle) {
-            return putStringForUser(cr, name, Integer.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.  The default value will be returned if the setting is
-         * not defined or not a {@code long}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid {@code long}.
-         */
-        public static long getLong(ContentResolver cr, String name, long def) {
-            return getLongForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static long getLongForUser(ContentResolver cr, String name, long def,
-                int userHandle) {
-            String valString = getStringForUser(cr, name, userHandle);
-            long value;
-            try {
-                value = valString != null ? Long.parseLong(valString) : def;
-            } catch (NumberFormatException e) {
-                value = def;
-            }
-            return value;
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @return The setting's current value.
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         */
-        public static long getLong(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getLongForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static long getLongForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String valString = getStringForUser(cr, name, userHandle);
-            try {
-                return Long.parseLong(valString);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a secure settings value as a long
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putLong(ContentResolver cr, String name, long value) {
-            return putLongForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putLongForUser(ContentResolver cr, String name, long value,
-                int userHandle) {
-            return putStringForUser(cr, name, Long.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a floating point number.  Note that internally setting values are
-         * always stored as strings; this function converts the string to an
-         * float for you. The default value will be returned if the setting
-         * is not defined or not a valid float.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid float.
-         */
-        public static float getFloat(ContentResolver cr, String name, float def) {
-            return getFloatForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static float getFloatForUser(ContentResolver cr, String name, float def,
-                int userHandle) {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return v != null ? Float.parseFloat(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a float.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a float
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not a float.
-         *
-         * @return The setting's current value.
-         */
-        public static float getFloat(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getFloatForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static float getFloatForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String v = getStringForUser(cr, name, userHandle);
-            if (v == null) {
-                throw new SettingNotFoundException(name);
-            }
-            try {
-                return Float.parseFloat(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as a
-         * floating point number. This will either create a new entry in the
-         * table if the given name does not exist, or modify the value of the
-         * existing row with that name.  Note that internally setting values
-         * are always stored as strings, so this function converts the given
-         * value to a string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putFloat(ContentResolver cr, String name, float value) {
-            return putFloatForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putFloatForUser(ContentResolver cr, String name, float value,
-                int userHandle) {
-            return putStringForUser(cr, name, Float.toString(value), userHandle);
-        }
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}
-         * instead
-         */
-        @Deprecated
-        public static final String DEVELOPMENT_SETTINGS_ENABLED =
-                Global.DEVELOPMENT_SETTINGS_ENABLED;
-
-        /**
-         * When the user has enable the option to have a "bug report" command
-         * in the power menu.
-         * @hide
-         */
-        public static final String BUGREPORT_IN_POWER_MENU = "bugreport_in_power_menu";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#ADB_ENABLED} instead
-         */
-        @Deprecated
-        public static final String ADB_ENABLED = Global.ADB_ENABLED;
-
-        /**
-         * The TCP/IP port to run ADB on, or -1 for USB
-         * @hide
-         */
-        public static final String ADB_PORT = "adb_port";
-
-        /**
-         * Whether to display the ADB notification.
-         * @hide
-         */
-        public static final String ADB_NOTIFY = "adb_notify";
-
-        /**
-         * The hostname for this device
-         * @hide
-         */
-        public static final String DEVICE_HOSTNAME = "device_hostname";
-
-        /**
-         * Setting to allow mock locations and location provider status to be injected into the
-         * LocationManager service for testing purposes during application development.  These
-         * locations and status values  override actual location and status information generated
-         * by network, gps, or other location providers.
-         */
-        public static final String ALLOW_MOCK_LOCATION = "mock_location";
-
-        /**
-         * A 64-bit number (as a hex string) that is randomly
-         * generated on the device's first boot and should remain
-         * constant for the lifetime of the device.  (The value may
-         * change if a factory reset is performed on the device.)
-         */
-        public static final String ANDROID_ID = "android_id";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_ON} instead
-         */
-        @Deprecated
-        public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
-         */
-        @Deprecated
-        public static final String DATA_ROAMING = Global.DATA_ROAMING;
-
-        /**
-         * Setting to record the input method used by default, holding the ID
-         * of the desired method.
-         */
-        public static final String DEFAULT_INPUT_METHOD = "default_input_method";
-
-        /**
-         * Setting to record the input method subtype used by default, holding the ID
-         * of the desired method.
-         */
-        public static final String SELECTED_INPUT_METHOD_SUBTYPE =
-                "selected_input_method_subtype";
-
-        /**
-         * Setting to record the history of input method subtype, holding the pair of ID of IME
-         * and its last used subtype.
-         * @hide
-         */
-        public static final String INPUT_METHODS_SUBTYPE_HISTORY =
-                "input_methods_subtype_history";
-
-        /**
-         * Setting to record the visibility of input method selector
-         */
-        public static final String INPUT_METHOD_SELECTOR_VISIBILITY =
-                "input_method_selector_visibility";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#DEVICE_PROVISIONED} instead
-         */
-        @Deprecated
-        public static final String DEVICE_PROVISIONED = Global.DEVICE_PROVISIONED;
-
-        /**
-         * Whether the current user has been set up via setup wizard (0 = false, 1 = true)
-         * @hide
-         */
-        public static final String USER_SETUP_COMPLETE = "user_setup_complete";
-
-        /**
-         * List of input methods that are currently enabled.  This is a string
-         * containing the IDs of all enabled input methods, each ID separated
-         * by ':'.
-         */
-        public static final String ENABLED_INPUT_METHODS = "enabled_input_methods";
-
-        /**
-         * List of system input methods that are currently disabled.  This is a string
-         * containing the IDs of all disabled input methods, each ID separated
-         * by ':'.
-         * @hide
-         */
-        public static final String DISABLED_SYSTEM_INPUT_METHODS = "disabled_system_input_methods";
-
-        /**
-         * Host name and port for global http proxy. Uses ':' seperator for
-         * between host and port.
-         *
-         * @deprecated Use {@link Global#HTTP_PROXY}
-         */
-        @Deprecated
-        public static final String HTTP_PROXY = Global.HTTP_PROXY;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#INSTALL_NON_MARKET_APPS} instead
-         */
-        @Deprecated
-        public static final String INSTALL_NON_MARKET_APPS = Global.INSTALL_NON_MARKET_APPS;
-
-        /**
-         * Comma-separated list of location providers that activities may access.
-         */
-        public static final String LOCATION_PROVIDERS_ALLOWED = "location_providers_allowed";
-
-        /**
-         * A flag containing settings used for biometric weak
-         * @hide
-         */
-        public static final String LOCK_BIOMETRIC_WEAK_FLAGS =
-                "lock_biometric_weak_flags";
-
-        /**
-         * Whether autolock is enabled (0 = false, 1 = true)
-         */
-        public static final String LOCK_PATTERN_ENABLED = "lock_pattern_autolock";
-
-        /**
-         * Whether lock pattern is visible as user enters (0 = false, 1 = true)
-         */
-        public static final String LOCK_PATTERN_VISIBLE = "lock_pattern_visible_pattern";
-
-        /**
-         * Whether lock pattern will vibrate as user enters (0 = false, 1 =
-         * true)
-         *
-         * @deprecated Starting in {@link VERSION_CODES#JELLY_BEAN_MR1} the
-         *             lockscreen uses
-         *             {@link Settings.System#HAPTIC_FEEDBACK_ENABLED}.
-         */
-        @Deprecated
-        public static final String
-                LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED = "lock_pattern_tactile_feedback_enabled";
-
-        /**
-         * Whether lock pattern will show dots (0 = false, 1 = true)
-         * @hide
-         */
-        public static final String LOCK_DOTS_VISIBLE = "lock_pattern_dotsvisible";
-
-        /**
-         * Whether lockscreen error pattern is visible (0 = false, 1 = true)
-         * @hide
-         */
-        public static final String LOCK_SHOW_ERROR_PATH = "lock_pattern_show_error_path";
-
-        /**
-         * This preference allows the device to be locked given time after screen goes off,
-         * subject to current DeviceAdmin policy limits.
-         * @hide
-         */
-        public static final String LOCK_SCREEN_LOCK_AFTER_TIMEOUT = "lock_screen_lock_after_timeout";
-
-
-        /**
-         * This preference contains the string that shows for owner info on LockScreen.
-         * @hide
-         */
-        public static final String LOCK_SCREEN_OWNER_INFO = "lock_screen_owner_info";
-
-        /**
-         * Ids of the user-selected appwidgets on the lockscreen (comma-delimited).
-         * @hide
-         */
-        public static final String LOCK_SCREEN_APPWIDGET_IDS =
-            "lock_screen_appwidget_ids";
-
-        /**
-         * Id of the appwidget shown on the lock screen when appwidgets are disabled.
-         * @hide
-         */
-        public static final String LOCK_SCREEN_FALLBACK_APPWIDGET_ID =
-            "lock_screen_fallback_appwidget_id";
-
-        /**
-         * Index of the lockscreen appwidget to restore, -1 if none.
-         * @hide
-         */
-        public static final String LOCK_SCREEN_STICKY_APPWIDGET =
-            "lock_screen_sticky_appwidget";
-
-        /**
-         * This preference enables showing the owner info on LockScreen.
-         * @hide
-         */
-        public static final String LOCK_SCREEN_OWNER_INFO_ENABLED =
-            "lock_screen_owner_info_enabled";
-
-        /**
-         * Whether the unsecure widget screen will be shown before a secure
-         * lock screen
-         * @hide
-         */
-        public static final String LOCK_BEFORE_UNLOCK =
-            "lock_before_unlock";
-
-        /**
-         * Determines the width and height of the LockPatternView widget
-         * @hide
-         */
-        public static final String LOCK_PATTERN_SIZE =
-            "lock_pattern_size";
-
-        /**
-         * The Logging ID (a unique 64-bit value) as a hex string.
-         * Used as a pseudonymous identifier for logging.
-         * @deprecated This identifier is poorly initialized and has
-         * many collisions.  It should not be used.
-         */
-        @Deprecated
-        public static final String LOGGING_ID = "logging_id";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#NETWORK_PREFERENCE} instead
-         */
-        @Deprecated
-        public static final String NETWORK_PREFERENCE = Global.NETWORK_PREFERENCE;
-
-        /**
-         * No longer supported.
-         */
-        public static final String PARENTAL_CONTROL_ENABLED = "parental_control_enabled";
-
-        /**
-         * No longer supported.
-         */
-        public static final String PARENTAL_CONTROL_LAST_UPDATE = "parental_control_last_update";
-
-        /**
-         * No longer supported.
-         */
-        public static final String PARENTAL_CONTROL_REDIRECT_URL = "parental_control_redirect_url";
-
-        /**
-         * Settings classname to launch when Settings is clicked from All
-         * Applications.  Needed because of user testing between the old
-         * and new Settings apps.
-         */
-        // TODO: 881807
-        public static final String SETTINGS_CLASSNAME = "settings_classname";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#USB_MASS_STORAGE_ENABLED} instead
-         */
-        @Deprecated
-        public static final String USB_MASS_STORAGE_ENABLED = Global.USB_MASS_STORAGE_ENABLED;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#USE_GOOGLE_MAIL} instead
-         */
-        @Deprecated
-        public static final String USE_GOOGLE_MAIL = Global.USE_GOOGLE_MAIL;
-
-        /**
-         * If accessibility is enabled.
-         */
-        public static final String ACCESSIBILITY_ENABLED = "accessibility_enabled";
-
-        /**
-         * If touch exploration is enabled.
-         */
-        public static final String TOUCH_EXPLORATION_ENABLED = "touch_exploration_enabled";
-
-        /**
-         * List of the enabled accessibility providers.
-         */
-        public static final String ENABLED_ACCESSIBILITY_SERVICES =
-            "enabled_accessibility_services";
-
-        /**
-         * List of the accessibility services to which the user has granted
-         * permission to put the device into touch exploration mode.
-         *
-         * @hide
-         */
-        public static final String TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES =
-            "touch_exploration_granted_accessibility_services";
-
-        /**
-         * Whether to speak passwords while in accessibility mode.
-         */
-        public static final String ACCESSIBILITY_SPEAK_PASSWORD = "speak_password";
-
-        /**
-         * If injection of accessibility enhancing JavaScript screen-reader
-         * is enabled.
-         * <p>
-         *   Note: The JavaScript based screen-reader is served by the
-         *   Google infrastructure and enable users with disabilities to
-         *   efficiently navigate in and explore web content.
-         * </p>
-         * <p>
-         *   This property represents a boolean value.
-         * </p>
-         * @hide
-         */
-        public static final String ACCESSIBILITY_SCRIPT_INJECTION =
-            "accessibility_script_injection";
-
-        /**
-         * The URL for the injected JavaScript based screen-reader used
-         * for providing accessibility of content in WebView.
-         * <p>
-         *   Note: The JavaScript based screen-reader is served by the
-         *   Google infrastructure and enable users with disabilities to
-         *   efficiently navigate in and explore web content.
-         * </p>
-         * <p>
-         *   This property represents a string value.
-         * </p>
-         * @hide
-         */
-        public static final String ACCESSIBILITY_SCREEN_READER_URL =
-            "accessibility_script_injection_url";
-
-        /**
-         * Key bindings for navigation in built-in accessibility support for web content.
-         * <p>
-         *   Note: These key bindings are for the built-in accessibility navigation for
-         *   web content which is used as a fall back solution if JavaScript in a WebView
-         *   is not enabled or the user has not opted-in script injection from Google.
-         * </p>
-         * <p>
-         *   The bindings are separated by semi-colon. A binding is a mapping from
-         *   a key to a sequence of actions (for more details look at
-         *   android.webkit.AccessibilityInjector). A key is represented as the hexademical
-         *   string representation of an integer obtained from a meta state (optional) shifted
-         *   sixteen times left and bitwise ored with a key code. An action is represented
-         *   as a hexademical string representation of an integer where the first two digits
-         *   are navigation action index, the second, the third, and the fourth digit pairs
-         *   represent the action arguments. The separate actions in a binding are colon
-         *   separated. The key and the action sequence it maps to are separated by equals.
-         * </p>
-         * <p>
-         *   For example, the binding below maps the DPAD right button to traverse the
-         *   current navigation axis once without firing an accessibility event and to
-         *   perform the same traversal again but to fire an event:
-         *   <code>
-         *     0x16=0x01000100:0x01000101;
-         *   </code>
-         * </p>
-         * <p>
-         *   The goal of this binding is to enable dynamic rebinding of keys to
-         *   navigation actions for web content without requiring a framework change.
-         * </p>
-         * <p>
-         *   This property represents a string value.
-         * </p>
-         * @hide
-         */
-        public static final String ACCESSIBILITY_WEB_CONTENT_KEY_BINDINGS =
-            "accessibility_web_content_key_bindings";
-
-        /**
-         * Setting that specifies whether the display magnification is enabled.
-         * Display magnifications allows the user to zoom in the display content
-         * and is targeted to low vision users. The current magnification scale
-         * is controlled by {@link #ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE}.
-         *
-         * @hide
-         */
-        public static final String ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED =
-                "accessibility_display_magnification_enabled";
-
-        /**
-         * Setting that specifies what the display magnification scale is.
-         * Display magnifications allows the user to zoom in the display
-         * content and is targeted to low vision users. Whether a display
-         * magnification is performed is controlled by
-         * {@link #ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED}
-         *
-         * @hide
-         */
-        public static final String ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE =
-                "accessibility_display_magnification_scale";
-
-        /**
-         * Setting that specifies whether the display magnification should be
-         * automatically updated. If this fearture is enabled the system will
-         * exit magnification mode or pan the viewport when a context change
-         * occurs. For example, on staring a new activity or rotating the screen,
-         * the system may zoom out so the user can see the new context he is in.
-         * Another example is on showing a window that is not visible in the
-         * magnified viewport the system may pan the viewport to make the window
-         * the has popped up so the user knows that the context has changed.
-         * Whether a screen magnification is performed is controlled by
-         * {@link #ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED}
-         *
-         * @hide
-         */
-        public static final String ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE =
-                "accessibility_display_magnification_auto_update";
-
-        /**
-         * The timout for considering a press to be a long press in milliseconds.
-         * @hide
-         */
-        public static final String LONG_PRESS_TIMEOUT = "long_press_timeout";
-
-        /**
-         * Setting to always use the default text-to-speech settings regardless
-         * of the application settings.
-         * 1 = override application settings,
-         * 0 = use application settings (if specified).
-         *
-         * @deprecated  The value of this setting is no longer respected by
-         * the framework text to speech APIs as of the Ice Cream Sandwich release.
-         */
-        @Deprecated
-        public static final String TTS_USE_DEFAULTS = "tts_use_defaults";
-
-        /**
-         * Default text-to-speech engine speech rate. 100 = 1x
-         */
-        public static final String TTS_DEFAULT_RATE = "tts_default_rate";
-
-        /**
-         * Default text-to-speech engine pitch. 100 = 1x
-         */
-        public static final String TTS_DEFAULT_PITCH = "tts_default_pitch";
-
-        /**
-         * Default text-to-speech engine.
-         */
-        public static final String TTS_DEFAULT_SYNTH = "tts_default_synth";
-
-        /**
-         * Default text-to-speech language.
-         *
-         * @deprecated this setting is no longer in use, as of the Ice Cream
-         * Sandwich release. Apps should never need to read this setting directly,
-         * instead can query the TextToSpeech framework classes for the default
-         * locale. {@link TextToSpeech#getLanguage()}.
-         */
-        @Deprecated
-        public static final String TTS_DEFAULT_LANG = "tts_default_lang";
-
-        /**
-         * Default text-to-speech country.
-         *
-         * @deprecated this setting is no longer in use, as of the Ice Cream
-         * Sandwich release. Apps should never need to read this setting directly,
-         * instead can query the TextToSpeech framework classes for the default
-         * locale. {@link TextToSpeech#getLanguage()}.
-         */
-        @Deprecated
-        public static final String TTS_DEFAULT_COUNTRY = "tts_default_country";
-
-        /**
-         * Default text-to-speech locale variant.
-         *
-         * @deprecated this setting is no longer in use, as of the Ice Cream
-         * Sandwich release. Apps should never need to read this setting directly,
-         * instead can query the TextToSpeech framework classes for the
-         * locale that is in use {@link TextToSpeech#getLanguage()}.
-         */
-        @Deprecated
-        public static final String TTS_DEFAULT_VARIANT = "tts_default_variant";
-
-        /**
-         * Stores the default tts locales on a per engine basis. Stored as
-         * a comma seperated list of values, each value being of the form
-         * {@code engine_name:locale} for example,
-         * {@code com.foo.ttsengine:eng-USA,com.bar.ttsengine:esp-ESP}. This
-         * supersedes {@link #TTS_DEFAULT_LANG}, {@link #TTS_DEFAULT_COUNTRY} and
-         * {@link #TTS_DEFAULT_VARIANT}. Apps should never need to read this
-         * setting directly, and can query the TextToSpeech framework classes
-         * for the locale that is in use.
-         *
-         * @hide
-         */
-        public static final String TTS_DEFAULT_LOCALE = "tts_default_locale";
-
-        /**
-         * Space delimited list of plugin packages that are enabled.
-         */
-        public static final String TTS_ENABLED_PLUGINS = "tts_enabled_plugins";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON}
-         * instead.
-         */
-        @Deprecated
-        public static final String WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON =
-                Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY}
-         * instead.
-         */
-        @Deprecated
-        public static final String WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY =
-                Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_NUM_OPEN_NETWORKS_KEPT}
-         * instead.
-         */
-        @Deprecated
-        public static final String WIFI_NUM_OPEN_NETWORKS_KEPT =
-                Global.WIFI_NUM_OPEN_NETWORKS_KEPT;
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_ON}
-         * instead.
-         */
-        @Deprecated
-        public static final String WIFI_ON = Global.WIFI_ON;
-
-        /**
-         * The acceptable packet loss percentage (range 0 - 100) before trying
-         * another AP on the same network.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE =
-                "wifi_watchdog_acceptable_packet_loss_percentage";
-
-        /**
-         * The number of access points required for a network in order for the
-         * watchdog to monitor it.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_AP_COUNT = "wifi_watchdog_ap_count";
-
-        /**
-         * The delay between background checks.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS =
-                "wifi_watchdog_background_check_delay_ms";
-
-        /**
-         * Whether the Wi-Fi watchdog is enabled for background checking even
-         * after it thinks the user has connected to a good access point.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED =
-                "wifi_watchdog_background_check_enabled";
-
-        /**
-         * The timeout for a background ping
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS =
-                "wifi_watchdog_background_check_timeout_ms";
-
-        /**
-         * The number of initial pings to perform that *may* be ignored if they
-         * fail. Again, if these fail, they will *not* be used in packet loss
-         * calculation. For example, one network always seemed to time out for
-         * the first couple pings, so this is set to 3 by default.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT =
-            "wifi_watchdog_initial_ignored_ping_count";
-
-        /**
-         * The maximum number of access points (per network) to attempt to test.
-         * If this number is reached, the watchdog will no longer monitor the
-         * initial connection state for the network. This is a safeguard for
-         * networks containing multiple APs whose DNS does not respond to pings.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_MAX_AP_CHECKS = "wifi_watchdog_max_ap_checks";
-
-        /**
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_WATCHDOG_ON} instead
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_ON = "wifi_watchdog_on";
-
-        /**
-         * A comma-separated list of SSIDs for which the Wi-Fi watchdog should be enabled.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_WATCH_LIST = "wifi_watchdog_watch_list";
-
-        /**
-         * The number of pings to test if an access point is a good connection.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_PING_COUNT = "wifi_watchdog_ping_count";
-
-        /**
-         * The delay between pings.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_PING_DELAY_MS = "wifi_watchdog_ping_delay_ms";
-
-        /**
-         * The timeout per ping.
-         * @deprecated This setting is not used.
-         */
-        @Deprecated
-        public static final String WIFI_WATCHDOG_PING_TIMEOUT_MS = "wifi_watchdog_ping_timeout_ms";
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Global#WIFI_MAX_DHCP_RETRY_COUNT} instead
-         */
-        @Deprecated
-        public static final String WIFI_MAX_DHCP_RETRY_COUNT = Global.WIFI_MAX_DHCP_RETRY_COUNT;
-
-        /**
-         * @deprecated Use
-         * {@link android.provider.Settings.Global#WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS} instead
-         */
-        @Deprecated
-        public static final String WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS =
-                Global.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS;
-
-        /**
-         * Whether the Wimax should be on.  Only the WiMAX service should touch this.
-         * @hide
-         */
-        public static final String WIMAX_ON = "wimax_on";
-
-        /**
-         * Whether background data usage is allowed.
-         *
-         * @deprecated As of {@link VERSION_CODES#ICE_CREAM_SANDWICH},
-         *             availability of background data depends on several
-         *             combined factors. When background data is unavailable,
-         *             {@link ConnectivityManager#getActiveNetworkInfo()} will
-         *             now appear disconnected.
-         */
-        @Deprecated
-        public static final String BACKGROUND_DATA = "background_data";
-
-        /**
-         * Origins for which browsers should allow geolocation by default.
-         * The value is a space-separated list of origins.
-         */
-        public static final String ALLOWED_GEOLOCATION_ORIGINS
-                = "allowed_geolocation_origins";
-
-        /**
-         * The preferred TTY mode     0 = TTy Off, CDMA default
-         *                            1 = TTY Full
-         *                            2 = TTY HCO
-         *                            3 = TTY VCO
-         * @hide
-         */
-        public static final String PREFERRED_TTY_MODE =
-                "preferred_tty_mode";
-
-        /**
-         * Whether the enhanced voice privacy mode is enabled.
-         * 0 = normal voice privacy
-         * 1 = enhanced voice privacy
-         * @hide
-         */
-        public static final String ENHANCED_VOICE_PRIVACY_ENABLED = "enhanced_voice_privacy_enabled";
-
-        /**
-         * Whether the TTY mode mode is enabled.
-         * 0 = disabled
-         * 1 = enabled
-         * @hide
-         */
-        public static final String TTY_MODE_ENABLED = "tty_mode_enabled";
-
-        /**
-         * Controls whether settings backup is enabled.
-         * Type: int ( 0 = disabled, 1 = enabled )
-         * @hide
-         */
-        public static final String BACKUP_ENABLED = "backup_enabled";
-
-        /**
-         * Controls whether application data is automatically restored from backup
-         * at install time.
-         * Type: int ( 0 = disabled, 1 = enabled )
-         * @hide
-         */
-        public static final String BACKUP_AUTO_RESTORE = "backup_auto_restore";
-
-        /**
-         * Indicates whether settings backup has been fully provisioned.
-         * Type: int ( 0 = unprovisioned, 1 = fully provisioned )
-         * @hide
-         */
-        public static final String BACKUP_PROVISIONED = "backup_provisioned";
-
-        /**
-         * Component of the transport to use for backup/restore.
-         * @hide
-         */
-        public static final String BACKUP_TRANSPORT = "backup_transport";
-
-        /**
-         * Version for which the setup wizard was last shown.  Bumped for
-         * each release when there is new setup information to show.
-         * @hide
-         */
-        public static final String LAST_SETUP_SHOWN = "last_setup_shown";
-
-        /**
-         * The interval in milliseconds after which Wi-Fi is considered idle.
-         * When idle, it is possible for the device to be switched from Wi-Fi to
-         * the mobile data network.
-         * @hide
-         * @deprecated Use {@link android.provider.Settings.Global#WIFI_IDLE_MS}
-         * instead.
-         */
-        @Deprecated
-        public static final String WIFI_IDLE_MS = Global.WIFI_IDLE_MS;
-
-        /**
-         * The global search provider chosen by the user (if multiple global
-         * search providers are installed). This will be the provider returned
-         * by {@link SearchManager#getGlobalSearchActivity()} if it's still
-         * installed. This setting is stored as a flattened component name as
-         * per {@link ComponentName#flattenToString()}.
-         *
-         * @hide
-         */
-        public static final String SEARCH_GLOBAL_SEARCH_ACTIVITY =
-                "search_global_search_activity";
-
-        /**
-         * The number of promoted sources in GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_NUM_PROMOTED_SOURCES = "search_num_promoted_sources";
-        /**
-         * The maximum number of suggestions returned by GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_MAX_RESULTS_TO_DISPLAY = "search_max_results_to_display";
-        /**
-         * The number of suggestions GlobalSearch will ask each non-web search source for.
-         * @hide
-         */
-        public static final String SEARCH_MAX_RESULTS_PER_SOURCE = "search_max_results_per_source";
-        /**
-         * The number of suggestions the GlobalSearch will ask the web search source for.
-         * @hide
-         */
-        public static final String SEARCH_WEB_RESULTS_OVERRIDE_LIMIT =
-                "search_web_results_override_limit";
-        /**
-         * The number of milliseconds that GlobalSearch will wait for suggestions from
-         * promoted sources before continuing with all other sources.
-         * @hide
-         */
-        public static final String SEARCH_PROMOTED_SOURCE_DEADLINE_MILLIS =
-                "search_promoted_source_deadline_millis";
-        /**
-         * The number of milliseconds before GlobalSearch aborts search suggesiton queries.
-         * @hide
-         */
-        public static final String SEARCH_SOURCE_TIMEOUT_MILLIS = "search_source_timeout_millis";
-        /**
-         * The maximum number of milliseconds that GlobalSearch shows the previous results
-         * after receiving a new query.
-         * @hide
-         */
-        public static final String SEARCH_PREFILL_MILLIS = "search_prefill_millis";
-        /**
-         * The maximum age of log data used for shortcuts in GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_MAX_STAT_AGE_MILLIS = "search_max_stat_age_millis";
-        /**
-         * The maximum age of log data used for source ranking in GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_MAX_SOURCE_EVENT_AGE_MILLIS =
-                "search_max_source_event_age_millis";
-        /**
-         * The minimum number of impressions needed to rank a source in GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_MIN_IMPRESSIONS_FOR_SOURCE_RANKING =
-                "search_min_impressions_for_source_ranking";
-        /**
-         * The minimum number of clicks needed to rank a source in GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_MIN_CLICKS_FOR_SOURCE_RANKING =
-                "search_min_clicks_for_source_ranking";
-        /**
-         * The maximum number of shortcuts shown by GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_MAX_SHORTCUTS_RETURNED = "search_max_shortcuts_returned";
-        /**
-         * The size of the core thread pool for suggestion queries in GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_QUERY_THREAD_CORE_POOL_SIZE =
-                "search_query_thread_core_pool_size";
-        /**
-         * The maximum size of the thread pool for suggestion queries in GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_QUERY_THREAD_MAX_POOL_SIZE =
-                "search_query_thread_max_pool_size";
-        /**
-         * The size of the core thread pool for shortcut refreshing in GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_SHORTCUT_REFRESH_CORE_POOL_SIZE =
-                "search_shortcut_refresh_core_pool_size";
-        /**
-         * The maximum size of the thread pool for shortcut refreshing in GlobalSearch.
-         * @hide
-         */
-        public static final String SEARCH_SHORTCUT_REFRESH_MAX_POOL_SIZE =
-                "search_shortcut_refresh_max_pool_size";
-        /**
-         * The maximun time that excess threads in the GlobalSeach thread pools will
-         * wait before terminating.
-         * @hide
-         */
-        public static final String SEARCH_THREAD_KEEPALIVE_SECONDS =
-                "search_thread_keepalive_seconds";
-        /**
-         * The maximum number of concurrent suggestion queries to each source.
-         * @hide
-         */
-        public static final String SEARCH_PER_SOURCE_CONCURRENT_QUERY_LIMIT =
-                "search_per_source_concurrent_query_limit";
-
-        /**
-         * Whether or not alert sounds are played on MountService events. (0 = false, 1 = true)
-         * @hide
-         */
-        public static final String MOUNT_PLAY_NOTIFICATION_SND = "mount_play_not_snd";
-
-        /**
-         * Whether or not UMS auto-starts on UMS host detection. (0 = false, 1 = true)
-         * @hide
-         */
-        public static final String MOUNT_UMS_AUTOSTART = "mount_ums_autostart";
-
-        /**
-         * Whether or not a notification is displayed on UMS host detection. (0 = false, 1 = true)
-         * @hide
-         */
-        public static final String MOUNT_UMS_PROMPT = "mount_ums_prompt";
-
-        /**
-         * Whether or not a notification is displayed while UMS is enabled. (0 = false, 1 = true)
-         * @hide
-         */
-        public static final String MOUNT_UMS_NOTIFY_ENABLED = "mount_ums_notify_enabled";
-
-        /**
-         * If nonzero, ANRs in invisible background processes bring up a dialog.
-         * Otherwise, the process will be silently killed.
-         * @hide
-         */
-        public static final String ANR_SHOW_BACKGROUND = "anr_show_background";
-
-        /**
-         * The {@link ComponentName} string of the service to be used as the voice recognition
-         * service.
-         *
-         * @hide
-         */
-        public static final String VOICE_RECOGNITION_SERVICE = "voice_recognition_service";
-
-
-        /**
-         * The {@link ComponentName} string of the selected spell checker service which is
-         * one of the services managed by the text service manager.
-         *
-         * @hide
-         */
-        public static final String SELECTED_SPELL_CHECKER = "selected_spell_checker";
-
-        /**
-         * The {@link ComponentName} string of the selected subtype of the selected spell checker
-         * service which is one of the services managed by the text service manager.
-         *
-         * @hide
-         */
-        public static final String SELECTED_SPELL_CHECKER_SUBTYPE =
-                "selected_spell_checker_subtype";
-
-        /**
-         * The {@link ComponentName} string whether spell checker is enabled or not.
-         *
-         * @hide
-         */
-        public static final String SPELL_CHECKER_ENABLED = "spell_checker_enabled";
-
-        /**
-         * What happens when the user presses the Power button while in-call
-         * and the screen is on.<br/>
-         * <b>Values:</b><br/>
-         * 1 - The Power button turns off the screen and locks the device. (Default behavior)<br/>
-         * 2 - The Power button hangs up the current call.<br/>
-         *
-         * @hide
-         */
-        public static final String INCALL_POWER_BUTTON_BEHAVIOR = "incall_power_button_behavior";
-
-        /**
-         * INCALL_POWER_BUTTON_BEHAVIOR value for "turn off screen".
-         * @hide
-         */
-        public static final int INCALL_POWER_BUTTON_BEHAVIOR_SCREEN_OFF = 0x1;
-
-        /**
-         * INCALL_POWER_BUTTON_BEHAVIOR value for "hang up".
-         * @hide
-         */
-        public static final int INCALL_POWER_BUTTON_BEHAVIOR_HANGUP = 0x2;
-
-        /**
-         * INCALL_POWER_BUTTON_BEHAVIOR default value.
-         * @hide
-         */
-        public static final int INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT =
-                INCALL_POWER_BUTTON_BEHAVIOR_SCREEN_OFF;
-
-        /**
-         * What happens when the user presses the Home button when the
-         * phone is ringing.<br/>
-         * <b>Values:</b><br/>
-         * 1 - Nothing happens. (Default behavior)<br/>
-         * 2 - The Home button answer the current call.<br/>
-         *
-         * @hide
-         */
-        public static final String RING_HOME_BUTTON_BEHAVIOR = "ring_home_button_behavior";
-
-        /**
-         * RING_HOME_BUTTON_BEHAVIOR value for "do nothing".
-         * @hide
-         */
-        public static final int RING_HOME_BUTTON_BEHAVIOR_DO_NOTHING = 0x1;
-
-        /**
-         * RING_HOME_BUTTON_BEHAVIOR value for "answer".
-         * @hide
-         */
-        public static final int RING_HOME_BUTTON_BEHAVIOR_ANSWER = 0x2;
-
-        /**
-         * RING_HOME_BUTTON_BEHAVIOR default value.
-         * @hide
-         */
-        public static final int RING_HOME_BUTTON_BEHAVIOR_DEFAULT =
-                RING_HOME_BUTTON_BEHAVIOR_DO_NOTHING;
-
-        /**
-         * The current night mode that has been selected by the user.  Owned
-         * and controlled by UiModeManagerService.  Constants are as per
-         * UiModeManager.
-         * @hide
-         */
-        public static final String UI_NIGHT_MODE = "ui_night_mode";
-
-        /**
-         * Whether screensavers are enabled.
-         * @hide
-         */
-        public static final String SCREENSAVER_ENABLED = "screensaver_enabled";
-
-        /**
-         * The user's chosen screensaver components.
-         *
-         * These will be launched by the PhoneWindowManager after a timeout when not on
-         * battery, or upon dock insertion (if SCREENSAVER_ACTIVATE_ON_DOCK is set to 1).
-         * @hide
-         */
-        public static final String SCREENSAVER_COMPONENTS = "screensaver_components";
-
-        /**
-         * If screensavers are enabled, whether the screensaver should be automatically launched
-         * when the device is inserted into a (desk) dock.
-         * @hide
-         */
-        public static final String SCREENSAVER_ACTIVATE_ON_DOCK = "screensaver_activate_on_dock";
-
-        /**
-         * If screensavers are enabled, whether the screensaver should be automatically launched
-         * when the screen times out when not on battery.
-         * @hide
-         */
-        public static final String SCREENSAVER_ACTIVATE_ON_SLEEP = "screensaver_activate_on_sleep";
-
-        /**
-         * If screensavers are enabled, the default screensaver component.
-         * @hide
-         */
-        public static final String SCREENSAVER_DEFAULT_COMPONENT = "screensaver_default_component";
-
-        /**
-         * Whether to allow killing of the foreground app by long-pressing the Back button
-         * @hide
-         */
-        public static final String KILL_APP_LONGPRESS_BACK = "kill_app_longpress_back";
-
-        /**
-         * Whether to include options in power menu for rebooting into recovery or bootloader
-         * @hide
-         */
-        public static final String ADVANCED_REBOOT = "advanced_reboot";
-
-        /**
-         * Whether newly installed apps should run with privacy guard by default
-         * @hide
-         */
-        public static final String PRIVACY_GUARD_DEFAULT = "privacy_guard_default";
-
-        /**
-         * This are the settings to be backed up.
-         *
-         * NOTE: Settings are backed up and restored in the order they appear
-         *       in this array. If you have one setting depending on another,
-         *       make sure that they are ordered appropriately.
-         *
-         * @hide
-         */
-        public static final String[] SETTINGS_TO_BACKUP = {
-            BUGREPORT_IN_POWER_MENU,
-            ALLOW_MOCK_LOCATION,
-            PARENTAL_CONTROL_ENABLED,
-            PARENTAL_CONTROL_REDIRECT_URL,
-            USB_MASS_STORAGE_ENABLED,                           // moved to global
-            ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
-            ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
-            ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE,
-            ACCESSIBILITY_SCRIPT_INJECTION,
-            BACKUP_AUTO_RESTORE,
-            ENABLED_ACCESSIBILITY_SERVICES,
-            TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
-            TOUCH_EXPLORATION_ENABLED,
-            ACCESSIBILITY_ENABLED,
-            ACCESSIBILITY_SPEAK_PASSWORD,
-            TTS_USE_DEFAULTS,
-            TTS_DEFAULT_RATE,
-            TTS_DEFAULT_PITCH,
-            TTS_DEFAULT_SYNTH,
-            TTS_DEFAULT_LANG,
-            TTS_DEFAULT_COUNTRY,
-            TTS_ENABLED_PLUGINS,
-            TTS_DEFAULT_LOCALE,
-            WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,            // moved to global
-            WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,               // moved to global
-            WIFI_NUM_OPEN_NETWORKS_KEPT,                        // moved to global
-            MOUNT_PLAY_NOTIFICATION_SND,
-            MOUNT_UMS_AUTOSTART,
-            MOUNT_UMS_PROMPT,
-            MOUNT_UMS_NOTIFY_ENABLED,
-            UI_NIGHT_MODE,
-            LOCK_SCREEN_OWNER_INFO,
-            LOCK_SCREEN_OWNER_INFO_ENABLED,
-            ADVANCED_REBOOT,
-            PRIVACY_GUARD_DEFAULT
-        };
-
-        /**
-         * Helper method for determining if a location provider is enabled.
-         * @param cr the content resolver to use
-         * @param provider the location provider to query
-         * @return true if the provider is enabled
-         */
-        public static final boolean isLocationProviderEnabled(ContentResolver cr, String provider) {
-            return isLocationProviderEnabledForUser(cr, provider, UserHandle.myUserId());
-        }
-
-        /**
-         * Helper method for determining if a location provider is enabled.
-         * @param cr the content resolver to use
-         * @param provider the location provider to query
-         * @param userId the userId to query
-         * @return true if the provider is enabled
-         * @hide
-         */
-        public static final boolean isLocationProviderEnabledForUser(ContentResolver cr, String provider, int userId) {
-            try {
-                if (ActivityManagerNative.getDefault().isPrivacyGuardEnabledForProcess(Binder.getCallingPid())) {
-                    return false;
-                }
-            } catch (RemoteException e) {
-                // ignore
-            }
-            String allowedProviders = Settings.Secure.getStringForUser(cr,
-                    LOCATION_PROVIDERS_ALLOWED, userId);
-            return TextUtils.delimitedStringContains(allowedProviders, ',', provider);
-        }
-
-        /**
-         * Thread-safe method for enabling or disabling a single location provider.
-         * @param cr the content resolver to use
-         * @param provider the location provider to enable or disable
-         * @param enabled true if the provider should be enabled
-         */
-        public static final void setLocationProviderEnabled(ContentResolver cr,
-                String provider, boolean enabled) {
-            setLocationProviderEnabledForUser(cr, provider, enabled, UserHandle.myUserId());
-        }
-
-        /**
-         * Thread-safe method for enabling or disabling a single location provider.
-         * @param cr the content resolver to use
-         * @param provider the location provider to enable or disable
-         * @param enabled true if the provider should be enabled
-         * @param userId the userId for which to enable/disable providers
-         * @hide
-         */
-        public static final void setLocationProviderEnabledForUser(ContentResolver cr,
-                String provider, boolean enabled, int userId) {
-            // to ensure thread safety, we write the provider name with a '+' or '-'
-            // and let the SettingsProvider handle it rather than reading and modifying
-            // the list of enabled providers.
-            if (enabled) {
-                provider = "+" + provider;
-            } else {
-                provider = "-" + provider;
-            }
-            putStringForUser(cr, Settings.Secure.LOCATION_PROVIDERS_ALLOWED, provider,
-                    userId);
-        }
-    }
-
-    /**
-     * Global system settings, containing preferences that always apply identically
-     * to all defined users.  Applications can read these but are not allowed to write;
-     * like the "Secure" settings, these are for preferences that the user must
-     * explicitly modify through the system UI or specialized APIs for those values.
-     */
-    public static final class Global extends NameValueTable {
-        public static final String SYS_PROP_SETTING_VERSION = "sys.settings_global_version";
-
-        /**
-         * The content:// style URL for global secure settings items.  Not public.
-         */
-        public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/global");
-
-        /**
-         * Setting whether the global gesture for enabling accessibility is enabled.
-         * If this gesture is enabled the user will be able to perfrom it to enable
-         * the accessibility state without visiting the settings app.
-         * @hide
-         */
-        public static final String ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED =
-                "enable_accessibility_global_gesture_enabled";
-
-        /**
-         * Whether Airplane Mode is on.
-         */
-        public static final String AIRPLANE_MODE_ON = "airplane_mode_on";
-
-        /**
-         * Constant for use in AIRPLANE_MODE_RADIOS to specify Bluetooth radio.
-         */
-        public static final String RADIO_BLUETOOTH = "bluetooth";
-
-        /**
-         * Constant for use in AIRPLANE_MODE_RADIOS to specify Wi-Fi radio.
-         */
-        public static final String RADIO_WIFI = "wifi";
-
-        /**
-         * {@hide}
-         */
-        public static final String RADIO_WIMAX = "wimax";
-        /**
-         * Constant for use in AIRPLANE_MODE_RADIOS to specify Cellular radio.
-         */
-        public static final String RADIO_CELL = "cell";
-
-        /**
-         * Constant for use in AIRPLANE_MODE_RADIOS to specify NFC radio.
-         */
-        public static final String RADIO_NFC = "nfc";
-
-        /**
-         * A comma separated list of radios that need to be disabled when airplane mode
-         * is on. This overrides WIFI_ON and BLUETOOTH_ON, if Wi-Fi and bluetooth are
-         * included in the comma separated list.
-         */
-        public static final String AIRPLANE_MODE_RADIOS = "airplane_mode_radios";
-
-        /**
-         * A comma separated list of radios that should to be disabled when airplane mode
-         * is on, but can be manually reenabled by the user.  For example, if RADIO_WIFI is
-         * added to both AIRPLANE_MODE_RADIOS and AIRPLANE_MODE_TOGGLEABLE_RADIOS, then Wifi
-         * will be turned off when entering airplane mode, but the user will be able to reenable
-         * Wifi in the Settings app.
-         *
-         * {@hide}
-         */
-        public static final String AIRPLANE_MODE_TOGGLEABLE_RADIOS = "airplane_mode_toggleable_radios";
-
-        /**
-         * The policy for deciding when Wi-Fi should go to sleep (which will in
-         * turn switch to using the mobile data as an Internet connection).
-         * <p>
-         * Set to one of {@link #WIFI_SLEEP_POLICY_DEFAULT},
-         * {@link #WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED}, or
-         * {@link #WIFI_SLEEP_POLICY_NEVER}.
-         */
-        public static final String WIFI_SLEEP_POLICY = "wifi_sleep_policy";
-
-        /**
-         * Value for {@link #WIFI_SLEEP_POLICY} to use the default Wi-Fi sleep
-         * policy, which is to sleep shortly after the turning off
-         * according to the {@link #STAY_ON_WHILE_PLUGGED_IN} setting.
-         */
-        public static final int WIFI_SLEEP_POLICY_DEFAULT = 0;
-
-        /**
-         * Value for {@link #WIFI_SLEEP_POLICY} to use the default policy when
-         * the device is on battery, and never go to sleep when the device is
-         * plugged in.
-         */
-        public static final int WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED = 1;
-
-        /**
-         * Value for {@link #WIFI_SLEEP_POLICY} to never go to sleep.
-         */
-        public static final int WIFI_SLEEP_POLICY_NEVER = 2;
-
-        /**
-         * Value to specify if the user prefers the date, time and time zone
-         * to be automatically fetched from the network (NITZ). 1=yes, 0=no
-         */
-        public static final String AUTO_TIME = "auto_time";
-
-        /**
-         * Value to specify if the user prefers the time zone
-         * to be automatically fetched from the network (NITZ). 1=yes, 0=no
-         */
-        public static final String AUTO_TIME_ZONE = "auto_time_zone";
-
-        /**
-         * URI for the car dock "in" event sound.
-         * @hide
-         */
-        public static final String CAR_DOCK_SOUND = "car_dock_sound";
-
-        /**
-         * URI for the car dock "out" event sound.
-         * @hide
-         */
-        public static final String CAR_UNDOCK_SOUND = "car_undock_sound";
-
-        /**
-         * URI for the desk dock "in" event sound.
-         * @hide
-         */
-        public static final String DESK_DOCK_SOUND = "desk_dock_sound";
-
-        /**
-         * URI for the desk dock "out" event sound.
-         * @hide
-         */
-        public static final String DESK_UNDOCK_SOUND = "desk_undock_sound";
-
-        /**
-         * Whether to play a sound for dock events.
-         * @hide
-         */
-        public static final String DOCK_SOUNDS_ENABLED = "dock_sounds_enabled";
-
-        /**
-         * URI for the "device locked" (keyguard shown) sound.
-         * @hide
-         */
-        public static final String LOCK_SOUND = "lock_sound";
-
-        /**
-         * URI for the "device unlocked" sound.
-         * @hide
-         */
-        public static final String UNLOCK_SOUND = "unlock_sound";
-
-        /**
-         * URI for the low battery sound file.
-         * @hide
-         */
-        public static final String LOW_BATTERY_SOUND = "low_battery_sound";
-
-        /**
-         * Whether to play a sound for low-battery alerts.
-         * @hide
-         */
-        public static final String POWER_SOUNDS_ENABLED = "power_sounds_enabled";
-
-        /**
-         * Whether to sound when charger power is connected/disconnected
-         * @hide
-         */
-        public static final String POWER_NOTIFICATIONS_ENABLED = "power_notifications_enabled";
-
-        /**
-         * Whether to vibrate when charger power is connected/disconnected
-         * @hide
-         */
-        public static final String POWER_NOTIFICATIONS_VIBRATE = "power_notifications_vibrate";
-
-        /**
-         * URI for power notification sounds
-         * @hide
-         */
-        public static final String POWER_NOTIFICATIONS_RINGTONE = "power_notifications_ringtone";
-
-        /**
-         * URI for the "wireless charging started" sound.
-         * @hide
-         */
-        public static final String WIRELESS_CHARGING_STARTED_SOUND =
-                "wireless_charging_started_sound";
-
-        /**
-         * Whether we keep the device on while the device is plugged in.
-         * Supported values are:
-         * <ul>
-         * <li>{@code 0} to never stay on while plugged in</li>
-         * <li>{@link BatteryManager#BATTERY_PLUGGED_AC} to stay on for AC charger</li>
-         * <li>{@link BatteryManager#BATTERY_PLUGGED_USB} to stay on for USB charger</li>
-         * <li>{@link BatteryManager#BATTERY_PLUGGED_WIRELESS} to stay on for wireless charger</li>
-         * </ul>
-         * These values can be OR-ed together.
-         */
-        public static final String STAY_ON_WHILE_PLUGGED_IN = "stay_on_while_plugged_in";
-
-        /**
-         * Whether ADB is enabled.
-         */
-        public static final String ADB_ENABLED = "adb_enabled";
-
-        /**
-         * Whether assisted GPS should be enabled or not.
-         * @hide
-         */
-        public static final String ASSISTED_GPS_ENABLED = "assisted_gps_enabled";
-
-        /**
-         * Whether bluetooth is enabled/disabled
-         * 0=disabled. 1=enabled.
-         */
-        public static final String BLUETOOTH_ON = "bluetooth_on";
-
-        /**
-         * CDMA Cell Broadcast SMS
-         *                            0 = CDMA Cell Broadcast SMS disabled
-         *                            1 = CDMA Cell Broadcast SMS enabled
-         * @hide
-         */
-        public static final String CDMA_CELL_BROADCAST_SMS =
-                "cdma_cell_broadcast_sms";
-
-        /**
-         * The CDMA roaming mode 0 = Home Networks, CDMA default
-         *                       1 = Roaming on Affiliated networks
-         *                       2 = Roaming on any networks
-         * @hide
-         */
-        public static final String CDMA_ROAMING_MODE = "roaming_settings";
-
-        /**
-         * The CDMA subscription mode 0 = RUIM/SIM (default)
-         *                                1 = NV
-         * @hide
-         */
-        public static final String CDMA_SUBSCRIPTION_MODE = "subscription_mode";
-
-        /** Inactivity timeout to track mobile data activity.
-        *
-        * If set to a positive integer, it indicates the inactivity timeout value in seconds to
-        * infer the data activity of mobile network. After a period of no activity on mobile
-        * networks with length specified by the timeout, an {@code ACTION_DATA_ACTIVITY_CHANGE}
-        * intent is fired to indicate a transition of network status from "active" to "idle". Any
-        * subsequent activity on mobile networks triggers the firing of {@code
-        * ACTION_DATA_ACTIVITY_CHANGE} intent indicating transition from "idle" to "active".
-        *
-        * Network activity refers to transmitting or receiving data on the network interfaces.
-        *
-        * Tracking is disabled if set to zero or negative value.
-        *
-        * @hide
-        */
-       public static final String DATA_ACTIVITY_TIMEOUT_MOBILE = "data_activity_timeout_mobile";
-
-       /** Timeout to tracking Wifi data activity. Same as {@code DATA_ACTIVITY_TIMEOUT_MOBILE}
-        * but for Wifi network.
-        * @hide
-        */
-       public static final String DATA_ACTIVITY_TIMEOUT_WIFI = "data_activity_timeout_wifi";
-
-       /**
-        * Whether or not data roaming is enabled. (0 = false, 1 = true)
-        */
-       public static final String DATA_ROAMING = "data_roaming";
-
-       /**
-        * Whether user has enabled development settings.
-        */
-       public static final String DEVELOPMENT_SETTINGS_ENABLED = "development_settings_enabled";
-
-       /**
-        * Whether the device has been provisioned (0 = false, 1 = true)
-        */
-       public static final String DEVICE_PROVISIONED = "device_provisioned";
-
-       /**
-        * The saved value for WindowManagerService.setForcedDisplayDensity().
-        * One integer in dpi.  If unset, then use the real display density.
-        * @hide
-        */
-       public static final String DISPLAY_DENSITY_FORCED = "display_density_forced";
-
-       /**
-        * The saved value for WindowManagerService.setForcedDisplaySize().
-        * Two integers separated by a comma.  If unset, then use the real display size.
-        * @hide
-        */
-       public static final String DISPLAY_SIZE_FORCED = "display_size_forced";
-
-       /**
-        * The maximum size, in bytes, of a download that the download manager will transfer over
-        * a non-wifi connection.
-        * @hide
-        */
-       public static final String DOWNLOAD_MAX_BYTES_OVER_MOBILE =
-               "download_manager_max_bytes_over_mobile";
-
-       /**
-        * The recommended maximum size, in bytes, of a download that the download manager should
-        * transfer over a non-wifi connection. Over this size, the use will be warned, but will
-        * have the option to start the download over the mobile connection anyway.
-        * @hide
-        */
-       public static final String DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE =
-               "download_manager_recommended_max_bytes_over_mobile";
-
-       /**
-        * Whether the package installer should allow installation of apps downloaded from
-        * sources other than Google Play.
-        *
-        * 1 = allow installing from other sources
-        * 0 = only allow installing from Google Play
-        */
-       public static final String INSTALL_NON_MARKET_APPS = "install_non_market_apps";
-
-       /**
-        * Whether mobile data connections are allowed by the user.  See
-        * ConnectivityManager for more info.
-        * @hide
-        */
-       public static final String MOBILE_DATA = "mobile_data";
-
-       /** {@hide} */
-       public static final String NETSTATS_ENABLED = "netstats_enabled";
-       /** {@hide} */
-       public static final String NETSTATS_POLL_INTERVAL = "netstats_poll_interval";
-       /** {@hide} */
-       public static final String NETSTATS_TIME_CACHE_MAX_AGE = "netstats_time_cache_max_age";
-       /** {@hide} */
-       public static final String NETSTATS_GLOBAL_ALERT_BYTES = "netstats_global_alert_bytes";
-       /** {@hide} */
-       public static final String NETSTATS_SAMPLE_ENABLED = "netstats_sample_enabled";
-       /** {@hide} */
-       public static final String NETSTATS_REPORT_XT_OVER_DEV = "netstats_report_xt_over_dev";
-
-       /** {@hide} */
-       public static final String NETSTATS_DEV_BUCKET_DURATION = "netstats_dev_bucket_duration";
-       /** {@hide} */
-       public static final String NETSTATS_DEV_PERSIST_BYTES = "netstats_dev_persist_bytes";
-       /** {@hide} */
-       public static final String NETSTATS_DEV_ROTATE_AGE = "netstats_dev_rotate_age";
-       /** {@hide} */
-       public static final String NETSTATS_DEV_DELETE_AGE = "netstats_dev_delete_age";
-
-       /** {@hide} */
-       public static final String NETSTATS_UID_BUCKET_DURATION = "netstats_uid_bucket_duration";
-       /** {@hide} */
-       public static final String NETSTATS_UID_PERSIST_BYTES = "netstats_uid_persist_bytes";
-       /** {@hide} */
-       public static final String NETSTATS_UID_ROTATE_AGE = "netstats_uid_rotate_age";
-       /** {@hide} */
-       public static final String NETSTATS_UID_DELETE_AGE = "netstats_uid_delete_age";
-
-       /** {@hide} */
-       public static final String NETSTATS_UID_TAG_BUCKET_DURATION = "netstats_uid_tag_bucket_duration";
-       /** {@hide} */
-       public static final String NETSTATS_UID_TAG_PERSIST_BYTES = "netstats_uid_tag_persist_bytes";
-       /** {@hide} */
-       public static final String NETSTATS_UID_TAG_ROTATE_AGE = "netstats_uid_tag_rotate_age";
-       /** {@hide} */
-       public static final String NETSTATS_UID_TAG_DELETE_AGE = "netstats_uid_tag_delete_age";
-
-       /**
-        * User preference for which network(s) should be used. Only the
-        * connectivity service should touch this.
-        */
-       public static final String NETWORK_PREFERENCE = "network_preference";
-
-       /**
-        * If the NITZ_UPDATE_DIFF time is exceeded then an automatic adjustment
-        * to SystemClock will be allowed even if NITZ_UPDATE_SPACING has not been
-        * exceeded.
-        * @hide
-        */
-       public static final String NITZ_UPDATE_DIFF = "nitz_update_diff";
-
-       /**
-        * The length of time in milli-seconds that automatic small adjustments to
-        * SystemClock are ignored if NITZ_UPDATE_DIFF is not exceeded.
-        * @hide
-        */
-       public static final String NITZ_UPDATE_SPACING = "nitz_update_spacing";
-
-       /** Preferred NTP server. {@hide} */
-       public static final String NTP_SERVER = "ntp_server";
-       /** Timeout in milliseconds to wait for NTP server. {@hide} */
-       public static final String NTP_TIMEOUT = "ntp_timeout";
-
-       /**
-        * Whether the package manager should send package verification broadcasts for verifiers to
-        * review apps prior to installation.
-        * 1 = request apps to be verified prior to installation, if a verifier exists.
-        * 0 = do not verify apps before installation
-        * @hide
-        */
-       public static final String PACKAGE_VERIFIER_ENABLE = "package_verifier_enable";
-
-       /** Timeout for package verification.
-        * @hide */
-       public static final String PACKAGE_VERIFIER_TIMEOUT = "verifier_timeout";
-
-       /** Default response code for package verification.
-        * @hide */
-       public static final String PACKAGE_VERIFIER_DEFAULT_RESPONSE = "verifier_default_response";
-
-       /**
-        * Show package verification setting in the Settings app.
-        * 1 = show (default)
-        * 0 = hide
-        * @hide
-        */
-       public static final String PACKAGE_VERIFIER_SETTING_VISIBLE = "verifier_setting_visible";
-
-       /**
-        * Run package verificaiton on apps installed through ADB/ADT/USB
-        * 1 = perform package verification on ADB installs (default)
-        * 0 = bypass package verification on ADB installs
-        * @hide
-        */
-       public static final String PACKAGE_VERIFIER_INCLUDE_ADB = "verifier_verify_adb_installs";
-
-       /**
-        * The interval in milliseconds at which to check packet counts on the
-        * mobile data interface when screen is on, to detect possible data
-        * connection problems.
-        * @hide
-        */
-       public static final String PDP_WATCHDOG_POLL_INTERVAL_MS =
-               "pdp_watchdog_poll_interval_ms";
-
-       /**
-        * The interval in milliseconds at which to check packet counts on the
-        * mobile data interface when screen is off, to detect possible data
-        * connection problems.
-        * @hide
-        */
-       public static final String PDP_WATCHDOG_LONG_POLL_INTERVAL_MS =
-               "pdp_watchdog_long_poll_interval_ms";
-
-       /**
-        * The interval in milliseconds at which to check packet counts on the
-        * mobile data interface after {@link #PDP_WATCHDOG_TRIGGER_PACKET_COUNT}
-        * outgoing packets has been reached without incoming packets.
-        * @hide
-        */
-       public static final String PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS =
-               "pdp_watchdog_error_poll_interval_ms";
-
-       /**
-        * The number of outgoing packets sent without seeing an incoming packet
-        * that triggers a countdown (of {@link #PDP_WATCHDOG_ERROR_POLL_COUNT}
-        * device is logged to the event log
-        * @hide
-        */
-       public static final String PDP_WATCHDOG_TRIGGER_PACKET_COUNT =
-               "pdp_watchdog_trigger_packet_count";
-
-       /**
-        * The number of polls to perform (at {@link #PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS})
-        * after hitting {@link #PDP_WATCHDOG_TRIGGER_PACKET_COUNT} before
-        * attempting data connection recovery.
-        * @hide
-        */
-       public static final String PDP_WATCHDOG_ERROR_POLL_COUNT =
-               "pdp_watchdog_error_poll_count";
-
-       /**
-        * The number of failed PDP reset attempts before moving to something more
-        * drastic: re-registering to the network.
-        * @hide
-        */
-       public static final String PDP_WATCHDOG_MAX_PDP_RESET_FAIL_COUNT =
-               "pdp_watchdog_max_pdp_reset_fail_count";
-
-       /**
-        * A positive value indicates how often the SamplingProfiler
-        * should take snapshots. Zero value means SamplingProfiler
-        * is disabled.
-        *
-        * @hide
-        */
-       public static final String SAMPLING_PROFILER_MS = "sampling_profiler_ms";
-
-       /**
-        * URL to open browser on to allow user to manage a prepay account
-        * @hide
-        */
-       public static final String SETUP_PREPAID_DATA_SERVICE_URL =
-               "setup_prepaid_data_service_url";
-
-       /**
-        * URL to attempt a GET on to see if this is a prepay device
-        * @hide
-        */
-       public static final String SETUP_PREPAID_DETECTION_TARGET_URL =
-               "setup_prepaid_detection_target_url";
-
-       /**
-        * Host to check for a redirect to after an attempt to GET
-        * SETUP_PREPAID_DETECTION_TARGET_URL. (If we redirected there,
-        * this is a prepaid device with zero balance.)
-        * @hide
-        */
-       public static final String SETUP_PREPAID_DETECTION_REDIR_HOST =
-               "setup_prepaid_detection_redir_host";
-
-       /**
-        * The interval in milliseconds at which to check the number of SMS sent out without asking
-        * for use permit, to limit the un-authorized SMS usage.
-        *
-        * @hide
-        */
-       public static final String SMS_OUTGOING_CHECK_INTERVAL_MS =
-               "sms_outgoing_check_interval_ms";
-
-       /**
-        * The number of outgoing SMS sent without asking for user permit (of {@link
-        * #SMS_OUTGOING_CHECK_INTERVAL_MS}
-        *
-        * @hide
-        */
-       public static final String SMS_OUTGOING_CHECK_MAX_COUNT =
-               "sms_outgoing_check_max_count";
-
-       /**
-        * Used to disable SMS short code confirmation - defaults to true.
-        * True indcates we will do the check, etc.  Set to false to disable.
-        * @see com.android.internal.telephony.SmsUsageMonitor
-        * @hide
-        */
-       public static final String SMS_SHORT_CODE_CONFIRMATION = "sms_short_code_confirmation";
-
-        /**
-         * Used to select which country we use to determine premium sms codes.
-         * One of com.android.internal.telephony.SMSDispatcher.PREMIUM_RULE_USE_SIM,
-         * com.android.internal.telephony.SMSDispatcher.PREMIUM_RULE_USE_NETWORK,
-         * or com.android.internal.telephony.SMSDispatcher.PREMIUM_RULE_USE_BOTH.
-         * @hide
-         */
-        public static final String SMS_SHORT_CODE_RULE = "sms_short_code_rule";
-
-       /**
-        * Used to disable Tethering on a device - defaults to true
-        * @hide
-        */
-       public static final String TETHER_SUPPORTED = "tether_supported";
-
-       /**
-        * Used to require DUN APN on the device or not - defaults to a build config value
-        * which defaults to false
-        * @hide
-        */
-       public static final String TETHER_DUN_REQUIRED = "tether_dun_required";
-
-       /**
-        * Used to hold a gservices-provisioned apn value for DUN.  If set, or the
-        * corresponding build config values are set it will override the APN DB
-        * values.
-        * Consists of a comma seperated list of strings:
-        * "name,apn,proxy,port,username,password,server,mmsc,mmsproxy,mmsport,mcc,mnc,auth,type"
-        * note that empty fields can be ommitted: "name,apn,,,,,,,,,310,260,,DUN"
-        * @hide
-        */
-       public static final String TETHER_DUN_APN = "tether_dun_apn";
-
-       /**
-        * The bandwidth throttle polling freqency in seconds
-        * @hide
-        */
-       public static final String THROTTLE_POLLING_SEC = "throttle_polling_sec";
-
-       /**
-        * The bandwidth throttle threshold (long)
-        * @hide
-        */
-       public static final String THROTTLE_THRESHOLD_BYTES = "throttle_threshold_bytes";
-
-       /**
-        * The bandwidth throttle value (kbps)
-        * @hide
-        */
-       public static final String THROTTLE_VALUE_KBITSPS = "throttle_value_kbitsps";
-
-       /**
-        * The bandwidth throttle reset calendar day (1-28)
-        * @hide
-        */
-       public static final String THROTTLE_RESET_DAY = "throttle_reset_day";
-
-       /**
-        * The throttling notifications we should send
-        * @hide
-        */
-       public static final String THROTTLE_NOTIFICATION_TYPE = "throttle_notification_type";
-
-       /**
-        * Help URI for data throttling policy
-        * @hide
-        */
-       public static final String THROTTLE_HELP_URI = "throttle_help_uri";
-
-       /**
-        * The length of time in Sec that we allow our notion of NTP time
-        * to be cached before we refresh it
-        * @hide
-        */
-       public static final String THROTTLE_MAX_NTP_CACHE_AGE_SEC =
-               "throttle_max_ntp_cache_age_sec";
-
-       /**
-        * USB Mass Storage Enabled
-        */
-       public static final String USB_MASS_STORAGE_ENABLED = "usb_mass_storage_enabled";
-
-       /**
-        * If this setting is set (to anything), then all references
-        * to Gmail on the device must change to Google Mail.
-        */
-       public static final String USE_GOOGLE_MAIL = "use_google_mail";
-
-       /** Autofill server address (Used in WebView/browser).
-        * {@hide} */
-       public static final String WEB_AUTOFILL_QUERY_URL =
-           "web_autofill_query_url";
-
-       /**
-        * Whether Wifi display is enabled/disabled
-        * 0=disabled. 1=enabled.
-        * @hide
-        */
-       public static final String WIFI_DISPLAY_ON = "wifi_display_on";
-
-       /**
-        * Whether to notify the user of open networks.
-        * <p>
-        * If not connected and the scan results have an open network, we will
-        * put this notification up. If we attempt to connect to a network or
-        * the open network(s) disappear, we remove the notification. When we
-        * show the notification, we will not show it again for
-        * {@link android.provider.Settings.Secure#WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY} time.
-        */
-       public static final String WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON =
-               "wifi_networks_available_notification_on";
-       /**
-        * {@hide}
-        */
-       public static final String WIMAX_NETWORKS_AVAILABLE_NOTIFICATION_ON =
-               "wimax_networks_available_notification_on";
-
-       /**
-        * Delay (in seconds) before repeating the Wi-Fi networks available notification.
-        * Connecting to a network will reset the timer.
-        */
-       public static final String WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY =
-               "wifi_networks_available_repeat_delay";
-
-       /**
-        * 802.11 country code in ISO 3166 format
-        * @hide
-        */
-       public static final String WIFI_COUNTRY_CODE = "wifi_country_code";
-
-       /**
-        * The interval in milliseconds to issue wake up scans when wifi needs
-        * to connect. This is necessary to connect to an access point when
-        * device is on the move and the screen is off.
-        * @hide
-        */
-       public static final String WIFI_FRAMEWORK_SCAN_INTERVAL_MS =
-               "wifi_framework_scan_interval_ms";
-
-       /**
-        * The interval in milliseconds after which Wi-Fi is considered idle.
-        * When idle, it is possible for the device to be switched from Wi-Fi to
-        * the mobile data network.
-        * @hide
-        */
-       public static final String WIFI_IDLE_MS = "wifi_idle_ms";
-
-       /**
-        * When the number of open networks exceeds this number, the
-        * least-recently-used excess networks will be removed.
-        */
-       public static final String WIFI_NUM_OPEN_NETWORKS_KEPT = "wifi_num_open_networks_kept";
-
-       /**
-        * Whether the Wi-Fi should be on.  Only the Wi-Fi service should touch this.
-        */
-       public static final String WIFI_ON = "wifi_on";
-
-       /**
-        * Used to save the Wifi_ON state prior to tethering.
-        * This state will be checked to restore Wifi after
-        * the user turns off tethering.
-        *
-        * @hide
-        */
-       public static final String WIFI_SAVED_STATE = "wifi_saved_state";
-
-       /**
-        * The interval in milliseconds to scan as used by the wifi supplicant
-        * @hide
-        */
-       public static final String WIFI_SUPPLICANT_SCAN_INTERVAL_MS =
-               "wifi_supplicant_scan_interval_ms";
-
-       /**
-        * The interval in milliseconds to scan at supplicant when p2p is connected
-        * @hide
-        */
-       public static final String WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS =
-               "wifi_scan_interval_p2p_connected_ms";
-
-       /**
-        * Whether the Wi-Fi watchdog is enabled.
-        */
-       public static final String WIFI_WATCHDOG_ON = "wifi_watchdog_on";
-
-       /**
-        * Setting to turn off poor network avoidance on Wi-Fi. Feature is enabled by default and
-        * the setting needs to be set to 0 to disable it.
-        * @hide
-        */
-       public static final String WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED =
-               "wifi_watchdog_poor_network_test_enabled";
-
-       /**
-        * Setting to turn on suspend optimizations at screen off on Wi-Fi. Enabled by default and
-        * needs to be set to 0 to disable it.
-        * @hide
-        */
-       public static final String WIFI_SUSPEND_OPTIMIZATIONS_ENABLED =
-               "wifi_suspend_optimizations_enabled";
-
-       /**
-        * The maximum number of times we will retry a connection to an access
-        * point for which we have failed in acquiring an IP address from DHCP.
-        * A value of N means that we will make N+1 connection attempts in all.
-        */
-       public static final String WIFI_MAX_DHCP_RETRY_COUNT = "wifi_max_dhcp_retry_count";
-
-       /**
-        * Maximum amount of time in milliseconds to hold a wakelock while waiting for mobile
-        * data connectivity to be established after a disconnect from Wi-Fi.
-        */
-       public static final String WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS =
-           "wifi_mobile_data_transition_wakelock_timeout_ms";
-
-       /**
-        * The operational wifi frequency band
-        * Set to one of {@link WifiManager#WIFI_FREQUENCY_BAND_AUTO},
-        * {@link WifiManager#WIFI_FREQUENCY_BAND_5GHZ} or
-        * {@link WifiManager#WIFI_FREQUENCY_BAND_2GHZ}
-        *
-        * @hide
-        */
-       public static final String WIFI_FREQUENCY_BAND = "wifi_frequency_band";
-
-       /**
-        * The Wi-Fi peer-to-peer device name
-        * @hide
-        */
-       public static final String WIFI_P2P_DEVICE_NAME = "wifi_p2p_device_name";
-
-       /**
-        * The number of milliseconds to delay when checking for data stalls during
-        * non-aggressive detection. (screen is turned off.)
-        * @hide
-        */
-       public static final String DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS =
-               "data_stall_alarm_non_aggressive_delay_in_ms";
-
-       /**
-        * The number of milliseconds to delay when checking for data stalls during
-        * aggressive detection. (screen on or suspected data stall)
-        * @hide
-        */
-       public static final String DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS =
-               "data_stall_alarm_aggressive_delay_in_ms";
-
-       /**
-        * The interval in milliseconds at which to check gprs registration
-        * after the first registration mismatch of gprs and voice service,
-        * to detect possible data network registration problems.
-        *
-        * @hide
-        */
-       public static final String GPRS_REGISTER_CHECK_PERIOD_MS =
-               "gprs_register_check_period_ms";
-
-       /**
-        * Nonzero causes Log.wtf() to crash.
-        * @hide
-        */
-       public static final String WTF_IS_FATAL = "wtf_is_fatal";
-
-       /**
-        * Ringer mode. This is used internally, changing this value will not
-        * change the ringer mode. See AudioManager.
-        */
-       public static final String MODE_RINGER = "mode_ringer";
-
-       /**
-        * Overlay display devices setting.
-        * The associated value is a specially formatted string that describes the
-        * size and density of simulated secondary display devices.
-        * <p>
-        * Format: {width}x{height}/{dpi};...
-        * </p><p>
-        * Example:
-        * <ul>
-        * <li><code>1280x720/213</code>: make one overlay that is 1280x720 at 213dpi.</li>
-        * <li><code>1920x1080/320;1280x720/213</code>: make two overlays, the first
-        * at 1080p and the second at 720p.</li>
-        * <li>If the value is empty, then no overlay display devices are created.</li>
-        * </ul></p>
-        *
-        * @hide
-        */
-       public static final String OVERLAY_DISPLAY_DEVICES = "overlay_display_devices";
-
-        /**
-         * Threshold values for the duration and level of a discharge cycle,
-         * under which we log discharge cycle info.
-         *
-         * @hide
-         */
-        public static final String
-                BATTERY_DISCHARGE_DURATION_THRESHOLD = "battery_discharge_duration_threshold";
-
-        /** @hide */
-        public static final String BATTERY_DISCHARGE_THRESHOLD = "battery_discharge_threshold";
-
-        /**
-         * Flag for allowing ActivityManagerService to send ACTION_APP_ERROR
-         * intents on application crashes and ANRs. If this is disabled, the
-         * crash/ANR dialog will never display the "Report" button.
-         * <p>
-         * Type: int (0 = disallow, 1 = allow)
-         *
-         * @hide
-         */
-        public static final String SEND_ACTION_APP_ERROR = "send_action_app_error";
-
-        /**
-         * Maximum age of entries kept by {@link DropBoxManager}.
-         *
-         * @hide
-         */
-        public static final String DROPBOX_AGE_SECONDS = "dropbox_age_seconds";
-
-        /**
-         * Maximum number of entry files which {@link DropBoxManager} will keep
-         * around.
-         *
-         * @hide
-         */
-        public static final String DROPBOX_MAX_FILES = "dropbox_max_files";
-
-        /**
-         * Maximum amount of disk space used by {@link DropBoxManager} no matter
-         * what.
-         *
-         * @hide
-         */
-        public static final String DROPBOX_QUOTA_KB = "dropbox_quota_kb";
-
-        /**
-         * Percent of free disk (excluding reserve) which {@link DropBoxManager}
-         * will use.
-         *
-         * @hide
-         */
-        public static final String DROPBOX_QUOTA_PERCENT = "dropbox_quota_percent";
-
-        /**
-         * Percent of total disk which {@link DropBoxManager} will never dip
-         * into.
-         *
-         * @hide
-         */
-        public static final String DROPBOX_RESERVE_PERCENT = "dropbox_reserve_percent";
-
-        /**
-         * Prefix for per-tag dropbox disable/enable settings.
-         *
-         * @hide
-         */
-        public static final String DROPBOX_TAG_PREFIX = "dropbox:";
-
-        /**
-         * Lines of logcat to include with system crash/ANR/etc. reports, as a
-         * prefix of the dropbox tag of the report type. For example,
-         * "logcat_for_system_server_anr" controls the lines of logcat captured
-         * with system server ANR reports. 0 to disable.
-         *
-         * @hide
-         */
-        public static final String ERROR_LOGCAT_PREFIX = "logcat_for_";
-
-        /**
-         * The interval in minutes after which the amount of free storage left
-         * on the device is logged to the event log
-         *
-         * @hide
-         */
-        public static final String SYS_FREE_STORAGE_LOG_INTERVAL = "sys_free_storage_log_interval";
-
-        /**
-         * Threshold for the amount of change in disk free space required to
-         * report the amount of free space. Used to prevent spamming the logs
-         * when the disk free space isn't changing frequently.
-         *
-         * @hide
-         */
-        public static final String
-                DISK_FREE_CHANGE_REPORTING_THRESHOLD = "disk_free_change_reporting_threshold";
-
-        /**
-         * Minimum percentage of free storage on the device that is used to
-         * determine if the device is running low on storage. The default is 10.
-         * <p>
-         * Say this value is set to 10, the device is considered running low on
-         * storage if 90% or more of the device storage is filled up.
-         *
-         * @hide
-         */
-        public static final String
-                SYS_STORAGE_THRESHOLD_PERCENTAGE = "sys_storage_threshold_percentage";
-
-        /**
-         * Maximum byte size of the low storage threshold. This is to ensure
-         * that {@link #SYS_STORAGE_THRESHOLD_PERCENTAGE} does not result in an
-         * overly large threshold for large storage devices. Currently this must
-         * be less than 2GB. This default is 500MB.
-         *
-         * @hide
-         */
-        public static final String
-                SYS_STORAGE_THRESHOLD_MAX_BYTES = "sys_storage_threshold_max_bytes";
-
-        /**
-         * Minimum bytes of free storage on the device before the data partition
-         * is considered full. By default, 1 MB is reserved to avoid system-wide
-         * SQLite disk full exceptions.
-         *
-         * @hide
-         */
-        public static final String
-                SYS_STORAGE_FULL_THRESHOLD_BYTES = "sys_storage_full_threshold_bytes";
-
-        /**
-         * The maximum reconnect delay for short network outages or when the
-         * network is suspended due to phone use.
-         *
-         * @hide
-         */
-        public static final String
-                SYNC_MAX_RETRY_DELAY_IN_SECONDS = "sync_max_retry_delay_in_seconds";
-
-        /**
-         * The number of milliseconds to delay before sending out
-         * {@link ConnectivityManager#CONNECTIVITY_ACTION} broadcasts.
-         *
-         * @hide
-         */
-        public static final String CONNECTIVITY_CHANGE_DELAY = "connectivity_change_delay";
-
-        /**
-         * Setting to turn off captive portal detection. Feature is enabled by
-         * default and the setting needs to be set to 0 to disable it.
-         *
-         * @hide
-         */
-        public static final String
-                CAPTIVE_PORTAL_DETECTION_ENABLED = "captive_portal_detection_enabled";
-
-        /**
-         * The server used for captive portal detection upon a new conection. A
-         * 204 response code from the server is used for validation.
-         *
-         * @hide
-         */
-        public static final String CAPTIVE_PORTAL_SERVER = "captive_portal_server";
-
-        /**
-         * Whether network service discovery is enabled.
-         *
-         * @hide
-         */
-        public static final String NSD_ON = "nsd_on";
-
-        /**
-         * Let user pick default install location.
-         *
-         * @hide
-         */
-        public static final String SET_INSTALL_LOCATION = "set_install_location";
-
-        /**
-         * Default install location value.
-         * 0 = auto, let system decide
-         * 1 = internal
-         * 2 = sdcard
-         * @hide
-         */
-        public static final String DEFAULT_INSTALL_LOCATION = "default_install_location";
-
-        /**
-         * ms during which to consume extra events related to Inet connection
-         * condition after a transtion to fully-connected
-         *
-         * @hide
-         */
-        public static final String
-                INET_CONDITION_DEBOUNCE_UP_DELAY = "inet_condition_debounce_up_delay";
-
-        /**
-         * ms during which to consume extra events related to Inet connection
-         * condtion after a transtion to partly-connected
-         *
-         * @hide
-         */
-        public static final String
-                INET_CONDITION_DEBOUNCE_DOWN_DELAY = "inet_condition_debounce_down_delay";
-
-        /** {@hide} */
-        public static final String
-                READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT = "read_external_storage_enforced_default";
-
-        /**
-         * Host name and port for global http proxy. Uses ':' seperator for
-         * between host and port.
-         */
-        public static final String HTTP_PROXY = "http_proxy";
-
-        /**
-         * Host name for global http proxy. Set via ConnectivityManager.
-         *
-         * @hide
-         */
-        public static final String GLOBAL_HTTP_PROXY_HOST = "global_http_proxy_host";
-
-        /**
-         * Integer host port for global http proxy. Set via ConnectivityManager.
-         *
-         * @hide
-         */
-        public static final String GLOBAL_HTTP_PROXY_PORT = "global_http_proxy_port";
-
-        /**
-         * Exclusion list for global proxy. This string contains a list of
-         * comma-separated domains where the global proxy does not apply.
-         * Domains should be listed in a comma- separated list. Example of
-         * acceptable formats: ".domain1.com,my.domain2.com" Use
-         * ConnectivityManager to set/get.
-         *
-         * @hide
-         */
-        public static final String
-                GLOBAL_HTTP_PROXY_EXCLUSION_LIST = "global_http_proxy_exclusion_list";
-
-        /**
-         * Enables the UI setting to allow the user to specify the global HTTP
-         * proxy and associated exclusion list.
-         *
-         * @hide
-         */
-        public static final String SET_GLOBAL_HTTP_PROXY = "set_global_http_proxy";
-
-        /**
-         * Setting for default DNS in case nobody suggests one
-         *
-         * @hide
-         */
-        public static final String DEFAULT_DNS_SERVER = "default_dns_server";
-
-        /** {@hide} */
-        public static final String
-                BLUETOOTH_HEADSET_PRIORITY_PREFIX = "bluetooth_headset_priority_";
-        /** {@hide} */
-        public static final String
-                BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX = "bluetooth_a2dp_sink_priority_";
-        /** {@hide} */
-        public static final String
-                BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX = "bluetooth_input_device_priority_";
-
-        /**
-         * Get the key that retrieves a bluetooth headset's priority.
-         * @hide
-         */
-        public static final String getBluetoothHeadsetPriorityKey(String address) {
-            return BLUETOOTH_HEADSET_PRIORITY_PREFIX + address.toUpperCase();
-        }
-
-        /**
-         * Get the key that retrieves a bluetooth a2dp sink's priority.
-         * @hide
-         */
-        public static final String getBluetoothA2dpSinkPriorityKey(String address) {
-            return BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX + address.toUpperCase();
-        }
-
-        /**
-         * Get the key that retrieves a bluetooth Input Device's priority.
-         * @hide
-         */
-        public static final String getBluetoothInputDevicePriorityKey(String address) {
-            return BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX + address.toUpperCase();
-        }
-
-        /**
-         * Scaling factor for normal window animations. Setting to 0 will
-         * disable window animations.
-         */
-        public static final String WINDOW_ANIMATION_SCALE = "window_animation_scale";
-
-        /**
-         * Scaling factor for activity transition animations. Setting to 0 will
-         * disable window animations.
-         */
-        public static final String TRANSITION_ANIMATION_SCALE = "transition_animation_scale";
-
-        /**
-         * Scaling factor for Animator-based animations. This affects both the
-         * start delay and duration of all such animations. Setting to 0 will
-         * cause animations to end immediately. The default value is 1.
-         */
-        public static final String ANIMATOR_DURATION_SCALE = "animator_duration_scale";
-
-        /**
-         * Scaling factor for normal window animations. Setting to 0 will
-         * disable window animations.
-         *
-         * @hide
-         */
-        public static final String FANCY_IME_ANIMATIONS = "fancy_ime_animations";
-
-        /**
-         * If 0, the compatibility mode is off for all applications.
-         * If 1, older applications run under compatibility mode.
-         * TODO: remove this settings before code freeze (bug/1907571)
-         * @hide
-         */
-        public static final String COMPATIBILITY_MODE = "compatibility_mode";
-
-        /**
-         * CDMA only settings
-         * Emergency Tone  0 = Off
-         *                 1 = Alert
-         *                 2 = Vibrate
-         * @hide
-         */
-        public static final String EMERGENCY_TONE = "emergency_tone";
-
-        /**
-         * CDMA only settings
-         * Whether the auto retry is enabled. The value is
-         * boolean (1 or 0).
-         * @hide
-         */
-        public static final String CALL_AUTO_RETRY = "call_auto_retry";
-
-        /**
-         * The preferred network mode   7 = Global
-         *                              6 = EvDo only
-         *                              5 = CDMA w/o EvDo
-         *                              4 = CDMA / EvDo auto
-         *                              3 = GSM / WCDMA auto
-         *                              2 = WCDMA only
-         *                              1 = GSM only
-         *                              0 = GSM / WCDMA preferred
-         * @hide
-         */
-        public static final String PREFERRED_NETWORK_MODE =
-                "preferred_network_mode";
-
-        /**
-         * The cdma subscription 0 = Subscription from RUIM, when available
-         *                       1 = Subscription from NV
-         * @hide
-         */
-        public static final String PREFERRED_CDMA_SUBSCRIPTION =
-                "preferred_cdma_subscription";
-
-        /**
-         * Name of an application package to be debugged.
-         */
-        public static final String DEBUG_APP = "debug_app";
-
-        /**
-         * If 1, when launching DEBUG_APP it will wait for the debugger before
-         * starting user code.  If 0, it will run normally.
-         */
-        public static final String WAIT_FOR_DEBUGGER = "wait_for_debugger";
-
-        /**
-         * Control whether the process CPU usage meter should be shown.
-         */
-        public static final String SHOW_PROCESSES = "show_processes";
-
-        /**
-         * If 1, the activity manager will aggressively finish activities and
-         * processes as soon as they are no longer needed.  If 0, the normal
-         * extended lifetime is used.
-         */
-        public static final String ALWAYS_FINISH_ACTIVITIES =
-                "always_finish_activities";
-
-        /**
-         * Use Dock audio output for media:
-         *      0 = disabled
-         *      1 = enabled
-         * @hide
-         */
-        public static final String DOCK_AUDIO_MEDIA_ENABLED = "dock_audio_media_enabled";
-
-        /**
-         * Persisted safe headphone volume management state by AudioService
-         * @hide
-         */
-        public static final String AUDIO_SAFE_VOLUME_STATE = "audio_safe_volume_state";
-
-        /**
-         * Settings to backup. This is here so that it's in the same place as the settings
-         * keys and easy to update.
-         *
-         * These keys may be mentioned in the SETTINGS_TO_BACKUP arrays in System
-         * and Secure as well.  This is because those tables drive both backup and
-         * restore, and restore needs to properly whitelist keys that used to live
-         * in those namespaces.  The keys will only actually be backed up / restored
-         * if they are also mentioned in this table (Global.SETTINGS_TO_BACKUP).
-         *
-         * NOTE: Settings are backed up and restored in the order they appear
-         *       in this array. If you have one setting depending on another,
-         *       make sure that they are ordered appropriately.
-         *
-         * @hide
-         */
-        public static final String[] SETTINGS_TO_BACKUP = {
-            STAY_ON_WHILE_PLUGGED_IN,
-            MODE_RINGER,
-            AUTO_TIME,
-            AUTO_TIME_ZONE,
-            POWER_SOUNDS_ENABLED,
-            POWER_NOTIFICATIONS_ENABLED,
-            POWER_NOTIFICATIONS_VIBRATE,
-            POWER_NOTIFICATIONS_RINGTONE,
-            DOCK_SOUNDS_ENABLED,
-            USB_MASS_STORAGE_ENABLED,
-            ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED,
-            WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
-            WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
-            WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED,
-            WIFI_NUM_OPEN_NETWORKS_KEPT,
-            EMERGENCY_TONE,
-            CALL_AUTO_RETRY,
-            DOCK_AUDIO_MEDIA_ENABLED
-        };
-
-        // Populated lazily, guarded by class object:
-        private static NameValueCache sNameValueCache = new NameValueCache(
-                    SYS_PROP_SETTING_VERSION,
-                    CONTENT_URI,
-                    CALL_METHOD_GET_GLOBAL,
-                    CALL_METHOD_PUT_GLOBAL);
-
-        /**
-         * Look up a name in the database.
-         * @param resolver to access the database with
-         * @param name to look up in the table
-         * @return the corresponding value, or null if not present
-         */
-        public static String getString(ContentResolver resolver, String name) {
-            return getStringForUser(resolver, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static String getStringForUser(ContentResolver resolver, String name,
-                int userHandle) {
-            return sNameValueCache.getStringForUser(resolver, name, userHandle);
-        }
-
-        /**
-         * Store a name/value pair into the database.
-         * @param resolver to access the database with
-         * @param name to store
-         * @param value to associate with the name
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putString(ContentResolver resolver,
-                String name, String value) {
-            return putStringForUser(resolver, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putStringForUser(ContentResolver resolver,
-                String name, String value, int userHandle) {
-            if (LOCAL_LOGV) {
-                Log.v(TAG, "Global.putString(name=" + name + ", value=" + value
-                        + " for " + userHandle);
-            }
-            return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
-        }
-
-        /**
-         * Construct the content URI for a particular name/value pair,
-         * useful for monitoring changes with a ContentObserver.
-         * @param name to look up in the table
-         * @return the corresponding content URI, or null if not present
-         */
-        public static Uri getUriFor(String name) {
-            return getUriFor(CONTENT_URI, name);
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.  The default value will be returned if the setting is
-         * not defined or not an integer.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid integer.
-         */
-        public static int getInt(ContentResolver cr, String name, int def) {
-            String v = getString(cr, name);
-            try {
-                return v != null ? Integer.parseInt(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         *
-         * @return The setting's current value.
-         */
-        public static int getInt(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            String v = getString(cr, name);
-            try {
-                return Integer.parseInt(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as an
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putInt(ContentResolver cr, String name, int value) {
-            return putString(cr, name, Integer.toString(value));
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.  The default value will be returned if the setting is
-         * not defined or not a {@code long}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid {@code long}.
-         */
-        public static long getLong(ContentResolver cr, String name, long def) {
-            String valString = getString(cr, name);
-            long value;
-            try {
-                value = valString != null ? Long.parseLong(valString) : def;
-            } catch (NumberFormatException e) {
-                value = def;
-            }
-            return value;
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @return The setting's current value.
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         */
-        public static long getLong(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            String valString = getString(cr, name);
-            try {
-                return Long.parseLong(valString);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a secure settings value as a long
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putLong(ContentResolver cr, String name, long value) {
-            return putString(cr, name, Long.toString(value));
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a floating point number.  Note that internally setting values are
-         * always stored as strings; this function converts the string to an
-         * float for you. The default value will be returned if the setting
-         * is not defined or not a valid float.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid float.
-         */
-        public static float getFloat(ContentResolver cr, String name, float def) {
-            String v = getString(cr, name);
-            try {
-                return v != null ? Float.parseFloat(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a float.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a float
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not a float.
-         *
-         * @return The setting's current value.
-         */
-        public static float getFloat(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            String v = getString(cr, name);
-            if (v == null) {
-                throw new SettingNotFoundException(name);
-            }
-            try {
-                return Float.parseFloat(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as a
-         * floating point number. This will either create a new entry in the
-         * table if the given name does not exist, or modify the value of the
-         * existing row with that name.  Note that internally setting values
-         * are always stored as strings, so this function converts the given
-         * value to a string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putFloat(ContentResolver cr, String name, float value) {
-            return putString(cr, name, Float.toString(value));
-        }
-    }
-
-    /**
-     * User-defined bookmarks and shortcuts.  The target of each bookmark is an
-     * Intent URL, allowing it to be either a web page or a particular
-     * application activity.
-     *
-     * @hide
-     */
-    public static final class Bookmarks implements BaseColumns
-    {
-        private static final String TAG = "Bookmarks";
-
-        /**
-         * The content:// style URL for this table
-         */
-        public static final Uri CONTENT_URI =
-            Uri.parse("content://" + AUTHORITY + "/bookmarks");
-
-        /**
-         * The row ID.
-         * <p>Type: INTEGER</p>
-         */
-        public static final String ID = "_id";
-
-        /**
-         * Descriptive name of the bookmark that can be displayed to the user.
-         * If this is empty, the title should be resolved at display time (use
-         * {@link #getTitle(Context, Cursor)} any time you want to display the
-         * title of a bookmark.)
-         * <P>
-         * Type: TEXT
-         * </P>
-         */
-        public static final String TITLE = "title";
-
-        /**
-         * Arbitrary string (displayed to the user) that allows bookmarks to be
-         * organized into categories.  There are some special names for
-         * standard folders, which all start with '@'.  The label displayed for
-         * the folder changes with the locale (via {@link #getLabelForFolder}) but
-         * the folder name does not change so you can consistently query for
-         * the folder regardless of the current locale.
-         *
-         * <P>Type: TEXT</P>
-         *
-         */
-        public static final String FOLDER = "folder";
-
-        /**
-         * The Intent URL of the bookmark, describing what it points to.  This
-         * value is given to {@link android.content.Intent#getIntent} to create
-         * an Intent that can be launched.
-         * <P>Type: TEXT</P>
-         */
-        public static final String INTENT = "intent";
-
-        /**
-         * Optional shortcut character associated with this bookmark.
-         * <P>Type: INTEGER</P>
-         */
-        public static final String SHORTCUT = "shortcut";
-
-        /**
-         * The order in which the bookmark should be displayed
-         * <P>Type: INTEGER</P>
-         */
-        public static final String ORDERING = "ordering";
-
-        private static final String[] sIntentProjection = { INTENT };
-        private static final String[] sShortcutProjection = { ID, SHORTCUT };
-        private static final String sShortcutSelection = SHORTCUT + "=?";
-
-        /**
-         * Convenience function to retrieve the bookmarked Intent for a
-         * particular shortcut key.
-         *
-         * @param cr The ContentResolver to query.
-         * @param shortcut The shortcut key.
-         *
-         * @return Intent The bookmarked URL, or null if there is no bookmark
-         *         matching the given shortcut.
-         */
-        public static Intent getIntentForShortcut(ContentResolver cr, char shortcut)
-        {
-            Intent intent = null;
-
-            Cursor c = cr.query(CONTENT_URI,
-                    sIntentProjection, sShortcutSelection,
-                    new String[] { String.valueOf((int) shortcut) }, ORDERING);
-            // Keep trying until we find a valid shortcut
-            try {
-                while (intent == null && c.moveToNext()) {
-                    try {
-                        String intentURI = c.getString(c.getColumnIndexOrThrow(INTENT));
-                        intent = Intent.parseUri(intentURI, 0);
-                    } catch (java.net.URISyntaxException e) {
-                        // The stored URL is bad...  ignore it.
-                    } catch (IllegalArgumentException e) {
-                        // Column not found
-                        Log.w(TAG, "Intent column not found", e);
-                    }
-                }
-            } finally {
-                if (c != null) c.close();
-            }
-
-            return intent;
-        }
-
-        /**
-         * Add a new bookmark to the system.
-         *
-         * @param cr The ContentResolver to query.
-         * @param intent The desired target of the bookmark.
-         * @param title Bookmark title that is shown to the user; null if none
-         *            or it should be resolved to the intent's title.
-         * @param folder Folder in which to place the bookmark; null if none.
-         * @param shortcut Shortcut that will invoke the bookmark; 0 if none. If
-         *            this is non-zero and there is an existing bookmark entry
-         *            with this same shortcut, then that existing shortcut is
-         *            cleared (the bookmark is not removed).
-         * @return The unique content URL for the new bookmark entry.
-         */
-        public static Uri add(ContentResolver cr,
-                                           Intent intent,
-                                           String title,
-                                           String folder,
-                                           char shortcut,
-                                           int ordering)
-        {
-            // If a shortcut is supplied, and it is already defined for
-            // another bookmark, then remove the old definition.
-            if (shortcut != 0) {
-                cr.delete(CONTENT_URI, sShortcutSelection,
-                        new String[] { String.valueOf((int) shortcut) });
-            }
-
-            ContentValues values = new ContentValues();
-            if (title != null) values.put(TITLE, title);
-            if (folder != null) values.put(FOLDER, folder);
-            values.put(INTENT, intent.toUri(0));
-            if (shortcut != 0) values.put(SHORTCUT, (int) shortcut);
-            values.put(ORDERING, ordering);
-            return cr.insert(CONTENT_URI, values);
-        }
-
-        /**
-         * Return the folder name as it should be displayed to the user.  This
-         * takes care of localizing special folders.
-         *
-         * @param r Resources object for current locale; only need access to
-         *          system resources.
-         * @param folder The value found in the {@link #FOLDER} column.
-         *
-         * @return CharSequence The label for this folder that should be shown
-         *         to the user.
-         */
-        public static CharSequence getLabelForFolder(Resources r, String folder) {
-            return folder;
-        }
-
-        /**
-         * Return the title as it should be displayed to the user. This takes
-         * care of localizing bookmarks that point to activities.
-         *
-         * @param context A context.
-         * @param cursor A cursor pointing to the row whose title should be
-         *        returned. The cursor must contain at least the {@link #TITLE}
-         *        and {@link #INTENT} columns.
-         * @return A title that is localized and can be displayed to the user,
-         *         or the empty string if one could not be found.
-         */
-        public static CharSequence getTitle(Context context, Cursor cursor) {
-            int titleColumn = cursor.getColumnIndex(TITLE);
-            int intentColumn = cursor.getColumnIndex(INTENT);
-            if (titleColumn == -1 || intentColumn == -1) {
-                throw new IllegalArgumentException(
-                        "The cursor must contain the TITLE and INTENT columns.");
-            }
-
-            String title = cursor.getString(titleColumn);
-            if (!TextUtils.isEmpty(title)) {
-                return title;
-            }
-
-            String intentUri = cursor.getString(intentColumn);
-            if (TextUtils.isEmpty(intentUri)) {
-                return "";
-            }
-
-            Intent intent;
-            try {
-                intent = Intent.parseUri(intentUri, 0);
-            } catch (URISyntaxException e) {
-                return "";
-            }
-
-            PackageManager packageManager = context.getPackageManager();
-            ResolveInfo info = packageManager.resolveActivity(intent, 0);
-            return info != null ? info.loadLabel(packageManager) : "";
-        }
-    }
-
-    /**
-     * Returns the device ID that we should use when connecting to the mobile gtalk server.
-     * This is a string like "android-0x1242", where the hex string is the Android ID obtained
-     * from the GoogleLoginService.
-     *
-     * @param androidId The Android ID for this device.
-     * @return The device ID that should be used when connecting to the mobile gtalk server.
-     * @hide
-     */
-    public static String getGTalkDeviceId(long androidId) {
-        return "android-" + Long.toHexString(androidId);
-    }
-}
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (C) 2012 ParanoidAndroid Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.provider;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.app.ActivityManagerNative;
+import android.app.SearchManager;
+import android.app.WallpaperManager;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.IContentProvider;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.net.ConnectivityManager;
+import android.net.Uri;
+import android.net.wifi.WifiManager;
+import android.os.BatteryManager;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.DropBoxManager;
+import android.os.IBinder;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.os.Build.VERSION_CODES;
+import android.speech.tts.TextToSpeech;
+import android.text.TextUtils;
+import android.util.AndroidException;
+import android.util.Log;
+import android.view.WindowOrientationListener;
+
+import com.android.internal.widget.ILockSettings;
+
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.HashSet;
+
+/**
+ * The Settings provider contains global system-level device preferences.
+ */
+public final class Settings {
+
+    // Intent actions for Settings
+
+    /**
+     * Activity Action: Show system settings.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SETTINGS = "android.settings.SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of APNs.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_APN_SETTINGS = "android.settings.APN_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of current location
+     * sources.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_LOCATION_SOURCE_SETTINGS =
+            "android.settings.LOCATION_SOURCE_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of wireless controls
+     * such as Wi-Fi, Bluetooth and Mobile networks.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_WIRELESS_SETTINGS =
+            "android.settings.WIRELESS_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow entering/exiting airplane mode.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_AIRPLANE_MODE_SETTINGS =
+            "android.settings.AIRPLANE_MODE_SETTINGS";
+
+    /**
+     * Activity Action: Show settings for accessibility modules.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_ACCESSIBILITY_SETTINGS =
+            "android.settings.ACCESSIBILITY_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of security and
+     * location privacy.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SECURITY_SETTINGS =
+            "android.settings.SECURITY_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of privacy options.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_PRIVACY_SETTINGS =
+            "android.settings.PRIVACY_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of Wi-Fi.
+
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_WIFI_SETTINGS =
+            "android.settings.WIFI_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of a static IP
+     * address for Wi-Fi.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you safeguard
+     * against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_WIFI_IP_SETTINGS =
+            "android.settings.WIFI_IP_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of Bluetooth.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_BLUETOOTH_SETTINGS =
+            "android.settings.BLUETOOTH_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of Wifi Displays.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_WIFI_DISPLAY_SETTINGS =
+            "android.settings.WIFI_DISPLAY_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of date and time.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_DATE_SETTINGS =
+            "android.settings.DATE_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of sound and volume.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SOUND_SETTINGS =
+            "android.settings.SOUND_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of display.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_DISPLAY_SETTINGS =
+            "android.settings.DISPLAY_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of locale.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_LOCALE_SETTINGS =
+            "android.settings.LOCALE_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to configure input methods, in particular
+     * allowing the user to enable input methods.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_INPUT_METHOD_SETTINGS =
+            "android.settings.INPUT_METHOD_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to enable/disable input method subtypes.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * To tell which input method's subtypes are displayed in the settings, add
+     * {@link #EXTRA_INPUT_METHOD_ID} extra to this Intent with the input method id.
+     * If there is no extra in this Intent, subtypes from all installed input methods
+     * will be displayed in the settings.
+     *
+     * @see android.view.inputmethod.InputMethodInfo#getId
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_INPUT_METHOD_SUBTYPE_SETTINGS =
+            "android.settings.INPUT_METHOD_SUBTYPE_SETTINGS";
+
+    /**
+     * Activity Action: Show a dialog to select input method.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SHOW_INPUT_METHOD_PICKER =
+            "android.settings.SHOW_INPUT_METHOD_PICKER";
+
+    /**
+     * Activity Action: Show settings to manage the user input dictionary.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_USER_DICTIONARY_SETTINGS =
+            "android.settings.USER_DICTIONARY_SETTINGS";
+
+    /**
+     * Activity Action: Adds a word to the user dictionary.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: An extra with key <code>word</code> that contains the word
+     * that should be added to the dictionary.
+     * <p>
+     * Output: Nothing.
+     *
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_USER_DICTIONARY_INSERT =
+            "com.android.settings.USER_DICTIONARY_INSERT";
+
+    /**
+     * Activity Action: Show settings to allow configuration of application-related settings.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_APPLICATION_SETTINGS =
+            "android.settings.APPLICATION_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of application
+     * development-related settings.  As of
+     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} this action is
+     * a required part of the platform.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_APPLICATION_DEVELOPMENT_SETTINGS =
+            "android.settings.APPLICATION_DEVELOPMENT_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of quick launch shortcuts.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_QUICK_LAUNCH_SETTINGS =
+            "android.settings.QUICK_LAUNCH_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to manage installed applications.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_MANAGE_APPLICATIONS_SETTINGS =
+            "android.settings.MANAGE_APPLICATIONS_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to manage all applications.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_MANAGE_ALL_APPLICATIONS_SETTINGS =
+            "android.settings.MANAGE_ALL_APPLICATIONS_SETTINGS";
+
+    /**
+     * Activity Action: Show screen of details about a particular application.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: The Intent's data URI specifies the application package name
+     * to be shown, with the "package" scheme.  That is "package:com.my.app".
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_APPLICATION_DETAILS_SETTINGS =
+            "android.settings.APPLICATION_DETAILS_SETTINGS";
+
+    /**
+     * Activity Action: Show settings for system update functionality.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     *
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SYSTEM_UPDATE_SETTINGS =
+            "android.settings.SYSTEM_UPDATE_SETTINGS";
+
+    /**
+     * Activity Action: Show settings to allow configuration of sync settings.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * The account types available to add via the add account button may be restricted by adding an
+     * {@link #EXTRA_AUTHORITIES} extra to this Intent with one or more syncable content provider's
+     * authorities. Only account types which can sync with that content provider will be offered to
+     * the user.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SYNC_SETTINGS =
+            "android.settings.SYNC_SETTINGS";
+
+    /**
+     * Activity Action: Show add account screen for creating a new account.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * The account types available to add may be restricted by adding an {@link #EXTRA_AUTHORITIES}
+     * extra to the Intent with one or more syncable content provider's authorities.  Only account
+     * types which can sync with that content provider will be offered to the user.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_ADD_ACCOUNT =
+            "android.settings.ADD_ACCOUNT_SETTINGS";
+
+    /**
+     * Activity Action: Show settings for selecting the network operator.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_NETWORK_OPERATOR_SETTINGS =
+            "android.settings.NETWORK_OPERATOR_SETTINGS";
+
+    /**
+     * Activity Action: Show settings for selection of 2G/3G.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_DATA_ROAMING_SETTINGS =
+            "android.settings.DATA_ROAMING_SETTINGS";
+
+    /**
+     * Activity Action: Show settings for internal storage.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_INTERNAL_STORAGE_SETTINGS =
+            "android.settings.INTERNAL_STORAGE_SETTINGS";
+    /**
+     * Activity Action: Show settings for memory card storage.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_MEMORY_CARD_SETTINGS =
+            "android.settings.MEMORY_CARD_SETTINGS";
+
+    /**
+     * Activity Action: Show settings for global search.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_SEARCH_SETTINGS =
+        "android.search.action.SEARCH_SETTINGS";
+
+    /**
+     * Activity Action: Show general device information settings (serial
+     * number, software version, phone number, etc.).
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_DEVICE_INFO_SETTINGS =
+        "android.settings.DEVICE_INFO_SETTINGS";
+
+    /**
+     * Activity Action: Show NFC settings.
+     * <p>
+     * This shows UI that allows NFC to be turned on or off.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing
+     * @see android.nfc.NfcAdapter#isEnabled()
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_NFC_SETTINGS = "android.settings.NFC_SETTINGS";
+
+    /**
+     * Activity Action: Show NFC Sharing settings.
+     * <p>
+     * This shows UI that allows NDEF Push (Android Beam) to be turned on or
+     * off.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing
+     * @see android.nfc.NfcAdapter#isNdefPushEnabled()
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_NFCSHARING_SETTINGS =
+        "android.settings.NFCSHARING_SETTINGS";
+
+    /**
+     * Activity Action: Show Daydream settings.
+     * <p>
+     * In some cases, a matching Activity may not exist, so ensure you
+     * safeguard against this.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     * @see android.service.dreams.DreamService
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_DREAM_SETTINGS = "android.settings.DREAM_SETTINGS";
+
+    // End of Intent actions for Settings
+
+    /**
+     * @hide - Private call() method on SettingsProvider to read from 'system' table.
+     */
+    public static final String CALL_METHOD_GET_SYSTEM = "GET_system";
+
+    /**
+     * @hide - Private call() method on SettingsProvider to read from 'secure' table.
+     */
+    public static final String CALL_METHOD_GET_SECURE = "GET_secure";
+
+    /**
+     * @hide - Private call() method on SettingsProvider to read from 'global' table.
+     */
+    public static final String CALL_METHOD_GET_GLOBAL = "GET_global";
+
+    /**
+     * @hide - User handle argument extra to the fast-path call()-based requests
+     */
+    public static final String CALL_METHOD_USER_KEY = "_user";
+
+    /** @hide - Private call() method to write to 'system' table */
+    public static final String CALL_METHOD_PUT_SYSTEM = "PUT_system";
+
+    /** @hide - Private call() method to write to 'secure' table */
+    public static final String CALL_METHOD_PUT_SECURE = "PUT_secure";
+
+    /** @hide - Private call() method to write to 'global' table */
+    public static final String CALL_METHOD_PUT_GLOBAL= "PUT_global";
+
+    /**
+     * Activity Extra: Limit available options in launched activity based on the given authority.
+     * <p>
+     * This can be passed as an extra field in an Activity Intent with one or more syncable content
+     * provider's authorities as a String[]. This field is used by some intents to alter the
+     * behavior of the called activity.
+     * <p>
+     * Example: The {@link #ACTION_ADD_ACCOUNT} intent restricts the account types available based
+     * on the authority given.
+     */
+    public static final String EXTRA_AUTHORITIES =
+            "authorities";
+
+    public static final String EXTRA_INPUT_METHOD_ID = "input_method_id";
+
+    private static final String JID_RESOURCE_PREFIX = "android";
+
+    public static final String AUTHORITY = "settings";
+
+    private static final String TAG = "Settings";
+    private static final boolean LOCAL_LOGV = false;
+
+    public static class SettingNotFoundException extends AndroidException {
+        public SettingNotFoundException(String msg) {
+            super(msg);
+        }
+    }
+
+    /**
+     * Common base for tables of name/value settings.
+     */
+    public static class NameValueTable implements BaseColumns {
+        public static final String NAME = "name";
+        public static final String VALUE = "value";
+
+        protected static boolean putString(ContentResolver resolver, Uri uri,
+                String name, String value) {
+            // The database will take care of replacing duplicates.
+            try {
+                ContentValues values = new ContentValues();
+                values.put(NAME, name);
+                values.put(VALUE, value);
+                resolver.insert(uri, values);
+                return true;
+            } catch (SQLException e) {
+                Log.w(TAG, "Can't set key " + name + " in " + uri, e);
+                return false;
+            }
+        }
+
+        public static Uri getUriFor(Uri uri, String name) {
+            return Uri.withAppendedPath(uri, name);
+        }
+    }
+
+    // Thread-safe.
+    private static class NameValueCache {
+        private final String mVersionSystemProperty;
+        private final Uri mUri;
+
+        private static final String[] SELECT_VALUE =
+            new String[] { Settings.NameValueTable.VALUE };
+        private static final String NAME_EQ_PLACEHOLDER = "name=?";
+
+        // Must synchronize on 'this' to access mValues and mValuesVersion.
+        private final HashMap<String, String> mValues = new HashMap<String, String>();
+        private long mValuesVersion = 0;
+
+        // Initially null; set lazily and held forever.  Synchronized on 'this'.
+        private IContentProvider mContentProvider = null;
+
+        // The method we'll call (or null, to not use) on the provider
+        // for the fast path of retrieving settings.
+        private final String mCallGetCommand;
+        private final String mCallSetCommand;
+
+        public NameValueCache(String versionSystemProperty, Uri uri,
+                String getCommand, String setCommand) {
+            mVersionSystemProperty = versionSystemProperty;
+            mUri = uri;
+            mCallGetCommand = getCommand;
+            mCallSetCommand = setCommand;
+        }
+
+        private IContentProvider lazyGetProvider(ContentResolver cr) {
+            IContentProvider cp = null;
+            synchronized (this) {
+                cp = mContentProvider;
+                if (cp == null) {
+                    cp = mContentProvider = cr.acquireProvider(mUri.getAuthority());
+                }
+            }
+            return cp;
+        }
+
+        public boolean putStringForUser(ContentResolver cr, String name, String value,
+                final int userHandle) {
+            try {
+                Bundle arg = new Bundle();
+                arg.putString(Settings.NameValueTable.VALUE, value);
+                arg.putInt(CALL_METHOD_USER_KEY, userHandle);
+                IContentProvider cp = lazyGetProvider(cr);
+                cp.call(mCallSetCommand, name, arg);
+            } catch (RemoteException e) {
+                Log.w(TAG, "Can't set key " + name + " in " + mUri, e);
+                return false;
+            }
+            return true;
+        }
+
+        public String getStringForUser(ContentResolver cr, String name, final int userHandle) {
+            final boolean isSelf = (userHandle == UserHandle.myUserId());
+            if (isSelf) {
+                long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
+
+                // Our own user's settings data uses a client-side cache
+                synchronized (this) {
+                    if (mValuesVersion != newValuesVersion) {
+                        if (LOCAL_LOGV || false) {
+                            Log.v(TAG, "invalidate [" + mUri.getLastPathSegment() + "]: current "
+                                    + newValuesVersion + " != cached " + mValuesVersion);
+                        }
+
+                        mValues.clear();
+                        mValuesVersion = newValuesVersion;
+                    }
+
+                    if (mValues.containsKey(name)) {
+                        return mValues.get(name);  // Could be null, that's OK -- negative caching
+                    }
+                }
+            } else {
+                if (LOCAL_LOGV) Log.v(TAG, "get setting for user " + userHandle
+                        + " by user " + UserHandle.myUserId() + " so skipping cache");
+            }
+
+            IContentProvider cp = lazyGetProvider(cr);
+
+            // Try the fast path first, not using query().  If this
+            // fails (alternate Settings provider that doesn't support
+            // this interface?) then we fall back to the query/table
+            // interface.
+            if (mCallGetCommand != null) {
+                try {
+                    Bundle args = null;
+                    if (!isSelf) {
+                        args = new Bundle();
+                        args.putInt(CALL_METHOD_USER_KEY, userHandle);
+                    }
+                    Bundle b = cp.call(mCallGetCommand, name, args);
+                    if (b != null) {
+                        String value = b.getPairValue();
+                        // Don't update our cache for reads of other users' data
+                        if (isSelf) {
+                            synchronized (this) {
+                                mValues.put(name, value);
+                            }
+                        } else {
+                            if (LOCAL_LOGV) Log.i(TAG, "call-query of user " + userHandle
+                                    + " by " + UserHandle.myUserId()
+                                    + " so not updating cache");
+                        }
+                        return value;
+                    }
+                    // If the response Bundle is null, we fall through
+                    // to the query interface below.
+                } catch (RemoteException e) {
+                    // Not supported by the remote side?  Fall through
+                    // to query().
+                }
+            }
+
+            Cursor c = null;
+            try {
+                c = cp.query(mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER,
+                             new String[]{name}, null, null);
+                if (c == null) {
+                    Log.w(TAG, "Can't get key " + name + " from " + mUri);
+                    return null;
+                }
+
+                String value = c.moveToNext() ? c.getString(0) : null;
+                synchronized (this) {
+                    mValues.put(name, value);
+                }
+                if (LOCAL_LOGV) {
+                    Log.v(TAG, "cache miss [" + mUri.getLastPathSegment() + "]: " +
+                            name + " = " + (value == null ? "(null)" : value));
+                }
+                return value;
+            } catch (RemoteException e) {
+                Log.w(TAG, "Can't get key " + name + " from " + mUri, e);
+                return null;  // Return null, but don't cache it.
+            } finally {
+                if (c != null) c.close();
+            }
+        }
+    }
+
+    /**
+     * System settings, containing miscellaneous system preferences.  This
+     * table holds simple name/value pairs.  There are convenience
+     * functions for accessing individual settings entries.
+     */
+    public static final class System extends NameValueTable {
+        public static final String SYS_PROP_SETTING_VERSION = "sys.settings_system_version";
+
+        /**
+         * The content:// style URL for this table
+         */
+        public static final Uri CONTENT_URI =
+            Uri.parse("content://" + AUTHORITY + "/system");
+
+        private static final NameValueCache sNameValueCache = new NameValueCache(
+                SYS_PROP_SETTING_VERSION,
+                CONTENT_URI,
+                CALL_METHOD_GET_SYSTEM,
+                CALL_METHOD_PUT_SYSTEM);
+
+        private static final HashSet<String> MOVED_TO_SECURE;
+        static {
+            MOVED_TO_SECURE = new HashSet<String>(30);
+            MOVED_TO_SECURE.add(Secure.ANDROID_ID);
+            MOVED_TO_SECURE.add(Secure.HTTP_PROXY);
+            MOVED_TO_SECURE.add(Secure.LOCATION_PROVIDERS_ALLOWED);
+            MOVED_TO_SECURE.add(Secure.LOCK_BIOMETRIC_WEAK_FLAGS);
+            MOVED_TO_SECURE.add(Secure.LOCK_PATTERN_ENABLED);
+            MOVED_TO_SECURE.add(Secure.LOCK_PATTERN_VISIBLE);
+            MOVED_TO_SECURE.add(Secure.LOCK_SHOW_ERROR_PATH);
+            MOVED_TO_SECURE.add(Secure.LOCK_DOTS_VISIBLE);
+            MOVED_TO_SECURE.add(Secure.LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED);
+            MOVED_TO_SECURE.add(Secure.LOGGING_ID);
+            MOVED_TO_SECURE.add(Secure.PARENTAL_CONTROL_ENABLED);
+            MOVED_TO_SECURE.add(Secure.PARENTAL_CONTROL_LAST_UPDATE);
+            MOVED_TO_SECURE.add(Secure.PARENTAL_CONTROL_REDIRECT_URL);
+            MOVED_TO_SECURE.add(Secure.SETTINGS_CLASSNAME);
+            MOVED_TO_SECURE.add(Secure.USE_GOOGLE_MAIL);
+            MOVED_TO_SECURE.add(Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON);
+            MOVED_TO_SECURE.add(Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY);
+            MOVED_TO_SECURE.add(Secure.WIFI_NUM_OPEN_NETWORKS_KEPT);
+            MOVED_TO_SECURE.add(Secure.WIFI_ON);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_AP_COUNT);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_MAX_AP_CHECKS);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_ON);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_PING_COUNT);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_PING_DELAY_MS);
+            MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS);
+        }
+
+        private static final HashSet<String> MOVED_TO_GLOBAL;
+        private static final HashSet<String> MOVED_TO_SECURE_THEN_GLOBAL;
+        static {
+            MOVED_TO_GLOBAL = new HashSet<String>();
+            MOVED_TO_SECURE_THEN_GLOBAL = new HashSet<String>();
+
+            // these were originally in system but migrated to secure in the past,
+            // so are duplicated in the Secure.* namespace
+            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.ADB_ENABLED);
+            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.BLUETOOTH_ON);
+            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.DATA_ROAMING);
+            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.DEVICE_PROVISIONED);
+            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.INSTALL_NON_MARKET_APPS);
+            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.USB_MASS_STORAGE_ENABLED);
+            MOVED_TO_SECURE_THEN_GLOBAL.add(Global.HTTP_PROXY);
+
+            // these are moving directly from system to global
+            MOVED_TO_GLOBAL.add(Settings.Global.AIRPLANE_MODE_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.AIRPLANE_MODE_RADIOS);
+            MOVED_TO_GLOBAL.add(Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
+            MOVED_TO_GLOBAL.add(Settings.Global.AUTO_TIME);
+            MOVED_TO_GLOBAL.add(Settings.Global.AUTO_TIME_ZONE);
+            MOVED_TO_GLOBAL.add(Settings.Global.CAR_DOCK_SOUND);
+            MOVED_TO_GLOBAL.add(Settings.Global.CAR_UNDOCK_SOUND);
+            MOVED_TO_GLOBAL.add(Settings.Global.DESK_DOCK_SOUND);
+            MOVED_TO_GLOBAL.add(Settings.Global.DESK_UNDOCK_SOUND);
+            MOVED_TO_GLOBAL.add(Settings.Global.DOCK_SOUNDS_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.LOCK_SOUND);
+            MOVED_TO_GLOBAL.add(Settings.Global.UNLOCK_SOUND);
+            MOVED_TO_GLOBAL.add(Settings.Global.LOW_BATTERY_SOUND);
+            MOVED_TO_GLOBAL.add(Settings.Global.POWER_SOUNDS_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.STAY_ON_WHILE_PLUGGED_IN);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SLEEP_POLICY);
+            MOVED_TO_GLOBAL.add(Settings.Global.MODE_RINGER);
+            MOVED_TO_GLOBAL.add(Settings.Global.WINDOW_ANIMATION_SCALE);
+            MOVED_TO_GLOBAL.add(Settings.Global.TRANSITION_ANIMATION_SCALE);
+            MOVED_TO_GLOBAL.add(Settings.Global.ANIMATOR_DURATION_SCALE);
+            MOVED_TO_GLOBAL.add(Settings.Global.FANCY_IME_ANIMATIONS);
+            MOVED_TO_GLOBAL.add(Settings.Global.COMPATIBILITY_MODE);
+            MOVED_TO_GLOBAL.add(Settings.Global.EMERGENCY_TONE);
+            MOVED_TO_GLOBAL.add(Settings.Global.CALL_AUTO_RETRY);
+            MOVED_TO_GLOBAL.add(Settings.Global.DEBUG_APP);
+            MOVED_TO_GLOBAL.add(Settings.Global.WAIT_FOR_DEBUGGER);
+            MOVED_TO_GLOBAL.add(Settings.Global.SHOW_PROCESSES);
+            MOVED_TO_GLOBAL.add(Settings.Global.ALWAYS_FINISH_ACTIVITIES);
+        }
+
+        /** @hide */
+        public static void getMovedKeys(HashSet<String> outKeySet) {
+            outKeySet.addAll(MOVED_TO_GLOBAL);
+            outKeySet.addAll(MOVED_TO_SECURE_THEN_GLOBAL);
+        }
+
+        /** @hide */
+        public static void getNonLegacyMovedKeys(HashSet<String> outKeySet) {
+            outKeySet.addAll(MOVED_TO_GLOBAL);
+        }
+
+        /**
+         * Look up a boolean in the database.
+         * @param resolver to access the database with
+         * @param name to look up in the table
+         * @param def Value to return if the setting is not defined.
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid boolean.
+         */
+        public static boolean getBoolean(ContentResolver cr, String name, boolean def) {
+            String v = getString(cr, name);
+            try {
+                if(v != null)
+                    return "1".equals(v);
+                else
+                    return def;
+            } catch (NumberFormatException e) {
+                return def;
+            }
+        }
+        /**
+         * Convenience function for updating a single settings value as a
+         * boolean. This will either create a new entry in the table if the
+         * given name does not exist, or modify the value of the existing row
+         * with that name.  Note that internally setting values are always
+         * stored as strings, so this function converts the given value to a
+         * string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putBoolean(ContentResolver cr, String name, boolean value) {
+            return putString(cr, name, value ? "1" : "0");
+        }
+
+        /**
+         * Look up a name in the database.
+         * @param resolver to access the database with
+         * @param name to look up in the table
+         * @return the corresponding value, or null if not present
+         */
+        public static String getString(ContentResolver resolver, String name) {
+            return getStringForUser(resolver, name, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static String getStringForUser(ContentResolver resolver, String name,
+                int userHandle) {
+            if (MOVED_TO_SECURE.contains(name)) {
+                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
+                        + " to android.provider.Settings.Secure, returning read-only value.");
+                return Secure.getStringForUser(resolver, name, userHandle);
+            }
+            if (MOVED_TO_GLOBAL.contains(name) || MOVED_TO_SECURE_THEN_GLOBAL.contains(name)) {
+                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
+                        + " to android.provider.Settings.Global, returning read-only value.");
+                return Global.getStringForUser(resolver, name, userHandle);
+            }
+            return sNameValueCache.getStringForUser(resolver, name, userHandle);
+        }
+
+        /**
+         * Store a name/value pair into the database.
+         * @param resolver to access the database with
+         * @param name to store
+         * @param value to associate with the name
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putString(ContentResolver resolver, String name, String value) {
+            return putStringForUser(resolver, name, value, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putStringForUser(ContentResolver resolver, String name, String value,
+                int userHandle) {
+            if (MOVED_TO_SECURE.contains(name)) {
+                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
+                        + " to android.provider.Settings.Secure, value is unchanged.");
+                return false;
+            }
+            if (MOVED_TO_GLOBAL.contains(name) || MOVED_TO_SECURE_THEN_GLOBAL.contains(name)) {
+                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
+                        + " to android.provider.Settings.Global, value is unchanged.");
+                return false;
+            }
+            return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
+        }
+
+        /**
+         * Construct the content URI for a particular name/value pair,
+         * useful for monitoring changes with a ContentObserver.
+         * @param name to look up in the table
+         * @return the corresponding content URI, or null if not present
+         */
+        public static Uri getUriFor(String name) {
+            if (MOVED_TO_SECURE.contains(name)) {
+                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
+                    + " to android.provider.Settings.Secure, returning Secure URI.");
+                return Secure.getUriFor(Secure.CONTENT_URI, name);
+            }
+            if (MOVED_TO_GLOBAL.contains(name) || MOVED_TO_SECURE_THEN_GLOBAL.contains(name)) {
+                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
+                        + " to android.provider.Settings.Global, returning read-only global URI.");
+                return Global.getUriFor(Global.CONTENT_URI, name);
+            }
+            return getUriFor(CONTENT_URI, name);
+        }
+
+        /**
+         * Convenience function for retrieving a single system settings value
+         * as an integer.  Note that internally setting values are always
+         * stored as strings; this function converts the string to an integer
+         * for you.  The default value will be returned if the setting is
+         * not defined or not an integer.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         * @param def Value to return if the setting is not defined.
+         *
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid integer.
+         */
+        public static int getInt(ContentResolver cr, String name, int def) {
+            return getIntForUser(cr, name, def, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static int getIntForUser(ContentResolver cr, String name, int def, int userHandle) {
+            String v = getStringForUser(cr, name, userHandle);
+            try {
+                return v != null ? Integer.parseInt(v) : def;
+            } catch (NumberFormatException e) {
+                return def;
+            }
+        }
+
+        /**
+         * Convenience function for retrieving a single system settings value
+         * as an integer.  Note that internally setting values are always
+         * stored as strings; this function converts the string to an integer
+         * for you.
+         * <p>
+         * This version does not take a default value.  If the setting has not
+         * been set, or the string value is not a number,
+         * it throws {@link SettingNotFoundException}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         *
+         * @throws SettingNotFoundException Thrown if a setting by the given
+         * name can't be found or the setting value is not an integer.
+         *
+         * @return The setting's current value.
+         */
+        public static int getInt(ContentResolver cr, String name)
+                throws SettingNotFoundException {
+            return getIntForUser(cr, name, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static int getIntForUser(ContentResolver cr, String name, int userHandle)
+                throws SettingNotFoundException {
+            String v = getStringForUser(cr, name, userHandle);
+            try {
+                return Integer.parseInt(v);
+            } catch (NumberFormatException e) {
+                throw new SettingNotFoundException(name);
+            }
+        }
+
+        /**
+         * Convenience function for updating a single settings value as an
+         * integer. This will either create a new entry in the table if the
+         * given name does not exist, or modify the value of the existing row
+         * with that name.  Note that internally setting values are always
+         * stored as strings, so this function converts the given value to a
+         * string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putInt(ContentResolver cr, String name, int value) {
+            return putIntForUser(cr, name, value, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putIntForUser(ContentResolver cr, String name, int value,
+                int userHandle) {
+            return putStringForUser(cr, name, Integer.toString(value), userHandle);
+        }
+
+        /**
+         * Convenience function for retrieving a single system settings value
+         * as a {@code long}.  Note that internally setting values are always
+         * stored as strings; this function converts the string to a {@code long}
+         * for you.  The default value will be returned if the setting is
+         * not defined or not a {@code long}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         * @param def Value to return if the setting is not defined.
+         *
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid {@code long}.
+         */
+        public static long getLong(ContentResolver cr, String name, long def) {
+            return getLongForUser(cr, name, def, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static long getLongForUser(ContentResolver cr, String name, long def,
+                int userHandle) {
+            String valString = getStringForUser(cr, name, userHandle);
+            long value;
+            try {
+                value = valString != null ? Long.parseLong(valString) : def;
+            } catch (NumberFormatException e) {
+                value = def;
+            }
+            return value;
+        }
+
+        /**
+         * Convenience function for retrieving a single system settings value
+         * as a {@code long}.  Note that internally setting values are always
+         * stored as strings; this function converts the string to a {@code long}
+         * for you.
+         * <p>
+         * This version does not take a default value.  If the setting has not
+         * been set, or the string value is not a number,
+         * it throws {@link SettingNotFoundException}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         *
+         * @return The setting's current value.
+         * @throws SettingNotFoundException Thrown if a setting by the given
+         * name can't be found or the setting value is not an integer.
+         */
+        public static long getLong(ContentResolver cr, String name)
+                throws SettingNotFoundException {
+            return getLongForUser(cr, name, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static long getLongForUser(ContentResolver cr, String name, int userHandle)
+                throws SettingNotFoundException {
+            String valString = getStringForUser(cr, name, userHandle);
+            try {
+                return Long.parseLong(valString);
+            } catch (NumberFormatException e) {
+                throw new SettingNotFoundException(name);
+            }
+        }
+
+        /**
+         * Convenience function for updating a single settings value as a long
+         * integer. This will either create a new entry in the table if the
+         * given name does not exist, or modify the value of the existing row
+         * with that name.  Note that internally setting values are always
+         * stored as strings, so this function converts the given value to a
+         * string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putLong(ContentResolver cr, String name, long value) {
+            return putLongForUser(cr, name, value, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putLongForUser(ContentResolver cr, String name, long value,
+                int userHandle) {
+            return putStringForUser(cr, name, Long.toString(value), userHandle);
+        }
+
+        /**
+         * Convenience function for retrieving a single system settings value
+         * as a floating point number.  Note that internally setting values are
+         * always stored as strings; this function converts the string to an
+         * float for you. The default value will be returned if the setting
+         * is not defined or not a valid float.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         * @param def Value to return if the setting is not defined.
+         *
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid float.
+         */
+        public static float getFloat(ContentResolver cr, String name, float def) {
+            return getFloatForUser(cr, name, def, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static float getFloatForUser(ContentResolver cr, String name, float def,
+                int userHandle) {
+            String v = getStringForUser(cr, name, userHandle);
+            try {
+                return v != null ? Float.parseFloat(v) : def;
+            } catch (NumberFormatException e) {
+                return def;
+            }
+        }
+
+        /**
+         * Convenience function for retrieving a single system settings value
+         * as a float.  Note that internally setting values are always
+         * stored as strings; this function converts the string to a float
+         * for you.
+         * <p>
+         * This version does not take a default value.  If the setting has not
+         * been set, or the string value is not a number,
+         * it throws {@link SettingNotFoundException}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         *
+         * @throws SettingNotFoundException Thrown if a setting by the given
+         * name can't be found or the setting value is not a float.
+         *
+         * @return The setting's current value.
+         */
+        public static float getFloat(ContentResolver cr, String name)
+                throws SettingNotFoundException {
+            return getFloatForUser(cr, name, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static float getFloatForUser(ContentResolver cr, String name, int userHandle)
+                throws SettingNotFoundException {
+            String v = getStringForUser(cr, name, userHandle);
+            if (v == null) {
+                throw new SettingNotFoundException(name);
+            }
+            try {
+                return Float.parseFloat(v);
+            } catch (NumberFormatException e) {
+                throw new SettingNotFoundException(name);
+            }
+        }
+
+        /**
+         * Convenience function for updating a single settings value as a
+         * floating point number. This will either create a new entry in the
+         * table if the given name does not exist, or modify the value of the
+         * existing row with that name.  Note that internally setting values
+         * are always stored as strings, so this function converts the given
+         * value to a string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putFloat(ContentResolver cr, String name, float value) {
+            return putFloatForUser(cr, name, value, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putFloatForUser(ContentResolver cr, String name, float value,
+                int userHandle) {
+            return putStringForUser(cr, name, Float.toString(value), userHandle);
+        }
+
+        /**
+         * Convenience function to read all of the current
+         * configuration-related settings into a
+         * {@link Configuration} object.
+         *
+         * @param cr The ContentResolver to access.
+         * @param outConfig Where to place the configuration settings.
+         */
+        public static void getConfiguration(ContentResolver cr, Configuration outConfig) {
+            getConfigurationForUser(cr, outConfig, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static void getConfigurationForUser(ContentResolver cr, Configuration outConfig,
+                int userHandle) {
+            outConfig.fontScale = Settings.System.getFloatForUser(
+                cr, FONT_SCALE, outConfig.fontScale, userHandle);
+            if (outConfig.fontScale < 0) {
+                outConfig.fontScale = 1;
+            }
+        }
+
+        /**
+         * @hide Erase the fields in the Configuration that should be applied
+         * by the settings.
+         */
+        public static void clearConfiguration(Configuration inoutConfig) {
+            inoutConfig.fontScale = 0;
+        }
+
+        /**
+         * Convenience function to write a batch of configuration-related
+         * settings from a {@link Configuration} object.
+         *
+         * @param cr The ContentResolver to access.
+         * @param config The settings to write.
+         * @return true if the values were set, false on database errors
+         */
+        public static boolean putConfiguration(ContentResolver cr, Configuration config) {
+            return putConfigurationForUser(cr, config, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putConfigurationForUser(ContentResolver cr, Configuration config,
+                int userHandle) {
+            return Settings.System.putFloatForUser(cr, FONT_SCALE, config.fontScale, userHandle);
+        }
+
+        /** @hide */
+        public static boolean hasInterestingConfigurationChanges(int changes) {
+            return (changes&ActivityInfo.CONFIG_FONT_SCALE) != 0;
+        }
+
+        /** @deprecated - Do not use */
+        @Deprecated
+        public static boolean getShowGTalkServiceStatus(ContentResolver cr) {
+            return getShowGTalkServiceStatusForUser(cr, UserHandle.myUserId());
+        }
+
+        /**
+         * @hide
+         * @deprecated - Do not use
+         */
+        public static boolean getShowGTalkServiceStatusForUser(ContentResolver cr,
+                int userHandle) {
+            return getIntForUser(cr, SHOW_GTALK_SERVICE_STATUS, 0, userHandle) != 0;
+        }
+
+        /** @deprecated - Do not use */
+        @Deprecated
+        public static void setShowGTalkServiceStatus(ContentResolver cr, boolean flag) {
+            setShowGTalkServiceStatusForUser(cr, flag, UserHandle.myUserId());
+        }
+
+        /**
+         * @hide
+         * @deprecated - Do not use
+         */
+        @Deprecated
+        public static void setShowGTalkServiceStatusForUser(ContentResolver cr, boolean flag,
+                int userHandle) {
+            putIntForUser(cr, SHOW_GTALK_SERVICE_STATUS, flag ? 1 : 0, userHandle);
+        }
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#STAY_ON_WHILE_PLUGGED_IN} instead
+         */
+        @Deprecated
+        public static final String STAY_ON_WHILE_PLUGGED_IN = Global.STAY_ON_WHILE_PLUGGED_IN;
+
+        /**
+         * What happens when the user presses the end call button if they're not
+         * on a call.<br/>
+         * <b>Values:</b><br/>
+         * 0 - The end button does nothing.<br/>
+         * 1 - The end button goes to the home screen.<br/>
+         * 2 - The end button puts the device to sleep and locks the keyguard.<br/>
+         * 3 - The end button goes to the home screen.  If the user is already on the
+         * home screen, it puts the device to sleep.
+         */
+        public static final String END_BUTTON_BEHAVIOR = "end_button_behavior";
+
+        /**
+         * END_BUTTON_BEHAVIOR value for "go home".
+         * @hide
+         */
+        public static final int END_BUTTON_BEHAVIOR_HOME = 0x1;
+
+        /**
+         * END_BUTTON_BEHAVIOR value for "go to sleep".
+         * @hide
+         */
+        public static final int END_BUTTON_BEHAVIOR_SLEEP = 0x2;
+
+        /**
+         * END_BUTTON_BEHAVIOR default value.
+         * @hide
+         */
+        public static final int END_BUTTON_BEHAVIOR_DEFAULT = END_BUTTON_BEHAVIOR_SLEEP;
+
+        /**
+         * Is advanced settings mode turned on. 0 == no, 1 == yes
+         * @hide
+         */
+        public static final String ADVANCED_SETTINGS = "advanced_settings";
+
+        /**
+         * ADVANCED_SETTINGS default value.
+         * @hide
+         */
+        public static final int ADVANCED_SETTINGS_DEFAULT = 0;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#AIRPLANE_MODE_ON} instead
+         */
+        @Deprecated
+        public static final String AIRPLANE_MODE_ON = Global.AIRPLANE_MODE_ON;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#RADIO_BLUETOOTH} instead
+         */
+        @Deprecated
+        public static final String RADIO_BLUETOOTH = Global.RADIO_BLUETOOTH;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#RADIO_WIFI} instead
+         */
+        @Deprecated
+        public static final String RADIO_WIFI = Global.RADIO_WIFI;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#RADIO_WIMAX} instead
+         * {@hide}
+         */
+        @Deprecated
+        public static final String RADIO_WIMAX = Global.RADIO_WIMAX;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#RADIO_CELL} instead
+         */
+        @Deprecated
+        public static final String RADIO_CELL = Global.RADIO_CELL;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#RADIO_NFC} instead
+         */
+        @Deprecated
+        public static final String RADIO_NFC = Global.RADIO_NFC;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#AIRPLANE_MODE_RADIOS} instead
+         */
+        @Deprecated
+        public static final String AIRPLANE_MODE_RADIOS = Global.AIRPLANE_MODE_RADIOS;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#AIRPLANE_MODE_TOGGLEABLE_RADIOS} instead
+         *
+         * {@hide}
+         */
+        @Deprecated
+        public static final String AIRPLANE_MODE_TOGGLEABLE_RADIOS =
+                Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_SLEEP_POLICY} instead
+         */
+        @Deprecated
+        public static final String WIFI_SLEEP_POLICY = Global.WIFI_SLEEP_POLICY;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_SLEEP_POLICY_DEFAULT} instead
+         */
+        @Deprecated
+        public static final int WIFI_SLEEP_POLICY_DEFAULT = Global.WIFI_SLEEP_POLICY_DEFAULT;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED} instead
+         */
+        @Deprecated
+        public static final int WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED =
+                Global.WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_SLEEP_POLICY_NEVER} instead
+         */
+        @Deprecated
+        public static final int WIFI_SLEEP_POLICY_NEVER = Global.WIFI_SLEEP_POLICY_NEVER;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#MODE_RINGER} instead
+         */
+        @Deprecated
+        public static final String MODE_RINGER = Global.MODE_RINGER;
+
+        /**
+         * Whether to use static IP and other static network attributes.
+         * <p>
+         * Set to 1 for true and 0 for false.
+         *
+         * @deprecated Use {@link WifiManager} instead
+         */
+        @Deprecated
+        public static final String WIFI_USE_STATIC_IP = "wifi_use_static_ip";
+
+        /**
+         * The static IP address.
+         * <p>
+         * Example: "192.168.1.51"
+         *
+         * @deprecated Use {@link WifiManager} instead
+         */
+        @Deprecated
+        public static final String WIFI_STATIC_IP = "wifi_static_ip";
+
+        /**
+         * If using static IP, the gateway's IP address.
+         * <p>
+         * Example: "192.168.1.1"
+         *
+         * @deprecated Use {@link WifiManager} instead
+         */
+        @Deprecated
+        public static final String WIFI_STATIC_GATEWAY = "wifi_static_gateway";
+
+        /**
+         * If using static IP, the net mask.
+         * <p>
+         * Example: "255.255.255.0"
+         *
+         * @deprecated Use {@link WifiManager} instead
+         */
+        @Deprecated
+        public static final String WIFI_STATIC_NETMASK = "wifi_static_netmask";
+
+        /**
+         * If using static IP, the primary DNS's IP address.
+         * <p>
+         * Example: "192.168.1.1"
+         *
+         * @deprecated Use {@link WifiManager} instead
+         */
+        @Deprecated
+        public static final String WIFI_STATIC_DNS1 = "wifi_static_dns1";
+
+        /**
+         * If using static IP, the secondary DNS's IP address.
+         * <p>
+         * Example: "192.168.1.2"
+         *
+         * @deprecated Use {@link WifiManager} instead
+         */
+        @Deprecated
+        public static final String WIFI_STATIC_DNS2 = "wifi_static_dns2";
+
+        /**
+         * Allows automatic retrieval of mms contents
+         * <p>Type: INT</p>
+         * 0 -- false
+         * 1 -- true
+         * @hide
+         */
+        public static final String MMS_AUTO_RETRIEVAL = "mms_auto_retrieval";
+
+        /**
+         * Allows automatic retrieval of mms contents during roaming
+         * <p>Type: INT</p>
+         * 0 -- false
+         * 1 -- true
+         * @hide
+         */
+        public static final String MMS_AUTO_RETRIEVAL_ON_ROAMING = "mms_auto_on_roaming";
+
+        /**
+         * Determines whether remote devices may discover and/or connect to
+         * this device.
+         * <P>Type: INT</P>
+         * 2 -- discoverable and connectable
+         * 1 -- connectable but not discoverable
+         * 0 -- neither connectable nor discoverable
+         */
+        public static final String BLUETOOTH_DISCOVERABILITY =
+            "bluetooth_discoverability";
+
+        /**
+         * Bluetooth discoverability timeout.  If this value is nonzero, then
+         * Bluetooth becomes discoverable for a certain number of seconds,
+         * after which is becomes simply connectable.  The value is in seconds.
+         */
+        public static final String BLUETOOTH_DISCOVERABILITY_TIMEOUT =
+            "bluetooth_discoverability_timeout";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#LOCK_PATTERN_ENABLED}
+         * instead
+         */
+        @Deprecated
+        public static final String LOCK_PATTERN_ENABLED = Secure.LOCK_PATTERN_ENABLED;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#LOCK_PATTERN_VISIBLE}
+         * instead
+         */
+        @Deprecated
+        public static final String LOCK_PATTERN_VISIBLE = "lock_pattern_visible_pattern";
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Secure#LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED}
+         * instead
+         */
+        @Deprecated
+        public static final String LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED =
+            "lock_pattern_tactile_feedback_enabled";
+
+
+        /**
+         * A formatted string of the next alarm that is set, or the empty string
+         * if there is no alarm set.
+         */
+        public static final String NEXT_ALARM_FORMATTED = "next_alarm_formatted";
+
+        /**
+         * Scaling factor for fonts, float.
+         */
+        public static final String FONT_SCALE = "font_scale";
+
+        /**
+         * Name of an application package to be debugged.
+         *
+         * @deprecated Use {@link Global#DEBUG_APP} instead
+         */
+        @Deprecated
+        public static final String DEBUG_APP = Global.DEBUG_APP;
+
+        /**
+         * If 1, when launching DEBUG_APP it will wait for the debugger before
+         * starting user code.  If 0, it will run normally.
+         *
+         * @deprecated Use {@link Global#WAIT_FOR_DEBUGGER} instead
+         */
+        @Deprecated
+        public static final String WAIT_FOR_DEBUGGER = Global.WAIT_FOR_DEBUGGER;
+
+        /**
+         * Whether or not to dim the screen. 0=no  1=yes
+         * @deprecated This setting is no longer used.
+         */
+        @Deprecated
+        public static final String DIM_SCREEN = "dim_screen";
+
+        /**
+         * The timeout before the screen turns off.
+         */
+        public static final String SCREEN_OFF_TIMEOUT = "screen_off_timeout";
+
+        /**
+         * The screen backlight brightness between 0 and 255.
+         */
+        public static final String SCREEN_BRIGHTNESS = "screen_brightness";
+
+        /**
+         * Control whether to enable automatic brightness mode.
+         */
+        public static final String SCREEN_BRIGHTNESS_MODE = "screen_brightness_mode";
+
+        /**
+         * Adjustment to auto-brightness to make it generally more (>0.0 <1.0)
+         * or less (<0.0 >-1.0) bright.
+         * @hide
+         */
+        public static final String SCREEN_AUTO_BRIGHTNESS_ADJ = "screen_auto_brightness_adj";
+
+        /**
+         * SCREEN_BRIGHTNESS_MODE value for manual mode.
+         */
+        public static final int SCREEN_BRIGHTNESS_MODE_MANUAL = 0;
+
+        /**
+         * SCREEN_BRIGHTNESS_MODE value for automatic mode.
+         */
+        public static final int SCREEN_BRIGHTNESS_MODE_AUTOMATIC = 1;
+
+        /**
+         * Custom automatic brightness light sensor levels.
+         * The value is a comma separated int array with length N.
+         * Example: "100,300,3000".
+         *
+         * @hide
+         */
+        public static final String AUTO_BRIGHTNESS_LUX = "auto_brightness_lux";
+
+        /**
+         * Custom automatic brightness display backlight brightness values.
+         * The value is a comma separated int array with length N+1.
+         * Example: "10,50,100,255".
+         *
+         * @hide
+         */
+        public static final String AUTO_BRIGHTNESS_BACKLIGHT = "auto_brightness_backlight";
+
+        /**
+         * Correction factor for auto-brightness adjustment light sensor
+         * debounce times.
+         * Smaller factors will make the adjustment more responsive, but might
+         * cause flicker and/or cause higher CPU usage.
+         * Valid range is 0.2 ... 3
+         *
+         * @hide
+         */
+        public static final String AUTO_BRIGHTNESS_RESPONSIVENESS = "auto_brightness_responsiveness";
+
+        /**
+         * Whether to enable the electron beam animation when turning screen on
+         *
+         * @hide */
+        public static final String ELECTRON_BEAM_ANIMATION_ON = "electron_beam_animation_on";
+
+        /**
+         * Whether to enable the electron beam animation when turning screen off
+         *
+         * @hide */
+        public static final String ELECTRON_BEAM_ANIMATION_OFF = "electron_beam_animation_off";
+
+        /**
+         * Control whether the process CPU usage meter should be shown.
+         *
+         * @deprecated Use {@link Global#SHOW_PROCESSES} instead
+         */
+        @Deprecated
+        public static final String SHOW_PROCESSES = Global.SHOW_PROCESSES;
+
+        /**
+         * If 1, the activity manager will aggressively finish activities and
+         * processes as soon as they are no longer needed.  If 0, the normal
+         * extended lifetime is used.
+         *
+         * @deprecated Use {@link Global#ALWAYS_FINISH_ACTIVITIES} instead
+         */
+        @Deprecated
+        public static final String ALWAYS_FINISH_ACTIVITIES = Global.ALWAYS_FINISH_ACTIVITIES;
+
+        /**
+         * Volume Overlay Mode, This is behaviour of the volume overlay panel
+         * Defaults to 0 - which is simple
+         * @hide
+         */
+        public static final String MODE_VOLUME_OVERLAY = "mode_volume_overlay";
+
+        /** @hide */
+        public static final int VOLUME_OVERLAY_SINGLE = 0;
+        /** @hide */
+        public static final int VOLUME_OVERLAY_EXPANDABLE = 1;
+        /** @hide */
+        public static final int VOLUME_OVERLAY_EXPANDED = 2;
+        /** @hide */
+        public static final int VOLUME_OVERLAY_NONE = 3;
+
+        /**
+         * Volume Adjust Sounds Enable, This is the noise made when using volume hard buttons
+         * Defaults to 1 - sounds enabled
+         * @hide
+         */
+        public static final String VOLUME_ADJUST_SOUNDS_ENABLED = "volume_adjust_sounds_enabled";
+
+        /**
+         * Determines which streams are affected by ringer mode changes. The
+         * stream type's bit should be set to 1 if it should be muted when going
+         * into an inaudible ringer mode.
+         */
+        public static final String MODE_RINGER_STREAMS_AFFECTED = "mode_ringer_streams_affected";
+
+         /**
+          * Determines which streams are affected by mute. The
+          * stream type's bit should be set to 1 if it should be muted when a mute request
+          * is received.
+          */
+         public static final String MUTE_STREAMS_AFFECTED = "mute_streams_affected";
+
+        /**
+         * Whether vibrate is on for different events. This is used internally,
+         * changing this value will not change the vibrate. See AudioManager.
+         */
+        public static final String VIBRATE_ON = "vibrate_on";
+
+        /**
+         * If 1, redirects the system vibrator to all currently attached input devices
+         * that support vibration.  If there are no such input devices, then the system
+         * vibrator is used instead.
+         * If 0, does not register the system vibrator.
+         *
+         * This setting is mainly intended to provide a compatibility mechanism for
+         * applications that only know about the system vibrator and do not use the
+         * input device vibrator API.
+         *
+         * @hide
+         */
+        public static final String VIBRATE_INPUT_DEVICES = "vibrate_input_devices";
+
+        /**
+         * Ringer volume. This is used internally, changing this value will not
+         * change the volume. See AudioManager.
+         */
+        public static final String VOLUME_RING = "volume_ring";
+
+        /**
+         * System/notifications volume. This is used internally, changing this
+         * value will not change the volume. See AudioManager.
+         */
+        public static final String VOLUME_SYSTEM = "volume_system";
+
+        /**
+         * Voice call volume. This is used internally, changing this value will
+         * not change the volume. See AudioManager.
+         */
+        public static final String VOLUME_VOICE = "volume_voice";
+
+        /**
+         * Music/media/gaming volume. This is used internally, changing this
+         * value will not change the volume. See AudioManager.
+         */
+        public static final String VOLUME_MUSIC = "volume_music";
+
+        /**
+         * FM volume (float in the range 0.0f to 1.0f).
+         * @hide
+         */
+        public static final String VOLUME_FM = "volume_fm";
+
+        /**
+         * Dummy string. Dummy string for padding
+         * @hide
+         */
+        public static final String DUMMY_STRING_FOR_PADDING = "";
+
+        /**		
+         * Alarm volume. This is used internally, changing this
+         * value will not change the volume. See AudioManager.
+         */
+        public static final String VOLUME_ALARM = "volume_alarm";
+
+        /**
+         * Notification volume. This is used internally, changing this
+         * value will not change the volume. See AudioManager.
+         */
+        public static final String VOLUME_NOTIFICATION = "volume_notification";
+
+        /**
+         * Bluetooth Headset volume. This is used internally, changing this value will
+         * not change the volume. See AudioManager.
+         */
+        public static final String VOLUME_BLUETOOTH_SCO = "volume_bluetooth_sco";
+
+        /**
+         * Whether to prevent loud volume levels when headset is first plugged in.
+         * @hide
+         */
+        public static final String SAFE_HEADSET_VOLUME = "safe_headset_volume";
+
+        /**
+         * Master volume (float in the range 0.0f to 1.0f).
+         * @hide
+         */
+        public static final String VOLUME_MASTER = "volume_master";
+
+        /**
+         * Master volume mute (int 1 = mute, 0 = not muted).
+         *
+         * @hide
+         */
+        public static final String VOLUME_MASTER_MUTE = "volume_master_mute";
+
+        /**
+         * Whether the notifications should use the ring volume (value of 1) or
+         * a separate notification volume (value of 0). In most cases, users
+         * will have this enabled so the notification and ringer volumes will be
+         * the same. However, power users can disable this and use the separate
+         * notification volume control.
+         * <p>
+         * Note: This is a one-off setting that will be removed in the future
+         * when there is profile support. For this reason, it is kept hidden
+         * from the public APIs.
+         *
+         * @hide
+         * @deprecated
+         */
+        @Deprecated
+        public static final String NOTIFICATIONS_USE_RING_VOLUME =
+            "notifications_use_ring_volume";
+
+        /**
+         * Whether the blacklisting feature for phone calls is enabled
+         * @hide
+         */
+        public static final String PHONE_BLACKLIST_ENABLED = "phone_blacklist_enabled";
+
+        /**
+         * Whether the phone ringtone should be played in an increasing manner
+         * @hide
+         */
+        public static final String INCREASING_RING = "increasing_ring";
+
+        /**
+         * Minimum volume index for increasing ring volume
+         * @hide
+         */
+        public static final String INCREASING_RING_MIN_VOLUME = "increasing_ring_min_vol";
+
+        /**
+         * Time (in ms) between ringtone volume increases
+         * @hide
+         */
+        public static final String INCREASING_RING_INTERVAL = "increasing_ring_interval";
+
+        /**
+         * Whether silent mode should allow vibration feedback. This is used
+         * internally in AudioService and the Sound settings activity to
+         * coordinate decoupling of vibrate and silent modes. This setting
+         * will likely be removed in a future release with support for
+         * audio/vibe feedback profiles.
+         *
+         * Not used anymore. On devices with vibrator, the user explicitly selects
+         * silent or vibrate mode.
+         * Kept for use by legacy database upgrade code in DatabaseHelper.
+         * @hide
+         */
+        public static final String VIBRATE_IN_SILENT = "vibrate_in_silent";
+
+        /**
+         * wake up when plugged or unplugged
+         *
+         * @hide
+         */
+        public static final String WAKEUP_WHEN_PLUGGED_UNPLUGGED = "wakeup_when_plugged_unplugged";
+
+        /**
+         * The mapping of stream type (integer) to its setting.
+         */
+        public static final String[] VOLUME_SETTINGS = {
+            VOLUME_VOICE, VOLUME_SYSTEM, VOLUME_RING, VOLUME_MUSIC,
+            VOLUME_ALARM, VOLUME_NOTIFICATION, VOLUME_BLUETOOTH_SCO,
+            DUMMY_STRING_FOR_PADDING,DUMMY_STRING_FOR_PADDING,
+            DUMMY_STRING_FOR_PADDING,VOLUME_FM
+        };
+
+        /**
+         * Appended to various volume related settings to record the previous
+         * values before they the settings were affected by a silent/vibrate
+         * ringer mode change.
+         */
+        public static final String APPEND_FOR_LAST_AUDIBLE = "_last_audible";
+
+        /**
+         * Persistent store for the system-wide default ringtone URI.
+         * <p>
+         * If you need to play the default ringtone at any given time, it is recommended
+         * you give {@link #DEFAULT_RINGTONE_URI} to the media player.  It will resolve
+         * to the set default ringtone at the time of playing.
+         *
+         * @see #DEFAULT_RINGTONE_URI
+         */
+        public static final String RINGTONE = "ringtone";
+
+        /**
+         * A {@link Uri} that will point to the current default ringtone at any
+         * given time.
+         * <p>
+         * If the current default ringtone is in the DRM provider and the caller
+         * does not have permission, the exception will be a
+         * FileNotFoundException.
+         */
+        public static final Uri DEFAULT_RINGTONE_URI = getUriFor(RINGTONE);
+
+        /**
+         * Persistent store for the system-wide default notification sound.
+         *
+         * @see #RINGTONE
+         * @see #DEFAULT_NOTIFICATION_URI
+         */
+        public static final String NOTIFICATION_SOUND = "notification_sound";
+
+        /**
+         * A {@link Uri} that will point to the current default notification
+         * sound at any given time.
+         *
+         * @see #DEFAULT_RINGTONE_URI
+         */
+        public static final Uri DEFAULT_NOTIFICATION_URI = getUriFor(NOTIFICATION_SOUND);
+
+        /**
+         * Persistent store for the system-wide default alarm alert.
+         *
+         * @see #RINGTONE
+         * @see #DEFAULT_ALARM_ALERT_URI
+         */
+        public static final String ALARM_ALERT = "alarm_alert";
+
+        /**
+         * A {@link Uri} that will point to the current default alarm alert at
+         * any given time.
+         *
+         * @see #DEFAULT_ALARM_ALERT_URI
+         */
+        public static final Uri DEFAULT_ALARM_ALERT_URI = getUriFor(ALARM_ALERT);
+
+        /**
+         * Persistent store for the system default media button event receiver.
+         *
+         * @hide
+         */
+        public static final String MEDIA_BUTTON_RECEIVER = "media_button_receiver";
+
+        /**
+         * Setting to enable Auto Replace (AutoText) in text editors. 1 = On, 0 = Off
+         */
+        public static final String TEXT_AUTO_REPLACE = "auto_replace";
+
+        /**
+         * Setting to enable Auto Caps in text editors. 1 = On, 0 = Off
+         */
+        public static final String TEXT_AUTO_CAPS = "auto_caps";
+
+        /**
+         * Setting to enable Auto Punctuate in text editors. 1 = On, 0 = Off. This
+         * feature converts two spaces to a "." and space.
+         */
+        public static final String TEXT_AUTO_PUNCTUATE = "auto_punctuate";
+
+        /**
+         * Setting to showing password characters in text editors. 1 = On, 0 = Off
+         */
+        public static final String TEXT_SHOW_PASSWORD = "show_password";
+
+        public static final String SHOW_GTALK_SERVICE_STATUS =
+                "SHOW_GTALK_SERVICE_STATUS";
+
+        /**
+         * Name of activity to use for wallpaper on the home screen.
+         *
+         * @deprecated Use {@link WallpaperManager} instead.
+         */
+        @Deprecated
+        public static final String WALLPAPER_ACTIVITY = "wallpaper_activity";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#AUTO_TIME}
+         * instead
+         */
+        @Deprecated
+        public static final String AUTO_TIME = Global.AUTO_TIME;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#AUTO_TIME_ZONE}
+         * instead
+         */
+        @Deprecated
+        public static final String AUTO_TIME_ZONE = Global.AUTO_TIME_ZONE;
+
+        /**
+         * Display times as 12 or 24 hours
+         *   12
+         *   24
+         */
+        public static final String TIME_12_24 = "time_12_24";
+
+        /**
+         * Date format string
+         *   mm/dd/yyyy
+         *   dd/mm/yyyy
+         *   yyyy/mm/dd
+         */
+        public static final String DATE_FORMAT = "date_format";
+
+        /**
+         * Whether the setup wizard has been run before (on first boot), or if
+         * it still needs to be run.
+         *
+         * nonzero = it has been run in the past
+         * 0 = it has not been run in the past
+         */
+        public static final String SETUP_WIZARD_HAS_RUN = "setup_wizard_has_run";
+
+        /**
+         * Scaling factor for normal window animations. Setting to 0 will disable window
+         * animations.
+         *
+         * @deprecated Use {@link Global#WINDOW_ANIMATION_SCALE} instead
+         */
+        @Deprecated
+        public static final String WINDOW_ANIMATION_SCALE = Global.WINDOW_ANIMATION_SCALE;
+
+        /**
+         * Scaling factor for activity transition animations. Setting to 0 will disable window
+         * animations.
+         *
+         * @deprecated Use {@link Global#TRANSITION_ANIMATION_SCALE} instead
+         */
+        @Deprecated
+        public static final String TRANSITION_ANIMATION_SCALE = Global.TRANSITION_ANIMATION_SCALE;
+
+        /**
+         * Scaling factor for Animator-based animations. This affects both the start delay and
+         * duration of all such animations. Setting to 0 will cause animations to end immediately.
+         * The default value is 1.
+         *
+         * @deprecated Use {@link Global#ANIMATOR_DURATION_SCALE} instead
+         */
+        @Deprecated
+        public static final String ANIMATOR_DURATION_SCALE = Global.ANIMATOR_DURATION_SCALE;
+
+        /**
+         * Control whether the accelerometer will be used to change screen
+         * orientation.  If 0, it will not be used unless explicitly requested
+         * by the application; if 1, it will be used by default unless explicitly
+         * disabled by the application.
+         */
+        public static final String ACCELEROMETER_ROTATION = "accelerometer_rotation";
+
+        /**
+         * Control the type of rotation which can be performed using the accelerometer
+         * if ACCELEROMETER_ROTATION is enabled.
+         * Value is a bitwise combination of
+         * 1 = 0 degrees (portrait)
+         * 2 = 90 degrees (left)
+         * 4 = 180 degrees (inverted portrait)
+         * 8 = 270 degrees (right)
+         * Setting to 0 is effectively orientation lock
+         * @hide
+         */
+        public static final String ACCELEROMETER_ROTATION_ANGLES = "accelerometer_rotation_angles";
+
+        /**
+         * Default screen rotation when no other policy applies.
+         * When {@link #ACCELEROMETER_ROTATION} is zero and no on-screen Activity expresses a
+         * preference, this rotation value will be used. Must be one of the
+         * {@link android.view.Surface#ROTATION_0 Surface rotation constants}.
+         *
+         * @see Display#getRotation
+         */
+        public static final String USER_ROTATION = "user_rotation";
+
+        /**
+         * Control whether the rotation lock toggle in the System UI should be hidden.
+         * Typically this is done for accessibility purposes to make it harder for
+         * the user to accidentally toggle the rotation lock while the display rotation
+         * has been locked for accessibility.
+         *
+         * If 0, then rotation lock toggle is not hidden for accessibility (although it may be
+         * unavailable for other reasons).  If 1, then the rotation lock toggle is hidden.
+         *
+         * @hide
+         */
+        public static final String HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY =
+                "hide_rotation_lock_toggle_for_accessibility";
+
+        /**
+         * Whether the phone vibrates when it is ringing due to an incoming call. This will
+         * be used by Phone and Setting apps; it shouldn't affect other apps.
+         * The value is boolean (1 or 0).
+         *
+         * Note: this is not same as "vibrate on ring", which had been available until ICS.
+         * It was about AudioManager's setting and thus affected all the applications which
+         * relied on the setting, while this is purely about the vibration setting for incoming
+         * calls.
+         *
+         * @hide
+         */
+        public static final String VIBRATE_WHEN_RINGING = "vibrate_when_ringing";
+
+        /**
+         * Whether the audible DTMF tones are played by the dialer when dialing. The value is
+         * boolean (1 or 0).
+         */
+        public static final String DTMF_TONE_WHEN_DIALING = "dtmf_tone";
+
+        /**
+         * CDMA only settings
+         * DTMF tone type played by the dialer when dialing.
+         *                 0 = Normal
+         *                 1 = Long
+         * @hide
+         */
+        public static final String DTMF_TONE_TYPE_WHEN_DIALING = "dtmf_tone_type";
+
+        /**
+         * Whether the hearing aid is enabled. The value is
+         * boolean (1 or 0).
+         * @hide
+         */
+        public static final String HEARING_AID = "hearing_aid";
+
+        /**
+         * CDMA only settings
+         * TTY Mode
+         * 0 = OFF
+         * 1 = FULL
+         * 2 = VCO
+         * 3 = HCO
+         * @hide
+         */
+        public static final String TTY_MODE = "tty_mode";
+
+        /**
+         * Whether noise suppression is enabled. The value is
+         * boolean (1 or 0).
+         * @hide
+         */
+        public static final String NOISE_SUPPRESSION = "noise_suppression";
+
+        /**
+         * Whether the sounds effects (key clicks, lid open ...) are enabled. The value is
+         * boolean (1 or 0).
+         */
+        public static final String SOUND_EFFECTS_ENABLED = "sound_effects_enabled";
+
+        /**
+         * Whether the haptic feedback (long presses, ...) are enabled. The value is
+         * boolean (1 or 0).
+         */
+        public static final String HAPTIC_FEEDBACK_ENABLED = "haptic_feedback_enabled";
+
+        /**
+         * @deprecated Each application that shows web suggestions should have its own
+         * setting for this.
+         */
+        @Deprecated
+        public static final String SHOW_WEB_SUGGESTIONS = "show_web_suggestions";
+
+        /**
+         * Whether the notification LED should repeatedly flash when a notification is
+         * pending. The value is boolean (1 or 0).
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE = "notification_light_pulse";
+
+        /**
+         * What color to use for the notification LED by default
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR = "notification_light_pulse_default_color";
+
+        /**
+         * How long to flash the notification LED by default
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON = "notification_light_pulse_default_led_on";
+
+        /**
+         * How long to wait between flashes for the notification LED by default
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF = "notification_light_pulse_default_led_off";
+
+        /**
+         * What color to use for the missed call notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CALL_COLOR = "notification_light_pulse_call_color";
+
+        /**
+         * How long to flash the missed call notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CALL_LED_ON = "notification_light_pulse_call_led_on";
+
+        /**
+         * How long to wait between flashes for the missed call notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CALL_LED_OFF = "notification_light_pulse_call_led_off";
+
+        /**
+         * What color to use for the voicemail notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_VMAIL_COLOR = "notification_light_pulse_vmail_color";
+
+        /**
+         * How long to flash the voicemail notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_VMAIL_LED_ON = "notification_light_pulse_vmail_led_on";
+
+        /**
+         * How long to wait between flashes for the voicemail notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_VMAIL_LED_OFF = "notification_light_pulse_vmail_led_off";
+
+        /**
+         * Whether to use the custom LED values for the notification pulse LED.
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE = "notification_light_pulse_custom_enable";
+
+        /**
+         * Which custom LED values to use for the notification pulse LED.
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES = "notification_light_pulse_custom_values";
+
+        /**
+         * Whether the battery light should be enabled (if hardware supports it)
+         * The value is boolean (1 or 0).
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_ENABLED = "battery_light_enabled";
+
+        /**
+         * Whether the battery LED should repeatedly flash when the battery is low
+         * on charge. The value is boolean (1 or 0).
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_PULSE = "battery_light_pulse";
+
+        /**
+         * What color to use for the battery LED while charging - low
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_LOW_COLOR = "battery_light_low_color";
+
+        /**
+         * What color to use for the battery LED while charging - medium
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_MEDIUM_COLOR = "battery_light_medium_color";
+
+        /**
+         * What color to use for the battery LED while charging - full
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_FULL_COLOR = "battery_light_full_color";
+
+        /** Sprint MWI Quirk: Show message wait indicator notifications
+         * @hide
+         */
+        public static final String ENABLE_MWI_NOTIFICATION = "enable_mwi_notification";
+
+        /**
+         * Show pointer location on screen?
+         * 0 = no
+         * 1 = yes
+         * @hide
+         */
+        public static final String POINTER_LOCATION = "pointer_location";
+
+        /**
+         * Show icon when stylus is used?
+         * 0 = no
+         * 1 = yes
+         * @hide
+         */
+        public static final String STYLUS_ICON_ENABLED = "stylus_icon_enabled";
+
+        /**
+         * Show touch positions on screen?
+         * 0 = no
+         * 1 = yes
+         * @hide
+         */
+        public static final String SHOW_TOUCHES = "show_touches";
+
+        /**
+         * Log raw orientation data from {@link WindowOrientationListener} for use with the
+         * orientationplot.py tool.
+         * 0 = no
+         * 1 = yes
+         * @hide
+         */
+        public static final String WINDOW_ORIENTATION_LISTENER_LOG =
+                "window_orientation_listener_log";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#POWER_SOUNDS_ENABLED}
+         * instead
+         * @hide
+         */
+        @Deprecated
+        public static final String POWER_SOUNDS_ENABLED = Global.POWER_SOUNDS_ENABLED;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#DOCK_SOUNDS_ENABLED}
+         * instead
+         * @hide
+         */
+        @Deprecated
+        public static final String DOCK_SOUNDS_ENABLED = Global.DOCK_SOUNDS_ENABLED;
+
+        /**
+         * Whether to play sounds when the keyguard is shown and dismissed.
+         * @hide
+         */
+        public static final String LOCKSCREEN_SOUNDS_ENABLED = "lockscreen_sounds_enabled";
+
+        /**
+         * Whether the lockscreen should be completely disabled.
+         * @hide
+         */
+        public static final String LOCKSCREEN_DISABLED = "lockscreen.disabled";
+
+        /**
+         * Stores values for custom lockscreen targets
+         * @hide
+         */
+        public static final String LOCKSCREEN_TARGETS = "lockscreen_targets";
+
+        /**
+         * Whether music controls should be shown on the lockscreen if a supporting
+         * music player is active.
+         * @hide
+         */
+        public static final String LOCKSCREEN_MUSIC_CONTROLS = "lockscreen_music_controls";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#LOW_BATTERY_SOUND}
+         * instead
+         * @hide
+         */
+        @Deprecated
+        public static final String LOW_BATTERY_SOUND = Global.LOW_BATTERY_SOUND;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#DESK_DOCK_SOUND}
+         * instead
+         * @hide
+         */
+        @Deprecated
+        public static final String DESK_DOCK_SOUND = Global.DESK_DOCK_SOUND;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#DESK_UNDOCK_SOUND}
+         * instead
+         * @hide
+         */
+        @Deprecated
+        public static final String DESK_UNDOCK_SOUND = Global.DESK_UNDOCK_SOUND;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#CAR_DOCK_SOUND}
+         * instead
+         * @hide
+         */
+        @Deprecated
+        public static final String CAR_DOCK_SOUND = Global.CAR_DOCK_SOUND;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#CAR_UNDOCK_SOUND}
+         * instead
+         * @hide
+         */
+        @Deprecated
+        public static final String CAR_UNDOCK_SOUND = Global.CAR_UNDOCK_SOUND;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#LOCK_SOUND}
+         * instead
+         * @hide
+         */
+        @Deprecated
+        public static final String LOCK_SOUND = Global.LOCK_SOUND;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#UNLOCK_SOUND}
+         * instead
+         * @hide
+         */
+        @Deprecated
+        public static final String UNLOCK_SOUND = Global.UNLOCK_SOUND;
+
+        /**
+         * Receive incoming SIP calls?
+         * 0 = no
+         * 1 = yes
+         * @hide
+         */
+        public static final String SIP_RECEIVE_CALLS = "sip_receive_calls";
+
+        /**
+         * Call Preference String.
+         * "SIP_ALWAYS" : Always use SIP with network access
+         * "SIP_ADDRESS_ONLY" : Only if destination is a SIP address
+         * "SIP_ASK_ME_EACH_TIME" : Always ask me each time
+         * @hide
+         */
+        public static final String SIP_CALL_OPTIONS = "sip_call_options";
+
+        /**
+         * One of the sip call options: Always use SIP with network access.
+         * @hide
+         */
+        public static final String SIP_ALWAYS = "SIP_ALWAYS";
+
+        /**
+         * One of the sip call options: Only if destination is a SIP address.
+         * @hide
+         */
+        public static final String SIP_ADDRESS_ONLY = "SIP_ADDRESS_ONLY";
+
+        /**
+         * One of the sip call options: Always ask me each time.
+         * @hide
+         */
+        public static final String SIP_ASK_ME_EACH_TIME = "SIP_ASK_ME_EACH_TIME";
+
+        /**
+         * Torch state (flashlight)
+         * @hide
+         */
+        public static final String TORCH_STATE = "torch_state";
+        /**
+         * Pointer speed setting.
+         * This is an integer value in a range between -7 and +7, so there are 15 possible values.
+         *   -7 = slowest
+         *    0 = default speed
+         *   +7 = fastest
+         * @hide
+         */
+        public static final String POINTER_SPEED = "pointer_speed";
+
+        /**
+         * Quick Settings Panel Tiles to Use
+         *
+         * @hide
+         */
+        public static final String QUICK_SETTINGS_TILES = "quick_settings_tiles";
+
+        /**
+         * Quick Settings Panel Dynamic Tiles
+         * number of tiles per row in quick settings
+         *
+         * @hide
+         */
+        public static final String QUICK_TILES_PER_ROW = "quick_tiles_per_row";
+
+        /**
+         * number of tiles per row in quick settings
+         *
+         * @hide
+         */
+        public static final String QUICK_TILES_PER_ROW_DUPLICATE_LANDSCAPE = "quick_tiles_per_row_duplicate_landscape";
+
+        /**
+         * text color on qs tiles
+         *
+         * @hide
+         */
+        public static final String QUICK_TILES_TEXT_COLOR = "quick_tiles_text_color";
+
+        /**
+         * qs tiles background color
+         *
+         * @hide
+         */
+        public static final String QUICK_TILES_BG_COLOR = "quick_tiles_bg_color";
+
+        /**
+         * Animate-flip Quick Settings Panel Tiles on click
+         *
+         * @hide
+         */
+        public static final String QUICK_SETTINGS_TILES_FLIP = "quick_settings_tiles_flip";
+
+        /**
+         * Quick Settings Panel Tiles to Use
+         *
+         * @hide
+         */
+        public static final String QUICK_TILES_BG_PRESSED_COLOR = "quick_tiles_bg_pressed_color";
+
+        /**
+         * Quick Settings Tile Content
+         *
+         * @hide
+         */
+        public static final String QS_DYNAMIC_ALARM = "qs_dyanmic_alarm";
+
+        /**
+         * Quick Settings Panel Dynamic Tiles
+         *
+         * @hide
+         */
+        public static final String QS_DYNAMIC_BUGREPORT = "qs_dyanmic_bugreport";
+
+        /**
+         * Quick Settings Panel Dynamic Tiles
+         *
+         * @hide
+         */
+        public static final String QS_DYNAMIC_IME = "qs_dyanmic_ime";
+
+        /**
+         * Quick Settings Panel Dynamic Tiles
+         *
+         * @hide
+         */
+        public static final String QS_DYNAMIC_USBTETHER = "qs_dyanmic_usbtether";
+
+        /**
+         * Quick Settings Panel Dynamic Tiles
+         *
+         * @hide
+         */
+        public static final String QS_DYNAMIC_DOCK_BATTERY = "qs_dyanmic_dock_battery";
+
+       /**
+        * Override and forcefully disable the fullscreen keyboard
+        * @hide
+        */
+        public static final String DISABLE_FULLSCREEN_KEYBOARD = "disable_fullscreen_keyboard";
+
+        /**
+         * Quick Settings Panel Dynamic Tiles
+         * @hide
+         */
+        public static final String QS_DYNAMIC_WIFI = "qs_dyanmic_wifi";
+
+        /**
+         * Quick Settings Quick Pulldown
+         *
+         * @hide
+         */
+        public static final String QS_QUICK_PULLDOWN = "qs_quick_pulldown";
+
+        /**
+         * Quick Settings Collapse Pane
+         *
+         * @hide
+         */
+        public static final String QS_COLLAPSE_PANEL = "qs_collapse_panel";
+
+        /**
+         * Use the Notification Power Widget? (Who wouldn't!)
+         *
+         * @hide
+         */
+        public static final String EXPANDED_VIEW_WIDGET = "expanded_view_widget";
+
+        /**
+         * Whether to hide the notification screen after clicking on a widget
+         * button
+         *
+         * @hide
+         */
+        public static final String EXPANDED_HIDE_ONCHANGE = "expanded_hide_onchange";
+
+        /**
+         * Hide scroll bar in power widget
+         *
+         * @hide
+         */
+        public static final String EXPANDED_HIDE_SCROLLBAR = "expanded_hide_scrollbar";
+
+        /**
+         * Haptic feedback in power widget
+         *
+         * @hide
+         */
+        public static final String EXPANDED_HAPTIC_FEEDBACK = "expanded_haptic_feedback";
+
+        /**
+         * Widget Buttons to Use
+         *
+         * @hide
+         */
+        public static final String WIDGET_BUTTONS = "expanded_widget_buttons";
+
+        /**
+         * Widget Buttons to Use - Tablet
+         *
+         * @hide
+         */
+        public static final String WIDGET_BUTTONS_TABLET = "expanded_widget_buttons_tablet";
+
+        /**
+         * Navigation controls to Use
+         *
+         * @hide
+         */
+        public static final String NAV_BUTTONS = "nav_buttons";
+
+        /**
+        * Notification Power Widget - Custom Brightness Mode
+        * @hide
+        */
+        public static final String EXPANDED_BRIGHTNESS_MODE = "expanded_brightness_mode";
+
+        /**
+        * Notification Power Widget - Custom Network Mode
+        * @hide
+        */
+        public static final String EXPANDED_NETWORK_MODE = "expanded_network_mode";
+
+        /**
+        * Notification Power Widget - Custom Screen Timeout
+        * @hide
+        */
+        public static final String EXPANDED_SCREENTIMEOUT_MODE = "expanded_screentimeout_mode";
+
+        /**
+        * Notification Power Widget - Custom Ring Mode
+        * @hide
+        */
+        public static final String EXPANDED_RING_MODE = "expanded_ring_mode";
+
+        /**
+        * Notification Power Widget - Custom Torch Mode
+        * @hide
+        */
+        public static final String EXPANDED_FLASH_MODE = "expanded_flash_mode";
+
+        /**
+        * AutoHide CombinedBar on tablets.
+        * @hide
+        */
+        public static final String COMBINED_BAR_AUTO_HIDE = "combined_bar_auto_hide";
+
+        /**
+         * Display style of AM/PM next to clock in status bar
+         * 0: Normal display (Eclair stock)
+         * 1: Small display (Froyo stock)
+         * 2: No display (Gingerbread/ICS stock)
+         * default: 2
+         * @hide
+         */
+        public static final String STATUS_BAR_AM_PM = "status_bar_am_pm";
+
+        /**
+         * Display style of the status bar battery information
+         * 0: Display the stock battery information
+         * 1: Display cm battery percentage implementation / dont show stock icon
+         * 2: Display cm circle battery implementation without percentage
+         * 3: Display cm circle battery implementation with percentage
+         * 4: Hide the battery information
+         * default: 0
+         * @hide
+         */
+        public static final String STATUS_BAR_BATTERY = "status_bar_battery";
+
+        /**
+         * Whether to show the clock in status bar
+         * of the stock battery icon
+         * 0: don't show the clock
+         * 1: show the clock
+         * default: 1
+         * @hide
+         */
+        public static final String STATUS_BAR_CLOCK = "status_bar_clock";
+
+        /**
+         * Whether to show the signal text or signal bars.
+         * default: 0
+         * 0: show signal bars
+         * 1: show signal text numbers
+         * 2: show signal text numbers w/small dBm appended
+         * @hide
+         */
+        public static final String STATUS_BAR_SIGNAL_TEXT = "status_bar_signal";
+
+        /**
+         * Circle battery icon color
+         * in statusbar
+         */
+        public static final String STATUS_BAR_CIRCLE_BATTERY_COLOR = "status_bar_circle_battery_color";
+
+        /**
+         * Circle battery icon text color
+         * in statusbar
+         */
+        public static final String STATUS_BAR_CIRCLE_BATTERY_TEXT_COLOR = "status_bar_circle_battery_text_color";
+
+        /**
+         * Circle battery animation speed during charge
+         * in statusbar
+         */
+        public static final String STATUS_BAR_CIRCLE_BATTERY_ANIMATIONSPEED = "status_bar_circle_battery_animationspeed";
+
+        /**
+         * Circle battery icon reset helper
+         * in statusbar
+         */
+        public static final String STATUS_BAR_CIRCLE_BATTERY_RESET = "status_bar_circle_battery_reset";
+
+        /**
+         * AM/PM Style for clock options
+         * 0 - Normal AM/PM
+         * 1 - Small AM/PM
+         * 2 - No AM/PM
+         * @hide
+         */
+        public static final String STATUSBAR_CLOCK_AM_PM_STYLE = "statusbar_clock_am_pm_style";
+
+        /**
+         * Style of clock
+         * 0 - Hide Clock
+         * 1 - Right Clock
+         * 2 - Center Clock
+         * @hide
+         */
+        public static final String STATUSBAR_CLOCK_STYLE = "statusbar_clock_style";
+
+        /**
+         * Setting for clock color
+         * @hide
+         */
+        public static final String STATUSBAR_CLOCK_COLOR = "statusbar_clock_color";
+
+        /**
+        * @hide
+        * Shows custom date before clock time
+        * 0 - No Date
+        * 1 - Small Date
+        * 2 - Normal Date
+        */
+        public static final String STATUSBAR_CLOCK_DATE_DISPLAY = "statusbar_clock_date_display";
+
+        /**
+        * @hide
+        * Sets the date string style
+        * 0 - Regular style
+        * 1 - Lowercase
+        * 2 - Uppercase
+        */
+        public static final String STATUSBAR_CLOCK_DATE_STYLE = "statusbar_clock_date_style";
+
+        /**
+        * @hide
+        * Stores the java DateFormat string for the date
+        */
+        public static final String STATUSBAR_CLOCK_DATE_FORMAT = "statusbar_clock_date_format";
+
+
+         /**
+         * Whether to control brightness from status bar
+         *
+         * @hide
+         */
+        public static final String STATUS_BAR_BRIGHTNESS_CONTROL = "status_bar_brightness_control";
+
+        /**
+         * Whether to show the IME switcher in the status bar
+         * @hide
+         */
+        public static final String STATUS_BAR_IME_SWITCHER = "status_bar_ime_switcher";
+
+         /**
+         * Expanded desktop on/off state
+         * @hide
+         */
+        public static final String EXPANDED_DESKTOP_STATE = "expanded_desktop_state";
+
+        /**
+         * Expanded desktop style (with status bar or without status bar)
+         * @hide
+         */
+        public static final String EXPANDED_DESKTOP_STYLE = "expanded_desktop_style";
+        
+        /*
+         * This will hide tabUI extras; compatibility button etc.
+         * @ hide
+         */
+        public static final String HIDE_EXTRAS_SYSTEM_BAR = "hide_extras_system_bar";
+        
+        /**
+         * Whether Status bar should be hiidden when there are no
+         * notifications
+         * @hide
+         */
+        public static final String AUTO_HIDE_STATUSBAR = "auto_hide_statusbar";
+        
+        /**
+         * Whether Status bar can be shown by swiping down in fullscreen apps
+         * @hide
+         */
+        public static final String FULLSCREEN_STATUSBAR = "fullscreen_statusbar"; 
+
+        /**
+         * Timeout of fullscreen Status bar
+         * @hide
+         */
+        public static final String FULLSCREEN_STATUSBAR_TIMEOUT = "fullscreen_statusbar_timeout"; 
+
+        /**
+         * Whether Status Bar is currently hidden or not
+         * @hide
+         */
+        public static final String HIDE_STATUSBAR = "hide_statusbar";
+
+        /**
+         * whether which Ram Usage Bar mode is used on recent switcher
+         * 0 = none, 1 = only app use, 2 = app and cache use, 3 = app, cache and system use
+         * @hide
+         */
+        public static final String RECENTS_RAM_BAR_MODE = "recents_ram_bar_mode";
+
+        /**
+         * Ram Usage Bar system mem color
+         *
+         * @hide
+         */
+        public static final String RECENTS_RAM_BAR_MEM_COLOR = "recents_ram_bar_mem_color";
+
+        /**
+         * Ram Usage Bar cached mem color
+         *
+         * @hide
+         */
+        public static final String RECENTS_RAM_BAR_CACHE_COLOR = "recents_ram_bar_cache_color";
+
+        /**
+         * Ram Usage Bar app mem color
+         *
+         * @hide
+         */
+        public static final String RECENTS_RAM_BAR_ACTIVE_APPS_COLOR = "recents_ram_bar_active_apps_color";
+
+        /**
+         * User Interface State
+         * 1 = Rebuild UI, resets to 0 automatically
+         * @hide
+         */
+        public static final String USER_INTERFACE_STATE = "user_interface_state";
+
+       /**
+        * Whether fcharge is enabled or not if kernel supports it
+        * @hide
+        */
+        public static final String FCHARGE_ENABLED = "fcharge_enabled";
+
+        /**
+         * Whether to use a separate delay for "slide to unlock" and security
+         * lock
+         * @hide
+         */
+        public static final String SCREEN_LOCK_SLIDE_DELAY_TOGGLE = "screen_lock_slide_delay_toggle";
+
+        /**
+         * How many ms to delay before enabling the "slide to unlock" screen
+         * lock when the screen goes off due to timeout
+         * @hide
+         */
+        public static final String SCREEN_LOCK_SLIDE_TIMEOUT_DELAY = "screen_lock_slide_timeout_delay";
+
+        /**
+         * How many ms to delay before enabling the "slide to unlock" screen
+         * lock when the screen is turned off by the user
+         * @hide
+         */
+        public static final String SCREEN_LOCK_SLIDE_SCREENOFF_DELAY = "screen_lock_slide_screenoff_delay";
+
+        /**
+         * Whether to use the custom quick unlock screen control
+         * @hide
+         */
+        public static final String LOCKSCREEN_QUICK_UNLOCK_CONTROL = "lockscreen_quick_unlock_control";
+
+        /**
+         * Boolean value whether to link ringtone and notification volumes
+         *
+         * @hide
+         */
+        public static final String VOLUME_LINK_NOTIFICATION = "volume_link_notification";
+
+       
+        /**
+         * Whether to unlock the menu key.  The value is boolean (1 or 0).
+         * @hide
+         */
+        public static final String MENU_UNLOCK_SCREEN = "menu_unlock_screen";
+
+        /**
+         * Whether to wake the screen with the volume keys, the value is boolean.
+         * @hide
+         */
+        public static final String VOLUME_WAKE_SCREEN = "volume_wake_screen";
+
+        /**
+         * Whether or not volume button music controls should be enabled to seek media tracks
+         * @hide
+         */
+        public static final String VOLBTN_MUSIC_CONTROLS = "volbtn_music_controls";
+
+        /**
+         * Whether or not to launch default music player when headset is connected
+         * @hide
+         */
+        public static final String HEADSET_CONNECT_PLAYER = "headset_connect_player";
+
+        /**
+         * Whether national data roaming should be used.
+         * @hide
+         */
+        public static final String MVNO_ROAMING = "mvno_roaming";
+
+        /**
+         * Whether to enable quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_ENABLED = "quiet_hours_enabled";
+
+        /**
+         * Sets when quiet hours starts. This is stored in minutes from the start of the day.
+         * @hide
+         */
+        public static final String QUIET_HOURS_START = "quiet_hours_start";
+
+        /**
+         * Sets when quiet hours end. This is stored in minutes from the start of the day.
+         * @hide
+         */
+        public static final String QUIET_HOURS_END = "quiet_hours_end";
+
+        /**
+         * Whether to remove the sound from outgoing notifications during quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_MUTE = "quiet_hours_mute";
+
+        /**
+         * Whether to disable haptic feedback during quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_HAPTIC = "quiet_hours_haptic";
+
+        /**
+         * Whether to remove the vibration from outgoing notifications during quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_STILL = "quiet_hours_still";
+        
+        /**
+         * Whether to attempt to dim the LED color during quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_DIM = "quiet_hours_dim";
+                
+        /**
+         * Do you want popups/floating windows?
+         * @hide
+         */
+        public static final String WE_WANT_POPUPS = "we_want_popups";
+
+        /**
+         * PA PIE Settings
+         */
+
+        /**
+         * On or off the Pie.
+         * @hide
+         */
+        public static final String PIE_CONTROLS = "pie_controls";
+
+        /**
+         * Pie menu, should default to 1 (yes, show)
+         * @hide
+         */
+        public static final String PIE_MENU = "pie_menu";
+
+        /**
+         * Pie search, should default to 1 (yes, show)
+         * @hide
+         */
+        public static final String PIE_SEARCH = "pie_search";
+
+        /**
+         * Pie will not rotate. Should default to 1 (yes, do not rotate)
+         * @hide
+         */
+        public static final String PIE_STICK = "pie_stick";
+
+        /**
+         * Pie last app, should default to 0 (no, show only when needed)
+         * @hide
+         */
+        public static final String PIE_LAST_APP = "pie_last_app";
+
+        /**
+         * Pie gap angle, should default to 3
+         * @hide
+         */
+        public static final String PIE_GAP = "pie_gap";
+
+        /**
+         * Pie trigger fraction, should default to 1
+         * @hide
+         */
+        public static final String PIE_TRIGGER = "pie_trigger";
+
+        /**
+         * Location of the pie in the screen
+         * @hide
+         */
+        public static final String PIE_GRAVITY = "pie_gravity";
+
+        /**
+         * Pie status report
+         * @hide
+         */
+        public static final String PIE_MODE = "pie_mode";
+
+        /**
+         * Pie size fraction
+         * @hide
+         */
+        public static final String PIE_SIZE = "pie_size";
+
+        /**
+         * Pie Notification Ability
+         * @hide
+         */
+        public static final String PIE_NOTIFICATIONS = "pie_notifications";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_ENABLE_COLOR = "pie_enable_color";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_JUICE = "pie_juice";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_BUTTON_COLOR = "pie_button_color";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_SNAP_BACKGROUND = "pie_snap_background";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_BACKGROUND = "pie_background";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_SELECT = "pie_select";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_OUTLINES = "pie_outlines";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_STATUS_CLOCK = "pie_status_clock";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_STATUS = "pie_status";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_CHEVRON_LEFT = "pie_chevron_left";
+
+        /**
+         * @hide
+         */
+        public static final String PIE_CHEVRON_RIGHT = "pie_chevron_right";
+
+        /**
+         * Center Pie? Should default to 1 (yes, center)
+         * @hide
+         */
+        public static final String PIE_CENTER = "pie_center";
+        
+        /**  
+         * Whether to enable lockscreen rotation
+         * @hide
+         */
+        public static final String LOCKSCREEN_AUTO_ROTATE = "lockscreen_auto_rotate";
+
+        /**
+         * Sets the lockscreen background style
+         * @hide
+         */
+        public static final String LOCKSCREEN_BACKGROUND = "lockscreen_background";
+
+         /**
+         * Action for long-pressing back button on lock screen
+         * @hide
+         */
+        public static final String LOCKSCREEN_LONG_BACK_ACTION = "lockscreen_long_back_action";
+
+        /**
+         * Action for long-pressing home button on lock screen
+         * @hide
+         */
+        public static final String LOCKSCREEN_LONG_HOME_ACTION = "lockscreen_long_home_action";
+
+        /**
+         * Action for long-pressing menu button on lock screen
+         * @hide
+         */
+        public static final String LOCKSCREEN_LONG_MENU_ACTION = "lockscreen_long_menu_action";
+
+         /**
+          * Always show the battery status on the lockscreen
+          * @hide
+          */
+        public static final String LOCKSCREEN_ALWAYS_SHOW_BATTERY = "lockscreen_always_show_battery";
+
+        /**
+         * Show the pending notification counts as overlays on the status bar
+         * @hide
+         */
+        public static final String STATUS_BAR_NOTIF_COUNT = "status_bar_notif_count";
+
+        /**
+         * Enable Stylus Gestures
+         *
+         * @hide
+         */
+        public static final String ENABLE_STYLUS_GESTURES = "enable_stylus_gestures";
+
+        /**
+         * Left Swipe Action
+         *
+         * @hide
+         */
+        public static final String GESTURES_LEFT_SWIPE = "gestures_left_swipe";
+
+        /**
+         * Right Swipe Action
+         *
+         * @hide
+         */
+        public static final String GESTURES_RIGHT_SWIPE = "gestures_right_swipe";
+
+        /**
+         * Up Swipe Action
+         *
+         * @hide
+         */
+        public static final String GESTURES_UP_SWIPE = "gestures_up_swipe";
+
+        /**
+         * down Swipe Action
+         *
+         * @hide
+         */
+        public static final String GESTURES_DOWN_SWIPE = "gestures_down_swipe";
+
+        /**
+         * Long press Action
+         *
+         * @hide
+         */
+        public static final String GESTURES_LONG_PRESS = "gestures_long_press";
+
+        /**
+         * double tap Action
+         *
+         * @hide
+         */
+        public static final String GESTURES_DOUBLE_TAP = "gestures_double_tap";
+
+        /**
+         * Whether to show the battery bar
+         * @hide
+         */
+        public static final String STATUSBAR_BATTERY_BAR = "statusbar_battery_bar";
+
+        /**
+         * @hide
+         */
+        public static final String STATUSBAR_BATTERY_BAR_COLOR = "statusbar_battery_bar_color";
+
+        /**
+         * @hide
+         */
+        public static final String STATUSBAR_BATTERY_BAR_THICKNESS = "statusbar_battery_bar_thickness";
+
+        /**
+         * @hide
+         */
+        public static final String STATUSBAR_BATTERY_BAR_STYLE = "statusbar_battery_bar_style";
+
+        /**
+         * @hide
+         */
+        public static final String STATUSBAR_BATTERY_BAR_ANIMATE = "statusbar_battery_bar_animate";
+
+        /**
+         * Show the pending notification counts as overlays on the status bar
+         * @hide
+         */
+        public static final String SYSTEM_PROFILES_ENABLED = "system_profiles_enabled";
+
+        /**
+         * Whether the power menu reboot menu is enabled
+         * @hide
+         */
+        public static final String POWER_MENU_REBOOT_ENABLED = "power_menu_reboot_enabled";
+
+        /**
+         * Whether power menu screenshot is enabled
+         * @hide
+         */
+        public static final String POWER_MENU_SCREENSHOT_ENABLED = "power_menu_screenshot_enabled";
+
+        /**
+         * Whether power menu expanded desktop is enabled
+         * @hide
+         */
+        public static final String POWER_MENU_EXPANDED_DESKTOP_ENABLED = "power_menu_expanded_desktop_enabled";
+
+        /**
+         * Whether power menu profiles switcher is enabled
+         * @hide
+         */
+        public static final String POWER_MENU_PROFILES_ENABLED = "power_menu_profiles_enabled";
+
+        /**
+         * Whether power menu airplane toggle is enabled
+         * @hide
+         */
+        public static final String POWER_MENU_AIRPLANE_ENABLED = "power_menu_airplane_enabled";
+
+        /**
+         * Whether power menu user switcher is enabled
+         * @hide
+         */
+        public static final String POWER_MENU_USER_ENABLED = "power_menu_user_enabled";
+
+        /**
+         * Whether power menu silent mode is enabled
+         * @hide
+         */
+        public static final String POWER_MENU_SOUND_ENABLED = "power_menu_silent_enabled";
+
+        /**
+         * Whether to unlock the screen with the home key.  The value is boolean (1 or 0).
+         * @hide
+         */
+        public static final String HOME_UNLOCK_SCREEN = "home_unlock_screen";
+
+        /**
+         * Whether the lockscreen vibrate should be enabled.
+         * @hide
+         */
+        public static final String LOCKSCREEN_VIBRATE_ENABLED = "lockscreen.vibrate_enabled";
+
+        /**
+         * Show the pending notification counts as overlays on the status bar
+         * Whether to enable custom rebindings of the actions performed on
+         * certain key press events.
+         * @hide
+         */
+        public static final String HARDWARE_KEY_REBINDING = "hardware_key_rebinding";
+
+         /**
+          * Action to perform when the home key is long-pressed. (Default is 2)
+          * 0 - Nothing
+          * 1 - Menu
+          * 2 - App-switch
+          * 3 - Search
+          * 4 - Voice search
+          * 5 - In-app search
+          * @hide
+          */
+         public static final String KEY_HOME_LONG_PRESS_ACTION = "key_home_long_press_action";
+
+         /**
+          * Action to perform when the menu key is pressed. (Default is 1)
+          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
+          * @hide
+          */
+         public static final String KEY_MENU_ACTION = "key_menu_action";
+
+         /**
+          * Action to perform when the menu key is long-pressed.
+          * (Default is 0 on devices with a search key, 3 on devices without)
+          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
+          * @hide
+          */
+         public static final String KEY_MENU_LONG_PRESS_ACTION = "key_menu_long_press_action";
+
+         /**
+          * Action to perform when the assistant (search) key is pressed. (Default is 3)
+          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
+          * @hide
+          */
+         public static final String KEY_ASSIST_ACTION = "key_assist_action";
+
+         /**
+          * Swap volume buttons when the screen is rotated
+          * 0 - Disabled
+          * 1 - Enabled (screen is rotated by 90 or 180 degrees: phone, hybrid)
+          * 2 - Enabled (screen is rotated by 180 or 270 degrees: tablet)
+          * @hide
+          */
+         public static final String SWAP_VOLUME_KEYS_ON_ROTATION = "swap_volume_keys_on_rotation";
+
+        /**
+         * Weather to minimize lockscreen challenge on screen turned on
+         * @hide
+         */
+        public static final String LOCKSCREEN_MAXIMIZE_WIDGETS = "lockscreen_maximize_widgets";
+
+         /**
+          * Action to perform when the assistant (search) key is long-pressed. (Default is 4)
+          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
+          * @hide
+          */
+         public static final String KEY_ASSIST_LONG_PRESS_ACTION = "key_assist_long_press_action";
+
+         /**
+          * Action to perform when the app switch key is pressed. (Default is 2)
+          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
+          * @hide
+          */
+         public static final String KEY_APP_SWITCH_ACTION = "key_app_switch_action";
+
+         /**
+          * Action to perform when the app switch key is long-pressed. (Default is 0)
+          * (See KEY_HOME_LONG_PRESS_ACTION for valid values)
+          * @hide
+          */
+         public static final String KEY_APP_SWITCH_LONG_PRESS_ACTION = "key_app_switch_long_press_action";
+
+        /**
+         * Control the display of the action overflow button within app UI.
+         * 0 = use system default
+         * 1 = force on
+         * @hide
+         */
+        public static final String UI_FORCE_OVERFLOW_BUTTON = "ui_force_overflow_button";
+
+         /**
+          * Volume keys control cursor in text fields (default is 0)
+          * 0 - Disabled
+          * 1 - Volume up/down moves cursor left/right
+          * 2 - Volume up/down moves cursor right/left
+          * @hide
+          */
+         public static final String VOLUME_KEY_CURSOR_CONTROL = "volume_key_cursor_control";
+
+        /**
+         * toggle to "fix" the following: (found in NotificationManagerService)
+         *  new in 4.2: if there was supposed to be a sound and we're in vibrate mode,
+         *  we always vibrate, even if no vibration was specified
+         * @hide
+         */
+        public static final String NOTIFICATION_CONVERT_SOUND_TO_VIBRATION = "convert_sound_to_vibration";
+
+        /**
+         * Use alternative application resolver
+         */
+        public static final String ACTIVITY_RESOLVER_USE_ALT = "activity_resolver_use_alt";
+        /**
+         * Custom navring actions
+         *
+
+         * Whether electronic beam animation is enabled or not
+         * @hide
+         */
+        public static final String SYSTEM_POWER_ENABLE_CRT_OFF = "system_power_enable_crt_off";
+
+        /**
+         * Electronic beam animation mode
+         * 0 = always horizontal, 1 = always vertical, 2 = dependent on orientation
+         * @hide
+         */
+        public static final String SYSTEM_POWER_CRT_MODE = "system_power_crt_mode";
+
+        /**
+         * Is current activity launcher or not
+         * @hide
+         */
+        public static final String IS_HOME = "is_home";
+
+        /**
+         * Sets transparency of statusbar
+         * @hide
+         */
+        public static final String STATUS_BAR_ALPHA = "status_bar_alpha";
+      
+        /**
+         * Sets color of statusbar
+         * @hide
+         */
+        public static final String STATUS_BAR_COLOR = "status_bar_color";
+        
+        /**
+         * Sets transparency mode of status and navigation bar
+         * 0 = only home, 1 = keyguard and home (default), 2 = always
+         * @hide
+         */
+        public static final String STATUS_NAV_BAR_ALPHA_MODE = "status_nav_bar_alpha_mode";
+
+        /**
+         * Whether to allow notification vibration while notification alerts are disabled
+         * (e.g. during phone calls). The vibration pattern to be used will be a subtle one;
+         * custom vibration is disabled at that point.
+         * @hide
+         */
+        public static final String NOTIFICATION_VIBRATE_DURING_ALERTS_DISABLED = "vibrate_while_no_alerts";
+
+        /**
+         * Custom navring actions
+         *
+         * @hide
+         */
+        public static final String[] NAVIGATION_RING_TARGETS = new String[] {
+            "navigation_ring_targets_0",
+            "navigation_ring_targets_1",
+            "navigation_ring_targets_2",
+        };
+
+        /**
+         * Holds the text for the Carrier label. An empty string
+         * will bring the default text back.
+         * @hide
+         */
+        public static final String CUSTOM_CARRIER_LABEL = "custom_carrier_label";
+
+        /**
+         * Notifications Expand Behavior
+         * @hide
+         */
+        public static final String NOTIFICATIONS_BEHAVIOUR = "notifications_behaviour";
+        
+        /**
+        * Sets the portrait background of notification drawer
+        * @hide
+        */
+        public static final String NOTIFICATION_BACKGROUND = "notification_background";
+
+        /**
+        * Sets the landscape background of notification drawer
+        * @hide
+        */
+        public static final String NOTIFICATION_BACKGROUND_LANDSCAPE = "notification_background_landscape";
+
+        /**
+        * Sets the alpha (transparency) of notification wallpaper
+        * @hide
+        */
+        public static final String NOTIF_WALLPAPER_ALPHA = "notif_wallpaper_alpha";
+ 
+        /**
+        * Sets the alpha (transparency) of notifications
+        * @hide
+        */
+        public static final String NOTIF_ALPHA = "notif_alpha";
+
+        /**
+         * @hide
+         */
+        public static final String MENU_LOCATION = "menu_location";
+
+        /**
+         * @hide
+         */
+        public static final String MENU_VISIBILITY = "menu_visibility";
+
+        /**
+         * @hide
+         */
+        public static final String NAVIGATION_BAR_BUTTONS_QTY = "navigation_bar_buttons_qty";
+
+        /**
+         * @hide
+         */
+        public static final String[] NAVIGATION_CUSTOM_ACTIVITIES = new String[] {
+            "navigation_custom_app_intent_0",
+            "navigation_custom_app_intent_1",
+            "navigation_custom_app_intent_2",
+            "navigation_custom_app_intent_3",
+            "navigation_custom_app_intent_4",
+            "navigation_custom_app_intent_5",
+            "navigation_custom_app_intent_6",
+        };
+
+        /**
+         * @hide
+         */
+        public static final String[] NAVIGATION_LONGPRESS_ACTIVITIES = new String[] {
+            "navigation_longpress_app_intent_0",
+            "navigation_longpress_app_intent_1",
+            "navigation_longpress_app_intent_2",
+            "navigation_longpress_app_intent_3",
+            "navigation_longpress_app_intent_4",
+            "navigation_longpress_app_intent_5",
+            "navigation_longpress_app_intent_6",
+        };
+
+        /**
+         * @hide
+         */
+        public static final String[] NAVIGATION_CUSTOM_APP_ICONS = new String[] {
+            "navigation_custom_app_icon_0",
+            "navigation_custom_app_icon_1",
+            "navigation_custom_app_icon_2",
+            "navigation_custom_app_icon_3",
+            "navigation_custom_app_icon_4",
+            "navigation_custom_app_icon_5",
+            "navigation_custom_app_icon_6",
+        };
+
+        /**
+         * Widgets to show, should be separated by |
+         */
+        public static final String NAVIGATION_BAR_WIDGETS = "navigation_bar_widgets";
+
+        /**
+         * @hide
+         */
+        public static final String NAVIGATION_BAR_BUTTON_ALPHA = "navigation_bar_button_alpha";
+
+        /**
+         * @hide
+         */
+        public static final String NAVIGATION_BAR_TINT = "navigation_bar_tint";
+
+        /**
+         * @hide
+         */
+        public static final String NAVIGATION_BAR_GLOW_TINT = "navigation_bar_glow_tint";
+
+        /**
+         * @hide
+         */
+        public static final String[] NAVIGATION_BAR_GLOW_DURATION = new String[] {
+            "navigation_bar_glow_duration_off",
+            "navigation_bar_glow_duration_on",
+        };
+
+       /**
+        * Lefty mode
+        * @hide
+        */
+        public static final String NAVIGATION_BAR_LEFTY_MODE = "navigation_bar_lefty_mode";
+
+       /**
+        *
+        * @hide
+        */
+        public static final String SYSTEMUI_NAVRING_AMOUNT = "systemui_navring_amount";
+
+       /**
+        *
+        * @hide
+        */
+        public static final String SYSTEMUI_NAVRING_LONG_ENABLE = "systemui_navring_long_enable";
+
+        /**
+         * Custom navring actions
+         *
+         * @hide
+         */
+        public static final String[] SYSTEMUI_NAVRING = new String[] {
+                "navring_0",
+                "navring_1",
+                "navring_2",
+                "navring_3",
+                "navring_4",
+        };
+
+        /**  
+         * Give MMS Notifications a breathing effect
+         * @hide
+         */
+        public static final String MMS_BREATH = "mms_breath";
+
+        /**	
+         * Give MMS Notifications a breathing effect
+         * @hide
+         */
+        public static final String MISSED_CALL_BREATH = "missed_call_breath";
+
+        /**
+         * Custom navring long press actions
+         *
+         * @hide
+         */
+        public static final String[] SYSTEMUI_NAVRING_LONG = new String[] {
+                "navring_long_0",
+                "navring_long_1",
+                "navring_long_2",
+                "navring_long_3",
+                "navring_long_4",
+        };
+
+        /**
+         * Volume key controls ringtone or media sound stream
+         *
+         * @hide
+         */
+        public static final String VOLUME_KEYS_CONTROL_RING_STREAM = "volume_keys_control_ring_stream";
+
+        /**
+         * Settings to backup. This is here so that it's in the same place as the settings
+         * keys and easy to update.
+         *
+         * NOTE: Settings are backed up and restored in the order they appear
+         *       in this array. If you have one setting depending on another,
+         *       make sure that they are ordered appropriately.
+         *
+         * @hide
+         */
+        public static final String[] SETTINGS_TO_BACKUP = {
+            STAY_ON_WHILE_PLUGGED_IN,   // moved to global
+            WIFI_USE_STATIC_IP,
+            WIFI_STATIC_IP,
+            WIFI_STATIC_GATEWAY,
+            WIFI_STATIC_NETMASK,
+            WIFI_STATIC_DNS1,
+            WIFI_STATIC_DNS2,
+            MMS_AUTO_RETRIEVAL,
+            MMS_AUTO_RETRIEVAL_ON_ROAMING,
+            BLUETOOTH_DISCOVERABILITY,
+            BLUETOOTH_DISCOVERABILITY_TIMEOUT,
+            DIM_SCREEN,
+            SCREEN_OFF_TIMEOUT,
+            SCREEN_BRIGHTNESS,
+            SCREEN_BRIGHTNESS_MODE,
+            SCREEN_AUTO_BRIGHTNESS_ADJ,
+            VIBRATE_INPUT_DEVICES,
+            MODE_RINGER,                // moved to global
+            MODE_RINGER_STREAMS_AFFECTED,
+            MUTE_STREAMS_AFFECTED,
+            VOLUME_VOICE,
+            VOLUME_SYSTEM,
+            VOLUME_RING,
+            VOLUME_MUSIC,
+			VOLUME_FM,
+            VOLUME_ALARM,
+            VOLUME_NOTIFICATION,
+            VOLUME_BLUETOOTH_SCO,
+            VOLUME_VOICE + APPEND_FOR_LAST_AUDIBLE,
+            VOLUME_SYSTEM + APPEND_FOR_LAST_AUDIBLE,
+            VOLUME_RING + APPEND_FOR_LAST_AUDIBLE,
+            VOLUME_MUSIC + APPEND_FOR_LAST_AUDIBLE,
+            VOLUME_ALARM + APPEND_FOR_LAST_AUDIBLE,
+            VOLUME_NOTIFICATION + APPEND_FOR_LAST_AUDIBLE,
+            VOLUME_BLUETOOTH_SCO + APPEND_FOR_LAST_AUDIBLE,
+            TEXT_AUTO_REPLACE,
+            TEXT_AUTO_CAPS,
+            TEXT_AUTO_PUNCTUATE,
+            TEXT_SHOW_PASSWORD,
+            AUTO_TIME,                  // moved to global
+            AUTO_TIME_ZONE,             // moved to global
+            TIME_12_24,
+            DATE_FORMAT,
+            ACCELEROMETER_ROTATION,
+            USER_ROTATION,
+            DTMF_TONE_WHEN_DIALING,
+            DTMF_TONE_TYPE_WHEN_DIALING,
+            HEARING_AID,
+            TTY_MODE,
+            NOISE_SUPPRESSION,
+            SOUND_EFFECTS_ENABLED,
+            HAPTIC_FEEDBACK_ENABLED,
+            POWER_SOUNDS_ENABLED,       // moved to global
+            DOCK_SOUNDS_ENABLED,        // moved to global
+            LOCKSCREEN_SOUNDS_ENABLED,
+            SHOW_WEB_SUGGESTIONS,
+            NOTIFICATION_LIGHT_PULSE,
+            NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR,
+            NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON,
+            NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF,
+            NOTIFICATION_VIBRATE_DURING_ALERTS_DISABLED,
+            SIP_CALL_OPTIONS,
+            SIP_RECEIVE_CALLS,
+            POINTER_SPEED,
+            QUIET_HOURS_ENABLED,
+            QUIET_HOURS_START,
+            QUIET_HOURS_END,
+            QUIET_HOURS_MUTE,
+            QUIET_HOURS_STILL,
+            QUIET_HOURS_DIM,
+            SYSTEM_PROFILES_ENABLED,
+            POWER_MENU_SCREENSHOT_ENABLED,
+            POWER_MENU_REBOOT_ENABLED,
+            POWER_MENU_PROFILES_ENABLED,
+            POWER_MENU_AIRPLANE_ENABLED,
+            POWER_MENU_SOUND_ENABLED,
+            POWER_MENU_USER_ENABLED,
+            LOCKSCREEN_VIBRATE_ENABLED,
+            LOCKSCREEN_ALWAYS_SHOW_BATTERY,
+        };
+
+        // Settings moved to Settings.Secure
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#ADB_ENABLED}
+         * instead
+         */
+        @Deprecated
+        public static final String ADB_ENABLED = Global.ADB_ENABLED;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#ANDROID_ID} instead
+         */
+        @Deprecated
+        public static final String ANDROID_ID = Secure.ANDROID_ID;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_ON} instead
+         */
+        @Deprecated
+        public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
+         */
+        @Deprecated
+        public static final String DATA_ROAMING = Global.DATA_ROAMING;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#DEVICE_PROVISIONED} instead
+         */
+        @Deprecated
+        public static final String DEVICE_PROVISIONED = Global.DEVICE_PROVISIONED;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#HTTP_PROXY} instead
+         */
+        @Deprecated
+        public static final String HTTP_PROXY = Global.HTTP_PROXY;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#INSTALL_NON_MARKET_APPS} instead
+         */
+        @Deprecated
+        public static final String INSTALL_NON_MARKET_APPS = Global.INSTALL_NON_MARKET_APPS;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#LOCATION_PROVIDERS_ALLOWED}
+         * instead
+         */
+        @Deprecated
+        public static final String LOCATION_PROVIDERS_ALLOWED = Secure.LOCATION_PROVIDERS_ALLOWED;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#LOGGING_ID} instead
+         */
+        @Deprecated
+        public static final String LOGGING_ID = Secure.LOGGING_ID;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#NETWORK_PREFERENCE} instead
+         */
+        @Deprecated
+        public static final String NETWORK_PREFERENCE = Global.NETWORK_PREFERENCE;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#PARENTAL_CONTROL_ENABLED}
+         * instead
+         */
+        @Deprecated
+        public static final String PARENTAL_CONTROL_ENABLED = Secure.PARENTAL_CONTROL_ENABLED;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#PARENTAL_CONTROL_LAST_UPDATE}
+         * instead
+         */
+        @Deprecated
+        public static final String PARENTAL_CONTROL_LAST_UPDATE = Secure.PARENTAL_CONTROL_LAST_UPDATE;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#PARENTAL_CONTROL_REDIRECT_URL}
+         * instead
+         */
+        @Deprecated
+        public static final String PARENTAL_CONTROL_REDIRECT_URL =
+            Secure.PARENTAL_CONTROL_REDIRECT_URL;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#SETTINGS_CLASSNAME} instead
+         */
+        @Deprecated
+        public static final String SETTINGS_CLASSNAME = Secure.SETTINGS_CLASSNAME;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#USB_MASS_STORAGE_ENABLED} instead
+         */
+        @Deprecated
+        public static final String USB_MASS_STORAGE_ENABLED = Global.USB_MASS_STORAGE_ENABLED;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#USE_GOOGLE_MAIL} instead
+         */
+        @Deprecated
+        public static final String USE_GOOGLE_MAIL = Global.USE_GOOGLE_MAIL;
+
+       /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Global#WIFI_MAX_DHCP_RETRY_COUNT} instead
+         */
+        @Deprecated
+        public static final String WIFI_MAX_DHCP_RETRY_COUNT = Global.WIFI_MAX_DHCP_RETRY_COUNT;
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Global#WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS} instead
+         */
+        @Deprecated
+        public static final String WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS =
+                Global.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS;
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Global#WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON} instead
+         */
+        @Deprecated
+        public static final String WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON =
+                Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON;
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Global#WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY} instead
+         */
+        @Deprecated
+        public static final String WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY =
+                Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_NUM_OPEN_NETWORKS_KEPT}
+         * instead
+         */
+        @Deprecated
+        public static final String WIFI_NUM_OPEN_NETWORKS_KEPT = Global.WIFI_NUM_OPEN_NETWORKS_KEPT;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_ON} instead
+         */
+        @Deprecated
+        public static final String WIFI_ON = Global.WIFI_ON;
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE}
+         * instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE =
+                Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_AP_COUNT} instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_AP_COUNT = Secure.WIFI_WATCHDOG_AP_COUNT;
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS} instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS =
+                Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS;
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED} instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED =
+                Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED;
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS}
+         * instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS =
+                Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS;
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT} instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT =
+            Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_MAX_AP_CHECKS}
+         * instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_MAX_AP_CHECKS = Secure.WIFI_WATCHDOG_MAX_AP_CHECKS;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_WATCHDOG_ON} instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_ON = Global.WIFI_WATCHDOG_ON;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_PING_COUNT} instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_PING_COUNT = Secure.WIFI_WATCHDOG_PING_COUNT;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_PING_DELAY_MS}
+         * instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_PING_DELAY_MS = Secure.WIFI_WATCHDOG_PING_DELAY_MS;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Secure#WIFI_WATCHDOG_PING_TIMEOUT_MS}
+         * instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_PING_TIMEOUT_MS =
+            Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS;
+
+        /**
+         * boolean value. toggles using arrow key locations on nav bar
+         * as left and right dpad keys
+         * @hide
+         */
+        public static final String NAVIGATION_BAR_MENU_ARROW_KEYS = "navigation_bar_menu_arrow_keys";
+
+        /**
+         * Navigation bar alpha while in homescreen and lockscreen.
+         *
+         * @hide
+         */
+        public static final String NAVIGATION_BAR_ALPHA = "navigation_bar_alpha";
+
+        /**
+         * Navigation bar color.
+         *
+         * @hide
+         */
+        public static final String NAVIGATION_BAR_COLOR = "navigation_bar_color";
+
+    }
+
+    /**
+     * Secure system settings, containing system preferences that applications
+     * can read but are not allowed to write.  These are for preferences that
+     * the user must explicitly modify through the system UI or specialized
+     * APIs for those values, not modified directly by applications.
+     */
+    public static final class Secure extends NameValueTable {
+        public static final String SYS_PROP_SETTING_VERSION = "sys.settings_secure_version";
+
+        /**
+         * The content:// style URL for this table
+         */
+        public static final Uri CONTENT_URI =
+            Uri.parse("content://" + AUTHORITY + "/secure");
+
+        // Populated lazily, guarded by class object:
+        private static final NameValueCache sNameValueCache = new NameValueCache(
+                SYS_PROP_SETTING_VERSION,
+                CONTENT_URI,
+                CALL_METHOD_GET_SECURE,
+                CALL_METHOD_PUT_SECURE);
+
+        private static ILockSettings sLockSettings = null;
+
+        private static boolean sIsSystemProcess;
+        private static final HashSet<String> MOVED_TO_LOCK_SETTINGS;
+        private static final HashSet<String> MOVED_TO_GLOBAL;
+        static {
+            MOVED_TO_LOCK_SETTINGS = new HashSet<String>(3);
+            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_PATTERN_ENABLED);
+            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_PATTERN_VISIBLE);
+            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_SHOW_ERROR_PATH);
+            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_DOTS_VISIBLE);
+            MOVED_TO_LOCK_SETTINGS.add(Secure.LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED);
+
+            MOVED_TO_GLOBAL = new HashSet<String>();
+            MOVED_TO_GLOBAL.add(Settings.Global.ADB_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.ASSISTED_GPS_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.BLUETOOTH_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.CDMA_CELL_BROADCAST_SMS);
+            MOVED_TO_GLOBAL.add(Settings.Global.CDMA_ROAMING_MODE);
+            MOVED_TO_GLOBAL.add(Settings.Global.CDMA_SUBSCRIPTION_MODE);
+            MOVED_TO_GLOBAL.add(Settings.Global.DATA_ACTIVITY_TIMEOUT_MOBILE);
+            MOVED_TO_GLOBAL.add(Settings.Global.DATA_ACTIVITY_TIMEOUT_WIFI);
+            MOVED_TO_GLOBAL.add(Settings.Global.DATA_ROAMING);
+            MOVED_TO_GLOBAL.add(Settings.Global.DEVELOPMENT_SETTINGS_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.DEVICE_PROVISIONED);
+            MOVED_TO_GLOBAL.add(Settings.Global.DISPLAY_DENSITY_FORCED);
+            MOVED_TO_GLOBAL.add(Settings.Global.DISPLAY_SIZE_FORCED);
+            MOVED_TO_GLOBAL.add(Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE);
+            MOVED_TO_GLOBAL.add(Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE);
+            MOVED_TO_GLOBAL.add(Settings.Global.INSTALL_NON_MARKET_APPS);
+            MOVED_TO_GLOBAL.add(Settings.Global.MOBILE_DATA);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_DEV_BUCKET_DURATION);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_DEV_DELETE_AGE);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_DEV_PERSIST_BYTES);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_DEV_ROTATE_AGE);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_GLOBAL_ALERT_BYTES);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_POLL_INTERVAL);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_REPORT_XT_OVER_DEV);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_SAMPLE_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_TIME_CACHE_MAX_AGE);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_BUCKET_DURATION);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_DELETE_AGE);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_PERSIST_BYTES);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_ROTATE_AGE);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_TAG_BUCKET_DURATION);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_TAG_DELETE_AGE);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_TAG_PERSIST_BYTES);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETSTATS_UID_TAG_ROTATE_AGE);
+            MOVED_TO_GLOBAL.add(Settings.Global.NETWORK_PREFERENCE);
+            MOVED_TO_GLOBAL.add(Settings.Global.NITZ_UPDATE_DIFF);
+            MOVED_TO_GLOBAL.add(Settings.Global.NITZ_UPDATE_SPACING);
+            MOVED_TO_GLOBAL.add(Settings.Global.NTP_SERVER);
+            MOVED_TO_GLOBAL.add(Settings.Global.NTP_TIMEOUT);
+            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_ERROR_POLL_COUNT);
+            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_LONG_POLL_INTERVAL_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_MAX_PDP_RESET_FAIL_COUNT);
+            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_POLL_INTERVAL_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.PDP_WATCHDOG_TRIGGER_PACKET_COUNT);
+            MOVED_TO_GLOBAL.add(Settings.Global.SAMPLING_PROFILER_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.SETUP_PREPAID_DATA_SERVICE_URL);
+            MOVED_TO_GLOBAL.add(Settings.Global.SETUP_PREPAID_DETECTION_REDIR_HOST);
+            MOVED_TO_GLOBAL.add(Settings.Global.SETUP_PREPAID_DETECTION_TARGET_URL);
+            MOVED_TO_GLOBAL.add(Settings.Global.TETHER_DUN_APN);
+            MOVED_TO_GLOBAL.add(Settings.Global.TETHER_DUN_REQUIRED);
+            MOVED_TO_GLOBAL.add(Settings.Global.TETHER_SUPPORTED);
+            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_HELP_URI);
+            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_MAX_NTP_CACHE_AGE_SEC);
+            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_NOTIFICATION_TYPE);
+            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_POLLING_SEC);
+            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_RESET_DAY);
+            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_THRESHOLD_BYTES);
+            MOVED_TO_GLOBAL.add(Settings.Global.THROTTLE_VALUE_KBITSPS);
+            MOVED_TO_GLOBAL.add(Settings.Global.USB_MASS_STORAGE_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.USE_GOOGLE_MAIL);
+            MOVED_TO_GLOBAL.add(Settings.Global.WEB_AUTOFILL_QUERY_URL);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_COUNTRY_CODE);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_FRAMEWORK_SCAN_INTERVAL_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_FREQUENCY_BAND);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_IDLE_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_NUM_OPEN_NETWORKS_KEPT);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_P2P_DEVICE_NAME);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SAVED_STATE);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_WATCHDOG_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIMAX_NETWORKS_AVAILABLE_NOTIFICATION_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.PACKAGE_VERIFIER_ENABLE);
+            MOVED_TO_GLOBAL.add(Settings.Global.PACKAGE_VERIFIER_TIMEOUT);
+            MOVED_TO_GLOBAL.add(Settings.Global.PACKAGE_VERIFIER_DEFAULT_RESPONSE);
+            MOVED_TO_GLOBAL.add(Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS);
+            MOVED_TO_GLOBAL.add(Settings.Global.WTF_IS_FATAL);
+            MOVED_TO_GLOBAL.add(Settings.Global.BATTERY_DISCHARGE_DURATION_THRESHOLD);
+            MOVED_TO_GLOBAL.add(Settings.Global.BATTERY_DISCHARGE_THRESHOLD);
+            MOVED_TO_GLOBAL.add(Settings.Global.SEND_ACTION_APP_ERROR);
+            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_AGE_SECONDS);
+            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_MAX_FILES);
+            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_QUOTA_KB);
+            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_QUOTA_PERCENT);
+            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_RESERVE_PERCENT);
+            MOVED_TO_GLOBAL.add(Settings.Global.DROPBOX_TAG_PREFIX);
+            MOVED_TO_GLOBAL.add(Settings.Global.ERROR_LOGCAT_PREFIX);
+            MOVED_TO_GLOBAL.add(Settings.Global.SYS_FREE_STORAGE_LOG_INTERVAL);
+            MOVED_TO_GLOBAL.add(Settings.Global.DISK_FREE_CHANGE_REPORTING_THRESHOLD);
+            MOVED_TO_GLOBAL.add(Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE);
+            MOVED_TO_GLOBAL.add(Settings.Global.SYS_STORAGE_THRESHOLD_MAX_BYTES);
+            MOVED_TO_GLOBAL.add(Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES);
+            MOVED_TO_GLOBAL.add(Settings.Global.SYNC_MAX_RETRY_DELAY_IN_SECONDS);
+            MOVED_TO_GLOBAL.add(Settings.Global.CONNECTIVITY_CHANGE_DELAY);
+            MOVED_TO_GLOBAL.add(Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED);
+            MOVED_TO_GLOBAL.add(Settings.Global.CAPTIVE_PORTAL_SERVER);
+            MOVED_TO_GLOBAL.add(Settings.Global.NSD_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.SET_INSTALL_LOCATION);
+            MOVED_TO_GLOBAL.add(Settings.Global.DEFAULT_INSTALL_LOCATION);
+            MOVED_TO_GLOBAL.add(Settings.Global.INET_CONDITION_DEBOUNCE_UP_DELAY);
+            MOVED_TO_GLOBAL.add(Settings.Global.INET_CONDITION_DEBOUNCE_DOWN_DELAY);
+            MOVED_TO_GLOBAL.add(Settings.Global.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT);
+            MOVED_TO_GLOBAL.add(Settings.Global.HTTP_PROXY);
+            MOVED_TO_GLOBAL.add(Settings.Global.GLOBAL_HTTP_PROXY_HOST);
+            MOVED_TO_GLOBAL.add(Settings.Global.GLOBAL_HTTP_PROXY_PORT);
+            MOVED_TO_GLOBAL.add(Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST);
+            MOVED_TO_GLOBAL.add(Settings.Global.SET_GLOBAL_HTTP_PROXY);
+            MOVED_TO_GLOBAL.add(Settings.Global.DEFAULT_DNS_SERVER);
+            MOVED_TO_GLOBAL.add(Settings.Global.PREFERRED_NETWORK_MODE);
+            MOVED_TO_GLOBAL.add(Settings.Global.PREFERRED_CDMA_SUBSCRIPTION);
+        }
+
+        /** @hide */
+        public static void getMovedKeys(HashSet<String> outKeySet) {
+            outKeySet.addAll(MOVED_TO_GLOBAL);
+        }
+
+        /**

+         * Look up a name in the database.
+         * @param resolver to access the database with
+         * @param name to look up in the table
+         * @return the corresponding value, or null if not present
+         */
+        public static String getString(ContentResolver resolver, String name) {
+            return getStringForUser(resolver, name, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static String getStringForUser(ContentResolver resolver, String name,
+                int userHandle) {
+            if (MOVED_TO_GLOBAL.contains(name)) {
+                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Secure"
+                        + " to android.provider.Settings.Global.");
+                return Global.getStringForUser(resolver, name, userHandle);
+            }
+
+            if (MOVED_TO_LOCK_SETTINGS.contains(name)) {
+                synchronized (Secure.class) {
+                    if (sLockSettings == null) {
+                        sLockSettings = ILockSettings.Stub.asInterface(
+                                (IBinder) ServiceManager.getService("lock_settings"));
+                        sIsSystemProcess = Process.myUid() == Process.SYSTEM_UID;
+                    }
+                }
+                if (sLockSettings != null && !sIsSystemProcess) {
+                    try {
+                        return sLockSettings.getString(name, "0", userHandle);
+                    } catch (RemoteException re) {
+                        // Fall through
+                    }
+                }
+            }
+
+            return sNameValueCache.getStringForUser(resolver, name, userHandle);
+        }
+
+        /**
+         * Store a name/value pair into the database.
+         * @param resolver to access the database with
+         * @param name to store
+         * @param value to associate with the name
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putString(ContentResolver resolver, String name, String value) {
+            return putStringForUser(resolver, name, value, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putStringForUser(ContentResolver resolver, String name, String value,
+                int userHandle) {
+            if (MOVED_TO_GLOBAL.contains(name)) {
+                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
+                        + " to android.provider.Settings.Global");
+                return Global.putStringForUser(resolver, name, value, userHandle);
+            }
+            return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
+        }
+
+        /**
+         * Construct the content URI for a particular name/value pair,
+         * useful for monitoring changes with a ContentObserver.
+         * @param name to look up in the table
+         * @return the corresponding content URI, or null if not present
+         */
+        public static Uri getUriFor(String name) {
+            if (MOVED_TO_GLOBAL.contains(name)) {
+                Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Secure"
+                        + " to android.provider.Settings.Global, returning global URI.");
+                return Global.getUriFor(Global.CONTENT_URI, name);
+            }
+            return getUriFor(CONTENT_URI, name);
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as an integer.  Note that internally setting values are always
+         * stored as strings; this function converts the string to an integer
+         * for you.  The default value will be returned if the setting is
+         * not defined or not an integer.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         * @param def Value to return if the setting is not defined.
+         *
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid integer.
+         */
+        public static int getInt(ContentResolver cr, String name, int def) {
+            return getIntForUser(cr, name, def, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static int getIntForUser(ContentResolver cr, String name, int def, int userHandle) {
+            String v = getStringForUser(cr, name, userHandle);
+            try {
+                return v != null ? Integer.parseInt(v) : def;
+            } catch (NumberFormatException e) {
+                return def;
+            }
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as an integer.  Note that internally setting values are always
+         * stored as strings; this function converts the string to an integer
+         * for you.
+         * <p>
+         * This version does not take a default value.  If the setting has not
+         * been set, or the string value is not a number,
+         * it throws {@link SettingNotFoundException}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         *
+         * @throws SettingNotFoundException Thrown if a setting by the given
+         * name can't be found or the setting value is not an integer.
+         *
+         * @return The setting's current value.
+         */
+        public static int getInt(ContentResolver cr, String name)
+                throws SettingNotFoundException {
+            return getIntForUser(cr, name, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static int getIntForUser(ContentResolver cr, String name, int userHandle)
+                throws SettingNotFoundException {
+            String v = getStringForUser(cr, name, userHandle);
+            try {
+                return Integer.parseInt(v);
+            } catch (NumberFormatException e) {
+                throw new SettingNotFoundException(name);
+            }
+        }
+
+        /**
+         * Convenience function for updating a single settings value as an
+         * integer. This will either create a new entry in the table if the
+         * given name does not exist, or modify the value of the existing row
+         * with that name.  Note that internally setting values are always
+         * stored as strings, so this function converts the given value to a
+         * string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putInt(ContentResolver cr, String name, int value) {
+            return putIntForUser(cr, name, value, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putIntForUser(ContentResolver cr, String name, int value,
+                int userHandle) {
+            return putStringForUser(cr, name, Integer.toString(value), userHandle);
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as a {@code long}.  Note that internally setting values are always
+         * stored as strings; this function converts the string to a {@code long}
+         * for you.  The default value will be returned if the setting is
+         * not defined or not a {@code long}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         * @param def Value to return if the setting is not defined.
+         *
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid {@code long}.
+         */
+        public static long getLong(ContentResolver cr, String name, long def) {
+            return getLongForUser(cr, name, def, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static long getLongForUser(ContentResolver cr, String name, long def,
+                int userHandle) {
+            String valString = getStringForUser(cr, name, userHandle);
+            long value;
+            try {
+                value = valString != null ? Long.parseLong(valString) : def;
+            } catch (NumberFormatException e) {
+                value = def;
+            }
+            return value;
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as a {@code long}.  Note that internally setting values are always
+         * stored as strings; this function converts the string to a {@code long}
+         * for you.
+         * <p>
+         * This version does not take a default value.  If the setting has not
+         * been set, or the string value is not a number,
+         * it throws {@link SettingNotFoundException}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         *
+         * @return The setting's current value.
+         * @throws SettingNotFoundException Thrown if a setting by the given
+         * name can't be found or the setting value is not an integer.
+         */
+        public static long getLong(ContentResolver cr, String name)
+                throws SettingNotFoundException {
+            return getLongForUser(cr, name, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static long getLongForUser(ContentResolver cr, String name, int userHandle)
+                throws SettingNotFoundException {
+            String valString = getStringForUser(cr, name, userHandle);
+            try {
+                return Long.parseLong(valString);
+            } catch (NumberFormatException e) {
+                throw new SettingNotFoundException(name);
+            }
+        }
+
+        /**
+         * Convenience function for updating a secure settings value as a long
+         * integer. This will either create a new entry in the table if the
+         * given name does not exist, or modify the value of the existing row
+         * with that name.  Note that internally setting values are always
+         * stored as strings, so this function converts the given value to a
+         * string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putLong(ContentResolver cr, String name, long value) {
+            return putLongForUser(cr, name, value, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putLongForUser(ContentResolver cr, String name, long value,
+                int userHandle) {
+            return putStringForUser(cr, name, Long.toString(value), userHandle);
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as a floating point number.  Note that internally setting values are
+         * always stored as strings; this function converts the string to an
+         * float for you. The default value will be returned if the setting
+         * is not defined or not a valid float.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         * @param def Value to return if the setting is not defined.
+         *
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid float.
+         */
+        public static float getFloat(ContentResolver cr, String name, float def) {
+            return getFloatForUser(cr, name, def, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static float getFloatForUser(ContentResolver cr, String name, float def,
+                int userHandle) {
+            String v = getStringForUser(cr, name, userHandle);
+            try {
+                return v != null ? Float.parseFloat(v) : def;
+            } catch (NumberFormatException e) {
+                return def;
+            }
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as a float.  Note that internally setting values are always
+         * stored as strings; this function converts the string to a float
+         * for you.
+         * <p>
+         * This version does not take a default value.  If the setting has not
+         * been set, or the string value is not a number,
+         * it throws {@link SettingNotFoundException}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         *
+         * @throws SettingNotFoundException Thrown if a setting by the given
+         * name can't be found or the setting value is not a float.
+         *
+         * @return The setting's current value.
+         */
+        public static float getFloat(ContentResolver cr, String name)
+                throws SettingNotFoundException {
+            return getFloatForUser(cr, name, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static float getFloatForUser(ContentResolver cr, String name, int userHandle)
+                throws SettingNotFoundException {
+            String v = getStringForUser(cr, name, userHandle);
+            if (v == null) {
+                throw new SettingNotFoundException(name);
+            }
+            try {
+                return Float.parseFloat(v);
+            } catch (NumberFormatException e) {
+                throw new SettingNotFoundException(name);
+            }
+        }
+
+        /**
+         * Convenience function for updating a single settings value as a
+         * floating point number. This will either create a new entry in the
+         * table if the given name does not exist, or modify the value of the
+         * existing row with that name.  Note that internally setting values
+         * are always stored as strings, so this function converts the given
+         * value to a string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putFloat(ContentResolver cr, String name, float value) {
+            return putFloatForUser(cr, name, value, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putFloatForUser(ContentResolver cr, String name, float value,
+                int userHandle) {
+            return putStringForUser(cr, name, Float.toString(value), userHandle);
+        }
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}
+         * instead
+         */
+        @Deprecated
+        public static final String DEVELOPMENT_SETTINGS_ENABLED =
+                Global.DEVELOPMENT_SETTINGS_ENABLED;
+
+        /**
+         * When the user has enable the option to have a "bug report" command
+         * in the power menu.
+         * @hide
+         */
+        public static final String BUGREPORT_IN_POWER_MENU = "bugreport_in_power_menu";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#ADB_ENABLED} instead
+         */
+        @Deprecated
+        public static final String ADB_ENABLED = Global.ADB_ENABLED;
+
+        /**
+         * The TCP/IP port to run ADB on, or -1 for USB
+         * @hide
+         */
+        public static final String ADB_PORT = "adb_port";
+
+        /**
+         * Whether to display the ADB notification.
+         * @hide
+         */
+        public static final String ADB_NOTIFY = "adb_notify";
+
+        /**
+         * The hostname for this device
+         * @hide
+         */
+        public static final String DEVICE_HOSTNAME = "device_hostname";
+
+        /**
+         * Setting to allow mock locations and location provider status to be injected into the
+         * LocationManager service for testing purposes during application development.  These
+         * locations and status values  override actual location and status information generated
+         * by network, gps, or other location providers.
+         */
+        public static final String ALLOW_MOCK_LOCATION = "mock_location";
+
+        /**
+         * A 64-bit number (as a hex string) that is randomly
+         * generated on the device's first boot and should remain
+         * constant for the lifetime of the device.  (The value may
+         * change if a factory reset is performed on the device.)
+         */
+        public static final String ANDROID_ID = "android_id";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_ON} instead
+         */
+        @Deprecated
+        public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
+         */
+        @Deprecated
+        public static final String DATA_ROAMING = Global.DATA_ROAMING;
+
+        /**
+         * Setting to record the input method used by default, holding the ID
+         * of the desired method.
+         */
+        public static final String DEFAULT_INPUT_METHOD = "default_input_method";
+
+        /**
+         * Setting to record the input method subtype used by default, holding the ID
+         * of the desired method.
+         */
+        public static final String SELECTED_INPUT_METHOD_SUBTYPE =
+                "selected_input_method_subtype";
+
+        /**
+         * Setting to record the history of input method subtype, holding the pair of ID of IME
+         * and its last used subtype.
+         * @hide
+         */
+        public static final String INPUT_METHODS_SUBTYPE_HISTORY =
+                "input_methods_subtype_history";
+
+        /**
+         * Setting to record the visibility of input method selector
+         */
+        public static final String INPUT_METHOD_SELECTOR_VISIBILITY =
+                "input_method_selector_visibility";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#DEVICE_PROVISIONED} instead
+         */
+        @Deprecated
+        public static final String DEVICE_PROVISIONED = Global.DEVICE_PROVISIONED;
+
+        /**
+         * Whether the current user has been set up via setup wizard (0 = false, 1 = true)
+         * @hide
+         */
+        public static final String USER_SETUP_COMPLETE = "user_setup_complete";
+
+        /**
+         * List of input methods that are currently enabled.  This is a string
+         * containing the IDs of all enabled input methods, each ID separated
+         * by ':'.
+         */
+        public static final String ENABLED_INPUT_METHODS = "enabled_input_methods";
+
+        /**
+         * List of system input methods that are currently disabled.  This is a string
+         * containing the IDs of all disabled input methods, each ID separated
+         * by ':'.
+         * @hide
+         */
+        public static final String DISABLED_SYSTEM_INPUT_METHODS = "disabled_system_input_methods";
+
+        /**
+         * Host name and port for global http proxy. Uses ':' seperator for
+         * between host and port.
+         *
+         * @deprecated Use {@link Global#HTTP_PROXY}
+         */
+        @Deprecated
+        public static final String HTTP_PROXY = Global.HTTP_PROXY;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#INSTALL_NON_MARKET_APPS} instead
+         */
+        @Deprecated
+        public static final String INSTALL_NON_MARKET_APPS = Global.INSTALL_NON_MARKET_APPS;
+
+        /**
+         * Comma-separated list of location providers that activities may access.
+         */
+        public static final String LOCATION_PROVIDERS_ALLOWED = "location_providers_allowed";
+
+        /**
+         * A flag containing settings used for biometric weak
+         * @hide
+         */
+        public static final String LOCK_BIOMETRIC_WEAK_FLAGS =
+                "lock_biometric_weak_flags";
+
+        /**
+         * Whether autolock is enabled (0 = false, 1 = true)
+         */
+        public static final String LOCK_PATTERN_ENABLED = "lock_pattern_autolock";
+
+        /**
+         * Whether lock pattern is visible as user enters (0 = false, 1 = true)
+         */
+        public static final String LOCK_PATTERN_VISIBLE = "lock_pattern_visible_pattern";
+
+        /**
+         * Whether lock pattern will vibrate as user enters (0 = false, 1 =
+         * true)
+         *
+         * @deprecated Starting in {@link VERSION_CODES#JELLY_BEAN_MR1} the
+         *             lockscreen uses
+         *             {@link Settings.System#HAPTIC_FEEDBACK_ENABLED}.
+         */
+        @Deprecated
+        public static final String
+                LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED = "lock_pattern_tactile_feedback_enabled";
+
+        /**
+         * Whether lock pattern will show dots (0 = false, 1 = true)
+         * @hide
+         */
+        public static final String LOCK_DOTS_VISIBLE = "lock_pattern_dotsvisible";
+
+        /**
+         * Whether lockscreen error pattern is visible (0 = false, 1 = true)
+         * @hide
+         */
+        public static final String LOCK_SHOW_ERROR_PATH = "lock_pattern_show_error_path";
+
+        /**
+         * This preference allows the device to be locked given time after screen goes off,
+         * subject to current DeviceAdmin policy limits.
+         * @hide
+         */
+        public static final String LOCK_SCREEN_LOCK_AFTER_TIMEOUT = "lock_screen_lock_after_timeout";
+
+
+        /**
+         * This preference contains the string that shows for owner info on LockScreen.
+         * @hide
+         */
+        public static final String LOCK_SCREEN_OWNER_INFO = "lock_screen_owner_info";
+
+        /**
+         * Ids of the user-selected appwidgets on the lockscreen (comma-delimited).
+         * @hide
+         */
+        public static final String LOCK_SCREEN_APPWIDGET_IDS =
+            "lock_screen_appwidget_ids";
+
+        /**
+         * Id of the appwidget shown on the lock screen when appwidgets are disabled.
+         * @hide
+         */
+        public static final String LOCK_SCREEN_FALLBACK_APPWIDGET_ID =
+            "lock_screen_fallback_appwidget_id";
+
+        /**
+         * Index of the lockscreen appwidget to restore, -1 if none.
+         * @hide
+         */
+        public static final String LOCK_SCREEN_STICKY_APPWIDGET =
+            "lock_screen_sticky_appwidget";
+
+        /**
+         * This preference enables showing the owner info on LockScreen.
+         * @hide
+         */
+        public static final String LOCK_SCREEN_OWNER_INFO_ENABLED =
+            "lock_screen_owner_info_enabled";
+
+        /**
+         * Whether the unsecure widget screen will be shown before a secure
+         * lock screen
+         * @hide
+         */
+        public static final String LOCK_BEFORE_UNLOCK =
+            "lock_before_unlock";
+
+        /**
+         * Determines the width and height of the LockPatternView widget
+         * @hide
+         */
+        public static final String LOCK_PATTERN_SIZE =
+            "lock_pattern_size";
+
+        /**
+         * The Logging ID (a unique 64-bit value) as a hex string.
+         * Used as a pseudonymous identifier for logging.
+         * @deprecated This identifier is poorly initialized and has
+         * many collisions.  It should not be used.
+         */
+        @Deprecated
+        public static final String LOGGING_ID = "logging_id";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#NETWORK_PREFERENCE} instead
+         */
+        @Deprecated
+        public static final String NETWORK_PREFERENCE = Global.NETWORK_PREFERENCE;
+
+        /**
+         * No longer supported.
+         */
+        public static final String PARENTAL_CONTROL_ENABLED = "parental_control_enabled";
+
+        /**
+         * No longer supported.
+         */
+        public static final String PARENTAL_CONTROL_LAST_UPDATE = "parental_control_last_update";
+
+        /**
+         * No longer supported.
+         */
+        public static final String PARENTAL_CONTROL_REDIRECT_URL = "parental_control_redirect_url";
+
+        /**
+         * Settings classname to launch when Settings is clicked from All
+         * Applications.  Needed because of user testing between the old
+         * and new Settings apps.
+         */
+        // TODO: 881807
+        public static final String SETTINGS_CLASSNAME = "settings_classname";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#USB_MASS_STORAGE_ENABLED} instead
+         */
+        @Deprecated
+        public static final String USB_MASS_STORAGE_ENABLED = Global.USB_MASS_STORAGE_ENABLED;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#USE_GOOGLE_MAIL} instead
+         */
+        @Deprecated
+        public static final String USE_GOOGLE_MAIL = Global.USE_GOOGLE_MAIL;
+
+        /**
+         * If accessibility is enabled.
+         */
+        public static final String ACCESSIBILITY_ENABLED = "accessibility_enabled";
+
+        /**
+         * If touch exploration is enabled.
+         */
+        public static final String TOUCH_EXPLORATION_ENABLED = "touch_exploration_enabled";
+
+        /**
+         * List of the enabled accessibility providers.
+         */
+        public static final String ENABLED_ACCESSIBILITY_SERVICES =
+            "enabled_accessibility_services";
+
+        /**
+         * List of the accessibility services to which the user has granted
+         * permission to put the device into touch exploration mode.
+         *
+         * @hide
+         */
+        public static final String TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES =
+            "touch_exploration_granted_accessibility_services";
+
+        /**
+         * Whether to speak passwords while in accessibility mode.
+         */
+        public static final String ACCESSIBILITY_SPEAK_PASSWORD = "speak_password";
+
+        /**
+         * If injection of accessibility enhancing JavaScript screen-reader
+         * is enabled.
+         * <p>
+         *   Note: The JavaScript based screen-reader is served by the
+         *   Google infrastructure and enable users with disabilities to
+         *   efficiently navigate in and explore web content.
+         * </p>
+         * <p>
+         *   This property represents a boolean value.
+         * </p>
+         * @hide
+         */
+        public static final String ACCESSIBILITY_SCRIPT_INJECTION =
+            "accessibility_script_injection";
+
+        /**
+         * The URL for the injected JavaScript based screen-reader used
+         * for providing accessibility of content in WebView.
+         * <p>
+         *   Note: The JavaScript based screen-reader is served by the
+         *   Google infrastructure and enable users with disabilities to
+         *   efficiently navigate in and explore web content.
+         * </p>
+         * <p>
+         *   This property represents a string value.
+         * </p>
+         * @hide
+         */
+        public static final String ACCESSIBILITY_SCREEN_READER_URL =
+            "accessibility_script_injection_url";
+
+        /**
+         * Key bindings for navigation in built-in accessibility support for web content.
+         * <p>
+         *   Note: These key bindings are for the built-in accessibility navigation for
+         *   web content which is used as a fall back solution if JavaScript in a WebView
+         *   is not enabled or the user has not opted-in script injection from Google.
+         * </p>
+         * <p>
+         *   The bindings are separated by semi-colon. A binding is a mapping from
+         *   a key to a sequence of actions (for more details look at
+         *   android.webkit.AccessibilityInjector). A key is represented as the hexademical
+         *   string representation of an integer obtained from a meta state (optional) shifted
+         *   sixteen times left and bitwise ored with a key code. An action is represented
+         *   as a hexademical string representation of an integer where the first two digits
+         *   are navigation action index, the second, the third, and the fourth digit pairs
+         *   represent the action arguments. The separate actions in a binding are colon
+         *   separated. The key and the action sequence it maps to are separated by equals.
+         * </p>
+         * <p>
+         *   For example, the binding below maps the DPAD right button to traverse the
+         *   current navigation axis once without firing an accessibility event and to
+         *   perform the same traversal again but to fire an event:
+         *   <code>
+         *     0x16=0x01000100:0x01000101;
+         *   </code>
+         * </p>
+         * <p>
+         *   The goal of this binding is to enable dynamic rebinding of keys to
+         *   navigation actions for web content without requiring a framework change.
+         * </p>
+         * <p>
+         *   This property represents a string value.
+         * </p>
+         * @hide
+         */
+        public static final String ACCESSIBILITY_WEB_CONTENT_KEY_BINDINGS =
+            "accessibility_web_content_key_bindings";
+
+        /**
+         * Setting that specifies whether the display magnification is enabled.
+         * Display magnifications allows the user to zoom in the display content
+         * and is targeted to low vision users. The current magnification scale
+         * is controlled by {@link #ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE}.
+         *
+         * @hide
+         */
+        public static final String ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED =
+                "accessibility_display_magnification_enabled";
+
+        /**
+         * Setting that specifies what the display magnification scale is.
+         * Display magnifications allows the user to zoom in the display
+         * content and is targeted to low vision users. Whether a display
+         * magnification is performed is controlled by
+         * {@link #ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED}
+         *
+         * @hide
+         */
+        public static final String ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE =
+                "accessibility_display_magnification_scale";
+
+        /**
+         * Setting that specifies whether the display magnification should be
+         * automatically updated. If this fearture is enabled the system will
+         * exit magnification mode or pan the viewport when a context change
+         * occurs. For example, on staring a new activity or rotating the screen,
+         * the system may zoom out so the user can see the new context he is in.
+         * Another example is on showing a window that is not visible in the
+         * magnified viewport the system may pan the viewport to make the window
+         * the has popped up so the user knows that the context has changed.
+         * Whether a screen magnification is performed is controlled by
+         * {@link #ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED}
+         *
+         * @hide
+         */
+        public static final String ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE =
+                "accessibility_display_magnification_auto_update";
+
+        /**
+         * The timout for considering a press to be a long press in milliseconds.
+         * @hide
+         */
+        public static final String LONG_PRESS_TIMEOUT = "long_press_timeout";
+
+        /**
+         * Setting to always use the default text-to-speech settings regardless
+         * of the application settings.
+         * 1 = override application settings,
+         * 0 = use application settings (if specified).
+         *
+         * @deprecated  The value of this setting is no longer respected by
+         * the framework text to speech APIs as of the Ice Cream Sandwich release.
+         */
+        @Deprecated
+        public static final String TTS_USE_DEFAULTS = "tts_use_defaults";
+
+        /**
+         * Default text-to-speech engine speech rate. 100 = 1x
+         */
+        public static final String TTS_DEFAULT_RATE = "tts_default_rate";
+
+        /**
+         * Default text-to-speech engine pitch. 100 = 1x
+         */
+        public static final String TTS_DEFAULT_PITCH = "tts_default_pitch";
+
+        /**
+         * Default text-to-speech engine.
+         */
+        public static final String TTS_DEFAULT_SYNTH = "tts_default_synth";
+
+        /**
+         * Default text-to-speech language.
+         *
+         * @deprecated this setting is no longer in use, as of the Ice Cream
+         * Sandwich release. Apps should never need to read this setting directly,
+         * instead can query the TextToSpeech framework classes for the default
+         * locale. {@link TextToSpeech#getLanguage()}.
+         */
+        @Deprecated
+        public static final String TTS_DEFAULT_LANG = "tts_default_lang";
+
+        /**
+         * Default text-to-speech country.
+         *
+         * @deprecated this setting is no longer in use, as of the Ice Cream
+         * Sandwich release. Apps should never need to read this setting directly,
+         * instead can query the TextToSpeech framework classes for the default
+         * locale. {@link TextToSpeech#getLanguage()}.
+         */
+        @Deprecated
+        public static final String TTS_DEFAULT_COUNTRY = "tts_default_country";
+
+        /**
+         * Default text-to-speech locale variant.
+         *
+         * @deprecated this setting is no longer in use, as of the Ice Cream
+         * Sandwich release. Apps should never need to read this setting directly,
+         * instead can query the TextToSpeech framework classes for the
+         * locale that is in use {@link TextToSpeech#getLanguage()}.
+         */
+        @Deprecated
+        public static final String TTS_DEFAULT_VARIANT = "tts_default_variant";
+
+        /**
+         * Stores the default tts locales on a per engine basis. Stored as
+         * a comma seperated list of values, each value being of the form
+         * {@code engine_name:locale} for example,
+         * {@code com.foo.ttsengine:eng-USA,com.bar.ttsengine:esp-ESP}. This
+         * supersedes {@link #TTS_DEFAULT_LANG}, {@link #TTS_DEFAULT_COUNTRY} and
+         * {@link #TTS_DEFAULT_VARIANT}. Apps should never need to read this
+         * setting directly, and can query the TextToSpeech framework classes
+         * for the locale that is in use.
+         *
+         * @hide
+         */
+        public static final String TTS_DEFAULT_LOCALE = "tts_default_locale";
+
+        /**
+         * Space delimited list of plugin packages that are enabled.
+         */
+        public static final String TTS_ENABLED_PLUGINS = "tts_enabled_plugins";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON}
+         * instead.
+         */
+        @Deprecated
+        public static final String WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON =
+                Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY}
+         * instead.
+         */
+        @Deprecated
+        public static final String WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY =
+                Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_NUM_OPEN_NETWORKS_KEPT}
+         * instead.
+         */
+        @Deprecated
+        public static final String WIFI_NUM_OPEN_NETWORKS_KEPT =
+                Global.WIFI_NUM_OPEN_NETWORKS_KEPT;
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_ON}
+         * instead.
+         */
+        @Deprecated
+        public static final String WIFI_ON = Global.WIFI_ON;
+
+        /**
+         * The acceptable packet loss percentage (range 0 - 100) before trying
+         * another AP on the same network.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE =
+                "wifi_watchdog_acceptable_packet_loss_percentage";
+
+        /**
+         * The number of access points required for a network in order for the
+         * watchdog to monitor it.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_AP_COUNT = "wifi_watchdog_ap_count";
+
+        /**
+         * The delay between background checks.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS =
+                "wifi_watchdog_background_check_delay_ms";
+
+        /**
+         * Whether the Wi-Fi watchdog is enabled for background checking even
+         * after it thinks the user has connected to a good access point.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED =
+                "wifi_watchdog_background_check_enabled";
+
+        /**
+         * The timeout for a background ping
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS =
+                "wifi_watchdog_background_check_timeout_ms";
+
+        /**
+         * The number of initial pings to perform that *may* be ignored if they
+         * fail. Again, if these fail, they will *not* be used in packet loss
+         * calculation. For example, one network always seemed to time out for
+         * the first couple pings, so this is set to 3 by default.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT =
+            "wifi_watchdog_initial_ignored_ping_count";
+
+        /**
+         * The maximum number of access points (per network) to attempt to test.
+         * If this number is reached, the watchdog will no longer monitor the
+         * initial connection state for the network. This is a safeguard for
+         * networks containing multiple APs whose DNS does not respond to pings.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_MAX_AP_CHECKS = "wifi_watchdog_max_ap_checks";
+
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_WATCHDOG_ON} instead
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_ON = "wifi_watchdog_on";
+
+        /**
+         * A comma-separated list of SSIDs for which the Wi-Fi watchdog should be enabled.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_WATCH_LIST = "wifi_watchdog_watch_list";
+
+        /**
+         * The number of pings to test if an access point is a good connection.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_PING_COUNT = "wifi_watchdog_ping_count";
+
+        /**
+         * The delay between pings.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_PING_DELAY_MS = "wifi_watchdog_ping_delay_ms";
+
+        /**
+         * The timeout per ping.
+         * @deprecated This setting is not used.
+         */
+        @Deprecated
+        public static final String WIFI_WATCHDOG_PING_TIMEOUT_MS = "wifi_watchdog_ping_timeout_ms";
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Global#WIFI_MAX_DHCP_RETRY_COUNT} instead
+         */
+        @Deprecated
+        public static final String WIFI_MAX_DHCP_RETRY_COUNT = Global.WIFI_MAX_DHCP_RETRY_COUNT;
+
+        /**
+         * @deprecated Use
+         * {@link android.provider.Settings.Global#WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS} instead
+         */
+        @Deprecated
+        public static final String WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS =
+                Global.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS;
+
+        /**
+         * Whether the Wimax should be on.  Only the WiMAX service should touch this.
+         * @hide
+         */
+        public static final String WIMAX_ON = "wimax_on";
+
+        /**
+         * Whether background data usage is allowed.
+         *
+         * @deprecated As of {@link VERSION_CODES#ICE_CREAM_SANDWICH},
+         *             availability of background data depends on several
+         *             combined factors. When background data is unavailable,
+         *             {@link ConnectivityManager#getActiveNetworkInfo()} will
+         *             now appear disconnected.
+         */
+        @Deprecated
+        public static final String BACKGROUND_DATA = "background_data";
+
+        /**
+         * Origins for which browsers should allow geolocation by default.
+         * The value is a space-separated list of origins.
+         */
+        public static final String ALLOWED_GEOLOCATION_ORIGINS
+                = "allowed_geolocation_origins";
+
+        /**
+         * The preferred TTY mode     0 = TTy Off, CDMA default
+         *                            1 = TTY Full
+         *                            2 = TTY HCO
+         *                            3 = TTY VCO
+         * @hide
+         */
+        public static final String PREFERRED_TTY_MODE =
+                "preferred_tty_mode";
+
+        /**
+         * Whether the enhanced voice privacy mode is enabled.
+         * 0 = normal voice privacy
+         * 1 = enhanced voice privacy
+         * @hide
+         */
+        public static final String ENHANCED_VOICE_PRIVACY_ENABLED = "enhanced_voice_privacy_enabled";
+
+        /**
+         * Whether the TTY mode mode is enabled.
+         * 0 = disabled
+         * 1 = enabled
+         * @hide
+         */
+        public static final String TTY_MODE_ENABLED = "tty_mode_enabled";
+
+        /**
+         * Controls whether settings backup is enabled.
+         * Type: int ( 0 = disabled, 1 = enabled )
+         * @hide
+         */
+        public static final String BACKUP_ENABLED = "backup_enabled";
+
+        /**
+         * Controls whether application data is automatically restored from backup
+         * at install time.
+         * Type: int ( 0 = disabled, 1 = enabled )
+         * @hide
+         */
+        public static final String BACKUP_AUTO_RESTORE = "backup_auto_restore";
+
+        /**
+         * Indicates whether settings backup has been fully provisioned.
+         * Type: int ( 0 = unprovisioned, 1 = fully provisioned )
+         * @hide
+         */
+        public static final String BACKUP_PROVISIONED = "backup_provisioned";
+
+        /**
+         * Component of the transport to use for backup/restore.
+         * @hide
+         */
+        public static final String BACKUP_TRANSPORT = "backup_transport";
+
+        /**
+         * Version for which the setup wizard was last shown.  Bumped for
+         * each release when there is new setup information to show.
+         * @hide
+         */
+        public static final String LAST_SETUP_SHOWN = "last_setup_shown";
+
+        /**
+         * The interval in milliseconds after which Wi-Fi is considered idle.
+         * When idle, it is possible for the device to be switched from Wi-Fi to
+         * the mobile data network.
+         * @hide
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_IDLE_MS}
+         * instead.
+         */
+        @Deprecated
+        public static final String WIFI_IDLE_MS = Global.WIFI_IDLE_MS;
+
+        /**
+         * The global search provider chosen by the user (if multiple global
+         * search providers are installed). This will be the provider returned
+         * by {@link SearchManager#getGlobalSearchActivity()} if it's still
+         * installed. This setting is stored as a flattened component name as
+         * per {@link ComponentName#flattenToString()}.
+         *
+         * @hide
+         */
+        public static final String SEARCH_GLOBAL_SEARCH_ACTIVITY =
+                "search_global_search_activity";
+
+        /**
+         * The number of promoted sources in GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_NUM_PROMOTED_SOURCES = "search_num_promoted_sources";
+        /**
+         * The maximum number of suggestions returned by GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_MAX_RESULTS_TO_DISPLAY = "search_max_results_to_display";
+        /**
+         * The number of suggestions GlobalSearch will ask each non-web search source for.
+         * @hide
+         */
+        public static final String SEARCH_MAX_RESULTS_PER_SOURCE = "search_max_results_per_source";
+        /**
+         * The number of suggestions the GlobalSearch will ask the web search source for.
+         * @hide
+         */
+        public static final String SEARCH_WEB_RESULTS_OVERRIDE_LIMIT =
+                "search_web_results_override_limit";
+        /**
+         * The number of milliseconds that GlobalSearch will wait for suggestions from
+         * promoted sources before continuing with all other sources.
+         * @hide
+         */
+        public static final String SEARCH_PROMOTED_SOURCE_DEADLINE_MILLIS =
+                "search_promoted_source_deadline_millis";
+        /**
+         * The number of milliseconds before GlobalSearch aborts search suggesiton queries.
+         * @hide
+         */
+        public static final String SEARCH_SOURCE_TIMEOUT_MILLIS = "search_source_timeout_millis";
+        /**
+         * The maximum number of milliseconds that GlobalSearch shows the previous results
+         * after receiving a new query.
+         * @hide
+         */
+        public static final String SEARCH_PREFILL_MILLIS = "search_prefill_millis";
+        /**
+         * The maximum age of log data used for shortcuts in GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_MAX_STAT_AGE_MILLIS = "search_max_stat_age_millis";
+        /**
+         * The maximum age of log data used for source ranking in GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_MAX_SOURCE_EVENT_AGE_MILLIS =
+                "search_max_source_event_age_millis";
+        /**
+         * The minimum number of impressions needed to rank a source in GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_MIN_IMPRESSIONS_FOR_SOURCE_RANKING =
+                "search_min_impressions_for_source_ranking";
+        /**
+         * The minimum number of clicks needed to rank a source in GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_MIN_CLICKS_FOR_SOURCE_RANKING =
+                "search_min_clicks_for_source_ranking";
+        /**
+         * The maximum number of shortcuts shown by GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_MAX_SHORTCUTS_RETURNED = "search_max_shortcuts_returned";
+        /**
+         * The size of the core thread pool for suggestion queries in GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_QUERY_THREAD_CORE_POOL_SIZE =
+                "search_query_thread_core_pool_size";
+        /**
+         * The maximum size of the thread pool for suggestion queries in GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_QUERY_THREAD_MAX_POOL_SIZE =
+                "search_query_thread_max_pool_size";
+        /**
+         * The size of the core thread pool for shortcut refreshing in GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_SHORTCUT_REFRESH_CORE_POOL_SIZE =
+                "search_shortcut_refresh_core_pool_size";
+        /**
+         * The maximum size of the thread pool for shortcut refreshing in GlobalSearch.
+         * @hide
+         */
+        public static final String SEARCH_SHORTCUT_REFRESH_MAX_POOL_SIZE =
+                "search_shortcut_refresh_max_pool_size";
+        /**
+         * The maximun time that excess threads in the GlobalSeach thread pools will
+         * wait before terminating.
+         * @hide
+         */
+        public static final String SEARCH_THREAD_KEEPALIVE_SECONDS =
+                "search_thread_keepalive_seconds";
+        /**
+         * The maximum number of concurrent suggestion queries to each source.
+         * @hide
+         */
+        public static final String SEARCH_PER_SOURCE_CONCURRENT_QUERY_LIMIT =
+                "search_per_source_concurrent_query_limit";
+
+        /**
+         * Whether or not alert sounds are played on MountService events. (0 = false, 1 = true)
+         * @hide
+         */
+        public static final String MOUNT_PLAY_NOTIFICATION_SND = "mount_play_not_snd";
+
+        /**
+         * Whether or not UMS auto-starts on UMS host detection. (0 = false, 1 = true)
+         * @hide
+         */
+        public static final String MOUNT_UMS_AUTOSTART = "mount_ums_autostart";
+
+        /**
+         * Whether or not a notification is displayed on UMS host detection. (0 = false, 1 = true)
+         * @hide
+         */
+        public static final String MOUNT_UMS_PROMPT = "mount_ums_prompt";
+
+        /**
+         * Whether or not a notification is displayed while UMS is enabled. (0 = false, 1 = true)
+         * @hide
+         */
+        public static final String MOUNT_UMS_NOTIFY_ENABLED = "mount_ums_notify_enabled";
+
+        /**
+         * If nonzero, ANRs in invisible background processes bring up a dialog.
+         * Otherwise, the process will be silently killed.
+         * @hide
+         */
+        public static final String ANR_SHOW_BACKGROUND = "anr_show_background";
+
+        /**
+         * The {@link ComponentName} string of the service to be used as the voice recognition
+         * service.
+         *
+         * @hide
+         */
+        public static final String VOICE_RECOGNITION_SERVICE = "voice_recognition_service";
+
+
+        /**
+         * The {@link ComponentName} string of the selected spell checker service which is
+         * one of the services managed by the text service manager.
+         *
+         * @hide
+         */
+        public static final String SELECTED_SPELL_CHECKER = "selected_spell_checker";
+
+        /**
+         * The {@link ComponentName} string of the selected subtype of the selected spell checker
+         * service which is one of the services managed by the text service manager.
+         *
+         * @hide
+         */
+        public static final String SELECTED_SPELL_CHECKER_SUBTYPE =
+                "selected_spell_checker_subtype";
+
+        /**
+         * The {@link ComponentName} string whether spell checker is enabled or not.
+         *
+         * @hide
+         */
+        public static final String SPELL_CHECKER_ENABLED = "spell_checker_enabled";
+
+        /**
+         * What happens when the user presses the Power button while in-call
+         * and the screen is on.<br/>
+         * <b>Values:</b><br/>
+         * 1 - The Power button turns off the screen and locks the device. (Default behavior)<br/>
+         * 2 - The Power button hangs up the current call.<br/>
+         *
+         * @hide
+         */
+        public static final String INCALL_POWER_BUTTON_BEHAVIOR = "incall_power_button_behavior";
+
+        /**
+         * INCALL_POWER_BUTTON_BEHAVIOR value for "turn off screen".
+         * @hide
+         */
+        public static final int INCALL_POWER_BUTTON_BEHAVIOR_SCREEN_OFF = 0x1;
+
+        /**
+         * INCALL_POWER_BUTTON_BEHAVIOR value for "hang up".
+         * @hide
+         */
+        public static final int INCALL_POWER_BUTTON_BEHAVIOR_HANGUP = 0x2;
+
+        /**
+         * INCALL_POWER_BUTTON_BEHAVIOR default value.
+         * @hide
+         */
+        public static final int INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT =
+                INCALL_POWER_BUTTON_BEHAVIOR_SCREEN_OFF;
+
+        /**
+         * What happens when the user presses the Home button when the
+         * phone is ringing.<br/>
+         * <b>Values:</b><br/>
+         * 1 - Nothing happens. (Default behavior)<br/>
+         * 2 - The Home button answer the current call.<br/>
+         *
+         * @hide
+         */
+        public static final String RING_HOME_BUTTON_BEHAVIOR = "ring_home_button_behavior";
+
+        /**
+         * RING_HOME_BUTTON_BEHAVIOR value for "do nothing".
+         * @hide
+         */
+        public static final int RING_HOME_BUTTON_BEHAVIOR_DO_NOTHING = 0x1;
+
+        /**
+         * RING_HOME_BUTTON_BEHAVIOR value for "answer".
+         * @hide
+         */
+        public static final int RING_HOME_BUTTON_BEHAVIOR_ANSWER = 0x2;
+
+        /**
+         * RING_HOME_BUTTON_BEHAVIOR default value.
+         * @hide
+         */
+        public static final int RING_HOME_BUTTON_BEHAVIOR_DEFAULT =
+                RING_HOME_BUTTON_BEHAVIOR_DO_NOTHING;
+
+        /**
+         * The current night mode that has been selected by the user.  Owned
+         * and controlled by UiModeManagerService.  Constants are as per
+         * UiModeManager.
+         * @hide
+         */
+        public static final String UI_NIGHT_MODE = "ui_night_mode";
+
+        /**
+         * Whether screensavers are enabled.
+         * @hide
+         */
+        public static final String SCREENSAVER_ENABLED = "screensaver_enabled";
+
+        /**
+         * The user's chosen screensaver components.
+         *
+         * These will be launched by the PhoneWindowManager after a timeout when not on
+         * battery, or upon dock insertion (if SCREENSAVER_ACTIVATE_ON_DOCK is set to 1).
+         * @hide
+         */
+        public static final String SCREENSAVER_COMPONENTS = "screensaver_components";
+
+        /**
+         * If screensavers are enabled, whether the screensaver should be automatically launched
+         * when the device is inserted into a (desk) dock.
+         * @hide
+         */
+        public static final String SCREENSAVER_ACTIVATE_ON_DOCK = "screensaver_activate_on_dock";
+
+        /**
+         * If screensavers are enabled, whether the screensaver should be automatically launched
+         * when the screen times out when not on battery.
+         * @hide
+         */
+        public static final String SCREENSAVER_ACTIVATE_ON_SLEEP = "screensaver_activate_on_sleep";
+
+        /**
+         * If screensavers are enabled, the default screensaver component.
+         * @hide
+         */
+        public static final String SCREENSAVER_DEFAULT_COMPONENT = "screensaver_default_component";
+
+        /**
+         * Whether to allow killing of the foreground app by long-pressing the Back button
+         * @hide
+         */
+        public static final String KILL_APP_LONGPRESS_BACK = "kill_app_longpress_back";
+
+        /**
+         * Whether to include options in power menu for rebooting into recovery or bootloader
+         * @hide
+         */
+        public static final String ADVANCED_REBOOT = "advanced_reboot";
+
+        /**
+         * Whether newly installed apps should run with privacy guard by default
+         * @hide
+         */
+        public static final String PRIVACY_GUARD_DEFAULT = "privacy_guard_default";
+
+        /**
+         * This are the settings to be backed up.
+         *
+         * NOTE: Settings are backed up and restored in the order they appear
+         *       in this array. If you have one setting depending on another,
+         *       make sure that they are ordered appropriately.
+         *
+         * @hide
+         */
+        public static final String[] SETTINGS_TO_BACKUP = {
+            BUGREPORT_IN_POWER_MENU,
+            ALLOW_MOCK_LOCATION,
+            PARENTAL_CONTROL_ENABLED,
+            PARENTAL_CONTROL_REDIRECT_URL,
+            USB_MASS_STORAGE_ENABLED,                           // moved to global
+            ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
+            ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
+            ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE,
+            ACCESSIBILITY_SCRIPT_INJECTION,
+            BACKUP_AUTO_RESTORE,
+            ENABLED_ACCESSIBILITY_SERVICES,
+            TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
+            TOUCH_EXPLORATION_ENABLED,
+            ACCESSIBILITY_ENABLED,
+            ACCESSIBILITY_SPEAK_PASSWORD,
+            TTS_USE_DEFAULTS,
+            TTS_DEFAULT_RATE,
+            TTS_DEFAULT_PITCH,
+            TTS_DEFAULT_SYNTH,
+            TTS_DEFAULT_LANG,
+            TTS_DEFAULT_COUNTRY,
+            TTS_ENABLED_PLUGINS,
+            TTS_DEFAULT_LOCALE,
+            WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,            // moved to global
+            WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,               // moved to global
+            WIFI_NUM_OPEN_NETWORKS_KEPT,                        // moved to global
+            MOUNT_PLAY_NOTIFICATION_SND,
+            MOUNT_UMS_AUTOSTART,
+            MOUNT_UMS_PROMPT,
+            MOUNT_UMS_NOTIFY_ENABLED,
+            UI_NIGHT_MODE,
+            LOCK_SCREEN_OWNER_INFO,
+            LOCK_SCREEN_OWNER_INFO_ENABLED,
+            ADVANCED_REBOOT,
+            PRIVACY_GUARD_DEFAULT
+        };
+
+        /**
+         * Helper method for determining if a location provider is enabled.
+         * @param cr the content resolver to use
+         * @param provider the location provider to query
+         * @return true if the provider is enabled
+         */
+        public static final boolean isLocationProviderEnabled(ContentResolver cr, String provider) {
+            return isLocationProviderEnabledForUser(cr, provider, UserHandle.myUserId());
+        }
+
+        /**
+         * Helper method for determining if a location provider is enabled.
+         * @param cr the content resolver to use
+         * @param provider the location provider to query
+         * @param userId the userId to query
+         * @return true if the provider is enabled
+         * @hide
+         */
+        public static final boolean isLocationProviderEnabledForUser(ContentResolver cr, String provider, int userId) {
+            try {
+                if (ActivityManagerNative.getDefault().isPrivacyGuardEnabledForProcess(Binder.getCallingPid())) {
+                    return false;
+                }
+            } catch (RemoteException e) {
+                // ignore
+            }
+            String allowedProviders = Settings.Secure.getStringForUser(cr,
+                    LOCATION_PROVIDERS_ALLOWED, userId);
+            return TextUtils.delimitedStringContains(allowedProviders, ',', provider);
+        }
+
+        /**
+         * Thread-safe method for enabling or disabling a single location provider.
+         * @param cr the content resolver to use
+         * @param provider the location provider to enable or disable
+         * @param enabled true if the provider should be enabled
+         */
+        public static final void setLocationProviderEnabled(ContentResolver cr,
+                String provider, boolean enabled) {
+            setLocationProviderEnabledForUser(cr, provider, enabled, UserHandle.myUserId());
+        }
+
+        /**
+         * Thread-safe method for enabling or disabling a single location provider.
+         * @param cr the content resolver to use
+         * @param provider the location provider to enable or disable
+         * @param enabled true if the provider should be enabled
+         * @param userId the userId for which to enable/disable providers
+         * @hide
+         */
+        public static final void setLocationProviderEnabledForUser(ContentResolver cr,
+                String provider, boolean enabled, int userId) {
+            // to ensure thread safety, we write the provider name with a '+' or '-'
+            // and let the SettingsProvider handle it rather than reading and modifying
+            // the list of enabled providers.
+            if (enabled) {
+                provider = "+" + provider;
+            } else {
+                provider = "-" + provider;
+            }
+            putStringForUser(cr, Settings.Secure.LOCATION_PROVIDERS_ALLOWED, provider,
+                    userId);
+        }
+    }
+
+    /**
+     * Global system settings, containing preferences that always apply identically
+     * to all defined users.  Applications can read these but are not allowed to write;
+     * like the "Secure" settings, these are for preferences that the user must
+     * explicitly modify through the system UI or specialized APIs for those values.
+     */
+    public static final class Global extends NameValueTable {
+        public static final String SYS_PROP_SETTING_VERSION = "sys.settings_global_version";
+
+        /**
+         * The content:// style URL for global secure settings items.  Not public.
+         */
+        public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/global");
+
+        /**
+         * Setting whether the global gesture for enabling accessibility is enabled.
+         * If this gesture is enabled the user will be able to perfrom it to enable
+         * the accessibility state without visiting the settings app.
+         * @hide
+         */
+        public static final String ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED =
+                "enable_accessibility_global_gesture_enabled";
+
+        /**
+         * Whether Airplane Mode is on.
+         */
+        public static final String AIRPLANE_MODE_ON = "airplane_mode_on";
+
+        /**
+         * Constant for use in AIRPLANE_MODE_RADIOS to specify Bluetooth radio.
+         */
+        public static final String RADIO_BLUETOOTH = "bluetooth";
+
+        /**
+         * Constant for use in AIRPLANE_MODE_RADIOS to specify Wi-Fi radio.
+         */
+        public static final String RADIO_WIFI = "wifi";
+
+        /**
+         * {@hide}
+         */
+        public static final String RADIO_WIMAX = "wimax";
+        /**
+         * Constant for use in AIRPLANE_MODE_RADIOS to specify Cellular radio.
+         */
+        public static final String RADIO_CELL = "cell";
+
+        /**
+         * Constant for use in AIRPLANE_MODE_RADIOS to specify NFC radio.
+         */
+        public static final String RADIO_NFC = "nfc";
+
+        /**
+         * A comma separated list of radios that need to be disabled when airplane mode
+         * is on. This overrides WIFI_ON and BLUETOOTH_ON, if Wi-Fi and bluetooth are
+         * included in the comma separated list.
+         */
+        public static final String AIRPLANE_MODE_RADIOS = "airplane_mode_radios";
+
+        /**
+         * A comma separated list of radios that should to be disabled when airplane mode
+         * is on, but can be manually reenabled by the user.  For example, if RADIO_WIFI is
+         * added to both AIRPLANE_MODE_RADIOS and AIRPLANE_MODE_TOGGLEABLE_RADIOS, then Wifi
+         * will be turned off when entering airplane mode, but the user will be able to reenable
+         * Wifi in the Settings app.
+         *
+         * {@hide}
+         */
+        public static final String AIRPLANE_MODE_TOGGLEABLE_RADIOS = "airplane_mode_toggleable_radios";
+
+        /**
+         * The policy for deciding when Wi-Fi should go to sleep (which will in
+         * turn switch to using the mobile data as an Internet connection).
+         * <p>
+         * Set to one of {@link #WIFI_SLEEP_POLICY_DEFAULT},
+         * {@link #WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED}, or
+         * {@link #WIFI_SLEEP_POLICY_NEVER}.
+         */
+        public static final String WIFI_SLEEP_POLICY = "wifi_sleep_policy";
+
+        /**
+         * Value for {@link #WIFI_SLEEP_POLICY} to use the default Wi-Fi sleep
+         * policy, which is to sleep shortly after the turning off
+         * according to the {@link #STAY_ON_WHILE_PLUGGED_IN} setting.
+         */
+        public static final int WIFI_SLEEP_POLICY_DEFAULT = 0;
+
+        /**
+         * Value for {@link #WIFI_SLEEP_POLICY} to use the default policy when
+         * the device is on battery, and never go to sleep when the device is
+         * plugged in.
+         */
+        public static final int WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED = 1;
+
+        /**
+         * Value for {@link #WIFI_SLEEP_POLICY} to never go to sleep.
+         */
+        public static final int WIFI_SLEEP_POLICY_NEVER = 2;
+
+        /**
+         * Value to specify if the user prefers the date, time and time zone
+         * to be automatically fetched from the network (NITZ). 1=yes, 0=no
+         */
+        public static final String AUTO_TIME = "auto_time";
+
+        /**
+         * Value to specify if the user prefers the time zone
+         * to be automatically fetched from the network (NITZ). 1=yes, 0=no
+         */
+        public static final String AUTO_TIME_ZONE = "auto_time_zone";
+
+        /**
+         * URI for the car dock "in" event sound.
+         * @hide
+         */
+        public static final String CAR_DOCK_SOUND = "car_dock_sound";
+
+        /**
+         * URI for the car dock "out" event sound.
+         * @hide
+         */
+        public static final String CAR_UNDOCK_SOUND = "car_undock_sound";
+
+        /**
+         * URI for the desk dock "in" event sound.
+         * @hide
+         */
+        public static final String DESK_DOCK_SOUND = "desk_dock_sound";
+
+        /**
+         * URI for the desk dock "out" event sound.
+         * @hide
+         */
+        public static final String DESK_UNDOCK_SOUND = "desk_undock_sound";
+
+        /**
+         * Whether to play a sound for dock events.
+         * @hide
+         */
+        public static final String DOCK_SOUNDS_ENABLED = "dock_sounds_enabled";
+
+        /**
+         * URI for the "device locked" (keyguard shown) sound.
+         * @hide
+         */
+        public static final String LOCK_SOUND = "lock_sound";
+
+        /**
+         * URI for the "device unlocked" sound.
+         * @hide
+         */
+        public static final String UNLOCK_SOUND = "unlock_sound";
+
+        /**
+         * URI for the low battery sound file.
+         * @hide
+         */
+        public static final String LOW_BATTERY_SOUND = "low_battery_sound";
+
+        /**
+         * Whether to play a sound for low-battery alerts.
+         * @hide
+         */
+        public static final String POWER_SOUNDS_ENABLED = "power_sounds_enabled";
+
+        /**
+         * Whether to sound when charger power is connected/disconnected
+         * @hide
+         */
+        public static final String POWER_NOTIFICATIONS_ENABLED = "power_notifications_enabled";
+
+        /**
+         * Whether to vibrate when charger power is connected/disconnected
+         * @hide
+         */
+        public static final String POWER_NOTIFICATIONS_VIBRATE = "power_notifications_vibrate";
+
+        /**
+         * URI for power notification sounds
+         * @hide
+         */
+        public static final String POWER_NOTIFICATIONS_RINGTONE = "power_notifications_ringtone";
+
+        /**
+         * URI for the "wireless charging started" sound.
+         * @hide
+         */
+        public static final String WIRELESS_CHARGING_STARTED_SOUND =
+                "wireless_charging_started_sound";
+
+        /**
+         * Whether we keep the device on while the device is plugged in.
+         * Supported values are:
+         * <ul>
+         * <li>{@code 0} to never stay on while plugged in</li>
+         * <li>{@link BatteryManager#BATTERY_PLUGGED_AC} to stay on for AC charger</li>
+         * <li>{@link BatteryManager#BATTERY_PLUGGED_USB} to stay on for USB charger</li>
+         * <li>{@link BatteryManager#BATTERY_PLUGGED_WIRELESS} to stay on for wireless charger</li>
+         * </ul>
+         * These values can be OR-ed together.
+         */
+        public static final String STAY_ON_WHILE_PLUGGED_IN = "stay_on_while_plugged_in";
+
+        /**
+         * Whether ADB is enabled.
+         */
+        public static final String ADB_ENABLED = "adb_enabled";
+
+        /**
+         * Whether assisted GPS should be enabled or not.
+         * @hide
+         */
+        public static final String ASSISTED_GPS_ENABLED = "assisted_gps_enabled";
+
+        /**
+         * Whether bluetooth is enabled/disabled
+         * 0=disabled. 1=enabled.
+         */
+        public static final String BLUETOOTH_ON = "bluetooth_on";
+
+        /**
+         * CDMA Cell Broadcast SMS
+         *                            0 = CDMA Cell Broadcast SMS disabled
+         *                            1 = CDMA Cell Broadcast SMS enabled
+         * @hide
+         */
+        public static final String CDMA_CELL_BROADCAST_SMS =
+                "cdma_cell_broadcast_sms";
+
+        /**
+         * The CDMA roaming mode 0 = Home Networks, CDMA default
+         *                       1 = Roaming on Affiliated networks
+         *                       2 = Roaming on any networks
+         * @hide
+         */
+        public static final String CDMA_ROAMING_MODE = "roaming_settings";
+
+        /**
+         * The CDMA subscription mode 0 = RUIM/SIM (default)
+         *                                1 = NV
+         * @hide
+         */
+        public static final String CDMA_SUBSCRIPTION_MODE = "subscription_mode";
+
+        /** Inactivity timeout to track mobile data activity.
+        *
+        * If set to a positive integer, it indicates the inactivity timeout value in seconds to
+        * infer the data activity of mobile network. After a period of no activity on mobile
+        * networks with length specified by the timeout, an {@code ACTION_DATA_ACTIVITY_CHANGE}
+        * intent is fired to indicate a transition of network status from "active" to "idle". Any
+        * subsequent activity on mobile networks triggers the firing of {@code
+        * ACTION_DATA_ACTIVITY_CHANGE} intent indicating transition from "idle" to "active".
+        *
+        * Network activity refers to transmitting or receiving data on the network interfaces.
+        *
+        * Tracking is disabled if set to zero or negative value.
+        *
+        * @hide
+        */
+       public static final String DATA_ACTIVITY_TIMEOUT_MOBILE = "data_activity_timeout_mobile";
+
+       /** Timeout to tracking Wifi data activity. Same as {@code DATA_ACTIVITY_TIMEOUT_MOBILE}
+        * but for Wifi network.
+        * @hide
+        */
+       public static final String DATA_ACTIVITY_TIMEOUT_WIFI = "data_activity_timeout_wifi";
+
+       /**
+        * Whether or not data roaming is enabled. (0 = false, 1 = true)
+        */
+       public static final String DATA_ROAMING = "data_roaming";
+
+       /**
+        * Whether user has enabled development settings.
+        */
+       public static final String DEVELOPMENT_SETTINGS_ENABLED = "development_settings_enabled";
+
+       /**
+        * Whether the device has been provisioned (0 = false, 1 = true)
+        */
+       public static final String DEVICE_PROVISIONED = "device_provisioned";
+
+       /**
+        * The saved value for WindowManagerService.setForcedDisplayDensity().
+        * One integer in dpi.  If unset, then use the real display density.
+        * @hide
+        */
+       public static final String DISPLAY_DENSITY_FORCED = "display_density_forced";
+
+       /**
+        * The saved value for WindowManagerService.setForcedDisplaySize().
+        * Two integers separated by a comma.  If unset, then use the real display size.
+        * @hide
+        */
+       public static final String DISPLAY_SIZE_FORCED = "display_size_forced";
+
+       /**
+        * The maximum size, in bytes, of a download that the download manager will transfer over
+        * a non-wifi connection.
+        * @hide
+        */
+       public static final String DOWNLOAD_MAX_BYTES_OVER_MOBILE =
+               "download_manager_max_bytes_over_mobile";
+
+       /**
+        * The recommended maximum size, in bytes, of a download that the download manager should
+        * transfer over a non-wifi connection. Over this size, the use will be warned, but will
+        * have the option to start the download over the mobile connection anyway.
+        * @hide
+        */
+       public static final String DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE =
+               "download_manager_recommended_max_bytes_over_mobile";
+
+       /**
+        * Whether the package installer should allow installation of apps downloaded from
+        * sources other than Google Play.
+        *
+        * 1 = allow installing from other sources
+        * 0 = only allow installing from Google Play
+        */
+       public static final String INSTALL_NON_MARKET_APPS = "install_non_market_apps";
+
+       /**
+        * Whether mobile data connections are allowed by the user.  See
+        * ConnectivityManager for more info.
+        * @hide
+        */
+       public static final String MOBILE_DATA = "mobile_data";
+
+       /** {@hide} */
+       public static final String NETSTATS_ENABLED = "netstats_enabled";
+       /** {@hide} */
+       public static final String NETSTATS_POLL_INTERVAL = "netstats_poll_interval";
+       /** {@hide} */
+       public static final String NETSTATS_TIME_CACHE_MAX_AGE = "netstats_time_cache_max_age";
+       /** {@hide} */
+       public static final String NETSTATS_GLOBAL_ALERT_BYTES = "netstats_global_alert_bytes";
+       /** {@hide} */
+       public static final String NETSTATS_SAMPLE_ENABLED = "netstats_sample_enabled";
+       /** {@hide} */
+       public static final String NETSTATS_REPORT_XT_OVER_DEV = "netstats_report_xt_over_dev";
+
+       /** {@hide} */
+       public static final String NETSTATS_DEV_BUCKET_DURATION = "netstats_dev_bucket_duration";
+       /** {@hide} */
+       public static final String NETSTATS_DEV_PERSIST_BYTES = "netstats_dev_persist_bytes";
+       /** {@hide} */
+       public static final String NETSTATS_DEV_ROTATE_AGE = "netstats_dev_rotate_age";
+       /** {@hide} */
+       public static final String NETSTATS_DEV_DELETE_AGE = "netstats_dev_delete_age";
+
+       /** {@hide} */
+       public static final String NETSTATS_UID_BUCKET_DURATION = "netstats_uid_bucket_duration";
+       /** {@hide} */
+       public static final String NETSTATS_UID_PERSIST_BYTES = "netstats_uid_persist_bytes";
+       /** {@hide} */
+       public static final String NETSTATS_UID_ROTATE_AGE = "netstats_uid_rotate_age";
+       /** {@hide} */
+       public static final String NETSTATS_UID_DELETE_AGE = "netstats_uid_delete_age";
+
+       /** {@hide} */
+       public static final String NETSTATS_UID_TAG_BUCKET_DURATION = "netstats_uid_tag_bucket_duration";
+       /** {@hide} */
+       public static final String NETSTATS_UID_TAG_PERSIST_BYTES = "netstats_uid_tag_persist_bytes";
+       /** {@hide} */
+       public static final String NETSTATS_UID_TAG_ROTATE_AGE = "netstats_uid_tag_rotate_age";
+       /** {@hide} */
+       public static final String NETSTATS_UID_TAG_DELETE_AGE = "netstats_uid_tag_delete_age";
+
+       /**
+        * User preference for which network(s) should be used. Only the
+        * connectivity service should touch this.
+        */
+       public static final String NETWORK_PREFERENCE = "network_preference";
+
+       /**
+        * If the NITZ_UPDATE_DIFF time is exceeded then an automatic adjustment
+        * to SystemClock will be allowed even if NITZ_UPDATE_SPACING has not been
+        * exceeded.
+        * @hide
+        */
+       public static final String NITZ_UPDATE_DIFF = "nitz_update_diff";
+
+       /**
+        * The length of time in milli-seconds that automatic small adjustments to
+        * SystemClock are ignored if NITZ_UPDATE_DIFF is not exceeded.
+        * @hide
+        */
+       public static final String NITZ_UPDATE_SPACING = "nitz_update_spacing";
+
+       /** Preferred NTP server. {@hide} */
+       public static final String NTP_SERVER = "ntp_server";
+       /** Timeout in milliseconds to wait for NTP server. {@hide} */
+       public static final String NTP_TIMEOUT = "ntp_timeout";
+
+       /**
+        * Whether the package manager should send package verification broadcasts for verifiers to
+        * review apps prior to installation.
+        * 1 = request apps to be verified prior to installation, if a verifier exists.
+        * 0 = do not verify apps before installation
+        * @hide
+        */
+       public static final String PACKAGE_VERIFIER_ENABLE = "package_verifier_enable";
+
+       /** Timeout for package verification.
+        * @hide */
+       public static final String PACKAGE_VERIFIER_TIMEOUT = "verifier_timeout";
+
+       /** Default response code for package verification.
+        * @hide */
+       public static final String PACKAGE_VERIFIER_DEFAULT_RESPONSE = "verifier_default_response";
+
+       /**
+        * Show package verification setting in the Settings app.
+        * 1 = show (default)
+        * 0 = hide
+        * @hide
+        */
+       public static final String PACKAGE_VERIFIER_SETTING_VISIBLE = "verifier_setting_visible";
+
+       /**
+        * Run package verificaiton on apps installed through ADB/ADT/USB
+        * 1 = perform package verification on ADB installs (default)
+        * 0 = bypass package verification on ADB installs
+        * @hide
+        */
+       public static final String PACKAGE_VERIFIER_INCLUDE_ADB = "verifier_verify_adb_installs";
+
+       /**
+        * The interval in milliseconds at which to check packet counts on the
+        * mobile data interface when screen is on, to detect possible data
+        * connection problems.
+        * @hide
+        */
+       public static final String PDP_WATCHDOG_POLL_INTERVAL_MS =
+               "pdp_watchdog_poll_interval_ms";
+
+       /**
+        * The interval in milliseconds at which to check packet counts on the
+        * mobile data interface when screen is off, to detect possible data
+        * connection problems.
+        * @hide
+        */
+       public static final String PDP_WATCHDOG_LONG_POLL_INTERVAL_MS =
+               "pdp_watchdog_long_poll_interval_ms";
+
+       /**
+        * The interval in milliseconds at which to check packet counts on the
+        * mobile data interface after {@link #PDP_WATCHDOG_TRIGGER_PACKET_COUNT}
+        * outgoing packets has been reached without incoming packets.
+        * @hide
+        */
+       public static final String PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS =
+               "pdp_watchdog_error_poll_interval_ms";
+
+       /**
+        * The number of outgoing packets sent without seeing an incoming packet
+        * that triggers a countdown (of {@link #PDP_WATCHDOG_ERROR_POLL_COUNT}
+        * device is logged to the event log
+        * @hide
+        */
+       public static final String PDP_WATCHDOG_TRIGGER_PACKET_COUNT =
+               "pdp_watchdog_trigger_packet_count";
+
+       /**
+        * The number of polls to perform (at {@link #PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS})
+        * after hitting {@link #PDP_WATCHDOG_TRIGGER_PACKET_COUNT} before
+        * attempting data connection recovery.
+        * @hide
+        */
+       public static final String PDP_WATCHDOG_ERROR_POLL_COUNT =
+               "pdp_watchdog_error_poll_count";
+
+       /**
+        * The number of failed PDP reset attempts before moving to something more
+        * drastic: re-registering to the network.
+        * @hide
+        */
+       public static final String PDP_WATCHDOG_MAX_PDP_RESET_FAIL_COUNT =
+               "pdp_watchdog_max_pdp_reset_fail_count";
+
+       /**
+        * A positive value indicates how often the SamplingProfiler
+        * should take snapshots. Zero value means SamplingProfiler
+        * is disabled.
+        *
+        * @hide
+        */
+       public static final String SAMPLING_PROFILER_MS = "sampling_profiler_ms";
+
+       /**
+        * URL to open browser on to allow user to manage a prepay account
+        * @hide
+        */
+       public static final String SETUP_PREPAID_DATA_SERVICE_URL =
+               "setup_prepaid_data_service_url";
+
+       /**
+        * URL to attempt a GET on to see if this is a prepay device
+        * @hide
+        */
+       public static final String SETUP_PREPAID_DETECTION_TARGET_URL =
+               "setup_prepaid_detection_target_url";
+
+       /**
+        * Host to check for a redirect to after an attempt to GET
+        * SETUP_PREPAID_DETECTION_TARGET_URL. (If we redirected there,
+        * this is a prepaid device with zero balance.)
+        * @hide
+        */
+       public static final String SETUP_PREPAID_DETECTION_REDIR_HOST =
+               "setup_prepaid_detection_redir_host";
+
+       /**
+        * The interval in milliseconds at which to check the number of SMS sent out without asking
+        * for use permit, to limit the un-authorized SMS usage.
+        *
+        * @hide
+        */
+       public static final String SMS_OUTGOING_CHECK_INTERVAL_MS =
+               "sms_outgoing_check_interval_ms";
+
+       /**
+        * The number of outgoing SMS sent without asking for user permit (of {@link
+        * #SMS_OUTGOING_CHECK_INTERVAL_MS}
+        *
+        * @hide
+        */
+       public static final String SMS_OUTGOING_CHECK_MAX_COUNT =
+               "sms_outgoing_check_max_count";
+
+       /**
+        * Used to disable SMS short code confirmation - defaults to true.
+        * True indcates we will do the check, etc.  Set to false to disable.
+        * @see com.android.internal.telephony.SmsUsageMonitor
+        * @hide
+        */
+       public static final String SMS_SHORT_CODE_CONFIRMATION = "sms_short_code_confirmation";
+
+        /**
+         * Used to select which country we use to determine premium sms codes.
+         * One of com.android.internal.telephony.SMSDispatcher.PREMIUM_RULE_USE_SIM,
+         * com.android.internal.telephony.SMSDispatcher.PREMIUM_RULE_USE_NETWORK,
+         * or com.android.internal.telephony.SMSDispatcher.PREMIUM_RULE_USE_BOTH.
+         * @hide
+         */
+        public static final String SMS_SHORT_CODE_RULE = "sms_short_code_rule";
+
+       /**
+        * Used to disable Tethering on a device - defaults to true
+        * @hide
+        */
+       public static final String TETHER_SUPPORTED = "tether_supported";
+
+       /**
+        * Used to require DUN APN on the device or not - defaults to a build config value
+        * which defaults to false
+        * @hide
+        */
+       public static final String TETHER_DUN_REQUIRED = "tether_dun_required";
+
+       /**
+        * Used to hold a gservices-provisioned apn value for DUN.  If set, or the
+        * corresponding build config values are set it will override the APN DB
+        * values.
+        * Consists of a comma seperated list of strings:
+        * "name,apn,proxy,port,username,password,server,mmsc,mmsproxy,mmsport,mcc,mnc,auth,type"
+        * note that empty fields can be ommitted: "name,apn,,,,,,,,,310,260,,DUN"
+        * @hide
+        */
+       public static final String TETHER_DUN_APN = "tether_dun_apn";
+
+       /**
+        * The bandwidth throttle polling freqency in seconds
+        * @hide
+        */
+       public static final String THROTTLE_POLLING_SEC = "throttle_polling_sec";
+
+       /**
+        * The bandwidth throttle threshold (long)
+        * @hide
+        */
+       public static final String THROTTLE_THRESHOLD_BYTES = "throttle_threshold_bytes";
+
+       /**
+        * The bandwidth throttle value (kbps)
+        * @hide
+        */
+       public static final String THROTTLE_VALUE_KBITSPS = "throttle_value_kbitsps";
+
+       /**
+        * The bandwidth throttle reset calendar day (1-28)
+        * @hide
+        */
+       public static final String THROTTLE_RESET_DAY = "throttle_reset_day";
+
+       /**
+        * The throttling notifications we should send
+        * @hide
+        */
+       public static final String THROTTLE_NOTIFICATION_TYPE = "throttle_notification_type";
+
+       /**
+        * Help URI for data throttling policy
+        * @hide
+        */
+       public static final String THROTTLE_HELP_URI = "throttle_help_uri";
+
+       /**
+        * The length of time in Sec that we allow our notion of NTP time
+        * to be cached before we refresh it
+        * @hide
+        */
+       public static final String THROTTLE_MAX_NTP_CACHE_AGE_SEC =
+               "throttle_max_ntp_cache_age_sec";
+
+       /**
+        * USB Mass Storage Enabled
+        */
+       public static final String USB_MASS_STORAGE_ENABLED = "usb_mass_storage_enabled";
+
+       /**
+        * If this setting is set (to anything), then all references
+        * to Gmail on the device must change to Google Mail.
+        */
+       public static final String USE_GOOGLE_MAIL = "use_google_mail";
+
+       /** Autofill server address (Used in WebView/browser).
+        * {@hide} */
+       public static final String WEB_AUTOFILL_QUERY_URL =
+           "web_autofill_query_url";
+
+       /**
+        * Whether Wifi display is enabled/disabled
+        * 0=disabled. 1=enabled.
+        * @hide
+        */
+       public static final String WIFI_DISPLAY_ON = "wifi_display_on";
+
+       /**
+        * Whether to notify the user of open networks.
+        * <p>
+        * If not connected and the scan results have an open network, we will
+        * put this notification up. If we attempt to connect to a network or
+        * the open network(s) disappear, we remove the notification. When we
+        * show the notification, we will not show it again for
+        * {@link android.provider.Settings.Secure#WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY} time.
+        */
+       public static final String WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON =
+               "wifi_networks_available_notification_on";
+       /**
+        * {@hide}
+        */
+       public static final String WIMAX_NETWORKS_AVAILABLE_NOTIFICATION_ON =
+               "wimax_networks_available_notification_on";
+
+       /**
+        * Delay (in seconds) before repeating the Wi-Fi networks available notification.
+        * Connecting to a network will reset the timer.
+        */
+       public static final String WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY =
+               "wifi_networks_available_repeat_delay";
+
+       /**
+        * 802.11 country code in ISO 3166 format
+        * @hide
+        */
+       public static final String WIFI_COUNTRY_CODE = "wifi_country_code";
+
+       /**
+        * The interval in milliseconds to issue wake up scans when wifi needs
+        * to connect. This is necessary to connect to an access point when
+        * device is on the move and the screen is off.
+        * @hide
+        */
+       public static final String WIFI_FRAMEWORK_SCAN_INTERVAL_MS =
+               "wifi_framework_scan_interval_ms";
+
+       /**
+        * The interval in milliseconds after which Wi-Fi is considered idle.
+        * When idle, it is possible for the device to be switched from Wi-Fi to
+        * the mobile data network.
+        * @hide
+        */
+       public static final String WIFI_IDLE_MS = "wifi_idle_ms";
+
+       /**
+        * When the number of open networks exceeds this number, the
+        * least-recently-used excess networks will be removed.
+        */
+       public static final String WIFI_NUM_OPEN_NETWORKS_KEPT = "wifi_num_open_networks_kept";
+
+       /**
+        * Whether the Wi-Fi should be on.  Only the Wi-Fi service should touch this.
+        */
+       public static final String WIFI_ON = "wifi_on";
+
+       /**
+        * Used to save the Wifi_ON state prior to tethering.
+        * This state will be checked to restore Wifi after
+        * the user turns off tethering.
+        *
+        * @hide
+        */
+       public static final String WIFI_SAVED_STATE = "wifi_saved_state";
+
+       /**
+        * The interval in milliseconds to scan as used by the wifi supplicant
+        * @hide
+        */
+       public static final String WIFI_SUPPLICANT_SCAN_INTERVAL_MS =
+               "wifi_supplicant_scan_interval_ms";
+
+       /**
+        * The interval in milliseconds to scan at supplicant when p2p is connected
+        * @hide
+        */
+       public static final String WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS =
+               "wifi_scan_interval_p2p_connected_ms";
+
+       /**
+        * Whether the Wi-Fi watchdog is enabled.
+        */
+       public static final String WIFI_WATCHDOG_ON = "wifi_watchdog_on";
+
+       /**
+        * Setting to turn off poor network avoidance on Wi-Fi. Feature is enabled by default and
+        * the setting needs to be set to 0 to disable it.
+        * @hide
+        */
+       public static final String WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED =
+               "wifi_watchdog_poor_network_test_enabled";
+
+       /**
+        * Setting to turn on suspend optimizations at screen off on Wi-Fi. Enabled by default and
+        * needs to be set to 0 to disable it.
+        * @hide
+        */
+       public static final String WIFI_SUSPEND_OPTIMIZATIONS_ENABLED =
+               "wifi_suspend_optimizations_enabled";
+
+       /**
+        * The maximum number of times we will retry a connection to an access
+        * point for which we have failed in acquiring an IP address from DHCP.
+        * A value of N means that we will make N+1 connection attempts in all.
+        */
+       public static final String WIFI_MAX_DHCP_RETRY_COUNT = "wifi_max_dhcp_retry_count";
+
+       /**
+        * Maximum amount of time in milliseconds to hold a wakelock while waiting for mobile
+        * data connectivity to be established after a disconnect from Wi-Fi.
+        */
+       public static final String WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS =
+           "wifi_mobile_data_transition_wakelock_timeout_ms";
+
+       /**
+        * The operational wifi frequency band
+        * Set to one of {@link WifiManager#WIFI_FREQUENCY_BAND_AUTO},
+        * {@link WifiManager#WIFI_FREQUENCY_BAND_5GHZ} or
+        * {@link WifiManager#WIFI_FREQUENCY_BAND_2GHZ}
+        *
+        * @hide
+        */
+       public static final String WIFI_FREQUENCY_BAND = "wifi_frequency_band";
+
+       /**
+        * The Wi-Fi peer-to-peer device name
+        * @hide
+        */
+       public static final String WIFI_P2P_DEVICE_NAME = "wifi_p2p_device_name";
+
+       /**
+        * The number of milliseconds to delay when checking for data stalls during
+        * non-aggressive detection. (screen is turned off.)
+        * @hide
+        */
+       public static final String DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS =
+               "data_stall_alarm_non_aggressive_delay_in_ms";
+
+       /**
+        * The number of milliseconds to delay when checking for data stalls during
+        * aggressive detection. (screen on or suspected data stall)
+        * @hide
+        */
+       public static final String DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS =
+               "data_stall_alarm_aggressive_delay_in_ms";
+
+       /**
+        * The interval in milliseconds at which to check gprs registration
+        * after the first registration mismatch of gprs and voice service,
+        * to detect possible data network registration problems.
+        *
+        * @hide
+        */
+       public static final String GPRS_REGISTER_CHECK_PERIOD_MS =
+               "gprs_register_check_period_ms";
+
+       /**
+        * Nonzero causes Log.wtf() to crash.
+        * @hide
+        */
+       public static final String WTF_IS_FATAL = "wtf_is_fatal";
+
+       /**
+        * Ringer mode. This is used internally, changing this value will not
+        * change the ringer mode. See AudioManager.
+        */
+       public static final String MODE_RINGER = "mode_ringer";
+
+       /**
+        * Overlay display devices setting.
+        * The associated value is a specially formatted string that describes the
+        * size and density of simulated secondary display devices.
+        * <p>
+        * Format: {width}x{height}/{dpi};...
+        * </p><p>
+        * Example:
+        * <ul>
+        * <li><code>1280x720/213</code>: make one overlay that is 1280x720 at 213dpi.</li>
+        * <li><code>1920x1080/320;1280x720/213</code>: make two overlays, the first
+        * at 1080p and the second at 720p.</li>
+        * <li>If the value is empty, then no overlay display devices are created.</li>
+        * </ul></p>
+        *
+        * @hide
+        */
+       public static final String OVERLAY_DISPLAY_DEVICES = "overlay_display_devices";
+
+        /**
+         * Threshold values for the duration and level of a discharge cycle,
+         * under which we log discharge cycle info.
+         *
+         * @hide
+         */
+        public static final String
+                BATTERY_DISCHARGE_DURATION_THRESHOLD = "battery_discharge_duration_threshold";
+
+        /** @hide */
+        public static final String BATTERY_DISCHARGE_THRESHOLD = "battery_discharge_threshold";
+
+        /**
+         * Flag for allowing ActivityManagerService to send ACTION_APP_ERROR
+         * intents on application crashes and ANRs. If this is disabled, the
+         * crash/ANR dialog will never display the "Report" button.
+         * <p>
+         * Type: int (0 = disallow, 1 = allow)
+         *
+         * @hide
+         */
+        public static final String SEND_ACTION_APP_ERROR = "send_action_app_error";
+
+        /**
+         * Maximum age of entries kept by {@link DropBoxManager}.
+         *
+         * @hide
+         */
+        public static final String DROPBOX_AGE_SECONDS = "dropbox_age_seconds";
+
+        /**
+         * Maximum number of entry files which {@link DropBoxManager} will keep
+         * around.
+         *
+         * @hide
+         */
+        public static final String DROPBOX_MAX_FILES = "dropbox_max_files";
+
+        /**
+         * Maximum amount of disk space used by {@link DropBoxManager} no matter
+         * what.
+         *
+         * @hide
+         */
+        public static final String DROPBOX_QUOTA_KB = "dropbox_quota_kb";
+
+        /**
+         * Percent of free disk (excluding reserve) which {@link DropBoxManager}
+         * will use.
+         *
+         * @hide
+         */
+        public static final String DROPBOX_QUOTA_PERCENT = "dropbox_quota_percent";
+
+        /**
+         * Percent of total disk which {@link DropBoxManager} will never dip
+         * into.
+         *
+         * @hide
+         */
+        public static final String DROPBOX_RESERVE_PERCENT = "dropbox_reserve_percent";
+
+        /**
+         * Prefix for per-tag dropbox disable/enable settings.
+         *
+         * @hide
+         */
+        public static final String DROPBOX_TAG_PREFIX = "dropbox:";
+
+        /**
+         * Lines of logcat to include with system crash/ANR/etc. reports, as a
+         * prefix of the dropbox tag of the report type. For example,
+         * "logcat_for_system_server_anr" controls the lines of logcat captured
+         * with system server ANR reports. 0 to disable.
+         *
+         * @hide
+         */
+        public static final String ERROR_LOGCAT_PREFIX = "logcat_for_";
+
+        /**
+         * The interval in minutes after which the amount of free storage left
+         * on the device is logged to the event log
+         *
+         * @hide
+         */
+        public static final String SYS_FREE_STORAGE_LOG_INTERVAL = "sys_free_storage_log_interval";
+
+        /**
+         * Threshold for the amount of change in disk free space required to
+         * report the amount of free space. Used to prevent spamming the logs
+         * when the disk free space isn't changing frequently.
+         *
+         * @hide
+         */
+        public static final String
+                DISK_FREE_CHANGE_REPORTING_THRESHOLD = "disk_free_change_reporting_threshold";
+
+        /**
+         * Minimum percentage of free storage on the device that is used to
+         * determine if the device is running low on storage. The default is 10.
+         * <p>
+         * Say this value is set to 10, the device is considered running low on
+         * storage if 90% or more of the device storage is filled up.
+         *
+         * @hide
+         */
+        public static final String
+                SYS_STORAGE_THRESHOLD_PERCENTAGE = "sys_storage_threshold_percentage";
+
+        /**
+         * Maximum byte size of the low storage threshold. This is to ensure
+         * that {@link #SYS_STORAGE_THRESHOLD_PERCENTAGE} does not result in an
+         * overly large threshold for large storage devices. Currently this must
+         * be less than 2GB. This default is 500MB.
+         *
+         * @hide
+         */
+        public static final String
+                SYS_STORAGE_THRESHOLD_MAX_BYTES = "sys_storage_threshold_max_bytes";
+
+        /**
+         * Minimum bytes of free storage on the device before the data partition
+         * is considered full. By default, 1 MB is reserved to avoid system-wide
+         * SQLite disk full exceptions.
+         *
+         * @hide
+         */
+        public static final String
+                SYS_STORAGE_FULL_THRESHOLD_BYTES = "sys_storage_full_threshold_bytes";
+
+        /**
+         * The maximum reconnect delay for short network outages or when the
+         * network is suspended due to phone use.
+         *
+         * @hide
+         */
+        public static final String
+                SYNC_MAX_RETRY_DELAY_IN_SECONDS = "sync_max_retry_delay_in_seconds";
+
+        /**
+         * The number of milliseconds to delay before sending out
+         * {@link ConnectivityManager#CONNECTIVITY_ACTION} broadcasts.
+         *
+         * @hide
+         */
+        public static final String CONNECTIVITY_CHANGE_DELAY = "connectivity_change_delay";
+
+        /**
+         * Setting to turn off captive portal detection. Feature is enabled by
+         * default and the setting needs to be set to 0 to disable it.
+         *
+         * @hide
+         */
+        public static final String
+                CAPTIVE_PORTAL_DETECTION_ENABLED = "captive_portal_detection_enabled";
+
+        /**
+         * The server used for captive portal detection upon a new conection. A
+         * 204 response code from the server is used for validation.
+         *
+         * @hide
+         */
+        public static final String CAPTIVE_PORTAL_SERVER = "captive_portal_server";
+
+        /**
+         * Whether network service discovery is enabled.
+         *
+         * @hide
+         */
+        public static final String NSD_ON = "nsd_on";
+
+        /**
+         * Let user pick default install location.
+         *
+         * @hide
+         */
+        public static final String SET_INSTALL_LOCATION = "set_install_location";
+
+        /**
+         * Default install location value.
+         * 0 = auto, let system decide
+         * 1 = internal
+         * 2 = sdcard
+         * @hide
+         */
+        public static final String DEFAULT_INSTALL_LOCATION = "default_install_location";
+
+        /**
+         * ms during which to consume extra events related to Inet connection
+         * condition after a transtion to fully-connected
+         *
+         * @hide
+         */
+        public static final String
+                INET_CONDITION_DEBOUNCE_UP_DELAY = "inet_condition_debounce_up_delay";
+
+        /**
+         * ms during which to consume extra events related to Inet connection
+         * condtion after a transtion to partly-connected
+         *
+         * @hide
+         */
+        public static final String
+                INET_CONDITION_DEBOUNCE_DOWN_DELAY = "inet_condition_debounce_down_delay";
+
+        /** {@hide} */
+        public static final String
+                READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT = "read_external_storage_enforced_default";
+
+        /**
+         * Host name and port for global http proxy. Uses ':' seperator for
+         * between host and port.
+         */
+        public static final String HTTP_PROXY = "http_proxy";
+
+        /**
+         * Host name for global http proxy. Set via ConnectivityManager.
+         *
+         * @hide
+         */
+        public static final String GLOBAL_HTTP_PROXY_HOST = "global_http_proxy_host";
+
+        /**
+         * Integer host port for global http proxy. Set via ConnectivityManager.
+         *
+         * @hide
+         */
+        public static final String GLOBAL_HTTP_PROXY_PORT = "global_http_proxy_port";
+
+        /**
+         * Exclusion list for global proxy. This string contains a list of
+         * comma-separated domains where the global proxy does not apply.
+         * Domains should be listed in a comma- separated list. Example of
+         * acceptable formats: ".domain1.com,my.domain2.com" Use
+         * ConnectivityManager to set/get.
+         *
+         * @hide
+         */
+        public static final String
+                GLOBAL_HTTP_PROXY_EXCLUSION_LIST = "global_http_proxy_exclusion_list";
+
+        /**
+         * Enables the UI setting to allow the user to specify the global HTTP
+         * proxy and associated exclusion list.
+         *
+         * @hide
+         */
+        public static final String SET_GLOBAL_HTTP_PROXY = "set_global_http_proxy";
+
+        /**
+         * Setting for default DNS in case nobody suggests one
+         *
+         * @hide
+         */
+        public static final String DEFAULT_DNS_SERVER = "default_dns_server";
+
+        /** {@hide} */
+        public static final String
+                BLUETOOTH_HEADSET_PRIORITY_PREFIX = "bluetooth_headset_priority_";
+        /** {@hide} */
+        public static final String
+                BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX = "bluetooth_a2dp_sink_priority_";
+        /** {@hide} */
+        public static final String
+                BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX = "bluetooth_input_device_priority_";
+
+        /**
+         * Get the key that retrieves a bluetooth headset's priority.
+         * @hide
+         */
+        public static final String getBluetoothHeadsetPriorityKey(String address) {
+            return BLUETOOTH_HEADSET_PRIORITY_PREFIX + address.toUpperCase();
+        }
+
+        /**
+         * Get the key that retrieves a bluetooth a2dp sink's priority.
+         * @hide
+         */
+        public static final String getBluetoothA2dpSinkPriorityKey(String address) {
+            return BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX + address.toUpperCase();
+        }
+
+        /**
+         * Get the key that retrieves a bluetooth Input Device's priority.
+         * @hide
+         */
+        public static final String getBluetoothInputDevicePriorityKey(String address) {
+            return BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX + address.toUpperCase();
+        }
+
+        /**
+         * Scaling factor for normal window animations. Setting to 0 will
+         * disable window animations.
+         */
+        public static final String WINDOW_ANIMATION_SCALE = "window_animation_scale";
+
+        /**
+         * Scaling factor for activity transition animations. Setting to 0 will
+         * disable window animations.
+         */
+        public static final String TRANSITION_ANIMATION_SCALE = "transition_animation_scale";
+
+        /**
+         * Scaling factor for Animator-based animations. This affects both the
+         * start delay and duration of all such animations. Setting to 0 will
+         * cause animations to end immediately. The default value is 1.
+         */
+        public static final String ANIMATOR_DURATION_SCALE = "animator_duration_scale";
+
+        /**
+         * Scaling factor for normal window animations. Setting to 0 will
+         * disable window animations.
+         *
+         * @hide
+         */
+        public static final String FANCY_IME_ANIMATIONS = "fancy_ime_animations";
+
+        /**
+         * If 0, the compatibility mode is off for all applications.
+         * If 1, older applications run under compatibility mode.
+         * TODO: remove this settings before code freeze (bug/1907571)
+         * @hide
+         */
+        public static final String COMPATIBILITY_MODE = "compatibility_mode";
+
+        /**
+         * CDMA only settings
+         * Emergency Tone  0 = Off
+         *                 1 = Alert
+         *                 2 = Vibrate
+         * @hide
+         */
+        public static final String EMERGENCY_TONE = "emergency_tone";
+
+        /**
+         * CDMA only settings
+         * Whether the auto retry is enabled. The value is
+         * boolean (1 or 0).
+         * @hide
+         */
+        public static final String CALL_AUTO_RETRY = "call_auto_retry";
+
+        /**
+         * The preferred network mode   7 = Global
+         *                              6 = EvDo only
+         *                              5 = CDMA w/o EvDo
+         *                              4 = CDMA / EvDo auto
+         *                              3 = GSM / WCDMA auto
+         *                              2 = WCDMA only
+         *                              1 = GSM only
+         *                              0 = GSM / WCDMA preferred
+         * @hide
+         */
+        public static final String PREFERRED_NETWORK_MODE =
+                "preferred_network_mode";
+
+        /**
+         * The cdma subscription 0 = Subscription from RUIM, when available
+         *                       1 = Subscription from NV
+         * @hide
+         */
+        public static final String PREFERRED_CDMA_SUBSCRIPTION =
+                "preferred_cdma_subscription";
+
+        /**
+         * Name of an application package to be debugged.
+         */
+        public static final String DEBUG_APP = "debug_app";
+
+        /**
+         * If 1, when launching DEBUG_APP it will wait for the debugger before
+         * starting user code.  If 0, it will run normally.
+         */
+        public static final String WAIT_FOR_DEBUGGER = "wait_for_debugger";
+
+        /**
+         * Control whether the process CPU usage meter should be shown.
+         */
+        public static final String SHOW_PROCESSES = "show_processes";
+
+        /**
+         * If 1, the activity manager will aggressively finish activities and
+         * processes as soon as they are no longer needed.  If 0, the normal
+         * extended lifetime is used.
+         */
+        public static final String ALWAYS_FINISH_ACTIVITIES =
+                "always_finish_activities";
+
+        /**
+         * Use Dock audio output for media:
+         *      0 = disabled
+         *      1 = enabled
+         * @hide
+         */
+        public static final String DOCK_AUDIO_MEDIA_ENABLED = "dock_audio_media_enabled";
+
+        /**
+         * Persisted safe headphone volume management state by AudioService
+         * @hide
+         */
+        public static final String AUDIO_SAFE_VOLUME_STATE = "audio_safe_volume_state";
+
+        /**
+         * Settings to backup. This is here so that it's in the same place as the settings
+         * keys and easy to update.
+         *
+         * These keys may be mentioned in the SETTINGS_TO_BACKUP arrays in System
+         * and Secure as well.  This is because those tables drive both backup and
+         * restore, and restore needs to properly whitelist keys that used to live
+         * in those namespaces.  The keys will only actually be backed up / restored
+         * if they are also mentioned in this table (Global.SETTINGS_TO_BACKUP).
+         *
+         * NOTE: Settings are backed up and restored in the order they appear
+         *       in this array. If you have one setting depending on another,
+         *       make sure that they are ordered appropriately.
+         *
+         * @hide
+         */
+        public static final String[] SETTINGS_TO_BACKUP = {
+            STAY_ON_WHILE_PLUGGED_IN,
+            MODE_RINGER,
+            AUTO_TIME,
+            AUTO_TIME_ZONE,
+            POWER_SOUNDS_ENABLED,
+            POWER_NOTIFICATIONS_ENABLED,
+            POWER_NOTIFICATIONS_VIBRATE,
+            POWER_NOTIFICATIONS_RINGTONE,
+            DOCK_SOUNDS_ENABLED,
+            USB_MASS_STORAGE_ENABLED,
+            ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED,
+            WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
+            WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
+            WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED,
+            WIFI_NUM_OPEN_NETWORKS_KEPT,
+            EMERGENCY_TONE,
+            CALL_AUTO_RETRY,
+            DOCK_AUDIO_MEDIA_ENABLED
+        };
+
+        // Populated lazily, guarded by class object:
+        private static NameValueCache sNameValueCache = new NameValueCache(
+                    SYS_PROP_SETTING_VERSION,
+                    CONTENT_URI,
+                    CALL_METHOD_GET_GLOBAL,
+                    CALL_METHOD_PUT_GLOBAL);
+
+        /**
+         * Look up a name in the database.
+         * @param resolver to access the database with
+         * @param name to look up in the table
+         * @return the corresponding value, or null if not present
+         */
+        public static String getString(ContentResolver resolver, String name) {
+            return getStringForUser(resolver, name, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static String getStringForUser(ContentResolver resolver, String name,
+                int userHandle) {
+            return sNameValueCache.getStringForUser(resolver, name, userHandle);
+        }
+
+        /**
+         * Store a name/value pair into the database.
+         * @param resolver to access the database with
+         * @param name to store
+         * @param value to associate with the name
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putString(ContentResolver resolver,
+                String name, String value) {
+            return putStringForUser(resolver, name, value, UserHandle.myUserId());
+        }
+
+        /** @hide */
+        public static boolean putStringForUser(ContentResolver resolver,
+                String name, String value, int userHandle) {
+            if (LOCAL_LOGV) {
+                Log.v(TAG, "Global.putString(name=" + name + ", value=" + value
+                        + " for " + userHandle);
+            }
+            return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
+        }
+
+        /**
+         * Construct the content URI for a particular name/value pair,
+         * useful for monitoring changes with a ContentObserver.
+         * @param name to look up in the table
+         * @return the corresponding content URI, or null if not present
+         */
+        public static Uri getUriFor(String name) {
+            return getUriFor(CONTENT_URI, name);
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as an integer.  Note that internally setting values are always
+         * stored as strings; this function converts the string to an integer
+         * for you.  The default value will be returned if the setting is
+         * not defined or not an integer.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         * @param def Value to return if the setting is not defined.
+         *
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid integer.
+         */
+        public static int getInt(ContentResolver cr, String name, int def) {
+            String v = getString(cr, name);
+            try {
+                return v != null ? Integer.parseInt(v) : def;
+            } catch (NumberFormatException e) {
+                return def;
+            }
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as an integer.  Note that internally setting values are always
+         * stored as strings; this function converts the string to an integer
+         * for you.
+         * <p>
+         * This version does not take a default value.  If the setting has not
+         * been set, or the string value is not a number,
+         * it throws {@link SettingNotFoundException}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         *
+         * @throws SettingNotFoundException Thrown if a setting by the given
+         * name can't be found or the setting value is not an integer.
+         *
+         * @return The setting's current value.
+         */
+        public static int getInt(ContentResolver cr, String name)
+                throws SettingNotFoundException {
+            String v = getString(cr, name);
+            try {
+                return Integer.parseInt(v);
+            } catch (NumberFormatException e) {
+                throw new SettingNotFoundException(name);
+            }
+        }
+
+        /**
+         * Convenience function for updating a single settings value as an
+         * integer. This will either create a new entry in the table if the
+         * given name does not exist, or modify the value of the existing row
+         * with that name.  Note that internally setting values are always
+         * stored as strings, so this function converts the given value to a
+         * string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putInt(ContentResolver cr, String name, int value) {
+            return putString(cr, name, Integer.toString(value));
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as a {@code long}.  Note that internally setting values are always
+         * stored as strings; this function converts the string to a {@code long}
+         * for you.  The default value will be returned if the setting is
+         * not defined or not a {@code long}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         * @param def Value to return if the setting is not defined.
+         *
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid {@code long}.
+         */
+        public static long getLong(ContentResolver cr, String name, long def) {
+            String valString = getString(cr, name);
+            long value;
+            try {
+                value = valString != null ? Long.parseLong(valString) : def;
+            } catch (NumberFormatException e) {
+                value = def;
+            }
+            return value;
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as a {@code long}.  Note that internally setting values are always
+         * stored as strings; this function converts the string to a {@code long}
+         * for you.
+         * <p>
+         * This version does not take a default value.  If the setting has not
+         * been set, or the string value is not a number,
+         * it throws {@link SettingNotFoundException}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         *
+         * @return The setting's current value.
+         * @throws SettingNotFoundException Thrown if a setting by the given
+         * name can't be found or the setting value is not an integer.
+         */
+        public static long getLong(ContentResolver cr, String name)
+                throws SettingNotFoundException {
+            String valString = getString(cr, name);
+            try {
+                return Long.parseLong(valString);
+            } catch (NumberFormatException e) {
+                throw new SettingNotFoundException(name);
+            }
+        }
+
+        /**
+         * Convenience function for updating a secure settings value as a long
+         * integer. This will either create a new entry in the table if the
+         * given name does not exist, or modify the value of the existing row
+         * with that name.  Note that internally setting values are always
+         * stored as strings, so this function converts the given value to a
+         * string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putLong(ContentResolver cr, String name, long value) {
+            return putString(cr, name, Long.toString(value));
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as a floating point number.  Note that internally setting values are
+         * always stored as strings; this function converts the string to an
+         * float for you. The default value will be returned if the setting
+         * is not defined or not a valid float.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         * @param def Value to return if the setting is not defined.
+         *
+         * @return The setting's current value, or 'def' if it is not defined
+         * or not a valid float.
+         */
+        public static float getFloat(ContentResolver cr, String name, float def) {
+            String v = getString(cr, name);
+            try {
+                return v != null ? Float.parseFloat(v) : def;
+            } catch (NumberFormatException e) {
+                return def;
+            }
+        }
+
+        /**
+         * Convenience function for retrieving a single secure settings value
+         * as a float.  Note that internally setting values are always
+         * stored as strings; this function converts the string to a float
+         * for you.
+         * <p>
+         * This version does not take a default value.  If the setting has not
+         * been set, or the string value is not a number,
+         * it throws {@link SettingNotFoundException}.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to retrieve.
+         *
+         * @throws SettingNotFoundException Thrown if a setting by the given
+         * name can't be found or the setting value is not a float.
+         *
+         * @return The setting's current value.
+         */
+        public static float getFloat(ContentResolver cr, String name)
+                throws SettingNotFoundException {
+            String v = getString(cr, name);
+            if (v == null) {
+                throw new SettingNotFoundException(name);
+            }
+            try {
+                return Float.parseFloat(v);
+            } catch (NumberFormatException e) {
+                throw new SettingNotFoundException(name);
+            }
+        }
+
+        /**
+         * Convenience function for updating a single settings value as a
+         * floating point number. This will either create a new entry in the
+         * table if the given name does not exist, or modify the value of the
+         * existing row with that name.  Note that internally setting values
+         * are always stored as strings, so this function converts the given
+         * value to a string before storing it.
+         *
+         * @param cr The ContentResolver to access.
+         * @param name The name of the setting to modify.
+         * @param value The new value for the setting.
+         * @return true if the value was set, false on database errors
+         */
+        public static boolean putFloat(ContentResolver cr, String name, float value) {
+            return putString(cr, name, Float.toString(value));
+        }
+    }
+
+    /**
+     * User-defined bookmarks and shortcuts.  The target of each bookmark is an
+     * Intent URL, allowing it to be either a web page or a particular
+     * application activity.
+     *
+     * @hide
+     */
+    public static final class Bookmarks implements BaseColumns
+    {
+        private static final String TAG = "Bookmarks";
+
+        /**
+         * The content:// style URL for this table
+         */
+        public static final Uri CONTENT_URI =
+            Uri.parse("content://" + AUTHORITY + "/bookmarks");
+
+        /**
+         * The row ID.
+         * <p>Type: INTEGER</p>
+         */
+        public static final String ID = "_id";
+
+        /**
+         * Descriptive name of the bookmark that can be displayed to the user.
+         * If this is empty, the title should be resolved at display time (use
+         * {@link #getTitle(Context, Cursor)} any time you want to display the
+         * title of a bookmark.)
+         * <P>
+         * Type: TEXT
+         * </P>
+         */
+        public static final String TITLE = "title";
+
+        /**
+         * Arbitrary string (displayed to the user) that allows bookmarks to be
+         * organized into categories.  There are some special names for
+         * standard folders, which all start with '@'.  The label displayed for
+         * the folder changes with the locale (via {@link #getLabelForFolder}) but
+         * the folder name does not change so you can consistently query for
+         * the folder regardless of the current locale.
+         *
+         * <P>Type: TEXT</P>
+         *
+         */
+        public static final String FOLDER = "folder";
+
+        /**
+         * The Intent URL of the bookmark, describing what it points to.  This
+         * value is given to {@link android.content.Intent#getIntent} to create
+         * an Intent that can be launched.
+         * <P>Type: TEXT</P>
+         */
+        public static final String INTENT = "intent";
+
+        /**
+         * Optional shortcut character associated with this bookmark.
+         * <P>Type: INTEGER</P>
+         */
+        public static final String SHORTCUT = "shortcut";
+
+        /**
+         * The order in which the bookmark should be displayed
+         * <P>Type: INTEGER</P>
+         */
+        public static final String ORDERING = "ordering";
+
+        private static final String[] sIntentProjection = { INTENT };
+        private static final String[] sShortcutProjection = { ID, SHORTCUT };
+        private static final String sShortcutSelection = SHORTCUT + "=?";
+
+        /**
+         * Convenience function to retrieve the bookmarked Intent for a
+         * particular shortcut key.
+         *
+         * @param cr The ContentResolver to query.
+         * @param shortcut The shortcut key.
+         *
+         * @return Intent The bookmarked URL, or null if there is no bookmark
+         *         matching the given shortcut.
+         */
+        public static Intent getIntentForShortcut(ContentResolver cr, char shortcut)
+        {
+            Intent intent = null;
+
+            Cursor c = cr.query(CONTENT_URI,
+                    sIntentProjection, sShortcutSelection,
+                    new String[] { String.valueOf((int) shortcut) }, ORDERING);
+            // Keep trying until we find a valid shortcut
+            try {
+                while (intent == null && c.moveToNext()) {
+                    try {
+                        String intentURI = c.getString(c.getColumnIndexOrThrow(INTENT));
+                        intent = Intent.parseUri(intentURI, 0);
+                    } catch (java.net.URISyntaxException e) {
+                        // The stored URL is bad...  ignore it.
+                    } catch (IllegalArgumentException e) {
+                        // Column not found
+                        Log.w(TAG, "Intent column not found", e);
+                    }
+                }
+            } finally {
+                if (c != null) c.close();
+            }
+
+            return intent;
+        }
+
+        /**
+         * Add a new bookmark to the system.
+         *
+         * @param cr The ContentResolver to query.
+         * @param intent The desired target of the bookmark.
+         * @param title Bookmark title that is shown to the user; null if none
+         *            or it should be resolved to the intent's title.
+         * @param folder Folder in which to place the bookmark; null if none.
+         * @param shortcut Shortcut that will invoke the bookmark; 0 if none. If
+         *            this is non-zero and there is an existing bookmark entry
+         *            with this same shortcut, then that existing shortcut is
+         *            cleared (the bookmark is not removed).
+         * @return The unique content URL for the new bookmark entry.
+         */
+        public static Uri add(ContentResolver cr,
+                                           Intent intent,
+                                           String title,
+                                           String folder,
+                                           char shortcut,
+                                           int ordering)
+        {
+            // If a shortcut is supplied, and it is already defined for
+            // another bookmark, then remove the old definition.
+            if (shortcut != 0) {
+                cr.delete(CONTENT_URI, sShortcutSelection,
+                        new String[] { String.valueOf((int) shortcut) });
+            }
+
+            ContentValues values = new ContentValues();
+            if (title != null) values.put(TITLE, title);
+            if (folder != null) values.put(FOLDER, folder);
+            values.put(INTENT, intent.toUri(0));
+            if (shortcut != 0) values.put(SHORTCUT, (int) shortcut);
+            values.put(ORDERING, ordering);
+            return cr.insert(CONTENT_URI, values);
+        }
+
+        /**
+         * Return the folder name as it should be displayed to the user.  This
+         * takes care of localizing special folders.
+         *
+         * @param r Resources object for current locale; only need access to
+         *          system resources.
+         * @param folder The value found in the {@link #FOLDER} column.
+         *
+         * @return CharSequence The label for this folder that should be shown
+         *         to the user.
+         */
+        public static CharSequence getLabelForFolder(Resources r, String folder) {
+            return folder;
+        }
+
+        /**
+         * Return the title as it should be displayed to the user. This takes
+         * care of localizing bookmarks that point to activities.
+         *
+         * @param context A context.
+         * @param cursor A cursor pointing to the row whose title should be
+         *        returned. The cursor must contain at least the {@link #TITLE}
+         *        and {@link #INTENT} columns.
+         * @return A title that is localized and can be displayed to the user,
+         *         or the empty string if one could not be found.
+         */
+        public static CharSequence getTitle(Context context, Cursor cursor) {
+            int titleColumn = cursor.getColumnIndex(TITLE);
+            int intentColumn = cursor.getColumnIndex(INTENT);
+            if (titleColumn == -1 || intentColumn == -1) {
+                throw new IllegalArgumentException(
+                        "The cursor must contain the TITLE and INTENT columns.");
+            }
+
+            String title = cursor.getString(titleColumn);
+            if (!TextUtils.isEmpty(title)) {
+                return title;
+            }
+
+            String intentUri = cursor.getString(intentColumn);
+            if (TextUtils.isEmpty(intentUri)) {
+                return "";
+            }
+
+            Intent intent;
+            try {
+                intent = Intent.parseUri(intentUri, 0);
+            } catch (URISyntaxException e) {
+                return "";
+            }
+
+            PackageManager packageManager = context.getPackageManager();
+            ResolveInfo info = packageManager.resolveActivity(intent, 0);
+            return info != null ? info.loadLabel(packageManager) : "";
+        }
+    }
+
+    /**
+     * Returns the device ID that we should use when connecting to the mobile gtalk server.
+     * This is a string like "android-0x1242", where the hex string is the Android ID obtained
+     * from the GoogleLoginService.
+     *
+     * @param androidId The Android ID for this device.
+     * @return The device ID that should be used when connecting to the mobile gtalk server.
+     * @hide
+     */
+    public static String getGTalkDeviceId(long androidId) {
+        return "android-" + Long.toHexString(androidId);
+    }
+}
diff --git a/core/java/android/view/VolumePanel.java b/core/java/android/view/VolumePanel.java
index 8a83fa5..3fba379 100644
--- a/core/java/android/view/VolumePanel.java
+++ b/core/java/android/view/VolumePanel.java
@@ -1,1135 +1,1147 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.view;
-
-import com.android.internal.R;
-
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.content.DialogInterface.OnDismissListener;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.res.Resources;
-import android.database.ContentObserver;
-import android.media.AudioManager;
-import android.media.AudioService;
-import android.media.AudioSystem;
-import android.media.RingtoneManager;
-import android.media.ToneGenerator;
-import android.net.Uri;
-import android.os.Handler;
-import android.os.Message;
-import android.os.RemoteException;
-import android.os.Vibrator;
-import android.provider.Settings;
-import android.util.Log;
-import android.view.WindowManager.LayoutParams;
-import android.widget.ImageView;
-import android.widget.SeekBar;
-import android.widget.SeekBar.OnSeekBarChangeListener;
-
-import java.util.HashMap;
-
-/**
- * Handle the volume up and down keys.
- *
- * This code really should be moved elsewhere.
- *
- * Seriously, it really really should be moved elsewhere.  This is used by
- * android.media.AudioService, which actually runs in the system process, to
- * show the volume dialog when the user changes the volume.  What a mess.
- *
- * @hide
- */
-public class VolumePanel extends Handler implements OnSeekBarChangeListener, View.OnClickListener
-{
-    private static final String TAG = "VolumePanel";
-    private static boolean LOGD = false;
-
-    /**
-     * The delay before playing a sound. This small period exists so the user
-     * can press another key (non-volume keys, too) to have it NOT be audible.
-     * <p>
-     * PhoneWindow will implement this part.
-     */
-    public static final int PLAY_SOUND_DELAY = 300;
-
-    /**
-     * The delay before vibrating. This small period exists so if the user is
-     * moving to silent mode, it will not emit a short vibrate (it normally
-     * would since vibrate is between normal mode and silent mode using hardware
-     * keys).
-     */
-    public static final int VIBRATE_DELAY = 300;
-
-    private static final int VIBRATE_DURATION = 300;
-    private static final int BEEP_DURATION = 150;
-    private static final int MAX_VOLUME = 100;
-    private static final int FREE_DELAY = 10000;
-    private static final int TIMEOUT_DELAY = 3000;
-
-    private static final int MSG_VOLUME_CHANGED = 0;
-    private static final int MSG_FREE_RESOURCES = 1;
-    private static final int MSG_PLAY_SOUND = 2;
-    private static final int MSG_STOP_SOUNDS = 3;
-    private static final int MSG_VIBRATE = 4;
-    private static final int MSG_TIMEOUT = 5;
-    private static final int MSG_RINGER_MODE_CHANGED = 6;
-    private static final int MSG_MUTE_CHANGED = 7;
-    private static final int MSG_REMOTE_VOLUME_CHANGED = 8;
-    private static final int MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN = 9;
-    private static final int MSG_SLIDER_VISIBILITY_CHANGED = 10;
-    private static final int MSG_DISPLAY_SAFE_VOLUME_WARNING = 11;
-
-    // Pseudo stream type for master volume
-    private static final int STREAM_MASTER = -100;
-    // Pseudo stream type for remote volume is defined in AudioService.STREAM_REMOTE_MUSIC
-
-    public static final int VOLUME_OVERLAY_SINGLE = 0;
-    public static final int VOLUME_OVERLAY_EXPANDABLE = 1;
-    public static final int VOLUME_OVERLAY_EXPANDED = 2;
-    public static final int VOLUME_OVERLAY_NONE = 3;
-
-    protected Context mContext;
-    private AudioManager mAudioManager;
-    protected AudioService mAudioService;
-    private boolean mRingIsSilent;
-    private boolean mShowCombinedVolumes;
-    private boolean mVoiceCapable;
-    private boolean mVolumeLinkNotification;
-    private int mCurrentOverlayStyle = -1;
-
-    // True if we want to play tones on the system stream when the master stream is specified.
-    private final boolean mPlayMasterStreamTones;
-
-    /** Dialog containing all the sliders */
-    private final Dialog mDialog;
-    /** Dialog's content view */
-    private final View mView;
-
-    /** The visible portion of the volume overlay */
-    private final ViewGroup mPanel;
-    /** Contains the sliders and their touchable icons */
-    private final ViewGroup mSliderGroup;
-    /** The button that expands the dialog to show all sliders */
-    private final View mMoreButton;
-    /** Dummy divider icon that needs to vanish with the more button */
-    private final View mDivider;
-
-    /** Currently active stream that shows up at the top of the list of sliders */
-    private int mActiveStreamType = -1;
-    /** All the slider controls mapped by stream type */
-    private HashMap<Integer,StreamControl> mStreamControls;
-
-    private enum StreamResources {
-        BluetoothSCOStream(AudioManager.STREAM_BLUETOOTH_SCO,
-                R.string.volume_icon_description_bluetooth,
-                R.drawable.ic_audio_bt,
-                R.drawable.ic_audio_bt,
-                false),
-        RingerStream(AudioManager.STREAM_RING,
-                R.string.volume_icon_description_ringer,
-                R.drawable.ic_audio_ring_notif,
-                R.drawable.ic_audio_ring_notif_mute,
-                true),
-        VoiceStream(AudioManager.STREAM_VOICE_CALL,
-                R.string.volume_icon_description_incall,
-                R.drawable.ic_audio_phone,
-                R.drawable.ic_audio_phone,
-                false),
-        AlarmStream(AudioManager.STREAM_ALARM,
-                R.string.volume_alarm,
-                R.drawable.ic_audio_alarm,
-                R.drawable.ic_audio_alarm_mute,
-                true),
-        MediaStream(AudioManager.STREAM_MUSIC,
-                R.string.volume_icon_description_media,
-                R.drawable.ic_audio_vol,
-                R.drawable.ic_audio_vol_mute,
-                true),
-        NotificationStream(AudioManager.STREAM_NOTIFICATION,
-                R.string.volume_icon_description_notification,
-                R.drawable.ic_audio_notification,
-                R.drawable.ic_audio_notification_mute,
-                true),
-        // for now, use media resources for master volume
-        MasterStream(STREAM_MASTER,
-                R.string.volume_icon_description_media, //FIXME should have its own description
-                R.drawable.ic_audio_vol,
-                R.drawable.ic_audio_vol_mute,
-                false),
-        RemoteStream(AudioService.STREAM_REMOTE_MUSIC,
-                R.string.volume_icon_description_media, //FIXME should have its own description
-                R.drawable.ic_media_route_on_holo_dark,
-                R.drawable.ic_media_route_disabled_holo_dark,
-                false);// will be dynamically updated
-
-        int streamType;
-        int descRes;
-        int iconRes;
-        int iconMuteRes;
-        // RING, VOICE_CALL & BLUETOOTH_SCO are hidden unless explicitly requested
-        boolean show;
-
-        StreamResources(int streamType, int descRes, int iconRes, int iconMuteRes, boolean show) {
-            this.streamType = streamType;
-            this.descRes = descRes;
-            this.iconRes = iconRes;
-            this.iconMuteRes = iconMuteRes;
-            this.show = show;
-        }
-    };
-
-    // List of stream types and their order
-    private static final StreamResources[] STREAMS = {
-        StreamResources.BluetoothSCOStream,
-        StreamResources.RingerStream,
-        StreamResources.VoiceStream,
-        StreamResources.MediaStream,
-        StreamResources.NotificationStream,
-        StreamResources.AlarmStream,
-        StreamResources.MasterStream,
-        StreamResources.RemoteStream
-    };
-
-    /** Object that contains data for each slider */
-    private class StreamControl {
-        int streamType;
-        ViewGroup group;
-        ImageView icon;
-        SeekBar seekbarView;
-        int iconRes;
-        int iconMuteRes;
-    }
-
-    // Synchronize when accessing this
-    private ToneGenerator mToneGenerators[];
-    private Vibrator mVibrator;
-
-    private ContentObserver mSettingsObserver = new ContentObserver(this) {
-        @Override
-        public void onChange(boolean selfChange) {
-            mVolumeLinkNotification = Settings.System.getInt(mContext.getContentResolver(),
-                    Settings.System.VOLUME_LINK_NOTIFICATION, 1) == 1;
-            final int overlayStyle = Settings.System.getInt(mContext.getContentResolver(),
-                    Settings.System.MODE_VOLUME_OVERLAY, VOLUME_OVERLAY_EXPANDABLE);
-            changeOverlayStyle(overlayStyle);
-        }
-    };
-
-    private static AlertDialog sConfirmSafeVolumeDialog;
-    private static Object sConfirmSafeVolumeLock = new Object();
-
-    private static class WarningDialogReceiver extends BroadcastReceiver
-            implements DialogInterface.OnDismissListener {
-        private Context mContext;
-        private Dialog mDialog;
-
-        WarningDialogReceiver(Context context, Dialog dialog) {
-            mContext = context;
-            mDialog = dialog;
-            IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
-            context.registerReceiver(this, filter);
-        }
-
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            mDialog.cancel();
-            synchronized (sConfirmSafeVolumeLock) {
-                sConfirmSafeVolumeDialog = null;
-            }
-        }
-
-        public void onDismiss(DialogInterface unused) {
-            mContext.unregisterReceiver(this);
-            synchronized (sConfirmSafeVolumeLock) {
-                sConfirmSafeVolumeDialog = null;
-            }
-        }
-    }
-
-
-    public VolumePanel(final Context context, AudioService volumeService) {
-        mContext = context;
-        mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
-        mAudioService = volumeService;
-
-        // For now, only show master volume if master volume is supported
-        boolean useMasterVolume = context.getResources().getBoolean(
-                com.android.internal.R.bool.config_useMasterVolume);
-        if (useMasterVolume) {
-            for (int i = 0; i < STREAMS.length; i++) {
-                StreamResources streamRes = STREAMS[i];
-                streamRes.show = (streamRes.streamType == STREAM_MASTER);
-            }
-        }
-
-        LayoutInflater inflater = (LayoutInflater) context
-                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        mView = inflater.inflate(R.layout.volume_adjust, null);
-        mView.setOnTouchListener(new View.OnTouchListener() {
-            public boolean onTouch(View v, MotionEvent event) {
-                resetTimeout();
-                return false;
-            }
-        });
-        mPanel = (ViewGroup) mView.findViewById(R.id.visible_panel);
-        mSliderGroup = (ViewGroup) mView.findViewById(R.id.slider_group);
-        mMoreButton = (ImageView) mView.findViewById(R.id.expand_button);
-        mDivider = (ImageView) mView.findViewById(R.id.expand_button_divider);
-
-        mDialog = new Dialog(context, R.style.Theme_Panel_Volume) {
-            public boolean onTouchEvent(MotionEvent event) {
-                if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
-                    forceTimeout();
-                    return true;
-                }
-                return false;
-            }
-        };
-        mDialog.setTitle("Volume control"); // No need to localize
-        mDialog.setContentView(mView);
-        mDialog.setOnDismissListener(new OnDismissListener() {
-            public void onDismiss(DialogInterface dialog) {
-                mActiveStreamType = -1;
-                mAudioManager.forceVolumeControlStream(mActiveStreamType);
-            }
-        });
-        // Change some window properties
-        Window window = mDialog.getWindow();
-        window.setGravity(Gravity.TOP);
-        LayoutParams lp = window.getAttributes();
-        lp.token = null;
-        // Offset from the top
-        lp.y = mContext.getResources().getDimensionPixelOffset(
-                com.android.internal.R.dimen.volume_panel_top);
-        lp.type = LayoutParams.TYPE_VOLUME_OVERLAY;
-        lp.width = LayoutParams.WRAP_CONTENT;
-        lp.height = LayoutParams.WRAP_CONTENT;
-        lp.privateFlags |= LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR;
-        window.setAttributes(lp);
-        window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL
-                | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
-
-        mToneGenerators = new ToneGenerator[AudioSystem.getNumStreamTypes()];
-        mVibrator = (Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
-        mVoiceCapable = context.getResources().getBoolean(R.bool.config_voice_capable);
-
-        // Get the user's preferences
-        mVolumeLinkNotification = Settings.System.getInt(mContext.getContentResolver(),
-                Settings.System.VOLUME_LINK_NOTIFICATION, 1) == 1;
-        final int chosenStyle = Settings.System.getInt(context.getContentResolver(),
-                Settings.System.MODE_VOLUME_OVERLAY, VOLUME_OVERLAY_EXPANDABLE);
-        changeOverlayStyle(chosenStyle);
-
-        context.getContentResolver().registerContentObserver(
-                Settings.System.getUriFor(Settings.System.VOLUME_LINK_NOTIFICATION), false,
-                mSettingsObserver);
-        context.getContentResolver().registerContentObserver(
-                Settings.System.getUriFor(Settings.System.MODE_VOLUME_OVERLAY), false,
-                mSettingsObserver);
-
-        // This is new with 4.2 it seems
-        boolean masterVolumeOnly = context.getResources().getBoolean(
-                com.android.internal.R.bool.config_useMasterVolume);
-        boolean masterVolumeKeySounds = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_useVolumeKeySounds);
-
-        mPlayMasterStreamTones = masterVolumeOnly && masterVolumeKeySounds;
-        // End this is new
-
-        mMoreButton.setOnClickListener(this);
-        listenToRingerMode();
-    }
-
-    private void listenToRingerMode() {
-        final IntentFilter filter = new IntentFilter();
-        filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
-        mContext.registerReceiver(new BroadcastReceiver() {
-
-            public void onReceive(Context context, Intent intent) {
-                final String action = intent.getAction();
-
-                if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
-                    removeMessages(MSG_RINGER_MODE_CHANGED);
-                    sendMessage(obtainMessage(MSG_RINGER_MODE_CHANGED));
-                }
-            }
-        }, filter);
-    }
-
-    private void changeOverlayStyle(int newStyle) {
-        Log.i("VolumePanel", "changeOverlayStyle : " + newStyle);
-        // Don't change to the same style
-        if (newStyle == mCurrentOverlayStyle) return;
-        switch (newStyle) {
-            case VOLUME_OVERLAY_SINGLE :
-                mMoreButton.setVisibility(View.GONE);
-                mDivider.setVisibility(View.GONE);
-                mShowCombinedVolumes = false;
-                mCurrentOverlayStyle = VOLUME_OVERLAY_SINGLE;
-                break;
-            case VOLUME_OVERLAY_EXPANDABLE :
-                mMoreButton.setVisibility(View.VISIBLE);
-                mDivider.setVisibility(View.VISIBLE);
-                mShowCombinedVolumes = true;
-                mCurrentOverlayStyle = VOLUME_OVERLAY_EXPANDABLE;
-                break;
-            case VOLUME_OVERLAY_EXPANDED :
-                mMoreButton.setVisibility(View.GONE);
-                mDivider.setVisibility(View.GONE);
-                mShowCombinedVolumes = true;
-                if (mCurrentOverlayStyle == VOLUME_OVERLAY_NONE) {
-                    addOtherVolumes();
-                    expand();
-                }
-                mCurrentOverlayStyle = VOLUME_OVERLAY_EXPANDED;
-                break;
-            case VOLUME_OVERLAY_NONE :
-                mShowCombinedVolumes = false;
-                mCurrentOverlayStyle = VOLUME_OVERLAY_NONE;
-                break;
-        }
-    }
-
-    private int getStreamMaxVolume(int streamType) {
-        if (streamType == STREAM_MASTER) {
-            return mAudioManager.getMasterMaxVolume();
-        } else if (streamType == AudioService.STREAM_REMOTE_MUSIC) {
-            return mAudioService.getRemoteStreamMaxVolume();
-        } else {
-            return mAudioManager.getStreamMaxVolume(streamType);
-        }
-    }
-
-    private int getStreamVolume(int streamType) {
-        if (streamType == STREAM_MASTER) {
-            return mAudioManager.getMasterVolume();
-        } else if (streamType == AudioService.STREAM_REMOTE_MUSIC) {
-            return mAudioService.getRemoteStreamVolume();
-        } else {
-            return mAudioManager.getStreamVolume(streamType);
-        }
-    }
-
-    private void setStreamVolume(int streamType, int index, int flags) {
-        if (streamType == STREAM_MASTER) {
-            mAudioManager.setMasterVolume(index, flags);
-        } else if (streamType == AudioService.STREAM_REMOTE_MUSIC) {
-            mAudioService.setRemoteStreamVolume(index);
-        } else {
-            mAudioManager.setStreamVolume(streamType, index, flags);
-        }
-    }
-
-    private boolean isMuted(int streamType) {
-        if (streamType == STREAM_MASTER) {
-            return mAudioManager.isMasterMute();
-        } else if (streamType == AudioService.STREAM_REMOTE_MUSIC) {
-            return (mAudioService.getRemoteStreamVolume() <= 0);
-        } else {
-            return mAudioManager.isStreamMute(streamType);
-        }
-    }
-
-    private void createSliders() {
-        LayoutInflater inflater = (LayoutInflater) mContext
-                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        mStreamControls = new HashMap<Integer, StreamControl>(STREAMS.length);
-        Resources res = mContext.getResources();
-        for (int i = 0; i < STREAMS.length; i++) {
-            StreamResources streamRes = STREAMS[i];
-            int streamType = streamRes.streamType;
-            StreamControl sc = new StreamControl();
-            sc.streamType = streamType;
-            sc.group = (ViewGroup) inflater.inflate(R.layout.volume_adjust_item, null);
-            sc.group.setTag(sc);
-            sc.icon = (ImageView) sc.group.findViewById(R.id.stream_icon);
-            sc.icon.setTag(sc);
-            sc.icon.setContentDescription(res.getString(streamRes.descRes));
-            sc.iconRes = streamRes.iconRes;
-            sc.iconMuteRes = streamRes.iconMuteRes;
-            sc.icon.setImageResource(sc.iconRes);
-            sc.icon.setOnClickListener(this);
-            sc.seekbarView = (SeekBar) sc.group.findViewById(R.id.seekbar);
-            int plusOne = (streamType == AudioSystem.STREAM_BLUETOOTH_SCO ||
-                    streamType == AudioSystem.STREAM_VOICE_CALL) ? 1 : 0;
-            sc.seekbarView.setMax(getStreamMaxVolume(streamType) + plusOne);
-            sc.seekbarView.setOnSeekBarChangeListener(this);
-            sc.seekbarView.setTag(sc);
-            mStreamControls.put(streamType, sc);
-        }
-    }
-
-    private void reorderSliders(int activeStreamType) {
-        mSliderGroup.removeAllViews();
-
-        StreamControl active = mStreamControls.get(activeStreamType);
-        if (active == null) {
-            Log.e("VolumePanel", "Missing stream type! - " + activeStreamType);
-            mActiveStreamType = -1;
-        } else {
-            mSliderGroup.addView(active.group);
-            mActiveStreamType = activeStreamType;
-            active.group.setVisibility(View.VISIBLE);
-            updateSlider(active);
-        }
-
-        addOtherVolumes();
-    }
-
-    private void addOtherVolumes() {
-        if (!mShowCombinedVolumes) return;
-
-        for (int i = 0; i < STREAMS.length; i++) {
-            // Skip the phone specific ones and the active one
-            final int streamType = STREAMS[i].streamType;
-            if (!STREAMS[i].show || streamType == mActiveStreamType) {
-                continue;
-            }
-            // Skip ring volume for non-phone devices
-            if (!mVoiceCapable && streamType == AudioManager.STREAM_RING) {
-                continue;
-            }
-            // Skip notification volume if linked with ring volume
-            if (mVoiceCapable && mVolumeLinkNotification &&
-                    streamType == AudioManager.STREAM_NOTIFICATION) {
-                continue;
-            }
-            StreamControl sc = mStreamControls.get(streamType);
-            mSliderGroup.addView(sc.group);
-            updateSlider(sc);
-        }
-    }
-
-    /** Update the mute and progress state of a slider */
-    private void updateSlider(StreamControl sc) {
-        sc.seekbarView.setProgress(getStreamVolume(sc.streamType));
-        final boolean muted = isMuted(sc.streamType);
-        sc.icon.setImageResource(muted ? sc.iconMuteRes : sc.iconRes);
-        if (sc.streamType == AudioManager.STREAM_RING &&
-                mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE) {
-            sc.icon.setImageResource(R.drawable.ic_audio_ring_notif_vibrate);
-        }
-        if (sc.streamType == AudioService.STREAM_REMOTE_MUSIC) {
-            // never disable touch interactions for remote playback, the muting is not tied to
-            // the state of the phone.
-            sc.seekbarView.setEnabled(true);
-        } else if (sc.streamType != mAudioManager.getMasterStreamType() && muted) {
-            sc.seekbarView.setEnabled(false);
-        } else {
-            sc.seekbarView.setEnabled(true);
-        }
-    }
-
-    private boolean isExpanded() {
-        return mMoreButton.getVisibility() != View.VISIBLE;
-    }
-
-    private void expand() {
-        final int count = mSliderGroup.getChildCount();
-        for (int i = 0; i < count; i++) {
-            if (mSliderGroup.getChildAt(i).getVisibility() != View.VISIBLE) {
-                mSliderGroup.getChildAt(i).setVisibility(View.VISIBLE);
-            }
-        }
-        mMoreButton.setVisibility(View.GONE);
-        mDivider.setVisibility(View.GONE);
-    }
-
-    private void hideSlider(int mActiveStreamType) {
-        final int count = mSliderGroup.getChildCount();
-        for (int i = 0; i < count; i++) {
-            StreamControl sc = (StreamControl) mSliderGroup.getChildAt(i).getTag();
-            if (mActiveStreamType == sc.streamType) {
-                mSliderGroup.getChildAt(i).setVisibility(View.GONE);
-            }
-        }
-    }
-
-    private void collapse() {
-        mMoreButton.setVisibility(View.VISIBLE);
-        mDivider.setVisibility(View.VISIBLE);
-        final int count = mSliderGroup.getChildCount();
-        for (int i = 1; i < count; i++) {
-            mSliderGroup.getChildAt(i).setVisibility(View.GONE);
-        }
-    }
-
-    private void updateStates() {
-        final int count = mSliderGroup.getChildCount();
-        for (int i = 0; i < count; i++) {
-            StreamControl sc = (StreamControl) mSliderGroup.getChildAt(i).getTag();
-            updateSlider(sc);
-        }
-    }
-
-    public void postVolumeChanged(int streamType, int flags) {
-        if (hasMessages(MSG_VOLUME_CHANGED)) return;
-        synchronized (this) {
-            if (mStreamControls == null) {
-                createSliders();
-            }
-        }
-        removeMessages(MSG_FREE_RESOURCES);
-        obtainMessage(MSG_VOLUME_CHANGED, streamType, flags).sendToTarget();
-    }
-
-    public void postRemoteVolumeChanged(int streamType, int flags) {
-        if (hasMessages(MSG_REMOTE_VOLUME_CHANGED)) return;
-        synchronized (this) {
-            if (mStreamControls == null) {
-                createSliders();
-            }
-        }
-        removeMessages(MSG_FREE_RESOURCES);
-        obtainMessage(MSG_REMOTE_VOLUME_CHANGED, streamType, flags).sendToTarget();
-    }
-
-    public void postRemoteSliderVisibility(boolean visible) {
-        obtainMessage(MSG_SLIDER_VISIBILITY_CHANGED,
-                AudioService.STREAM_REMOTE_MUSIC, visible ? 1 : 0).sendToTarget();
-    }
-
-    /**
-     * Called by AudioService when it has received new remote playback information that
-     * would affect the VolumePanel display (mainly volumes). The difference with
-     * {@link #postRemoteVolumeChanged(int, int)} is that the handling of the posted message
-     * (MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN) will only update the volume slider if it is being
-     * displayed.
-     * This special code path is due to the fact that remote volume updates arrive to AudioService
-     * asynchronously. So after AudioService has sent the volume update (which should be treated
-     * as a request to update the volume), the application will likely set a new volume. If the UI
-     * is still up, we need to refresh the display to show this new value.
-     */
-    public void postHasNewRemotePlaybackInfo() {
-        if (hasMessages(MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN)) return;
-        // don't create or prevent resources to be freed, if they disappear, this update came too
-        //   late and shouldn't warrant the panel to be displayed longer
-        obtainMessage(MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN).sendToTarget();
-    }
-
-    public void postMasterVolumeChanged(int flags) {
-        postVolumeChanged(STREAM_MASTER, flags);
-    }
-
-    public void postMuteChanged(int streamType, int flags) {
-        if (hasMessages(MSG_VOLUME_CHANGED)) return;
-        synchronized (this) {
-            if (mStreamControls == null) {
-                createSliders();
-            }
-        }
-        removeMessages(MSG_FREE_RESOURCES);
-        obtainMessage(MSG_MUTE_CHANGED, streamType, flags).sendToTarget();
-    }
-
-    public void postMasterMuteChanged(int flags) {
-        postMuteChanged(STREAM_MASTER, flags);
-    }
-
-    public void postDisplaySafeVolumeWarning() {
-        if (hasMessages(MSG_DISPLAY_SAFE_VOLUME_WARNING)) return;
-        obtainMessage(MSG_DISPLAY_SAFE_VOLUME_WARNING, 0, 0).sendToTarget();
-    }
-
-    /**
-     * Override this if you have other work to do when the volume changes (for
-     * example, vibrating, playing a sound, etc.). Make sure to call through to
-     * the superclass implementation.
-     */
-    protected void onVolumeChanged(int streamType, int flags) {
-
-        if (LOGD) Log.d(TAG, "onVolumeChanged(streamType: " + streamType + ", flags: " + flags + ")");
-
-        if ((flags & AudioManager.FLAG_SHOW_UI) != 0) {
-            synchronized (this) {
-                if (streamType != mActiveStreamType) {
-                    if (mCurrentOverlayStyle == VOLUME_OVERLAY_EXPANDABLE) {
-                        hideSlider(mActiveStreamType);
-                    }
-                    reorderSliders(streamType);
-                }
-                onShowVolumeChanged(streamType, flags);
-            }
-        }
-
-        if ((flags & AudioManager.FLAG_PLAY_SOUND) != 0 && ! mRingIsSilent) {
-            removeMessages(MSG_PLAY_SOUND);
-            sendMessageDelayed(obtainMessage(MSG_PLAY_SOUND, streamType, flags), PLAY_SOUND_DELAY);
-        }
-
-        if ((flags & AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE) != 0) {
-            removeMessages(MSG_PLAY_SOUND);
-            removeMessages(MSG_VIBRATE);
-            onStopSounds();
-        }
-
-        removeMessages(MSG_FREE_RESOURCES);
-        sendMessageDelayed(obtainMessage(MSG_FREE_RESOURCES), FREE_DELAY);
-
-        resetTimeout();
-    }
-
-    protected void onMuteChanged(int streamType, int flags) {
-
-        if (LOGD) Log.d(TAG, "onMuteChanged(streamType: " + streamType + ", flags: " + flags + ")");
-
-        StreamControl sc = mStreamControls.get(streamType);
-        if (sc != null) {
-            sc.icon.setImageResource(isMuted(sc.streamType) ? sc.iconMuteRes : sc.iconRes);
-        }
-
-        onVolumeChanged(streamType, flags);
-    }
-
-    protected void onShowVolumeChanged(int streamType, int flags) {
-        int index = getStreamVolume(streamType);
-
-        mRingIsSilent = false;
-
-        if (LOGD) {
-            Log.d(TAG, "onShowVolumeChanged(streamType: " + streamType
-                    + ", flags: " + flags + "), index: " + index);
-        }
-
-        // get max volume for progress bar
-
-        int max = getStreamMaxVolume(streamType);
-
-        switch (streamType) {
-
-            case AudioManager.STREAM_RING: {
-//                setRingerIcon();
-                Uri ringuri = RingtoneManager.getActualDefaultRingtoneUri(
-                        mContext, RingtoneManager.TYPE_RINGTONE);
-                if (ringuri == null) {
-                    mRingIsSilent = true;
-                }
-                break;
-            }
-
-            case AudioManager.STREAM_MUSIC: {
-                // Special case for when Bluetooth is active for music
-                if ((mAudioManager.getDevicesForStream(AudioManager.STREAM_MUSIC) &
-                        (AudioManager.DEVICE_OUT_BLUETOOTH_A2DP |
-                        AudioManager.DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
-                        AudioManager.DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)) != 0) {
-                    setMusicIcon(R.drawable.ic_audio_bt, R.drawable.ic_audio_bt_mute);
-                } else {
-                    setMusicIcon(R.drawable.ic_audio_vol, R.drawable.ic_audio_vol_mute);
-                }
-                break;
-            }
-
-            case AudioManager.STREAM_VOICE_CALL: {
-                /*
-                 * For in-call voice call volume, there is no inaudible volume.
-                 * Rescale the UI control so the progress bar doesn't go all
-                 * the way to zero and don't show the mute icon.
-                 */
-                index++;
-                max++;
-                break;
-            }
-
-            case AudioManager.STREAM_ALARM: {
-                break;
-            }
-
-            case AudioManager.STREAM_NOTIFICATION: {
-                Uri ringuri = RingtoneManager.getActualDefaultRingtoneUri(
-                        mContext, RingtoneManager.TYPE_NOTIFICATION);
-                if (ringuri == null) {
-                    mRingIsSilent = true;
-                }
-                break;
-            }
-
-            case AudioManager.STREAM_BLUETOOTH_SCO: {
-                /*
-                 * For in-call voice call volume, there is no inaudible volume.
-                 * Rescale the UI control so the progress bar doesn't go all
-                 * the way to zero and don't show the mute icon.
-                 */
-                index++;
-                max++;
-                break;
-            }
-
-            case AudioService.STREAM_REMOTE_MUSIC: {
-                if (LOGD) { Log.d(TAG, "showing remote volume "+index+" over "+ max); }
-                break;
-            }
-        }
-
-        StreamControl sc = mStreamControls.get(streamType);
-        if (sc != null) {
-            if (sc.seekbarView.getMax() != max) {
-                sc.seekbarView.setMax(max);
-            }
-
-            sc.seekbarView.setProgress(index);
-            if (((flags & AudioManager.FLAG_FIXED_VOLUME) != 0) ||
-                    (streamType != mAudioManager.getMasterStreamType() &&
-                     streamType != AudioService.STREAM_REMOTE_MUSIC &&
-                     isMuted(streamType))) {
-                sc.seekbarView.setEnabled(false);
-            } else {
-                sc.seekbarView.setEnabled(true);
-            }
-        }
-
-        // Only Show if style needs it
-        if (!mDialog.isShowing() && mCurrentOverlayStyle != VOLUME_OVERLAY_NONE) {
-            int stream = (streamType == AudioService.STREAM_REMOTE_MUSIC) ? -1 : streamType;
-            // when the stream is for remote playback, use -1 to reset the stream type evaluation
-            mAudioManager.forceVolumeControlStream(stream);
-            mDialog.setContentView(mView);
-            // Showing dialog - use collapsed state
-            if (mShowCombinedVolumes && mCurrentOverlayStyle != VOLUME_OVERLAY_EXPANDED) {
-                collapse();
-            }
-            // If just changed the style and we need to expand
-            if (mCurrentOverlayStyle == VOLUME_OVERLAY_EXPANDED) {
-                expand();
-            }
-            mDialog.show();
-        }
-
-        // Do a little vibrate if applicable (only when going into vibrate mode)
-        if ((streamType != AudioService.STREAM_REMOTE_MUSIC) &&
-                ((flags & AudioManager.FLAG_VIBRATE) != 0) &&
-                mAudioService.isStreamAffectedByRingerMode(streamType) &&
-                mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE) {
-            sendMessageDelayed(obtainMessage(MSG_VIBRATE), VIBRATE_DELAY);
-        }
-    }
-
-    protected void onPlaySound(int streamType, int flags) {
-
-        // If preference is no sound - just exit here
-        if (Settings.System.getInt(mContext.getContentResolver(),
-                 Settings.System.VOLUME_ADJUST_SOUNDS_ENABLED, 1) == 0) {
-             return;
-         }
-
-        if (hasMessages(MSG_STOP_SOUNDS)) {
-            removeMessages(MSG_STOP_SOUNDS);
-            // Force stop right now
-            onStopSounds();
-        }
-
-        synchronized (this) {
-            ToneGenerator toneGen = getOrCreateToneGenerator(streamType);
-            if (toneGen != null) {
-                toneGen.startTone(ToneGenerator.TONE_PROP_BEEP);
-                sendMessageDelayed(obtainMessage(MSG_STOP_SOUNDS), BEEP_DURATION);
-            }
-        }
-    }
-
-    protected void onStopSounds() {
-
-        synchronized (this) {
-            int numStreamTypes = AudioSystem.getNumStreamTypes();
-            for (int i = numStreamTypes - 1; i >= 0; i--) {
-                ToneGenerator toneGen = mToneGenerators[i];
-                if (toneGen != null) {
-                    toneGen.stopTone();
-                }
-            }
-        }
-    }
-
-    protected void onVibrate() {
-
-        // Make sure we ended up in vibrate ringer mode
-        if (mAudioManager.getRingerMode() != AudioManager.RINGER_MODE_VIBRATE) {
-            return;
-        }
-
-        mVibrator.vibrate(VIBRATE_DURATION);
-    }
-
-    protected void onRemoteVolumeChanged(int streamType, int flags) {
-        // streamType is the real stream type being affected, but for the UI sliders, we
-        // refer to AudioService.STREAM_REMOTE_MUSIC. We still play the beeps on the real
-        // stream type.
-        if (LOGD) Log.d(TAG, "onRemoteVolumeChanged(stream:"+streamType+", flags: " + flags + ")");
-
-        if (((flags & AudioManager.FLAG_SHOW_UI) != 0) || mDialog.isShowing()) {
-            synchronized (this) {
-                if (mActiveStreamType != AudioService.STREAM_REMOTE_MUSIC) {
-                    reorderSliders(AudioService.STREAM_REMOTE_MUSIC);
-                }
-                onShowVolumeChanged(AudioService.STREAM_REMOTE_MUSIC, flags);
-            }
-        } else {
-            if (LOGD) Log.d(TAG, "not calling onShowVolumeChanged(), no FLAG_SHOW_UI or no UI");
-        }
-
-        if ((flags & AudioManager.FLAG_PLAY_SOUND) != 0 && ! mRingIsSilent) {
-            removeMessages(MSG_PLAY_SOUND);
-            sendMessageDelayed(obtainMessage(MSG_PLAY_SOUND, streamType, flags), PLAY_SOUND_DELAY);
-        }
-
-        if ((flags & AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE) != 0) {
-            removeMessages(MSG_PLAY_SOUND);
-            removeMessages(MSG_VIBRATE);
-            onStopSounds();
-        }
-
-        removeMessages(MSG_FREE_RESOURCES);
-        sendMessageDelayed(obtainMessage(MSG_FREE_RESOURCES), FREE_DELAY);
-
-        resetTimeout();
-    }
-
-    protected void onRemoteVolumeUpdateIfShown() {
-        if (LOGD) Log.d(TAG, "onRemoteVolumeUpdateIfShown()");
-        if (mDialog.isShowing()
-                && (mActiveStreamType == AudioService.STREAM_REMOTE_MUSIC)
-                && (mStreamControls != null)) {
-            onShowVolumeChanged(AudioService.STREAM_REMOTE_MUSIC, 0);
-        }
-    }
-
-
-    /**
-     * Handler for MSG_SLIDER_VISIBILITY_CHANGED
-     * Hide or show a slider
-     * @param streamType can be a valid stream type value, or VolumePanel.STREAM_MASTER,
-     *                   or AudioService.STREAM_REMOTE_MUSIC
-     * @param visible
-     */
-    synchronized protected void onSliderVisibilityChanged(int streamType, int visible) {
-        if (LOGD) Log.d(TAG, "onSliderVisibilityChanged(stream="+streamType+", visi="+visible+")");
-        boolean isVisible = (visible == 1);
-        for (int i = STREAMS.length - 1 ; i >= 0 ; i--) {
-            StreamResources streamRes = STREAMS[i];
-            if (streamRes.streamType == streamType) {
-                streamRes.show = isVisible;
-                if (!isVisible && (mActiveStreamType == streamType)) {
-                    mActiveStreamType = -1;
-                }
-                break;
-            }
-        }
-    }
-
-    protected void onDisplaySafeVolumeWarning() {
-        synchronized (sConfirmSafeVolumeLock) {
-            if (sConfirmSafeVolumeDialog != null) {
-                return;
-            }
-            sConfirmSafeVolumeDialog = new AlertDialog.Builder(mContext)
-                    .setMessage(com.android.internal.R.string.safe_media_volume_warning)
-                    .setPositiveButton(com.android.internal.R.string.yes,
-                                        new DialogInterface.OnClickListener() {
-                        public void onClick(DialogInterface dialog, int which) {
-                            mAudioService.disableSafeMediaVolume();
-                        }
-                    })
-                    .setNegativeButton(com.android.internal.R.string.no, null)
-                    .setIconAttribute(android.R.attr.alertDialogIcon)
-                    .create();
-            final WarningDialogReceiver warning = new WarningDialogReceiver(mContext,
-                    sConfirmSafeVolumeDialog);
-
-            sConfirmSafeVolumeDialog.setOnDismissListener(warning);
-            sConfirmSafeVolumeDialog.getWindow().setType(
-                                                    WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
-            sConfirmSafeVolumeDialog.show();
-        }
-    }
-
-    /**
-     * Lock on this VolumePanel instance as long as you use the returned ToneGenerator.
-     */
-    private ToneGenerator getOrCreateToneGenerator(int streamType) {
-        if (streamType == STREAM_MASTER) {
-            // For devices that use the master volume setting only but still want to
-            // play a volume-changed tone, direct the master volume pseudostream to
-            // the system stream's tone generator.
-            if (mPlayMasterStreamTones) {
-                streamType = AudioManager.STREAM_SYSTEM;
-            } else {
-                return null;
-            }
-        }
-        synchronized (this) {
-            if (mToneGenerators[streamType] == null) {
-                try {
-                    mToneGenerators[streamType] = new ToneGenerator(streamType, MAX_VOLUME);
-                } catch (RuntimeException e) {
-                    if (LOGD) {
-                        Log.d(TAG, "ToneGenerator constructor failed with "
-                                + "RuntimeException: " + e);
-                    }
-                }
-            }
-            return mToneGenerators[streamType];
-        }
-    }
-
-
-    /**
-     * Switch between icons because Bluetooth music is same as music volume, but with
-     * different icons.
-     */
-    private void setMusicIcon(int resId, int resMuteId) {
-        StreamControl sc = mStreamControls.get(AudioManager.STREAM_MUSIC);
-        if (sc != null) {
-            sc.iconRes = resId;
-            sc.iconMuteRes = resMuteId;
-            sc.icon.setImageResource(isMuted(sc.streamType) ? sc.iconMuteRes : sc.iconRes);
-        }
-    }
-
-    protected void onFreeResources() {
-        synchronized (this) {
-            for (int i = mToneGenerators.length - 1; i >= 0; i--) {
-                if (mToneGenerators[i] != null) {
-                    mToneGenerators[i].release();
-                }
-                mToneGenerators[i] = null;
-            }
-        }
-    }
-
-    @Override
-    public void handleMessage(Message msg) {
-        switch (msg.what) {
-
-            case MSG_VOLUME_CHANGED: {
-                onVolumeChanged(msg.arg1, msg.arg2);
-                break;
-            }
-
-            case MSG_MUTE_CHANGED: {
-                onMuteChanged(msg.arg1, msg.arg2);
-                break;
-            }
-
-            case MSG_FREE_RESOURCES: {
-                onFreeResources();
-                break;
-            }
-
-            case MSG_STOP_SOUNDS: {
-                onStopSounds();
-                break;
-            }
-
-            case MSG_PLAY_SOUND: {
-                onPlaySound(msg.arg1, msg.arg2);
-                break;
-            }
-
-            case MSG_VIBRATE: {
-                onVibrate();
-                break;
-            }
-
-            case MSG_TIMEOUT: {
-                if (mDialog.isShowing()) {
-                    mDialog.dismiss();
-                    mActiveStreamType = -1;
-                }
-                break;
-            }
-            case MSG_RINGER_MODE_CHANGED: {
-                if (mDialog.isShowing()) {
-                    updateStates();
-                }
-                break;
-            }
-
-            case MSG_REMOTE_VOLUME_CHANGED: {
-                onRemoteVolumeChanged(msg.arg1, msg.arg2);
-                break;
-            }
-
-            case MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN:
-                onRemoteVolumeUpdateIfShown();
-                break;
-
-            case MSG_SLIDER_VISIBILITY_CHANGED:
-                onSliderVisibilityChanged(msg.arg1, msg.arg2);
-                break;
-
-            case MSG_DISPLAY_SAFE_VOLUME_WARNING:
-                onDisplaySafeVolumeWarning();
-                break;
-        }
-    }
-
-    private void resetTimeout() {
-        removeMessages(MSG_TIMEOUT);
-        sendMessageDelayed(obtainMessage(MSG_TIMEOUT), TIMEOUT_DELAY);
-    }
-
-    private void forceTimeout() {
-        removeMessages(MSG_TIMEOUT);
-        sendMessage(obtainMessage(MSG_TIMEOUT));
-    }
-
-    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-        final Object tag = seekBar.getTag();
-        if (fromUser && tag instanceof StreamControl) {
-            StreamControl sc = (StreamControl) tag;
-            if (getStreamVolume(sc.streamType) != progress) {
-                setStreamVolume(sc.streamType, progress, 0);
-            }
-        }
-        resetTimeout();
-    }
-
-    public void onStartTrackingTouch(SeekBar seekBar) {
-    }
-
-    public void onStopTrackingTouch(SeekBar seekBar) {
-        final Object tag = seekBar.getTag();
-        if (tag instanceof StreamControl) {
-            StreamControl sc = (StreamControl) tag;
-            // because remote volume updates are asynchronous, AudioService might have received
-            // a new remote volume value since the finger adjusted the slider. So when the
-            // progress of the slider isn't being tracked anymore, adjust the slider to the last
-            // "published" remote volume value, so the UI reflects the actual volume.
-            if (sc.streamType == AudioService.STREAM_REMOTE_MUSIC) {
-                seekBar.setProgress(getStreamVolume(AudioService.STREAM_REMOTE_MUSIC));
-            }
-        }
-    }
-
-    public void onClick(View v) {
-        if (v == mMoreButton) {
-            expand();
-        } else if (v instanceof ImageView) {
-            Intent volumeSettings = new Intent(android.provider.Settings.ACTION_SOUND_SETTINGS);
-            volumeSettings.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
-            forceTimeout();
-            mContext.startActivity(volumeSettings);
-            return;
-        }
-        resetTimeout();
-    }
-}
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.view;
+
+import com.android.internal.R;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface.OnDismissListener;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.media.AudioManager;
+import android.media.AudioService;
+import android.media.AudioSystem;
+import android.media.RingtoneManager;
+import android.media.ToneGenerator;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.Vibrator;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.WindowManager.LayoutParams;
+import android.widget.ImageView;
+import android.widget.SeekBar;
+import android.widget.SeekBar.OnSeekBarChangeListener;
+
+import java.util.HashMap;
+
+/**
+ * Handle the volume up and down keys.
+ *
+ * This code really should be moved elsewhere.
+ *
+ * Seriously, it really really should be moved elsewhere.  This is used by
+ * android.media.AudioService, which actually runs in the system process, to
+ * show the volume dialog when the user changes the volume.  What a mess.
+ *
+ * @hide
+ */
+public class VolumePanel extends Handler implements OnSeekBarChangeListener, View.OnClickListener
+{
+    private static final String TAG = "VolumePanel";
+    private static boolean LOGD = false;
+
+    /**
+     * The delay before playing a sound. This small period exists so the user
+     * can press another key (non-volume keys, too) to have it NOT be audible.
+     * <p>
+     * PhoneWindow will implement this part.
+     */
+    public static final int PLAY_SOUND_DELAY = 300;
+
+    /**
+     * The delay before vibrating. This small period exists so if the user is
+     * moving to silent mode, it will not emit a short vibrate (it normally
+     * would since vibrate is between normal mode and silent mode using hardware
+     * keys).
+     */
+    public static final int VIBRATE_DELAY = 300;
+
+    private static final int VIBRATE_DURATION = 300;
+    private static final int BEEP_DURATION = 150;
+    private static final int MAX_VOLUME = 100;
+    private static final int FREE_DELAY = 10000;
+    private static final int TIMEOUT_DELAY = 3000;
+
+    private static final int MSG_VOLUME_CHANGED = 0;
+    private static final int MSG_FREE_RESOURCES = 1;
+    private static final int MSG_PLAY_SOUND = 2;
+    private static final int MSG_STOP_SOUNDS = 3;
+    private static final int MSG_VIBRATE = 4;
+    private static final int MSG_TIMEOUT = 5;
+    private static final int MSG_RINGER_MODE_CHANGED = 6;
+    private static final int MSG_MUTE_CHANGED = 7;
+    private static final int MSG_REMOTE_VOLUME_CHANGED = 8;
+    private static final int MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN = 9;
+    private static final int MSG_SLIDER_VISIBILITY_CHANGED = 10;
+    private static final int MSG_DISPLAY_SAFE_VOLUME_WARNING = 11;
+
+    // Pseudo stream type for master volume
+    private static final int STREAM_MASTER = -100;
+    // Pseudo stream type for remote volume is defined in AudioService.STREAM_REMOTE_MUSIC
+
+    public static final int VOLUME_OVERLAY_SINGLE = 0;
+    public static final int VOLUME_OVERLAY_EXPANDABLE = 1;
+    public static final int VOLUME_OVERLAY_EXPANDED = 2;
+    public static final int VOLUME_OVERLAY_NONE = 3;
+
+    protected Context mContext;
+    private AudioManager mAudioManager;
+    protected AudioService mAudioService;
+    private boolean mRingIsSilent;
+    private boolean mShowCombinedVolumes;
+    private boolean mVoiceCapable;
+    private boolean mVolumeLinkNotification;
+    private int mCurrentOverlayStyle = -1;
+
+    // True if we want to play tones on the system stream when the master stream is specified.
+    private final boolean mPlayMasterStreamTones;
+
+    /** Dialog containing all the sliders */
+    private final Dialog mDialog;
+    /** Dialog's content view */
+    private final View mView;
+
+    /** The visible portion of the volume overlay */
+    private final ViewGroup mPanel;
+    /** Contains the sliders and their touchable icons */
+    private final ViewGroup mSliderGroup;
+    /** The button that expands the dialog to show all sliders */
+    private final View mMoreButton;
+    /** Dummy divider icon that needs to vanish with the more button */
+    private final View mDivider;
+
+    /** Currently active stream that shows up at the top of the list of sliders */
+    private int mActiveStreamType = -1;
+    /** All the slider controls mapped by stream type */
+    private HashMap<Integer,StreamControl> mStreamControls;
+
+    private enum StreamResources {
+        BluetoothSCOStream(AudioManager.STREAM_BLUETOOTH_SCO,
+                R.string.volume_icon_description_bluetooth,
+                R.drawable.ic_audio_bt,
+                R.drawable.ic_audio_bt,
+                false),
+        RingerStream(AudioManager.STREAM_RING,
+                R.string.volume_icon_description_ringer,
+                R.drawable.ic_audio_ring_notif,
+                R.drawable.ic_audio_ring_notif_mute,
+                true),
+        VoiceStream(AudioManager.STREAM_VOICE_CALL,
+                R.string.volume_icon_description_incall,
+                R.drawable.ic_audio_phone,
+                R.drawable.ic_audio_phone,
+                false),
+        AlarmStream(AudioManager.STREAM_ALARM,
+                R.string.volume_alarm,
+                R.drawable.ic_audio_alarm,
+                R.drawable.ic_audio_alarm_mute,
+                true),
+        MediaStream(AudioManager.STREAM_MUSIC,
+                R.string.volume_icon_description_media,
+                R.drawable.ic_audio_vol,
+                R.drawable.ic_audio_vol_mute,
+                true),
+        NotificationStream(AudioManager.STREAM_NOTIFICATION,
+                R.string.volume_icon_description_notification,
+                R.drawable.ic_audio_notification,
+                R.drawable.ic_audio_notification_mute,
+                true),
+        FMStream(AudioManager.STREAM_FM,
+                R.string.volume_icon_description_media,
+                R.drawable.ic_audio_vol,
+                R.drawable.ic_audio_vol_mute,
+                true),		
+        // for now, use media resources for master volume
+        MasterStream(STREAM_MASTER,
+                R.string.volume_icon_description_media, //FIXME should have its own description
+                R.drawable.ic_audio_vol,
+                R.drawable.ic_audio_vol_mute,
+                false),
+        RemoteStream(AudioService.STREAM_REMOTE_MUSIC,
+                R.string.volume_icon_description_media, //FIXME should have its own description
+                R.drawable.ic_media_route_on_holo_dark,
+                R.drawable.ic_media_route_disabled_holo_dark,
+                false);// will be dynamically updated
+
+        int streamType;
+        int descRes;
+        int iconRes;
+        int iconMuteRes;
+        // RING, VOICE_CALL & BLUETOOTH_SCO are hidden unless explicitly requested
+        boolean show;
+
+        StreamResources(int streamType, int descRes, int iconRes, int iconMuteRes, boolean show) {
+            this.streamType = streamType;
+            this.descRes = descRes;
+            this.iconRes = iconRes;
+            this.iconMuteRes = iconMuteRes;
+            this.show = show;
+        }
+    };
+
+    // List of stream types and their order
+    private static final StreamResources[] STREAMS = {
+        StreamResources.BluetoothSCOStream,
+        StreamResources.RingerStream,
+        StreamResources.VoiceStream,
+        StreamResources.MediaStream,
+        StreamResources.NotificationStream,
+        StreamResources.AlarmStream,
+		StreamResources.FMStream,
+        StreamResources.MasterStream,
+        StreamResources.RemoteStream
+    };
+
+    /** Object that contains data for each slider */
+    private class StreamControl {
+        int streamType;
+        ViewGroup group;
+        ImageView icon;
+        SeekBar seekbarView;
+        int iconRes;
+        int iconMuteRes;
+    }
+
+    // Synchronize when accessing this
+    private ToneGenerator mToneGenerators[];
+    private Vibrator mVibrator;
+
+    private ContentObserver mSettingsObserver = new ContentObserver(this) {
+        @Override
+        public void onChange(boolean selfChange) {
+            mVolumeLinkNotification = Settings.System.getInt(mContext.getContentResolver(),
+                    Settings.System.VOLUME_LINK_NOTIFICATION, 1) == 1;
+            final int overlayStyle = Settings.System.getInt(mContext.getContentResolver(),
+                    Settings.System.MODE_VOLUME_OVERLAY, VOLUME_OVERLAY_EXPANDABLE);
+            changeOverlayStyle(overlayStyle);
+        }
+    };
+
+    private static AlertDialog sConfirmSafeVolumeDialog;
+    private static Object sConfirmSafeVolumeLock = new Object();
+
+    private static class WarningDialogReceiver extends BroadcastReceiver
+            implements DialogInterface.OnDismissListener {
+        private Context mContext;
+        private Dialog mDialog;
+
+        WarningDialogReceiver(Context context, Dialog dialog) {
+            mContext = context;
+            mDialog = dialog;
+            IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
+            context.registerReceiver(this, filter);
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            mDialog.cancel();
+            synchronized (sConfirmSafeVolumeLock) {
+                sConfirmSafeVolumeDialog = null;
+            }
+        }
+
+        public void onDismiss(DialogInterface unused) {
+            mContext.unregisterReceiver(this);
+            synchronized (sConfirmSafeVolumeLock) {
+                sConfirmSafeVolumeDialog = null;
+            }
+        }
+    }
+
+
+    public VolumePanel(final Context context, AudioService volumeService) {
+        mContext = context;
+        mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+        mAudioService = volumeService;
+
+        // For now, only show master volume if master volume is supported
+        boolean useMasterVolume = context.getResources().getBoolean(
+                com.android.internal.R.bool.config_useMasterVolume);
+        if (useMasterVolume) {
+            for (int i = 0; i < STREAMS.length; i++) {
+                StreamResources streamRes = STREAMS[i];
+                streamRes.show = (streamRes.streamType == STREAM_MASTER);
+            }
+        }
+
+        LayoutInflater inflater = (LayoutInflater) context
+                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        mView = inflater.inflate(R.layout.volume_adjust, null);
+        mView.setOnTouchListener(new View.OnTouchListener() {
+            public boolean onTouch(View v, MotionEvent event) {
+                resetTimeout();
+                return false;
+            }
+        });
+        mPanel = (ViewGroup) mView.findViewById(R.id.visible_panel);
+        mSliderGroup = (ViewGroup) mView.findViewById(R.id.slider_group);
+        mMoreButton = (ImageView) mView.findViewById(R.id.expand_button);
+        mDivider = (ImageView) mView.findViewById(R.id.expand_button_divider);
+
+        mDialog = new Dialog(context, R.style.Theme_Panel_Volume) {
+            public boolean onTouchEvent(MotionEvent event) {
+                if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
+                    forceTimeout();
+                    return true;
+                }
+                return false;
+            }
+        };
+        mDialog.setTitle("Volume control"); // No need to localize
+        mDialog.setContentView(mView);
+        mDialog.setOnDismissListener(new OnDismissListener() {
+            public void onDismiss(DialogInterface dialog) {
+                mActiveStreamType = -1;
+                mAudioManager.forceVolumeControlStream(mActiveStreamType);
+            }
+        });
+        // Change some window properties
+        Window window = mDialog.getWindow();
+        window.setGravity(Gravity.TOP);
+        LayoutParams lp = window.getAttributes();
+        lp.token = null;
+        // Offset from the top
+        lp.y = mContext.getResources().getDimensionPixelOffset(
+                com.android.internal.R.dimen.volume_panel_top);
+        lp.type = LayoutParams.TYPE_VOLUME_OVERLAY;
+        lp.width = LayoutParams.WRAP_CONTENT;
+        lp.height = LayoutParams.WRAP_CONTENT;
+        lp.privateFlags |= LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR;
+        window.setAttributes(lp);
+        window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL
+                | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
+
+        mToneGenerators = new ToneGenerator[AudioSystem.getNumStreamTypes()];
+        mVibrator = (Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
+        mVoiceCapable = context.getResources().getBoolean(R.bool.config_voice_capable);
+
+        // Get the user's preferences
+        mVolumeLinkNotification = Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.VOLUME_LINK_NOTIFICATION, 1) == 1;
+        final int chosenStyle = Settings.System.getInt(context.getContentResolver(),
+                Settings.System.MODE_VOLUME_OVERLAY, VOLUME_OVERLAY_EXPANDABLE);
+        changeOverlayStyle(chosenStyle);
+
+        context.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.VOLUME_LINK_NOTIFICATION), false,
+                mSettingsObserver);
+        context.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.MODE_VOLUME_OVERLAY), false,
+                mSettingsObserver);
+
+        // This is new with 4.2 it seems
+        boolean masterVolumeOnly = context.getResources().getBoolean(
+                com.android.internal.R.bool.config_useMasterVolume);
+        boolean masterVolumeKeySounds = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_useVolumeKeySounds);
+
+        mPlayMasterStreamTones = masterVolumeOnly && masterVolumeKeySounds;
+        // End this is new
+
+        mMoreButton.setOnClickListener(this);
+        listenToRingerMode();
+    }
+
+    private void listenToRingerMode() {
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
+        mContext.registerReceiver(new BroadcastReceiver() {
+
+            public void onReceive(Context context, Intent intent) {
+                final String action = intent.getAction();
+
+                if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
+                    removeMessages(MSG_RINGER_MODE_CHANGED);
+                    sendMessage(obtainMessage(MSG_RINGER_MODE_CHANGED));
+                }
+            }
+        }, filter);
+    }
+
+    private void changeOverlayStyle(int newStyle) {
+        Log.i("VolumePanel", "changeOverlayStyle : " + newStyle);
+        // Don't change to the same style
+        if (newStyle == mCurrentOverlayStyle) return;
+        switch (newStyle) {
+            case VOLUME_OVERLAY_SINGLE :
+                mMoreButton.setVisibility(View.GONE);
+                mDivider.setVisibility(View.GONE);
+                mShowCombinedVolumes = false;
+                mCurrentOverlayStyle = VOLUME_OVERLAY_SINGLE;
+                break;
+            case VOLUME_OVERLAY_EXPANDABLE :
+                mMoreButton.setVisibility(View.VISIBLE);
+                mDivider.setVisibility(View.VISIBLE);
+                mShowCombinedVolumes = true;
+                mCurrentOverlayStyle = VOLUME_OVERLAY_EXPANDABLE;
+                break;
+            case VOLUME_OVERLAY_EXPANDED :
+                mMoreButton.setVisibility(View.GONE);
+                mDivider.setVisibility(View.GONE);
+                mShowCombinedVolumes = true;
+                if (mCurrentOverlayStyle == VOLUME_OVERLAY_NONE) {
+                    addOtherVolumes();
+                    expand();
+                }
+                mCurrentOverlayStyle = VOLUME_OVERLAY_EXPANDED;
+                break;
+            case VOLUME_OVERLAY_NONE :
+                mShowCombinedVolumes = false;
+                mCurrentOverlayStyle = VOLUME_OVERLAY_NONE;
+                break;
+        }
+    }
+
+    private int getStreamMaxVolume(int streamType) {
+        if (streamType == STREAM_MASTER) {
+            return mAudioManager.getMasterMaxVolume();
+        } else if (streamType == AudioService.STREAM_REMOTE_MUSIC) {
+            return mAudioService.getRemoteStreamMaxVolume();
+        } else {
+            return mAudioManager.getStreamMaxVolume(streamType);
+        }
+    }
+
+    private int getStreamVolume(int streamType) {
+        if (streamType == STREAM_MASTER) {
+            return mAudioManager.getMasterVolume();
+        } else if (streamType == AudioService.STREAM_REMOTE_MUSIC) {
+            return mAudioService.getRemoteStreamVolume();
+        } else {
+            return mAudioManager.getStreamVolume(streamType);
+        }
+    }
+
+    private void setStreamVolume(int streamType, int index, int flags) {
+        if (streamType == STREAM_MASTER) {
+            mAudioManager.setMasterVolume(index, flags);
+        } else if (streamType == AudioService.STREAM_REMOTE_MUSIC) {
+            mAudioService.setRemoteStreamVolume(index);
+        } else {
+            mAudioManager.setStreamVolume(streamType, index, flags);
+        }
+    }
+
+    private boolean isMuted(int streamType) {
+        if (streamType == STREAM_MASTER) {
+            return mAudioManager.isMasterMute();
+        } else if (streamType == AudioService.STREAM_REMOTE_MUSIC) {
+            return (mAudioService.getRemoteStreamVolume() <= 0);
+        } else {
+            return mAudioManager.isStreamMute(streamType);
+        }
+    }
+
+    private void createSliders() {
+        LayoutInflater inflater = (LayoutInflater) mContext
+                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        mStreamControls = new HashMap<Integer, StreamControl>(STREAMS.length);
+        Resources res = mContext.getResources();
+        for (int i = 0; i < STREAMS.length; i++) {
+            StreamResources streamRes = STREAMS[i];
+            int streamType = streamRes.streamType;
+            StreamControl sc = new StreamControl();
+            sc.streamType = streamType;
+            sc.group = (ViewGroup) inflater.inflate(R.layout.volume_adjust_item, null);
+            sc.group.setTag(sc);
+            sc.icon = (ImageView) sc.group.findViewById(R.id.stream_icon);
+            sc.icon.setTag(sc);
+            sc.icon.setContentDescription(res.getString(streamRes.descRes));
+            sc.iconRes = streamRes.iconRes;
+            sc.iconMuteRes = streamRes.iconMuteRes;
+            sc.icon.setImageResource(sc.iconRes);
+            sc.icon.setOnClickListener(this);
+            sc.seekbarView = (SeekBar) sc.group.findViewById(R.id.seekbar);
+            int plusOne = (streamType == AudioSystem.STREAM_BLUETOOTH_SCO ||
+                    streamType == AudioSystem.STREAM_VOICE_CALL) ? 1 : 0;
+            sc.seekbarView.setMax(getStreamMaxVolume(streamType) + plusOne);
+            sc.seekbarView.setOnSeekBarChangeListener(this);
+            sc.seekbarView.setTag(sc);
+            mStreamControls.put(streamType, sc);
+        }
+    }
+
+    private void reorderSliders(int activeStreamType) {
+        mSliderGroup.removeAllViews();
+
+        StreamControl active = mStreamControls.get(activeStreamType);
+        if (active == null) {
+            Log.e("VolumePanel", "Missing stream type! - " + activeStreamType);
+            mActiveStreamType = -1;
+        } else {
+            mSliderGroup.addView(active.group);
+            mActiveStreamType = activeStreamType;
+            active.group.setVisibility(View.VISIBLE);
+            updateSlider(active);
+        }
+
+        addOtherVolumes();
+    }
+
+    private void addOtherVolumes() {
+        if (!mShowCombinedVolumes) return;
+
+        for (int i = 0; i < STREAMS.length; i++) {
+            // Skip the phone specific ones and the active one
+            final int streamType = STREAMS[i].streamType;
+            if (!STREAMS[i].show || streamType == mActiveStreamType) {
+                continue;
+            }
+            // Skip ring volume for non-phone devices
+            if (!mVoiceCapable && streamType == AudioManager.STREAM_RING) {
+                continue;
+            }
+            // Skip notification volume if linked with ring volume
+            if (mVoiceCapable && mVolumeLinkNotification &&
+                    streamType == AudioManager.STREAM_NOTIFICATION) {
+                continue;
+            }
+            StreamControl sc = mStreamControls.get(streamType);
+            mSliderGroup.addView(sc.group);
+            updateSlider(sc);
+        }
+    }
+
+    /** Update the mute and progress state of a slider */
+    private void updateSlider(StreamControl sc) {
+        sc.seekbarView.setProgress(getStreamVolume(sc.streamType));
+        final boolean muted = isMuted(sc.streamType);
+        sc.icon.setImageResource(muted ? sc.iconMuteRes : sc.iconRes);
+        if (sc.streamType == AudioManager.STREAM_RING &&
+                mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE) {
+            sc.icon.setImageResource(R.drawable.ic_audio_ring_notif_vibrate);
+        }
+        if (sc.streamType == AudioService.STREAM_REMOTE_MUSIC) {
+            // never disable touch interactions for remote playback, the muting is not tied to
+            // the state of the phone.
+            sc.seekbarView.setEnabled(true);
+        } else if (sc.streamType != mAudioManager.getMasterStreamType() && muted) {
+            sc.seekbarView.setEnabled(false);
+        } else {
+            sc.seekbarView.setEnabled(true);
+        }
+    }
+
+    private boolean isExpanded() {
+        return mMoreButton.getVisibility() != View.VISIBLE;
+    }
+
+    private void expand() {
+        final int count = mSliderGroup.getChildCount();
+        for (int i = 0; i < count; i++) {
+            if (mSliderGroup.getChildAt(i).getVisibility() != View.VISIBLE) {
+                mSliderGroup.getChildAt(i).setVisibility(View.VISIBLE);
+            }
+        }
+        mMoreButton.setVisibility(View.GONE);
+        mDivider.setVisibility(View.GONE);
+    }
+
+    private void hideSlider(int mActiveStreamType) {
+        final int count = mSliderGroup.getChildCount();
+        for (int i = 0; i < count; i++) {
+            StreamControl sc = (StreamControl) mSliderGroup.getChildAt(i).getTag();
+            if (mActiveStreamType == sc.streamType) {
+                mSliderGroup.getChildAt(i).setVisibility(View.GONE);
+            }
+        }
+    }
+
+    private void collapse() {
+        mMoreButton.setVisibility(View.VISIBLE);
+        mDivider.setVisibility(View.VISIBLE);
+        final int count = mSliderGroup.getChildCount();
+        for (int i = 1; i < count; i++) {
+            mSliderGroup.getChildAt(i).setVisibility(View.GONE);
+        }
+    }
+
+    private void updateStates() {
+        final int count = mSliderGroup.getChildCount();
+        for (int i = 0; i < count; i++) {
+            StreamControl sc = (StreamControl) mSliderGroup.getChildAt(i).getTag();
+            updateSlider(sc);
+        }
+    }
+
+    public void postVolumeChanged(int streamType, int flags) {
+        if (hasMessages(MSG_VOLUME_CHANGED)) return;
+        synchronized (this) {
+            if (mStreamControls == null) {
+                createSliders();
+            }
+        }
+        removeMessages(MSG_FREE_RESOURCES);
+        obtainMessage(MSG_VOLUME_CHANGED, streamType, flags).sendToTarget();
+    }
+
+    public void postRemoteVolumeChanged(int streamType, int flags) {
+        if (hasMessages(MSG_REMOTE_VOLUME_CHANGED)) return;
+        synchronized (this) {
+            if (mStreamControls == null) {
+                createSliders();
+            }
+        }
+        removeMessages(MSG_FREE_RESOURCES);
+        obtainMessage(MSG_REMOTE_VOLUME_CHANGED, streamType, flags).sendToTarget();
+    }
+
+    public void postRemoteSliderVisibility(boolean visible) {
+        obtainMessage(MSG_SLIDER_VISIBILITY_CHANGED,
+                AudioService.STREAM_REMOTE_MUSIC, visible ? 1 : 0).sendToTarget();
+    }
+
+    /**
+     * Called by AudioService when it has received new remote playback information that
+     * would affect the VolumePanel display (mainly volumes). The difference with
+     * {@link #postRemoteVolumeChanged(int, int)} is that the handling of the posted message
+     * (MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN) will only update the volume slider if it is being
+     * displayed.
+     * This special code path is due to the fact that remote volume updates arrive to AudioService
+     * asynchronously. So after AudioService has sent the volume update (which should be treated
+     * as a request to update the volume), the application will likely set a new volume. If the UI
+     * is still up, we need to refresh the display to show this new value.
+     */
+    public void postHasNewRemotePlaybackInfo() {
+        if (hasMessages(MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN)) return;
+        // don't create or prevent resources to be freed, if they disappear, this update came too
+        //   late and shouldn't warrant the panel to be displayed longer
+        obtainMessage(MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN).sendToTarget();
+    }
+
+    public void postMasterVolumeChanged(int flags) {
+        postVolumeChanged(STREAM_MASTER, flags);
+    }
+
+    public void postMuteChanged(int streamType, int flags) {
+        if (hasMessages(MSG_VOLUME_CHANGED)) return;
+        synchronized (this) {
+            if (mStreamControls == null) {
+                createSliders();
+            }
+        }
+        removeMessages(MSG_FREE_RESOURCES);
+        obtainMessage(MSG_MUTE_CHANGED, streamType, flags).sendToTarget();
+    }
+
+    public void postMasterMuteChanged(int flags) {
+        postMuteChanged(STREAM_MASTER, flags);
+    }
+
+    public void postDisplaySafeVolumeWarning() {
+        if (hasMessages(MSG_DISPLAY_SAFE_VOLUME_WARNING)) return;
+        obtainMessage(MSG_DISPLAY_SAFE_VOLUME_WARNING, 0, 0).sendToTarget();
+    }
+
+    /**
+     * Override this if you have other work to do when the volume changes (for
+     * example, vibrating, playing a sound, etc.). Make sure to call through to
+     * the superclass implementation.
+     */
+    protected void onVolumeChanged(int streamType, int flags) {
+
+        if (LOGD) Log.d(TAG, "onVolumeChanged(streamType: " + streamType + ", flags: " + flags + ")");
+
+        if ((flags & AudioManager.FLAG_SHOW_UI) != 0) {
+            synchronized (this) {
+                if (streamType != mActiveStreamType) {
+                    if (mCurrentOverlayStyle == VOLUME_OVERLAY_EXPANDABLE) {
+                        hideSlider(mActiveStreamType);
+                    }
+                    reorderSliders(streamType);
+                }
+                onShowVolumeChanged(streamType, flags);
+            }
+        }
+
+        if ((flags & AudioManager.FLAG_PLAY_SOUND) != 0 && ! mRingIsSilent) {
+            removeMessages(MSG_PLAY_SOUND);
+            sendMessageDelayed(obtainMessage(MSG_PLAY_SOUND, streamType, flags), PLAY_SOUND_DELAY);
+        }
+
+        if ((flags & AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE) != 0) {
+            removeMessages(MSG_PLAY_SOUND);
+            removeMessages(MSG_VIBRATE);
+            onStopSounds();
+        }
+
+        removeMessages(MSG_FREE_RESOURCES);
+        sendMessageDelayed(obtainMessage(MSG_FREE_RESOURCES), FREE_DELAY);
+
+        resetTimeout();
+    }
+
+    protected void onMuteChanged(int streamType, int flags) {
+
+        if (LOGD) Log.d(TAG, "onMuteChanged(streamType: " + streamType + ", flags: " + flags + ")");
+
+        StreamControl sc = mStreamControls.get(streamType);
+        if (sc != null) {
+            sc.icon.setImageResource(isMuted(sc.streamType) ? sc.iconMuteRes : sc.iconRes);
+        }
+
+        onVolumeChanged(streamType, flags);
+    }
+
+    protected void onShowVolumeChanged(int streamType, int flags) {
+        int index = getStreamVolume(streamType);
+
+        mRingIsSilent = false;
+
+        if (LOGD) {
+            Log.d(TAG, "onShowVolumeChanged(streamType: " + streamType
+                    + ", flags: " + flags + "), index: " + index);
+        }
+
+        // get max volume for progress bar
+
+        int max = getStreamMaxVolume(streamType);
+
+        switch (streamType) {
+
+            case AudioManager.STREAM_RING: {
+//                setRingerIcon();
+                Uri ringuri = RingtoneManager.getActualDefaultRingtoneUri(
+                        mContext, RingtoneManager.TYPE_RINGTONE);
+                if (ringuri == null) {
+                    mRingIsSilent = true;
+                }
+                break;
+            }
+
+            case AudioManager.STREAM_MUSIC: {
+                // Special case for when Bluetooth is active for music
+                if ((mAudioManager.getDevicesForStream(AudioManager.STREAM_MUSIC) &
+                        (AudioManager.DEVICE_OUT_BLUETOOTH_A2DP |
+                        AudioManager.DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
+                        AudioManager.DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)) != 0) {
+                    setMusicIcon(R.drawable.ic_audio_bt, R.drawable.ic_audio_bt_mute);
+                } else {
+                    setMusicIcon(R.drawable.ic_audio_vol, R.drawable.ic_audio_vol_mute);
+                }
+                break;
+            }
+ 
+            case AudioManager.STREAM_FM: {
+                setMusicIcon(R.drawable.ic_audio_vol, R.drawable.ic_audio_vol_mute);
+                break;
+            }
+
+            case AudioManager.STREAM_VOICE_CALL: {
+                /*
+                 * For in-call voice call volume, there is no inaudible volume.
+                 * Rescale the UI control so the progress bar doesn't go all
+                 * the way to zero and don't show the mute icon.
+                 */
+                index++;
+                max++;
+                break;
+            }
+
+            case AudioManager.STREAM_ALARM: {
+                break;
+            }
+
+            case AudioManager.STREAM_NOTIFICATION: {
+                Uri ringuri = RingtoneManager.getActualDefaultRingtoneUri(
+                        mContext, RingtoneManager.TYPE_NOTIFICATION);
+                if (ringuri == null) {
+                    mRingIsSilent = true;
+                }
+                break;
+            }
+
+            case AudioManager.STREAM_BLUETOOTH_SCO: {
+                /*
+                 * For in-call voice call volume, there is no inaudible volume.
+                 * Rescale the UI control so the progress bar doesn't go all
+                 * the way to zero and don't show the mute icon.
+                 */
+                index++;
+                max++;
+                break;
+            }
+
+            case AudioService.STREAM_REMOTE_MUSIC: {
+                if (LOGD) { Log.d(TAG, "showing remote volume "+index+" over "+ max); }
+                break;
+            }
+        }
+
+        StreamControl sc = mStreamControls.get(streamType);
+        if (sc != null) {
+            if (sc.seekbarView.getMax() != max) {
+                sc.seekbarView.setMax(max);
+            }
+
+            sc.seekbarView.setProgress(index);
+            if (((flags & AudioManager.FLAG_FIXED_VOLUME) != 0) ||
+                    (streamType != mAudioManager.getMasterStreamType() &&
+                     streamType != AudioService.STREAM_REMOTE_MUSIC &&
+                     isMuted(streamType))) {
+                sc.seekbarView.setEnabled(false);
+            } else {
+                sc.seekbarView.setEnabled(true);
+            }
+        }
+
+        // Only Show if style needs it
+        if (!mDialog.isShowing() && mCurrentOverlayStyle != VOLUME_OVERLAY_NONE) {
+            int stream = (streamType == AudioService.STREAM_REMOTE_MUSIC) ? -1 : streamType;
+            // when the stream is for remote playback, use -1 to reset the stream type evaluation
+            mAudioManager.forceVolumeControlStream(stream);
+            mDialog.setContentView(mView);
+            // Showing dialog - use collapsed state
+            if (mShowCombinedVolumes && mCurrentOverlayStyle != VOLUME_OVERLAY_EXPANDED) {
+                collapse();
+            }
+            // If just changed the style and we need to expand
+            if (mCurrentOverlayStyle == VOLUME_OVERLAY_EXPANDED) {
+                expand();
+            }
+            mDialog.show();
+        }
+
+        // Do a little vibrate if applicable (only when going into vibrate mode)
+        if ((streamType != AudioService.STREAM_REMOTE_MUSIC) &&
+                ((flags & AudioManager.FLAG_VIBRATE) != 0) &&
+                mAudioService.isStreamAffectedByRingerMode(streamType) &&
+                mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE) {
+            sendMessageDelayed(obtainMessage(MSG_VIBRATE), VIBRATE_DELAY);
+        }
+    }
+
+    protected void onPlaySound(int streamType, int flags) {
+
+        // If preference is no sound - just exit here
+        if (Settings.System.getInt(mContext.getContentResolver(),
+                 Settings.System.VOLUME_ADJUST_SOUNDS_ENABLED, 1) == 0) {
+             return;
+         }
+
+        if (hasMessages(MSG_STOP_SOUNDS)) {
+            removeMessages(MSG_STOP_SOUNDS);
+            // Force stop right now
+            onStopSounds();
+        }
+
+        synchronized (this) {
+            ToneGenerator toneGen = getOrCreateToneGenerator(streamType);
+            if (toneGen != null) {
+                toneGen.startTone(ToneGenerator.TONE_PROP_BEEP);
+                sendMessageDelayed(obtainMessage(MSG_STOP_SOUNDS), BEEP_DURATION);
+            }
+        }
+    }
+
+    protected void onStopSounds() {
+
+        synchronized (this) {
+            int numStreamTypes = AudioSystem.getNumStreamTypes();
+            for (int i = numStreamTypes - 1; i >= 0; i--) {
+                ToneGenerator toneGen = mToneGenerators[i];
+                if (toneGen != null) {
+                    toneGen.stopTone();
+                }
+            }
+        }
+    }
+
+    protected void onVibrate() {
+
+        // Make sure we ended up in vibrate ringer mode
+        if (mAudioManager.getRingerMode() != AudioManager.RINGER_MODE_VIBRATE) {
+            return;
+        }
+
+        mVibrator.vibrate(VIBRATE_DURATION);
+    }
+
+    protected void onRemoteVolumeChanged(int streamType, int flags) {
+        // streamType is the real stream type being affected, but for the UI sliders, we
+        // refer to AudioService.STREAM_REMOTE_MUSIC. We still play the beeps on the real
+        // stream type.
+        if (LOGD) Log.d(TAG, "onRemoteVolumeChanged(stream:"+streamType+", flags: " + flags + ")");
+
+        if (((flags & AudioManager.FLAG_SHOW_UI) != 0) || mDialog.isShowing()) {
+            synchronized (this) {
+                if (mActiveStreamType != AudioService.STREAM_REMOTE_MUSIC) {
+                    reorderSliders(AudioService.STREAM_REMOTE_MUSIC);
+                }
+                onShowVolumeChanged(AudioService.STREAM_REMOTE_MUSIC, flags);
+            }
+        } else {
+            if (LOGD) Log.d(TAG, "not calling onShowVolumeChanged(), no FLAG_SHOW_UI or no UI");
+        }
+
+        if ((flags & AudioManager.FLAG_PLAY_SOUND) != 0 && ! mRingIsSilent) {
+            removeMessages(MSG_PLAY_SOUND);
+            sendMessageDelayed(obtainMessage(MSG_PLAY_SOUND, streamType, flags), PLAY_SOUND_DELAY);
+        }
+
+        if ((flags & AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE) != 0) {
+            removeMessages(MSG_PLAY_SOUND);
+            removeMessages(MSG_VIBRATE);
+            onStopSounds();
+        }
+
+        removeMessages(MSG_FREE_RESOURCES);
+        sendMessageDelayed(obtainMessage(MSG_FREE_RESOURCES), FREE_DELAY);
+
+        resetTimeout();
+    }
+
+    protected void onRemoteVolumeUpdateIfShown() {
+        if (LOGD) Log.d(TAG, "onRemoteVolumeUpdateIfShown()");
+        if (mDialog.isShowing()
+                && (mActiveStreamType == AudioService.STREAM_REMOTE_MUSIC)
+                && (mStreamControls != null)) {
+            onShowVolumeChanged(AudioService.STREAM_REMOTE_MUSIC, 0);
+        }
+    }
+
+
+    /**
+     * Handler for MSG_SLIDER_VISIBILITY_CHANGED
+     * Hide or show a slider
+     * @param streamType can be a valid stream type value, or VolumePanel.STREAM_MASTER,
+     *                   or AudioService.STREAM_REMOTE_MUSIC
+     * @param visible
+     */
+    synchronized protected void onSliderVisibilityChanged(int streamType, int visible) {
+        if (LOGD) Log.d(TAG, "onSliderVisibilityChanged(stream="+streamType+", visi="+visible+")");
+        boolean isVisible = (visible == 1);
+        for (int i = STREAMS.length - 1 ; i >= 0 ; i--) {
+            StreamResources streamRes = STREAMS[i];
+            if (streamRes.streamType == streamType) {
+                streamRes.show = isVisible;
+                if (!isVisible && (mActiveStreamType == streamType)) {
+                    mActiveStreamType = -1;
+                }
+                break;
+            }
+        }
+    }
+
+    protected void onDisplaySafeVolumeWarning() {
+        synchronized (sConfirmSafeVolumeLock) {
+            if (sConfirmSafeVolumeDialog != null) {
+                return;
+            }
+            sConfirmSafeVolumeDialog = new AlertDialog.Builder(mContext)
+                    .setMessage(com.android.internal.R.string.safe_media_volume_warning)
+                    .setPositiveButton(com.android.internal.R.string.yes,
+                                        new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            mAudioService.disableSafeMediaVolume();
+                        }
+                    })
+                    .setNegativeButton(com.android.internal.R.string.no, null)
+                    .setIconAttribute(android.R.attr.alertDialogIcon)
+                    .create();
+            final WarningDialogReceiver warning = new WarningDialogReceiver(mContext,
+                    sConfirmSafeVolumeDialog);
+
+            sConfirmSafeVolumeDialog.setOnDismissListener(warning);
+            sConfirmSafeVolumeDialog.getWindow().setType(
+                                                    WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
+            sConfirmSafeVolumeDialog.show();
+        }
+    }
+
+    /**
+     * Lock on this VolumePanel instance as long as you use the returned ToneGenerator.
+     */
+    private ToneGenerator getOrCreateToneGenerator(int streamType) {
+        if (streamType == STREAM_MASTER) {
+            // For devices that use the master volume setting only but still want to
+            // play a volume-changed tone, direct the master volume pseudostream to
+            // the system stream's tone generator.
+            if (mPlayMasterStreamTones) {
+                streamType = AudioManager.STREAM_SYSTEM;
+            } else {
+                return null;
+            }
+        }
+        synchronized (this) {
+            if (mToneGenerators[streamType] == null) {
+                try {
+                    mToneGenerators[streamType] = new ToneGenerator(streamType, MAX_VOLUME);
+                } catch (RuntimeException e) {
+                    if (LOGD) {
+                        Log.d(TAG, "ToneGenerator constructor failed with "
+                                + "RuntimeException: " + e);
+                    }
+                }
+            }
+            return mToneGenerators[streamType];
+        }
+    }
+
+
+    /**
+     * Switch between icons because Bluetooth music is same as music volume, but with
+     * different icons.
+     */
+    private void setMusicIcon(int resId, int resMuteId) {
+        StreamControl sc = mStreamControls.get(AudioManager.STREAM_MUSIC);
+        if (sc != null) {
+            sc.iconRes = resId;
+            sc.iconMuteRes = resMuteId;
+            sc.icon.setImageResource(isMuted(sc.streamType) ? sc.iconMuteRes : sc.iconRes);
+        }
+    }
+
+    protected void onFreeResources() {
+        synchronized (this) {
+            for (int i = mToneGenerators.length - 1; i >= 0; i--) {
+                if (mToneGenerators[i] != null) {
+                    mToneGenerators[i].release();
+                }
+                mToneGenerators[i] = null;
+            }
+        }
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        switch (msg.what) {
+
+            case MSG_VOLUME_CHANGED: {
+                onVolumeChanged(msg.arg1, msg.arg2);
+                break;
+            }
+
+            case MSG_MUTE_CHANGED: {
+                onMuteChanged(msg.arg1, msg.arg2);
+                break;
+            }
+
+            case MSG_FREE_RESOURCES: {
+                onFreeResources();
+                break;
+            }
+
+            case MSG_STOP_SOUNDS: {
+                onStopSounds();
+                break;
+            }
+
+            case MSG_PLAY_SOUND: {
+                onPlaySound(msg.arg1, msg.arg2);
+                break;
+            }
+
+            case MSG_VIBRATE: {
+                onVibrate();
+                break;
+            }
+
+            case MSG_TIMEOUT: {
+                if (mDialog.isShowing()) {
+                    mDialog.dismiss();
+                    mActiveStreamType = -1;
+                }
+                break;
+            }
+            case MSG_RINGER_MODE_CHANGED: {
+                if (mDialog.isShowing()) {
+                    updateStates();
+                }
+                break;
+            }
+
+            case MSG_REMOTE_VOLUME_CHANGED: {
+                onRemoteVolumeChanged(msg.arg1, msg.arg2);
+                break;
+            }
+
+            case MSG_REMOTE_VOLUME_UPDATE_IF_SHOWN:
+                onRemoteVolumeUpdateIfShown();
+                break;
+
+            case MSG_SLIDER_VISIBILITY_CHANGED:
+                onSliderVisibilityChanged(msg.arg1, msg.arg2);
+                break;
+
+            case MSG_DISPLAY_SAFE_VOLUME_WARNING:
+                onDisplaySafeVolumeWarning();
+                break;
+        }
+    }
+
+    private void resetTimeout() {
+        removeMessages(MSG_TIMEOUT);
+        sendMessageDelayed(obtainMessage(MSG_TIMEOUT), TIMEOUT_DELAY);
+    }
+
+    private void forceTimeout() {
+        removeMessages(MSG_TIMEOUT);
+        sendMessage(obtainMessage(MSG_TIMEOUT));
+    }
+
+    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+        final Object tag = seekBar.getTag();
+        if (fromUser && tag instanceof StreamControl) {
+            StreamControl sc = (StreamControl) tag;
+            if (getStreamVolume(sc.streamType) != progress) {
+                setStreamVolume(sc.streamType, progress, 0);
+            }
+        }
+        resetTimeout();
+    }
+
+    public void onStartTrackingTouch(SeekBar seekBar) {
+    }
+
+    public void onStopTrackingTouch(SeekBar seekBar) {
+        final Object tag = seekBar.getTag();
+        if (tag instanceof StreamControl) {
+            StreamControl sc = (StreamControl) tag;
+            // because remote volume updates are asynchronous, AudioService might have received
+            // a new remote volume value since the finger adjusted the slider. So when the
+            // progress of the slider isn't being tracked anymore, adjust the slider to the last
+            // "published" remote volume value, so the UI reflects the actual volume.
+            if (sc.streamType == AudioService.STREAM_REMOTE_MUSIC) {
+                seekBar.setProgress(getStreamVolume(AudioService.STREAM_REMOTE_MUSIC));
+            }
+        }
+    }
+
+    public void onClick(View v) {
+        if (v == mMoreButton) {
+            expand();
+        } else if (v instanceof ImageView) {
+            Intent volumeSettings = new Intent(android.provider.Settings.ACTION_SOUND_SETTINGS);
+            volumeSettings.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
+            forceTimeout();
+            mContext.startActivity(volumeSettings);
+            return;
+        }
+        resetTimeout();
+    }
+}
diff --git a/media/java/android/media/AudioManager.java b/media/java/android/media/AudioManager.java
index ac2588d..ac0b1ab 100644
--- a/media/java/android/media/AudioManager.java
+++ b/media/java/android/media/AudioManager.java
@@ -1,2539 +1,2553 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.media;
-
-import android.annotation.SdkConstant;
-import android.annotation.SdkConstant.SdkConstantType;
-import android.app.PendingIntent;
-import android.app.ProfileGroup;
-import android.app.ProfileManager;
-import android.bluetooth.BluetoothDevice;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Binder;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.Message;
-import android.os.RemoteException;
-import android.os.SystemClock;
-import android.os.ServiceManager;
-import android.provider.Settings;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.Surface;
-import android.view.VolumePanel;
-import android.view.WindowManager;
-
-import java.util.HashMap;
-
-/**
- * AudioManager provides access to volume and ringer mode control.
- * <p>
- * Use <code>Context.getSystemService(Context.AUDIO_SERVICE)</code> to get
- * an instance of this class.
- */
-public class AudioManager {
-
-    private final Context mContext;
-    private long mVolumeKeyUpTime;
-    private final boolean mUseMasterVolume;
-    private final boolean mUseVolumeKeySounds;
-    private static String TAG = "AudioManager";
-    private final ProfileManager mProfileManager;
-    private final WindowManager mWindowManager;
-
-    /**
-     * Broadcast intent, a hint for applications that audio is about to become
-     * 'noisy' due to a change in audio outputs. For example, this intent may
-     * be sent when a wired headset is unplugged, or when an A2DP audio
-     * sink is disconnected, and the audio system is about to automatically
-     * switch audio route to the speaker. Applications that are controlling
-     * audio streams may consider pausing, reducing volume or some other action
-     * on receipt of this intent so as not to surprise the user with audio
-     * from the speaker.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_AUDIO_BECOMING_NOISY = "android.media.AUDIO_BECOMING_NOISY";
-
-    /**
-     * Sticky broadcast intent action indicating that the ringer mode has
-     * changed. Includes the new ringer mode.
-     *
-     * @see #EXTRA_RINGER_MODE
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String RINGER_MODE_CHANGED_ACTION = "android.media.RINGER_MODE_CHANGED";
-
-    /**
-     * The new ringer mode.
-     *
-     * @see #RINGER_MODE_CHANGED_ACTION
-     * @see #RINGER_MODE_NORMAL
-     * @see #RINGER_MODE_SILENT
-     * @see #RINGER_MODE_VIBRATE
-     */
-    public static final String EXTRA_RINGER_MODE = "android.media.EXTRA_RINGER_MODE";
-
-    /**
-     * Broadcast intent action indicating that the vibrate setting has
-     * changed. Includes the vibrate type and its new setting.
-     *
-     * @see #EXTRA_VIBRATE_TYPE
-     * @see #EXTRA_VIBRATE_SETTING
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String VIBRATE_SETTING_CHANGED_ACTION =
-        "android.media.VIBRATE_SETTING_CHANGED";
-
-    /**
-     * @hide Broadcast intent when the volume for a particular stream type changes.
-     * Includes the stream, the new volume and previous volumes.
-     * Notes:
-     *  - for internal platform use only, do not make public,
-     *  - never used for "remote" volume changes
-     *
-     * @see #EXTRA_VOLUME_STREAM_TYPE
-     * @see #EXTRA_VOLUME_STREAM_VALUE
-     * @see #EXTRA_PREV_VOLUME_STREAM_VALUE
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String VOLUME_CHANGED_ACTION = "android.media.VOLUME_CHANGED_ACTION";
-
-    /**
-     * @hide Broadcast intent when the master volume changes.
-     * Includes the new volume
-     *
-     * @see #EXTRA_MASTER_VOLUME_VALUE
-     * @see #EXTRA_PREV_MASTER_VOLUME_VALUE
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String MASTER_VOLUME_CHANGED_ACTION =
-        "android.media.MASTER_VOLUME_CHANGED_ACTION";
-
-    /**
-     * @hide Broadcast intent when the master mute state changes.
-     * Includes the the new volume
-     *
-     * @see #EXTRA_MASTER_VOLUME_MUTED
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String MASTER_MUTE_CHANGED_ACTION =
-        "android.media.MASTER_MUTE_CHANGED_ACTION";
-
-    /**
-     * The new vibrate setting for a particular type.
-     *
-     * @see #VIBRATE_SETTING_CHANGED_ACTION
-     * @see #EXTRA_VIBRATE_TYPE
-     * @see #VIBRATE_SETTING_ON
-     * @see #VIBRATE_SETTING_OFF
-     * @see #VIBRATE_SETTING_ONLY_SILENT
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
-     */
-    public static final String EXTRA_VIBRATE_SETTING = "android.media.EXTRA_VIBRATE_SETTING";
-
-    /**
-     * The vibrate type whose setting has changed.
-     *
-     * @see #VIBRATE_SETTING_CHANGED_ACTION
-     * @see #VIBRATE_TYPE_NOTIFICATION
-     * @see #VIBRATE_TYPE_RINGER
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
-     */
-    public static final String EXTRA_VIBRATE_TYPE = "android.media.EXTRA_VIBRATE_TYPE";
-
-    /**
-     * @hide The stream type for the volume changed intent.
-     */
-    public static final String EXTRA_VOLUME_STREAM_TYPE = "android.media.EXTRA_VOLUME_STREAM_TYPE";
-
-    /**
-     * @hide The volume associated with the stream for the volume changed intent.
-     */
-    public static final String EXTRA_VOLUME_STREAM_VALUE =
-        "android.media.EXTRA_VOLUME_STREAM_VALUE";
-
-    /**
-     * @hide The previous volume associated with the stream for the volume changed intent.
-     */
-    public static final String EXTRA_PREV_VOLUME_STREAM_VALUE =
-        "android.media.EXTRA_PREV_VOLUME_STREAM_VALUE";
-
-    /**
-     * @hide The new master volume value for the master volume changed intent.
-     * Value is integer between 0 and 100 inclusive.
-     */
-    public static final String EXTRA_MASTER_VOLUME_VALUE =
-        "android.media.EXTRA_MASTER_VOLUME_VALUE";
-
-    /**
-     * @hide The previous master volume value for the master volume changed intent.
-     * Value is integer between 0 and 100 inclusive.
-     */
-    public static final String EXTRA_PREV_MASTER_VOLUME_VALUE =
-        "android.media.EXTRA_PREV_MASTER_VOLUME_VALUE";
-
-    /**
-     * @hide The new master volume mute state for the master mute changed intent.
-     * Value is boolean
-     */
-    public static final String EXTRA_MASTER_VOLUME_MUTED =
-        "android.media.EXTRA_MASTER_VOLUME_MUTED";
-
-    /** The audio stream for phone calls */
-    public static final int STREAM_VOICE_CALL = AudioSystem.STREAM_VOICE_CALL;
-    /** The audio stream for system sounds */
-    public static final int STREAM_SYSTEM = AudioSystem.STREAM_SYSTEM;
-    /** The audio stream for the phone ring */
-    public static final int STREAM_RING = AudioSystem.STREAM_RING;
-    /** The audio stream for music playback */
-    public static final int STREAM_MUSIC = AudioSystem.STREAM_MUSIC;
-    /** The audio stream for alarms */
-    public static final int STREAM_ALARM = AudioSystem.STREAM_ALARM;
-    /** The audio stream for notifications */
-    public static final int STREAM_NOTIFICATION = AudioSystem.STREAM_NOTIFICATION;
-    /** @hide The audio stream for phone calls when connected to bluetooth */
-    public static final int STREAM_BLUETOOTH_SCO = AudioSystem.STREAM_BLUETOOTH_SCO;
-    /** @hide The audio stream for enforced system sounds in certain countries (e.g camera in Japan) */
-    public static final int STREAM_SYSTEM_ENFORCED = AudioSystem.STREAM_SYSTEM_ENFORCED;
-    /** The audio stream for DTMF Tones */
-    public static final int STREAM_DTMF = AudioSystem.STREAM_DTMF;
-    /** @hide The audio stream for text to speech (TTS) */
-    public static final int STREAM_TTS = AudioSystem.STREAM_TTS;
-    /** Number of audio streams */
-    /**
-     * @deprecated Use AudioSystem.getNumStreamTypes() instead
-     */
-    @Deprecated public static final int NUM_STREAMS = AudioSystem.NUM_STREAMS;
-
-
-    /**  @hide Default volume index values for audio streams */
-    public static final int[] DEFAULT_STREAM_VOLUME = new int[] {
-        4,  // STREAM_VOICE_CALL
-        7,  // STREAM_SYSTEM
-        5,  // STREAM_RING
-        11, // STREAM_MUSIC
-        6,  // STREAM_ALARM
-        5,  // STREAM_NOTIFICATION
-        7,  // STREAM_BLUETOOTH_SCO
-        7,  // STREAM_SYSTEM_ENFORCED
-        11, // STREAM_DTMF
-        11  // STREAM_TTS
-    };
-
-    /**
-     * Increase the ringer volume.
-     *
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     */
-    public static final int ADJUST_RAISE = 1;
-
-    /**
-     * Decrease the ringer volume.
-     *
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     */
-    public static final int ADJUST_LOWER = -1;
-
-    /**
-     * Maintain the previous ringer volume. This may be useful when needing to
-     * show the volume toast without actually modifying the volume.
-     *
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     */
-    public static final int ADJUST_SAME = 0;
-
-    // Flags should be powers of 2!
-
-    /**
-     * Show a toast containing the current volume.
-     *
-     * @see #adjustStreamVolume(int, int, int)
-     * @see #adjustVolume(int, int)
-     * @see #setStreamVolume(int, int, int)
-     * @see #setRingerMode(int)
-     */
-    public static final int FLAG_SHOW_UI = 1 << 0;
-
-    /**
-     * Whether to include ringer modes as possible options when changing volume.
-     * For example, if true and volume level is 0 and the volume is adjusted
-     * with {@link #ADJUST_LOWER}, then the ringer mode may switch the silent or
-     * vibrate mode.
-     * <p>
-     * By default this is on for the ring stream. If this flag is included,
-     * this behavior will be present regardless of the stream type being
-     * affected by the ringer mode.
-     *
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     */
-    public static final int FLAG_ALLOW_RINGER_MODES = 1 << 1;
-
-    /**
-     * Whether to play a sound when changing the volume.
-     * <p>
-     * If this is given to {@link #adjustVolume(int, int)} or
-     * {@link #adjustSuggestedStreamVolume(int, int, int)}, it may be ignored
-     * in some cases (for example, the decided stream type is not
-     * {@link AudioManager#STREAM_RING}, or the volume is being adjusted
-     * downward).
-     *
-     * @see #adjustStreamVolume(int, int, int)
-     * @see #adjustVolume(int, int)
-     * @see #setStreamVolume(int, int, int)
-     */
-    public static final int FLAG_PLAY_SOUND = 1 << 2;
-
-    /**
-     * Removes any sounds/vibrate that may be in the queue, or are playing (related to
-     * changing volume).
-     */
-    public static final int FLAG_REMOVE_SOUND_AND_VIBRATE = 1 << 3;
-
-    /**
-     * Whether to vibrate if going into the vibrate ringer mode.
-     */
-    public static final int FLAG_VIBRATE = 1 << 4;
-
-    /**
-     * Indicates to VolumePanel that the volume slider should be disabled as user
-     * cannot change the stream volume
-     * @hide
-     */
-    public static final int FLAG_FIXED_VOLUME = 1 << 5;
-
-    /**
-     * Ringer mode that will be silent and will not vibrate. (This overrides the
-     * vibrate setting.)
-     *
-     * @see #setRingerMode(int)
-     * @see #getRingerMode()
-     */
-    public static final int RINGER_MODE_SILENT = 0;
-
-    /**
-     * Ringer mode that will be silent and will vibrate. (This will cause the
-     * phone ringer to always vibrate, but the notification vibrate to only
-     * vibrate if set.)
-     *
-     * @see #setRingerMode(int)
-     * @see #getRingerMode()
-     */
-    public static final int RINGER_MODE_VIBRATE = 1;
-
-    /**
-     * Ringer mode that may be audible and may vibrate. It will be audible if
-     * the volume before changing out of this mode was audible. It will vibrate
-     * if the vibrate setting is on.
-     *
-     * @see #setRingerMode(int)
-     * @see #getRingerMode()
-     */
-    public static final int RINGER_MODE_NORMAL = 2;
-
-    // maximum valid ringer mode value. Values must start from 0 and be contiguous.
-    private static final int RINGER_MODE_MAX = RINGER_MODE_NORMAL;
-
-    /**
-     * Vibrate type that corresponds to the ringer.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @see #shouldVibrate(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
-    public static final int VIBRATE_TYPE_RINGER = 0;
-
-    /**
-     * Vibrate type that corresponds to notifications.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @see #shouldVibrate(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
-    public static final int VIBRATE_TYPE_NOTIFICATION = 1;
-
-    /**
-     * Vibrate setting that suggests to never vibrate.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
-    public static final int VIBRATE_SETTING_OFF = 0;
-
-    /**
-     * Vibrate setting that suggests to vibrate when possible.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
-    public static final int VIBRATE_SETTING_ON = 1;
-
-    /**
-     * Vibrate setting that suggests to only vibrate when in the vibrate ringer
-     * mode.
-     *
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
-    public static final int VIBRATE_SETTING_ONLY_SILENT = 2;
-
-    /**
-     * Suggests using the default stream type. This may not be used in all
-     * places a stream type is needed.
-     */
-    public static final int USE_DEFAULT_STREAM_TYPE = Integer.MIN_VALUE;
-
-    private static IAudioService sService;
-
-    /**
-     * @hide
-     */
-    public AudioManager(Context context) {
-        mContext = context;
-        mUseMasterVolume = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_useMasterVolume);
-        mUseVolumeKeySounds = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_useVolumeKeySounds);
-        mProfileManager = (ProfileManager) context.getSystemService(Context.PROFILE_SERVICE);
-        mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-    }
-
-    private static IAudioService getService()
-    {
-        if (sService != null) {
-            return sService;
-        }
-        IBinder b = ServiceManager.getService(Context.AUDIO_SERVICE);
-        sService = IAudioService.Stub.asInterface(b);
-        return sService;
-    }
-
-    /**
-     * @hide
-     */
-    public void preDispatchKeyEvent(KeyEvent event, int stream) {
-        /*
-         * If the user hits another key within the play sound delay, then
-         * cancel the sound
-         */
-        int keyCode = event.getKeyCode();
-        if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP
-                && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE
-                && mVolumeKeyUpTime + VolumePanel.PLAY_SOUND_DELAY
-                        > SystemClock.uptimeMillis()) {
-            /*
-             * The user has hit another key during the delay (e.g., 300ms)
-             * since the last volume key up, so cancel any sounds.
-             */
-            if (mUseMasterVolume) {
-                adjustMasterVolume(ADJUST_SAME, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
-            } else {
-                adjustSuggestedStreamVolume(ADJUST_SAME,
-                        stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
-            }
-        }
-    }
-
-    /**
-     * @hide
-     */
-    public void handleKeyDown(KeyEvent event, int stream) {
-        int keyCode = event.getKeyCode();
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_VOLUME_UP:
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-                /*
-                 * Adjust the volume in on key down since it is more
-                 * responsive to the user.
-                 */
-                int direction;
-                int swapKeys = Settings.System.getInt(mContext.getContentResolver(),
-                        Settings.System.SWAP_VOLUME_KEYS_ON_ROTATION, 0);
-                int rotation = mWindowManager.getDefaultDisplay().getRotation();
-                if (swapKeys == 1 // phone or hybrid
-                        && (rotation == Surface.ROTATION_90
-                        || rotation == Surface.ROTATION_180)) {
-                    direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP
-                            ? ADJUST_LOWER
-                            : ADJUST_RAISE;
-                } else if (swapKeys == 2 // tablet
-                        && (rotation == Surface.ROTATION_180
-                        || rotation == Surface.ROTATION_270)) {
-                    direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP
-                            ? ADJUST_LOWER
-                            : ADJUST_RAISE;
-                } else {
-                    direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP
-                            ? ADJUST_RAISE
-                            : ADJUST_LOWER;
-                }
-                int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
-
-                if (mUseMasterVolume) {
-                    adjustMasterVolume(direction, flags);
-                } else {
-                    adjustSuggestedStreamVolume(direction, stream, flags);
-                }
-                break;
-            case KeyEvent.KEYCODE_VOLUME_MUTE:
-                if (event.getRepeatCount() == 0) {
-                    if (mUseMasterVolume) {
-                        setMasterMute(!isMasterMute());
-                    } else {
-                        // TODO: Actually handle MUTE.
-                    }
-                }
-                break;
-        }
-    }
-
-    /**
-     * @hide
-     */
-    public void handleKeyUp(KeyEvent event, int stream) {
-        int keyCode = event.getKeyCode();
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_VOLUME_UP:
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-                /*
-                 * Play a sound. This is done on key up since we don't want the
-                 * sound to play when a user holds down volume down to mute.
-                 */
-                if (mUseVolumeKeySounds) {
-                    if (mUseMasterVolume) {
-                        adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
-                    } else {
-                        int flags = FLAG_PLAY_SOUND;
-                        adjustSuggestedStreamVolume(
-                                ADJUST_SAME,
-                                stream,
-                                flags);
-                    }
-                }
-                mVolumeKeyUpTime = SystemClock.uptimeMillis();
-                break;
-        }
-    }
-
-    /**
-     * Adjusts the volume of a particular stream by one step in a direction.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},
-     * {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC} or
-     * {@link #STREAM_ALARM}
-     * @param direction The direction to adjust the volume. One of
-     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
-     *            {@link #ADJUST_SAME}.
-     * @param flags One or more flags.
-     * @see #adjustVolume(int, int)
-     * @see #setStreamVolume(int, int, int)
-     */
-    public void adjustStreamVolume(int streamType, int direction, int flags) {
-        IAudioService service = getService();
-        try {
-            if (mUseMasterVolume) {
-                service.adjustMasterVolume(direction, flags);
-            } else {
-                service.adjustStreamVolume(streamType, direction, flags);
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in adjustStreamVolume", e);
-        }
-    }
-
-    /**
-     * Adjusts the volume of the most relevant stream. For example, if a call is
-     * active, it will have the highest priority regardless of if the in-call
-     * screen is showing. Another example, if music is playing in the background
-     * and a call is not active, the music stream will be adjusted.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param direction The direction to adjust the volume. One of
-     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
-     *            {@link #ADJUST_SAME}.
-     * @param flags One or more flags.
-     * @see #adjustSuggestedStreamVolume(int, int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     * @see #setStreamVolume(int, int, int)
-     */
-    public void adjustVolume(int direction, int flags) {
-        IAudioService service = getService();
-        try {
-            if (mUseMasterVolume) {
-                service.adjustMasterVolume(direction, flags);
-            } else {
-                service.adjustVolume(direction, flags);
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in adjustVolume", e);
-        }
-    }
-
-    /**
-     * Adjusts the volume of the most relevant stream, or the given fallback
-     * stream.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param direction The direction to adjust the volume. One of
-     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
-     *            {@link #ADJUST_SAME}.
-     * @param suggestedStreamType The stream type that will be used if there
-     *            isn't a relevant stream. {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
-     * @param flags One or more flags.
-     * @see #adjustVolume(int, int)
-     * @see #adjustStreamVolume(int, int, int)
-     * @see #setStreamVolume(int, int, int)
-     */
-    public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags) {
-        IAudioService service = getService();
-        try {
-            if (mUseMasterVolume) {
-                service.adjustMasterVolume(direction, flags);
-            } else {
-                service.adjustSuggestedStreamVolume(direction, suggestedStreamType, flags);
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in adjustSuggestedStreamVolume", e);
-        }
-    }
-
-    /**
-     * Adjusts the master volume for the device's audio amplifier.
-     * <p>
-     *
-     * @param steps The number of volume steps to adjust. A positive
-     *            value will raise the volume.
-     * @param flags One or more flags.
-     * @hide
-     */
-    public void adjustMasterVolume(int steps, int flags) {
-        IAudioService service = getService();
-        try {
-            service.adjustMasterVolume(steps, flags);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in adjustMasterVolume", e);
-        }
-    }
-
-    /**
-     * Returns the current ringtone mode.
-     *
-     * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},
-     *         {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
-     * @see #setRingerMode(int)
-     */
-    public int getRingerMode() {
-        IAudioService service = getService();
-        try {
-            return service.getRingerMode();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getRingerMode", e);
-            return RINGER_MODE_NORMAL;
-        }
-    }
-
-    /**
-     * Checks valid ringer mode values.
-     *
-     * @return true if the ringer mode indicated is valid, false otherwise.
-     *
-     * @see #setRingerMode(int)
-     * @hide
-     */
-    public static boolean isValidRingerMode(int ringerMode) {
-        if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * Returns the maximum volume index for a particular stream.
-     *
-     * @param streamType The stream type whose maximum volume index is returned.
-     * @return The maximum valid volume index for the stream.
-     * @see #getStreamVolume(int)
-     */
-    public int getStreamMaxVolume(int streamType) {
-        IAudioService service = getService();
-        try {
-            if (mUseMasterVolume) {
-                return service.getMasterMaxVolume();
-            } else {
-                return service.getStreamMaxVolume(streamType);
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getStreamMaxVolume", e);
-            return 0;
-        }
-    }
-
-    /**
-     * Returns the current volume index for a particular stream.
-     *
-     * @param streamType The stream type whose volume index is returned.
-     * @return The current volume index for the stream.
-     * @see #getStreamMaxVolume(int)
-     * @see #setStreamVolume(int, int, int)
-     */
-    public int getStreamVolume(int streamType) {
-        IAudioService service = getService();
-        try {
-            if (mUseMasterVolume) {
-                return service.getMasterVolume();
-            } else {
-                return service.getStreamVolume(streamType);
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getStreamVolume", e);
-            return 0;
-        }
-    }
-
-    /**
-     * Get last audible volume before stream was muted.
-     *
-     * @hide
-     */
-    public int getLastAudibleStreamVolume(int streamType) {
-        IAudioService service = getService();
-        try {
-            if (mUseMasterVolume) {
-                return service.getLastAudibleMasterVolume();
-            } else {
-                return service.getLastAudibleStreamVolume(streamType);
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getLastAudibleStreamVolume", e);
-            return 0;
-        }
-    }
-
-    /**
-     * Get the stream type whose volume is driving the UI sounds volume.
-     * UI sounds are screen lock/unlock, camera shutter, key clicks...
-     * @hide
-     */
-    public int getMasterStreamType() {
-        IAudioService service = getService();
-        try {
-            return service.getMasterStreamType();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getMasterStreamType", e);
-            return STREAM_RING;
-        }
-    }
-
-    /**
-     * Sets the ringer mode.
-     * <p>
-     * Silent mode will mute the volume and will not vibrate. Vibrate mode will
-     * mute the volume and vibrate. Normal mode will be audible and may vibrate
-     * according to user settings.
-     *
-     * @param ringerMode The ringer mode, one of {@link #RINGER_MODE_NORMAL},
-     *            {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
-     * @see #getRingerMode()
-     */
-    public void setRingerMode(int ringerMode) {
-        if (!isValidRingerMode(ringerMode)) {
-            return;
-        }
-        IAudioService service = getService();
-        try {
-            service.setRingerMode(ringerMode);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setRingerMode", e);
-        }
-    }
-
-    /**
-     * Sets the volume index for a particular stream.
-     *
-     * @param streamType The stream whose volume index should be set.
-     * @param index The volume index to set. See
-     *            {@link #getStreamMaxVolume(int)} for the largest valid value.
-     * @param flags One or more flags.
-     * @see #getStreamMaxVolume(int)
-     * @see #getStreamVolume(int)
-     */
-    public void setStreamVolume(int streamType, int index, int flags) {
-        IAudioService service = getService();
-        try {
-            if (mUseMasterVolume) {
-                service.setMasterVolume(index, flags);
-            } else {
-                service.setStreamVolume(streamType, index, flags);
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setStreamVolume", e);
-        }
-    }
-
-    /**
-     * Returns the maximum volume index for master volume.
-     *
-     * @hide
-     */
-    public int getMasterMaxVolume() {
-        IAudioService service = getService();
-        try {
-            return service.getMasterMaxVolume();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getMasterMaxVolume", e);
-            return 0;
-        }
-    }
-
-    /**
-     * Returns the current volume index for master volume.
-     *
-     * @return The current volume index for master volume.
-     * @hide
-     */
-    public int getMasterVolume() {
-        IAudioService service = getService();
-        try {
-            return service.getMasterVolume();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getMasterVolume", e);
-            return 0;
-        }
-    }
-
-    /**
-     * Get last audible volume before master volume was muted.
-     *
-     * @hide
-     */
-    public int getLastAudibleMasterVolume() {
-        IAudioService service = getService();
-        try {
-            return service.getLastAudibleMasterVolume();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getLastAudibleMasterVolume", e);
-            return 0;
-        }
-    }
-
-    /**
-     * Sets the volume index for master volume.
-     *
-     * @param index The volume index to set. See
-     *            {@link #getMasterMaxVolume(int)} for the largest valid value.
-     * @param flags One or more flags.
-     * @see #getMasterMaxVolume(int)
-     * @see #getMasterVolume(int)
-     * @hide
-     */
-    public void setMasterVolume(int index, int flags) {
-        IAudioService service = getService();
-        try {
-            service.setMasterVolume(index, flags);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setMasterVolume", e);
-        }
-    }
-
-    /**
-     * Solo or unsolo a particular stream. All other streams are muted.
-     * <p>
-     * The solo command is protected against client process death: if a process
-     * with an active solo request on a stream dies, all streams that were muted
-     * because of this request will be unmuted automatically.
-     * <p>
-     * The solo requests for a given stream are cumulative: the AudioManager
-     * can receive several solo requests from one or more clients and the stream
-     * will be unsoloed only when the same number of unsolo requests are received.
-     * <p>
-     * For a better user experience, applications MUST unsolo a soloed stream
-     * in onPause() and solo is again in onResume() if appropriate.
-     *
-     * @param streamType The stream to be soloed/unsoloed.
-     * @param state The required solo state: true for solo ON, false for solo OFF
-     */
-    public void setStreamSolo(int streamType, boolean state) {
-        IAudioService service = getService();
-        try {
-            service.setStreamSolo(streamType, state, mICallBack);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setStreamSolo", e);
-        }
-    }
-
-    /**
-     * Mute or unmute an audio stream.
-     * <p>
-     * The mute command is protected against client process death: if a process
-     * with an active mute request on a stream dies, this stream will be unmuted
-     * automatically.
-     * <p>
-     * The mute requests for a given stream are cumulative: the AudioManager
-     * can receive several mute requests from one or more clients and the stream
-     * will be unmuted only when the same number of unmute requests are received.
-     * <p>
-     * For a better user experience, applications MUST unmute a muted stream
-     * in onPause() and mute is again in onResume() if appropriate.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param streamType The stream to be muted/unmuted.
-     * @param state The required mute state: true for mute ON, false for mute OFF
-     */
-    public void setStreamMute(int streamType, boolean state) {
-        IAudioService service = getService();
-        try {
-            service.setStreamMute(streamType, state, mICallBack);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setStreamMute", e);
-        }
-    }
-
-    /**
-     * get stream mute state.
-     *
-     * @hide
-     */
-    public boolean isStreamMute(int streamType) {
-        IAudioService service = getService();
-        try {
-            return service.isStreamMute(streamType);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in isStreamMute", e);
-            return false;
-        }
-    }
-
-    /**
-     * set master mute state.
-     *
-     * @hide
-     */
-    public void setMasterMute(boolean state) {
-        setMasterMute(state, FLAG_SHOW_UI);
-    }
-
-    /**
-     * set master mute state with optional flags.
-     *
-     * @hide
-     */
-    public void setMasterMute(boolean state, int flags) {
-        IAudioService service = getService();
-        try {
-            service.setMasterMute(state, flags, mICallBack);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setMasterMute", e);
-        }
-    }
-
-    /**
-     * get master mute state.
-     *
-     * @hide
-     */
-    public boolean isMasterMute() {
-        IAudioService service = getService();
-        try {
-            return service.isMasterMute();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in isMasterMute", e);
-            return false;
-        }
-    }
-
-    /**
-     * forces the stream controlled by hard volume keys
-     * specifying streamType == -1 releases control to the
-     * logic.
-     *
-     * @hide
-     */
-    public void forceVolumeControlStream(int streamType) {
-        IAudioService service = getService();
-        try {
-            service.forceVolumeControlStream(streamType, mICallBack);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in forceVolumeControlStream", e);
-        }
-    }
-
-    /**
-     * Returns whether a particular type should vibrate according to user
-     * settings and the current ringer mode.
-     * <p>
-     * This shouldn't be needed by most clients that use notifications to
-     * vibrate. The notification manager will not vibrate if the policy doesn't
-     * allow it, so the client should always set a vibrate pattern and let the
-     * notification manager control whether or not to actually vibrate.
-     *
-     * @param vibrateType The type of vibrate. One of
-     *            {@link #VIBRATE_TYPE_NOTIFICATION} or
-     *            {@link #VIBRATE_TYPE_RINGER}.
-     * @return Whether the type should vibrate at the instant this method is
-     *         called.
-     * @see #setVibrateSetting(int, int)
-     * @see #getVibrateSetting(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
-    public boolean shouldVibrate(int vibrateType) {
-        String packageName = mContext.getPackageName();
-        // Don't apply profiles for "android" context, as these could
-        // come from the NotificationManager, and originate from a real package.
-        if (!packageName.equals("android")) {
-            ProfileGroup profileGroup = mProfileManager.getActiveProfileGroup(packageName);
-            if (profileGroup != null) {
-                Log.v(TAG, "shouldVibrate, group: " + profileGroup.getUuid()
-                        + " mode: " + profileGroup.getVibrateMode());
-                switch (profileGroup.getVibrateMode()) {
-                    case OVERRIDE :
-                        return true;
-                    case SUPPRESS :
-                        return false;
-                    case DEFAULT :
-                        // Drop through
-                }
-            }
-        } else {
-            Log.v(TAG, "Not applying override for 'android' package");
-        }
-        IAudioService service = getService();
-        try {
-            return service.shouldVibrate(vibrateType);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in shouldVibrate", e);
-            return false;
-        }
-    }
-
-    /**
-     * Returns whether the user's vibrate setting for a vibrate type.
-     * <p>
-     * This shouldn't be needed by most clients that want to vibrate, instead
-     * see {@link #shouldVibrate(int)}.
-     *
-     * @param vibrateType The type of vibrate. One of
-     *            {@link #VIBRATE_TYPE_NOTIFICATION} or
-     *            {@link #VIBRATE_TYPE_RINGER}.
-     * @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},
-     *         {@link #VIBRATE_SETTING_OFF}, or
-     *         {@link #VIBRATE_SETTING_ONLY_SILENT}.
-     * @see #setVibrateSetting(int, int)
-     * @see #shouldVibrate(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
-    public int getVibrateSetting(int vibrateType) {
-        IAudioService service = getService();
-        try {
-            return service.getVibrateSetting(vibrateType);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getVibrateSetting", e);
-            return VIBRATE_SETTING_OFF;
-        }
-    }
-
-    /**
-     * Sets the setting for when the vibrate type should vibrate.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param vibrateType The type of vibrate. One of
-     *            {@link #VIBRATE_TYPE_NOTIFICATION} or
-     *            {@link #VIBRATE_TYPE_RINGER}.
-     * @param vibrateSetting The vibrate setting, one of
-     *            {@link #VIBRATE_SETTING_ON},
-     *            {@link #VIBRATE_SETTING_OFF}, or
-     *            {@link #VIBRATE_SETTING_ONLY_SILENT}.
-     * @see #getVibrateSetting(int)
-     * @see #shouldVibrate(int)
-     * @deprecated Applications should maintain their own vibrate policy based on
-     * current ringer mode that can be queried via {@link #getRingerMode()}.
-     */
-    public void setVibrateSetting(int vibrateType, int vibrateSetting) {
-        IAudioService service = getService();
-        try {
-            service.setVibrateSetting(vibrateType, vibrateSetting);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setVibrateSetting", e);
-        }
-    }
-
-    /**
-     * Sets the speakerphone on or off.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param on set <var>true</var> to turn on speakerphone;
-     *           <var>false</var> to turn it off
-     */
-    public void setSpeakerphoneOn(boolean on){
-        IAudioService service = getService();
-        try {
-            service.setSpeakerphoneOn(on);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setSpeakerphoneOn", e);
-        }
-    }
-
-    /**
-     * Checks whether the speakerphone is on or off.
-     *
-     * @return true if speakerphone is on, false if it's off
-     */
-    public boolean isSpeakerphoneOn() {
-        IAudioService service = getService();
-        try {
-            return service.isSpeakerphoneOn();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in isSpeakerphoneOn", e);
-            return false;
-        }
-     }
-
-    //====================================================================
-    // Bluetooth SCO control
-    /**
-     * Sticky broadcast intent action indicating that the bluetoooth SCO audio
-     * connection state has changed. The intent contains on extra {@link #EXTRA_SCO_AUDIO_STATE}
-     * indicating the new state which is either {@link #SCO_AUDIO_STATE_DISCONNECTED}
-     * or {@link #SCO_AUDIO_STATE_CONNECTED}
-     *
-     * @see #startBluetoothSco()
-     * @deprecated Use  {@link #ACTION_SCO_AUDIO_STATE_UPDATED} instead
-     */
-    @Deprecated
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_SCO_AUDIO_STATE_CHANGED =
-            "android.media.SCO_AUDIO_STATE_CHANGED";
-
-     /**
-     * Sticky broadcast intent action indicating that the bluetoooth SCO audio
-     * connection state has been updated.
-     * <p>This intent has two extras:
-     * <ul>
-     *   <li> {@link #EXTRA_SCO_AUDIO_STATE} - The new SCO audio state. </li>
-     *   <li> {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}- The previous SCO audio state. </li>
-     * </ul>
-     * <p> EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE can be any of:
-     * <ul>
-     *   <li> {@link #SCO_AUDIO_STATE_DISCONNECTED}, </li>
-     *   <li> {@link #SCO_AUDIO_STATE_CONNECTING} or </li>
-     *   <li> {@link #SCO_AUDIO_STATE_CONNECTED}, </li>
-     * </ul>
-     * @see #startBluetoothSco()
-     */
-    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-    public static final String ACTION_SCO_AUDIO_STATE_UPDATED =
-            "android.media.ACTION_SCO_AUDIO_STATE_UPDATED";
-
-    /**
-     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_CHANGED} or
-     * {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the new bluetooth SCO connection state.
-     */
-    public static final String EXTRA_SCO_AUDIO_STATE =
-            "android.media.extra.SCO_AUDIO_STATE";
-
-    /**
-     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the previous
-     * bluetooth SCO connection state.
-     */
-    public static final String EXTRA_SCO_AUDIO_PREVIOUS_STATE =
-            "android.media.extra.SCO_AUDIO_PREVIOUS_STATE";
-
-    /**
-     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
-     * indicating that the SCO audio channel is not established
-     */
-    public static final int SCO_AUDIO_STATE_DISCONNECTED = 0;
-    /**
-     * Value for extra {@link #EXTRA_SCO_AUDIO_STATE} or {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}
-     * indicating that the SCO audio channel is established
-     */
-    public static final int SCO_AUDIO_STATE_CONNECTED = 1;
-    /**
-     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
-     * indicating that the SCO audio channel is being established
-     */
-    public static final int SCO_AUDIO_STATE_CONNECTING = 2;
-    /**
-     * Value for extra EXTRA_SCO_AUDIO_STATE indicating that
-     * there was an error trying to obtain the state
-     */
-    public static final int SCO_AUDIO_STATE_ERROR = -1;
-
-
-    /**
-     * Indicates if current platform supports use of SCO for off call use cases.
-     * Application wanted to use bluetooth SCO audio when the phone is not in call
-     * must first call this method to make sure that the platform supports this
-     * feature.
-     * @return true if bluetooth SCO can be used for audio when not in call
-     *         false otherwise
-     * @see #startBluetoothSco()
-    */
-    public boolean isBluetoothScoAvailableOffCall() {
-        return mContext.getResources().getBoolean(
-               com.android.internal.R.bool.config_bluetooth_sco_off_call);
-    }
-
-    /**
-     * Start bluetooth SCO audio connection.
-     * <p>Requires Permission:
-     *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
-     * <p>This method can be used by applications wanting to send and received audio
-     * to/from a bluetooth SCO headset while the phone is not in call.
-     * <p>As the SCO connection establishment can take several seconds,
-     * applications should not rely on the connection to be available when the method
-     * returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}
-     * and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.
-     * <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO
-     * audio state before calling startBluetoothSco() by reading the intent returned by the receiver
-     * registration. If the state is already CONNECTED, no state change will be received via the
-     * intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
-     * so that the connection stays active in case the current initiator stops the connection.
-     * <p>Unless the connection is already active as described above, the state will always
-     * transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
-     * succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).
-     * <p>When finished with the SCO connection or if the establishment fails, the application must
-     * call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.
-     * <p>Even if a SCO connection is established, the following restrictions apply on audio
-     * output streams so that they can be routed to SCO headset:
-     * <ul>
-     *   <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>
-     *   <li> the format must be mono </li>
-     *   <li> the sampling must be 16kHz or 8kHz </li>
-     * </ul>
-     * <p>The following restrictions apply on input streams:
-     * <ul>
-     *   <li> the format must be mono </li>
-     *   <li> the sampling must be 8kHz </li>
-     * </ul>
-     * <p>Note that the phone application always has the priority on the usage of the SCO
-     * connection for telephony. If this method is called while the phone is in call
-     * it will be ignored. Similarly, if a call is received or sent while an application
-     * is using the SCO connection, the connection will be lost for the application and NOT
-     * returned automatically when the call ends.
-     * @see #stopBluetoothSco()
-     * @see #ACTION_SCO_AUDIO_STATE_UPDATED
-     */
-    public void startBluetoothSco(){
-        IAudioService service = getService();
-        try {
-            service.startBluetoothSco(mICallBack);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in startBluetoothSco", e);
-        }
-    }
-
-    /**
-     * Stop bluetooth SCO audio connection.
-     * <p>Requires Permission:
-     *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
-     * <p>This method must be called by applications having requested the use of
-     * bluetooth SCO audio with {@link #startBluetoothSco()}
-     * when finished with the SCO connection or if connection fails.
-     * @see #startBluetoothSco()
-     */
-    public void stopBluetoothSco(){
-        IAudioService service = getService();
-        try {
-            service.stopBluetoothSco(mICallBack);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in stopBluetoothSco", e);
-        }
-    }
-
-    /**
-     * Request use of Bluetooth SCO headset for communications.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param on set <var>true</var> to use bluetooth SCO for communications;
-     *               <var>false</var> to not use bluetooth SCO for communications
-     */
-    public void setBluetoothScoOn(boolean on){
-        IAudioService service = getService();
-        try {
-            service.setBluetoothScoOn(on);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setBluetoothScoOn", e);
-        }
-    }
-
-    /**
-     * Checks whether communications use Bluetooth SCO.
-     *
-     * @return true if SCO is used for communications;
-     *         false if otherwise
-     */
-    public boolean isBluetoothScoOn() {
-        IAudioService service = getService();
-        try {
-            return service.isBluetoothScoOn();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in isBluetoothScoOn", e);
-            return false;
-        }
-    }
-
-    /**
-     * @param on set <var>true</var> to route A2DP audio to/from Bluetooth
-     *           headset; <var>false</var> disable A2DP audio
-     * @deprecated Do not use.
-     */
-    @Deprecated public void setBluetoothA2dpOn(boolean on){
-    }
-
-    /**
-     * Checks whether A2DP audio routing to the Bluetooth headset is on or off.
-     *
-     * @return true if A2DP audio is being routed to/from Bluetooth headset;
-     *         false if otherwise
-     */
-    public boolean isBluetoothA2dpOn() {
-        if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_BLUETOOTH_A2DP,"")
-            == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    /**
-     * @hide
-     * Signals whether remote submix audio rerouting is enabled.
-     */
-    public void setRemoteSubmixOn(boolean on, int address) {
-        IAudioService service = getService();
-        try {
-            service.setRemoteSubmixOn(on, address);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setRemoteSubmixOn", e);
-        }
-    }
-
-    /**
-     * Sets audio routing to the wired headset on or off.
-     *
-     * @param on set <var>true</var> to route audio to/from wired
-     *           headset; <var>false</var> disable wired headset audio
-     * @deprecated Do not use.
-     */
-    @Deprecated public void setWiredHeadsetOn(boolean on){
-    }
-
-    /**
-     * Checks whether a wired headset is connected or not.
-     * <p>This is not a valid indication that audio playback is
-     * actually over the wired headset as audio routing depends on other conditions.
-     *
-     * @return true if a wired headset is connected.
-     *         false if otherwise
-     * @deprecated Use only to check is a headset is connected or not.
-     */
-    public boolean isWiredHeadsetOn() {
-        if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_WIRED_HEADSET,"")
-                == AudioSystem.DEVICE_STATE_UNAVAILABLE &&
-            AudioSystem.getDeviceConnectionState(DEVICE_OUT_WIRED_HEADPHONE,"")
-                == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    /**
-     * Sets the microphone mute on or off.
-     * <p>
-     * This method should only be used by applications that replace the platform-wide
-     * management of audio settings or the main telephony application.
-     *
-     * @param on set <var>true</var> to mute the microphone;
-     *           <var>false</var> to turn mute off
-     */
-    public void setMicrophoneMute(boolean on){
-        AudioSystem.muteMicrophone(on);
-    }
-
-    /**
-     * Checks whether the microphone mute is on or off.
-     *
-     * @return true if microphone is muted, false if it's not
-     */
-    public boolean isMicrophoneMute() {
-        return AudioSystem.isMicrophoneMuted();
-    }
-
-    /**
-     * Sets the audio mode.
-     * <p>
-     * The audio mode encompasses audio routing AND the behavior of
-     * the telephony layer. Therefore this method should only be used by applications that
-     * replace the platform-wide management of audio settings or the main telephony application.
-     * In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony
-     * application when it places a phone call, as it will cause signals from the radio layer
-     * to feed the platform mixer.
-     *
-     * @param mode  the requested audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
-     *              {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
-     *              Informs the HAL about the current audio state so that
-     *              it can route the audio appropriately.
-     */
-    public void setMode(int mode) {
-        IAudioService service = getService();
-        try {
-            service.setMode(mode, mICallBack);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setMode", e);
-        }
-    }
-
-    /**
-     * Returns the current audio mode.
-     *
-     * @return      the current audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
-     *              {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
-     *              Returns the current current audio state from the HAL.
-     */
-    public int getMode() {
-        IAudioService service = getService();
-        try {
-            return service.getMode();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in getMode", e);
-            return MODE_INVALID;
-        }
-    }
-
-    /* modes for setMode/getMode/setRoute/getRoute */
-    /**
-     * Audio harware modes.
-     */
-    /**
-     * Invalid audio mode.
-     */
-    public static final int MODE_INVALID            = AudioSystem.MODE_INVALID;
-    /**
-     * Current audio mode. Used to apply audio routing to current mode.
-     */
-    public static final int MODE_CURRENT            = AudioSystem.MODE_CURRENT;
-    /**
-     * Normal audio mode: not ringing and no call established.
-     */
-    public static final int MODE_NORMAL             = AudioSystem.MODE_NORMAL;
-    /**
-     * Ringing audio mode. An incoming is being signaled.
-     */
-    public static final int MODE_RINGTONE           = AudioSystem.MODE_RINGTONE;
-    /**
-     * In call audio mode. A telephony call is established.
-     */
-    public static final int MODE_IN_CALL            = AudioSystem.MODE_IN_CALL;
-    /**
-     * In communication audio mode. An audio/video chat or VoIP call is established.
-     */
-    public static final int MODE_IN_COMMUNICATION   = AudioSystem.MODE_IN_COMMUNICATION;
-
-    /* Routing bits for setRouting/getRouting API */
-    /**
-     * Routing audio output to earpiece
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_EARPIECE          = AudioSystem.ROUTE_EARPIECE;
-    /**
-     * Routing audio output to speaker
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_SPEAKER           = AudioSystem.ROUTE_SPEAKER;
-    /**
-     * @deprecated use {@link #ROUTE_BLUETOOTH_SCO}
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_BLUETOOTH = AudioSystem.ROUTE_BLUETOOTH_SCO;
-    /**
-     * Routing audio output to bluetooth SCO
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_BLUETOOTH_SCO     = AudioSystem.ROUTE_BLUETOOTH_SCO;
-    /**
-     * Routing audio output to headset
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_HEADSET           = AudioSystem.ROUTE_HEADSET;
-    /**
-     * Routing audio output to bluetooth A2DP
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_BLUETOOTH_A2DP    = AudioSystem.ROUTE_BLUETOOTH_A2DP;
-    /**
-     * Used for mask parameter of {@link #setRouting(int,int,int)}.
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated public static final int ROUTE_ALL               = AudioSystem.ROUTE_ALL;
-
-    /**
-     * Sets the audio routing for a specified mode
-     *
-     * @param mode   audio mode to change route. E.g., MODE_RINGTONE.
-     * @param routes bit vector of routes requested, created from one or
-     *               more of ROUTE_xxx types. Set bits indicate that route should be on
-     * @param mask   bit vector of routes to change, created from one or more of
-     * ROUTE_xxx types. Unset bits indicate the route should be left unchanged
-     *
-     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
-     * setBluetoothScoOn() methods instead.
-     */
-    @Deprecated
-    public void setRouting(int mode, int routes, int mask) {
-    }
-
-    /**
-     * Returns the current audio routing bit vector for a specified mode.
-     *
-     * @param mode audio mode to get route (e.g., MODE_RINGTONE)
-     * @return an audio route bit vector that can be compared with ROUTE_xxx
-     * bits
-     * @deprecated   Do not query audio routing directly, use isSpeakerphoneOn(),
-     * isBluetoothScoOn(), isBluetoothA2dpOn() and isWiredHeadsetOn() methods instead.
-     */
-    @Deprecated
-    public int getRouting(int mode) {
-        return -1;
-    }
-
-    /**
-     * Checks whether any music is active.
-     *
-     * @return true if any music tracks are active.
-     */
-    public boolean isMusicActive() {
-        return AudioSystem.isStreamActive(STREAM_MUSIC, 0);
-    }
-
-    /**
-     * @hide
-     * Checks whether speech recognition is active
-     * @return true if a recording with source {@link MediaRecorder.AudioSource#VOICE_RECOGNITION}
-     *    is underway.
-     */
-    public boolean isSpeechRecognitionActive() {
-        return AudioSystem.isSourceActive(MediaRecorder.AudioSource.VOICE_RECOGNITION);
-    }
-
-    /**
-     * @hide
-     * If the stream is active locally or remotely, adjust its volume according to the enforced
-     * priority rules.
-     * Note: only AudioManager.STREAM_MUSIC is supported at the moment
-     */
-    public void adjustLocalOrRemoteStreamVolume(int streamType, int direction) {
-        if (streamType != STREAM_MUSIC) {
-            Log.w(TAG, "adjustLocalOrRemoteStreamVolume() doesn't support stream " + streamType);
-        }
-        IAudioService service = getService();
-        try {
-            service.adjustLocalOrRemoteStreamVolume(streamType, direction);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in adjustLocalOrRemoteStreamVolume", e);
-        }
-    }
-
-    /*
-     * Sets a generic audio configuration parameter. The use of these parameters
-     * are platform dependant, see libaudio
-     *
-     * ** Temporary interface - DO NOT USE
-     *
-     * TODO: Replace with a more generic key:value get/set mechanism
-     *
-     * param key   name of parameter to set. Must not be null.
-     * param value value of parameter. Must not be null.
-     */
-    /**
-     * @hide
-     * @deprecated Use {@link #setPrameters(String)} instead
-     */
-    @Deprecated public void setParameter(String key, String value) {
-        setParameters(key+"="+value);
-    }
-
-    /**
-     * Sets a variable number of parameter values to audio hardware.
-     *
-     * @param keyValuePairs list of parameters key value pairs in the form:
-     *    key1=value1;key2=value2;...
-     *
-     */
-    public void setParameters(String keyValuePairs) {
-        AudioSystem.setParameters(keyValuePairs);
-    }
-
-    /**
-     * Sets a varaible number of parameter values to audio hardware.
-     *
-     * @param keys list of parameters
-     * @return list of parameters key value pairs in the form:
-     *    key1=value1;key2=value2;...
-     */
-    public String getParameters(String keys) {
-        return AudioSystem.getParameters(keys);
-    }
-
-    /* Sound effect identifiers */
-    /**
-     * Keyboard and direction pad click sound
-     * @see #playSoundEffect(int)
-     */
-    public static final int FX_KEY_CLICK = 0;
-    /**
-     * Focus has moved up
-     * @see #playSoundEffect(int)
-     */
-    public static final int FX_FOCUS_NAVIGATION_UP = 1;
-    /**
-     * Focus has moved down
-     * @see #playSoundEffect(int)
-     */
-    public static final int FX_FOCUS_NAVIGATION_DOWN = 2;
-    /**
-     * Focus has moved left
-     * @see #playSoundEffect(int)
-     */
-    public static final int FX_FOCUS_NAVIGATION_LEFT = 3;
-    /**
-     * Focus has moved right
-     * @see #playSoundEffect(int)
-     */
-    public static final int FX_FOCUS_NAVIGATION_RIGHT = 4;
-    /**
-     * IME standard keypress sound
-     * @see #playSoundEffect(int)
-     */
-    public static final int FX_KEYPRESS_STANDARD = 5;
-    /**
-     * IME spacebar keypress sound
-     * @see #playSoundEffect(int)
-     */
-    public static final int FX_KEYPRESS_SPACEBAR = 6;
-    /**
-     * IME delete keypress sound
-     * @see #playSoundEffect(int)
-     */
-    public static final int FX_KEYPRESS_DELETE = 7;
-    /**
-     * IME return_keypress sound
-     * @see #playSoundEffect(int)
-     */
-    public static final int FX_KEYPRESS_RETURN = 8;
-    /**
-     * @hide Number of sound effects
-     */
-    public static final int NUM_SOUND_EFFECTS = 9;
-
-    /**
-     * Plays a sound effect (Key clicks, lid open/close...)
-     * @param effectType The type of sound effect. One of
-     *            {@link #FX_KEY_CLICK},
-     *            {@link #FX_FOCUS_NAVIGATION_UP},
-     *            {@link #FX_FOCUS_NAVIGATION_DOWN},
-     *            {@link #FX_FOCUS_NAVIGATION_LEFT},
-     *            {@link #FX_FOCUS_NAVIGATION_RIGHT},
-     *            {@link #FX_KEYPRESS_STANDARD},
-     *            {@link #FX_KEYPRESS_SPACEBAR},
-     *            {@link #FX_KEYPRESS_DELETE},
-     *            {@link #FX_KEYPRESS_RETURN},
-     * NOTE: This version uses the UI settings to determine
-     * whether sounds are heard or not.
-     */
-    public void  playSoundEffect(int effectType) {
-        if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
-            return;
-        }
-
-        if (!querySoundEffectsEnabled()) {
-            return;
-        }
-
-        IAudioService service = getService();
-        try {
-            service.playSoundEffect(effectType);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in playSoundEffect"+e);
-        }
-    }
-
-    /**
-     * Plays a sound effect (Key clicks, lid open/close...)
-     * @param effectType The type of sound effect. One of
-     *            {@link #FX_KEY_CLICK},
-     *            {@link #FX_FOCUS_NAVIGATION_UP},
-     *            {@link #FX_FOCUS_NAVIGATION_DOWN},
-     *            {@link #FX_FOCUS_NAVIGATION_LEFT},
-     *            {@link #FX_FOCUS_NAVIGATION_RIGHT},
-     *            {@link #FX_KEYPRESS_STANDARD},
-     *            {@link #FX_KEYPRESS_SPACEBAR},
-     *            {@link #FX_KEYPRESS_DELETE},
-     *            {@link #FX_KEYPRESS_RETURN},
-     * @param volume Sound effect volume.
-     * The volume value is a raw scalar so UI controls should be scaled logarithmically.
-     * If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used.
-     * NOTE: This version is for applications that have their own
-     * settings panel for enabling and controlling volume.
-     */
-    public void  playSoundEffect(int effectType, float volume) {
-        if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
-            return;
-        }
-
-        IAudioService service = getService();
-        try {
-            service.playSoundEffectVolume(effectType, volume);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in playSoundEffect"+e);
-        }
-    }
-
-    /**
-     * Settings has an in memory cache, so this is fast.
-     */
-    private boolean querySoundEffectsEnabled() {
-        return Settings.System.getInt(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0) != 0;
-    }
-
-
-    /**
-     *  Load Sound effects.
-     *  This method must be called when sound effects are enabled.
-     */
-    public void loadSoundEffects() {
-        IAudioService service = getService();
-        try {
-            service.loadSoundEffects();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in loadSoundEffects"+e);
-        }
-    }
-
-    /**
-     *  Unload Sound effects.
-     *  This method can be called to free some memory when
-     *  sound effects are disabled.
-     */
-    public void unloadSoundEffects() {
-        IAudioService service = getService();
-        try {
-            service.unloadSoundEffects();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in unloadSoundEffects"+e);
-        }
-    }
-
-    /**
-     * Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
-     */
-    public static final int AUDIOFOCUS_GAIN = 1;
-    /**
-     * Used to indicate a temporary gain or request of audio focus, anticipated to last a short
-     * amount of time. Examples of temporary changes are the playback of driving directions, or an
-     * event notification.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
-     */
-    public static final int AUDIOFOCUS_GAIN_TRANSIENT = 2;
-    /**
-     * Used to indicate a temporary request of audio focus, anticipated to last a short
-     * amount of time, and where it is acceptable for other audio applications to keep playing
-     * after having lowered their output level (also referred to as "ducking").
-     * Examples of temporary changes are the playback of driving directions where playback of music
-     * in the background is acceptable.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
-     */
-    public static final int AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK = 3;
-    /**
-     * Used to indicate a loss of audio focus of unknown duration.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     */
-    public static final int AUDIOFOCUS_LOSS = -1 * AUDIOFOCUS_GAIN;
-    /**
-     * Used to indicate a transient loss of audio focus.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     */
-    public static final int AUDIOFOCUS_LOSS_TRANSIENT = -1 * AUDIOFOCUS_GAIN_TRANSIENT;
-    /**
-     * Used to indicate a transient loss of audio focus where the loser of the audio focus can
-     * lower its output volume if it wants to continue playing (also referred to as "ducking"), as
-     * the new focus owner doesn't require others to be silent.
-     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
-     */
-    public static final int AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK =
-            -1 * AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
-
-    /**
-     * Interface definition for a callback to be invoked when the audio focus of the system is
-     * updated.
-     */
-    public interface OnAudioFocusChangeListener {
-        /**
-         * Called on the listener to notify it the audio focus for this listener has been changed.
-         * The focusChange value indicates whether the focus was gained,
-         * whether the focus was lost, and whether that loss is transient, or whether the new focus
-         * holder will hold it for an unknown amount of time.
-         * When losing focus, listeners can use the focus change information to decide what
-         * behavior to adopt when losing focus. A music player could for instance elect to lower
-         * the volume of its music stream (duck) for transient focus losses, and pause otherwise.
-         * @param focusChange the type of focus change, one of {@link AudioManager#AUDIOFOCUS_GAIN},
-         *   {@link AudioManager#AUDIOFOCUS_LOSS}, {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT}
-         *   and {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}.
-         */
-        public void onAudioFocusChange(int focusChange);
-    }
-
-    /**
-     * Map to convert focus event listener IDs, as used in the AudioService audio focus stack,
-     * to actual listener objects.
-     */
-    private final HashMap<String, OnAudioFocusChangeListener> mAudioFocusIdListenerMap =
-            new HashMap<String, OnAudioFocusChangeListener>();
-    /**
-     * Lock to prevent concurrent changes to the list of focus listeners for this AudioManager
-     * instance.
-     */
-    private final Object mFocusListenerLock = new Object();
-
-    private OnAudioFocusChangeListener findFocusListener(String id) {
-        return mAudioFocusIdListenerMap.get(id);
-    }
-
-    /**
-     * Handler for audio focus events coming from the audio service.
-     */
-    private final FocusEventHandlerDelegate mAudioFocusEventHandlerDelegate =
-            new FocusEventHandlerDelegate();
-
-    /**
-     * Helper class to handle the forwarding of audio focus events to the appropriate listener
-     */
-    private class FocusEventHandlerDelegate {
-        private final Handler mHandler;
-
-        FocusEventHandlerDelegate() {
-            Looper looper;
-            if ((looper = Looper.myLooper()) == null) {
-                looper = Looper.getMainLooper();
-            }
-
-            if (looper != null) {
-                // implement the event handler delegate to receive audio focus events
-                mHandler = new Handler(looper) {
-                    @Override
-                    public void handleMessage(Message msg) {
-                        OnAudioFocusChangeListener listener = null;
-                        synchronized(mFocusListenerLock) {
-                            listener = findFocusListener((String)msg.obj);
-                        }
-                        if (listener != null) {
-                            listener.onAudioFocusChange(msg.what);
-                        }
-                    }
-                };
-            } else {
-                mHandler = null;
-            }
-        }
-
-        Handler getHandler() {
-            return mHandler;
-        }
-    }
-
-    private final IAudioFocusDispatcher mAudioFocusDispatcher = new IAudioFocusDispatcher.Stub() {
-
-        public void dispatchAudioFocusChange(int focusChange, String id) {
-            Message m = mAudioFocusEventHandlerDelegate.getHandler().obtainMessage(focusChange, id);
-            mAudioFocusEventHandlerDelegate.getHandler().sendMessage(m);
-        }
-
-    };
-
-    private String getIdForAudioFocusListener(OnAudioFocusChangeListener l) {
-        if (l == null) {
-            return new String(this.toString());
-        } else {
-            return new String(this.toString() + l.toString());
-        }
-    }
-
-    /**
-     * @hide
-     * Registers a listener to be called when audio focus changes. Calling this method is optional
-     * before calling {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, as it
-     * will register the listener as well if it wasn't registered already.
-     * @param l the listener to be notified of audio focus changes.
-     */
-    public void registerAudioFocusListener(OnAudioFocusChangeListener l) {
-        synchronized(mFocusListenerLock) {
-            if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
-                return;
-            }
-            mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l), l);
-        }
-    }
-
-    /**
-     * @hide
-     * Causes the specified listener to not be called anymore when focus is gained or lost.
-     * @param l the listener to unregister.
-     */
-    public void unregisterAudioFocusListener(OnAudioFocusChangeListener l) {
-
-        // remove locally
-        synchronized(mFocusListenerLock) {
-            mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
-        }
-    }
-
-
-    /**
-     * A failed focus change request.
-     */
-    public static final int AUDIOFOCUS_REQUEST_FAILED = 0;
-    /**
-     * A successful focus change request.
-     */
-    public static final int AUDIOFOCUS_REQUEST_GRANTED = 1;
-
-
-    /**
-     *  Request audio focus.
-     *  Send a request to obtain the audio focus
-     *  @param l the listener to be notified of audio focus changes
-     *  @param streamType the main audio stream type affected by the focus request
-     *  @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request
-     *      is temporary, and focus will be abandonned shortly. Examples of transient requests are
-     *      for the playback of driving directions, or notifications sounds.
-     *      Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for
-     *      the previous focus owner to keep playing if it ducks its audio output.
-     *      Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such
-     *      as the playback of a song or a video.
-     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
-     */
-    public int requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint) {
-        int status = AUDIOFOCUS_REQUEST_FAILED;
-        if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK))
-        {
-            Log.e(TAG, "Invalid duration hint, audio focus request denied");
-            return status;
-        }
-        registerAudioFocusListener(l);
-        //TODO protect request by permission check?
-        IAudioService service = getService();
-        try {
-            status = service.requestAudioFocus(streamType, durationHint, mICallBack,
-                    mAudioFocusDispatcher, getIdForAudioFocusListener(l),
-                    mContext.getPackageName() /* package name */);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Can't call requestAudioFocus() on AudioService due to "+e);
-        }
-        return status;
-    }
-
-    /**
-     * @hide
-     * Used internally by telephony package to request audio focus. Will cause the focus request
-     * to be associated with the "voice communication" identifier only used in AudioService
-     * to identify this use case.
-     * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
-     *    the establishment of the call
-     * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
-     *    media applications resume after a call
-     */
-    public void requestAudioFocusForCall(int streamType, int durationHint) {
-        IAudioService service = getService();
-        try {
-            service.requestAudioFocus(streamType, durationHint, mICallBack, null,
-                    AudioService.IN_VOICE_COMM_FOCUS_ID,
-                    "system" /* dump-friendly package name */);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService due to "+e);
-        }
-    }
-
-    /**
-     * @hide
-     * Used internally by telephony package to abandon audio focus, typically after a call or
-     * when ringing ends and the call is rejected or not answered.
-     * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.
-     */
-    public void abandonAudioFocusForCall() {
-        IAudioService service = getService();
-        try {
-            service.abandonAudioFocus(null, AudioService.IN_VOICE_COMM_FOCUS_ID);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Can't call abandonAudioFocusForCall() on AudioService due to "+e);
-        }
-    }
-
-    /**
-     *  Abandon audio focus. Causes the previous focus owner, if any, to receive focus.
-     *  @param l the listener with which focus was requested.
-     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
-     */
-    public int abandonAudioFocus(OnAudioFocusChangeListener l) {
-        int status = AUDIOFOCUS_REQUEST_FAILED;
-        unregisterAudioFocusListener(l);
-        IAudioService service = getService();
-        try {
-            status = service.abandonAudioFocus(mAudioFocusDispatcher,
-                    getIdForAudioFocusListener(l));
-        } catch (RemoteException e) {
-            Log.e(TAG, "Can't call abandonAudioFocus() on AudioService due to "+e);
-        }
-        return status;
-    }
-
-
-    //====================================================================
-    // Remote Control
-    /**
-     * Register a component to be the sole receiver of MEDIA_BUTTON intents.
-     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
-     *      that will receive the media button intent. This broadcast receiver must be declared
-     *      in the application manifest. The package of the component must match that of
-     *      the context you're registering from.
-     */
-    public void registerMediaButtonEventReceiver(ComponentName eventReceiver) {
-        if (eventReceiver == null) {
-            return;
-        }
-        if (!eventReceiver.getPackageName().equals(mContext.getPackageName())) {
-            Log.e(TAG, "registerMediaButtonEventReceiver() error: " +
-                    "receiver and context package names don't match");
-            return;
-        }
-        // construct a PendingIntent for the media button and register it
-        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
-        //     the associated intent will be handled by the component being registered
-        mediaButtonIntent.setComponent(eventReceiver);
-        PendingIntent pi = PendingIntent.getBroadcast(mContext,
-                0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);
-        registerMediaButtonIntent(pi, eventReceiver);
-    }
-
-    /**
-     * @hide
-     * no-op if (pi == null) or (eventReceiver == null)
-     */
-    public void registerMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver) {
-        if ((pi == null) || (eventReceiver == null)) {
-            Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
-            return;
-        }
-        IAudioService service = getService();
-        try {
-            // pi != null
-            service.registerMediaButtonIntent(pi, eventReceiver);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in registerMediaButtonIntent"+e);
-        }
-    }
-
-    /**
-     * @hide
-     * Used internally by telephony package to register an intent receiver for ACTION_MEDIA_BUTTON.
-     * @param eventReceiver the component that will receive the media button key events,
-     *          no-op if eventReceiver is null
-     */
-    public void registerMediaButtonEventReceiverForCalls(ComponentName eventReceiver) {
-        if (eventReceiver == null) {
-            return;
-        }
-        IAudioService service = getService();
-        try {
-            // eventReceiver != null
-            service.registerMediaButtonEventReceiverForCalls(eventReceiver);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in registerMediaButtonEventReceiverForCalls", e);
-        }
-    }
-
-    /**
-     * @hide
-     */
-    public void unregisterMediaButtonEventReceiverForCalls() {
-        IAudioService service = getService();
-        try {
-            service.unregisterMediaButtonEventReceiverForCalls();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in unregisterMediaButtonEventReceiverForCalls", e);
-        }
-    }
-
-    /**
-     * Unregister the receiver of MEDIA_BUTTON intents.
-     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
-     *      that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.
-     */
-    public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver) {
-        if (eventReceiver == null) {
-            return;
-        }
-        // construct a PendingIntent for the media button and unregister it
-        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
-        //     the associated intent will be handled by the component being registered
-        mediaButtonIntent.setComponent(eventReceiver);
-        PendingIntent pi = PendingIntent.getBroadcast(mContext,
-                0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);
-        unregisterMediaButtonIntent(pi, eventReceiver);
-    }
-
-    /**
-     * @hide
-     */
-    public void unregisterMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver) {
-        IAudioService service = getService();
-        try {
-            service.unregisterMediaButtonIntent(pi, eventReceiver);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in unregisterMediaButtonIntent"+e);
-        }
-    }
-
-    /**
-     * Registers the remote control client for providing information to display on the remote
-     * controls.
-     * @param rcClient The remote control client from which remote controls will receive
-     *      information to display.
-     * @see RemoteControlClient
-     */
-    public void registerRemoteControlClient(RemoteControlClient rcClient) {
-        if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
-            return;
-        }
-        IAudioService service = getService();
-        try {
-            int rcseId = service.registerRemoteControlClient(
-                    rcClient.getRcMediaIntent(),       /* mediaIntent   */
-                    rcClient.getIRemoteControlClient(),/* rcClient      */
-                    // used to match media button event receiver and audio focus
-                    mContext.getPackageName());        /* packageName   */
-            rcClient.setRcseId(rcseId);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in registerRemoteControlClient"+e);
-        }
-    }
-
-    /**
-     * Unregisters the remote control client that was providing information to display on the
-     * remote controls.
-     * @param rcClient The remote control client to unregister.
-     * @see #registerRemoteControlClient(RemoteControlClient)
-     */
-    public void unregisterRemoteControlClient(RemoteControlClient rcClient) {
-        if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
-            return;
-        }
-        IAudioService service = getService();
-        try {
-            service.unregisterRemoteControlClient(rcClient.getRcMediaIntent(), /* mediaIntent   */
-                    rcClient.getIRemoteControlClient());                       /* rcClient      */
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in unregisterRemoteControlClient"+e);
-        }
-    }
-
-    /**
-     * @hide
-     * Registers a remote control display that will be sent information by remote control clients.
-     * @param rcd
-     */
-    public void registerRemoteControlDisplay(IRemoteControlDisplay rcd) {
-        if (rcd == null) {
-            return;
-        }
-        IAudioService service = getService();
-        try {
-            service.registerRemoteControlDisplay(rcd);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in registerRemoteControlDisplay " + e);
-        }
-    }
-
-    /**
-     * @hide
-     * Unregisters a remote control display that was sent information by remote control clients.
-     * @param rcd
-     */
-    public void unregisterRemoteControlDisplay(IRemoteControlDisplay rcd) {
-        if (rcd == null) {
-            return;
-        }
-        IAudioService service = getService();
-        try {
-            service.unregisterRemoteControlDisplay(rcd);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in unregisterRemoteControlDisplay " + e);
-        }
-    }
-
-    /**
-     * @hide
-     * Sets the artwork size a remote control display expects when receiving bitmaps.
-     * @param rcd
-     * @param w the maximum width of the expected bitmap. Negative values indicate it is
-     *   useless to send artwork.
-     * @param h the maximum height of the expected bitmap. Negative values indicate it is
-     *   useless to send artwork.
-     */
-    public void remoteControlDisplayUsesBitmapSize(IRemoteControlDisplay rcd, int w, int h) {
-        if (rcd == null) {
-            return;
-        }
-        IAudioService service = getService();
-        try {
-            service.remoteControlDisplayUsesBitmapSize(rcd, w, h);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in remoteControlDisplayUsesBitmapSize " + e);
-        }
-    }
-
-    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
-    /**
-     * @hide
-     * Broadcast intent action indicating that the displays on the remote controls
-     * should be updated because a new remote control client is now active. If there is no
-     * {@link #EXTRA_REMOTE_CONTROL_CLIENT}, the remote control display should be cleared
-     * because there is no valid client to supply it with information.
-     *
-     * @see #EXTRA_REMOTE_CONTROL_CLIENT
-     */
-    public static final String REMOTE_CONTROL_CLIENT_CHANGED =
-            "android.media.REMOTE_CONTROL_CLIENT_CHANGED";
-
-    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
-    /**
-     * @hide
-     * The IRemoteControlClientDispatcher monotonically increasing generation counter.
-     *
-     * @see #REMOTE_CONTROL_CLIENT_CHANGED_ACTION
-     */
-    public static final String EXTRA_REMOTE_CONTROL_CLIENT_GENERATION =
-            "android.media.EXTRA_REMOTE_CONTROL_CLIENT_GENERATION";
-
-    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
-    /**
-     * @hide
-     * The name of the RemoteControlClient.
-     * This String is passed as the client name when calling methods from the
-     * IRemoteControlClientDispatcher interface.
-     *
-     * @see #REMOTE_CONTROL_CLIENT_CHANGED_ACTION
-     */
-    public static final String EXTRA_REMOTE_CONTROL_CLIENT_NAME =
-            "android.media.EXTRA_REMOTE_CONTROL_CLIENT_NAME";
-
-    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
-    /**
-     * @hide
-     * The media button event receiver associated with the RemoteControlClient.
-     * The {@link android.content.ComponentName} value of the event receiver can be retrieved with
-     * {@link android.content.ComponentName#unflattenFromString(String)}
-     *
-     * @see #REMOTE_CONTROL_CLIENT_CHANGED_ACTION
-     */
-    public static final String EXTRA_REMOTE_CONTROL_EVENT_RECEIVER =
-            "android.media.EXTRA_REMOTE_CONTROL_EVENT_RECEIVER";
-
-    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
-    /**
-     * @hide
-     * The flags describing what information has changed in the current remote control client.
-     *
-     * @see #REMOTE_CONTROL_CLIENT_CHANGED_ACTION
-     */
-    public static final String EXTRA_REMOTE_CONTROL_CLIENT_INFO_CHANGED =
-            "android.media.EXTRA_REMOTE_CONTROL_CLIENT_INFO_CHANGED";
-
-    /**
-     *  @hide
-     *  Reload audio settings. This method is called by Settings backup
-     *  agent when audio settings are restored and causes the AudioService
-     *  to read and apply restored settings.
-     */
-    public void reloadAudioSettings() {
-        IAudioService service = getService();
-        try {
-            service.reloadAudioSettings();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in reloadAudioSettings"+e);
-        }
-    }
-
-     /**
-      * {@hide}
-      */
-     private final IBinder mICallBack = new Binder();
-
-    /**
-     * Checks whether the phone is in silent mode, with or without vibrate.
-     *
-     * @return true if phone is in silent mode, with or without vibrate.
-     *
-     * @see #getRingerMode()
-     *
-     * @hide pending API Council approval
-     */
-    public boolean isSilentMode() {
-        int ringerMode = getRingerMode();
-        boolean silentMode =
-            (ringerMode == RINGER_MODE_SILENT) ||
-            (ringerMode == RINGER_MODE_VIBRATE);
-        return silentMode;
-    }
-
-    // This section re-defines new output device constants from AudioSystem, because the AudioSystem
-    // class is not used by other parts of the framework, which instead use definitions and methods
-    // from AudioManager. AudioSystem is an internal class used by AudioManager and AudioService.
-
-    /** {@hide} The audio output device code for the small speaker at the front of the device used
-     *  when placing calls.  Does not refer to an in-ear headphone without attached microphone,
-     *  such as earbuds, earphones, or in-ear monitors (IEM). Those would be handled as a
-     *  {@link #DEVICE_OUT_WIRED_HEADPHONE}.
-     */
-    public static final int DEVICE_OUT_EARPIECE = AudioSystem.DEVICE_OUT_EARPIECE;
-    /** {@hide} The audio output device code for the built-in speaker */
-    public static final int DEVICE_OUT_SPEAKER = AudioSystem.DEVICE_OUT_SPEAKER;
-    /** {@hide} The audio output device code for a wired headset with attached microphone */
-    public static final int DEVICE_OUT_WIRED_HEADSET = AudioSystem.DEVICE_OUT_WIRED_HEADSET;
-    /** {@hide} The audio output device code for a wired headphone without attached microphone */
-    public static final int DEVICE_OUT_WIRED_HEADPHONE = AudioSystem.DEVICE_OUT_WIRED_HEADPHONE;
-    /** {@hide} The audio output device code for generic Bluetooth SCO, for voice */
-    public static final int DEVICE_OUT_BLUETOOTH_SCO = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
-    /** {@hide} The audio output device code for Bluetooth SCO Headset Profile (HSP) and
-     *  Hands-Free Profile (HFP), for voice
-     */
-    public static final int DEVICE_OUT_BLUETOOTH_SCO_HEADSET =
-            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
-    /** {@hide} The audio output device code for Bluetooth SCO car audio, for voice */
-    public static final int DEVICE_OUT_BLUETOOTH_SCO_CARKIT =
-            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
-    /** {@hide} The audio output device code for generic Bluetooth A2DP, for music */
-    public static final int DEVICE_OUT_BLUETOOTH_A2DP = AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP;
-    /** {@hide} The audio output device code for Bluetooth A2DP headphones, for music */
-    public static final int DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES =
-            AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;
-    /** {@hide} The audio output device code for Bluetooth A2DP external speaker, for music */
-    public static final int DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER =
-            AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER;
-    /** {@hide} The audio output device code for S/PDIF or HDMI */
-    public static final int DEVICE_OUT_AUX_DIGITAL = AudioSystem.DEVICE_OUT_AUX_DIGITAL;
-    /** {@hide} The audio output device code for an analog wired headset attached via a
-     *  docking station
-     */
-    public static final int DEVICE_OUT_ANLG_DOCK_HEADSET = AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET;
-    /** {@hide} The audio output device code for a digital wired headset attached via a
-     *  docking station
-     */
-    public static final int DEVICE_OUT_DGTL_DOCK_HEADSET = AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET;
-    /** {@hide} The audio output device code for a USB audio accessory. The accessory is in USB host
-     * mode and the Android device in USB device mode
-     */
-    public static final int DEVICE_OUT_USB_ACCESSORY = AudioSystem.DEVICE_OUT_USB_ACCESSORY;
-    /** {@hide} The audio output device code for a USB audio device. The device is in USB device
-     * mode and the Android device in USB host mode
-     */
-    public static final int DEVICE_OUT_USB_DEVICE = AudioSystem.DEVICE_OUT_USB_DEVICE;
-    /** {@hide} This is not used as a returned value from {@link #getDevicesForStream}, but could be
-     *  used in the future in a set method to select whatever default device is chosen by the
-     *  platform-specific implementation.
-     */
-    public static final int DEVICE_OUT_DEFAULT = AudioSystem.DEVICE_OUT_DEFAULT;
-
-    /**
-     * Return the enabled devices for the specified output stream type.
-     *
-     * @param streamType The stream type to query. One of
-     *            {@link #STREAM_VOICE_CALL},
-     *            {@link #STREAM_SYSTEM},
-     *            {@link #STREAM_RING},
-     *            {@link #STREAM_MUSIC},
-     *            {@link #STREAM_ALARM},
-     *            {@link #STREAM_NOTIFICATION},
-     *            {@link #STREAM_DTMF}.
-     *
-     * @return The bit-mask "or" of audio output device codes for all enabled devices on this
-     *         stream. Zero or more of
-     *            {@link #DEVICE_OUT_EARPIECE},
-     *            {@link #DEVICE_OUT_SPEAKER},
-     *            {@link #DEVICE_OUT_WIRED_HEADSET},
-     *            {@link #DEVICE_OUT_WIRED_HEADPHONE},
-     *            {@link #DEVICE_OUT_BLUETOOTH_SCO},
-     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_HEADSET},
-     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_CARKIT},
-     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP},
-     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES},
-     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER},
-     *            {@link #DEVICE_OUT_AUX_DIGITAL},
-     *            {@link #DEVICE_OUT_ANLG_DOCK_HEADSET},
-     *            {@link #DEVICE_OUT_DGTL_DOCK_HEADSET}.
-     *            {@link #DEVICE_OUT_DEFAULT} is not used here.
-     *
-     * The implementation may support additional device codes beyond those listed, so
-     * the application should ignore any bits which it does not recognize.
-     * Note that the information may be imprecise when the implementation
-     * cannot distinguish whether a particular device is enabled.
-     *
-     * {@hide}
-     */
-    public int getDevicesForStream(int streamType) {
-        switch (streamType) {
-        case STREAM_VOICE_CALL:
-        case STREAM_SYSTEM:
-        case STREAM_RING:
-        case STREAM_MUSIC:
-        case STREAM_ALARM:
-        case STREAM_NOTIFICATION:
-        case STREAM_DTMF:
-            return AudioSystem.getDevicesForStream(streamType);
-        default:
-            return 0;
-        }
-    }
-
-     /**
-     * Indicate wired accessory connection state change.
-     * @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)
-     * @param state  new connection state: 1 connected, 0 disconnected
-     * @param name   device name
-     * {@hide}
-     */
-    public void setWiredDeviceConnectionState(int device, int state, String name) {
-        IAudioService service = getService();
-        try {
-            service.setWiredDeviceConnectionState(device, state, name);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setWiredDeviceConnectionState "+e);
-        }
-    }
-
-     /**
-     * Indicate A2DP sink connection state change.
-     * @param device Bluetooth device connected/disconnected
-     * @param state  new connection state (BluetoothProfile.STATE_xxx)
-     * @return a delay in ms that the caller should wait before broadcasting
-     * BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED intent.
-     * {@hide}
-     */
-    public int setBluetoothA2dpDeviceConnectionState(BluetoothDevice device, int state) {
-        IAudioService service = getService();
-        int delay = 0;
-        try {
-            delay = service.setBluetoothA2dpDeviceConnectionState(device, state);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Dead object in setBluetoothA2dpDeviceConnectionState "+e);
-        } finally {
-            return delay;
-        }
-    }
-
-    /** {@hide} */
-    public IRingtonePlayer getRingtonePlayer() {
-        try {
-            return getService().getRingtonePlayer();
-        } catch (RemoteException e) {
-            return null;
-        }
-    }
-
-    /**
-     * Used as a key for {@link #getProperty} to request the native or optimal output sample rate
-     * for this device's primary output stream, in decimal Hz.
-     */
-    public static final String PROPERTY_OUTPUT_SAMPLE_RATE =
-            "android.media.property.OUTPUT_SAMPLE_RATE";
-
-    /**
-     * Used as a key for {@link #getProperty} to request the native or optimal output buffer size
-     * for this device's primary output stream, in decimal PCM frames.
-     */
-    public static final String PROPERTY_OUTPUT_FRAMES_PER_BUFFER =
-            "android.media.property.OUTPUT_FRAMES_PER_BUFFER";
-
-    /**
-     * Returns the value of the property with the specified key.
-     * @param key One of the strings corresponding to a property key: either
-     *            {@link #PROPERTY_OUTPUT_SAMPLE_RATE} or
-     *            {@link #PROPERTY_OUTPUT_FRAMES_PER_BUFFER}
-     * @return A string representing the associated value for that property key,
-     *         or null if there is no value for that key.
-     */
-    public String getProperty(String key) {
-        if (PROPERTY_OUTPUT_SAMPLE_RATE.equals(key)) {
-            int outputSampleRate = AudioSystem.getPrimaryOutputSamplingRate();
-            return outputSampleRate > 0 ? Integer.toString(outputSampleRate) : null;
-        } else if (PROPERTY_OUTPUT_FRAMES_PER_BUFFER.equals(key)) {
-            int outputFramesPerBuffer = AudioSystem.getPrimaryOutputFrameCount();
-            return outputFramesPerBuffer > 0 ? Integer.toString(outputFramesPerBuffer) : null;
-        } else {
-            // null or unknown key
-            return null;
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.media;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.app.PendingIntent;
+import android.app.ProfileGroup;
+import android.app.ProfileManager;
+import android.bluetooth.BluetoothDevice;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.SystemClock;
+import android.os.ServiceManager;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.Surface;
+import android.view.VolumePanel;
+import android.view.WindowManager;
+
+import java.util.HashMap;
+
+/**
+ * AudioManager provides access to volume and ringer mode control.
+ * <p>
+ * Use <code>Context.getSystemService(Context.AUDIO_SERVICE)</code> to get
+ * an instance of this class.
+ */
+public class AudioManager {
+
+    private final Context mContext;
+    private long mVolumeKeyUpTime;
+    private final boolean mUseMasterVolume;
+    private final boolean mUseVolumeKeySounds;
+    private static String TAG = "AudioManager";
+    private final ProfileManager mProfileManager;
+    private final WindowManager mWindowManager;
+
+    /**
+     * Broadcast intent, a hint for applications that audio is about to become
+     * 'noisy' due to a change in audio outputs. For example, this intent may
+     * be sent when a wired headset is unplugged, or when an A2DP audio
+     * sink is disconnected, and the audio system is about to automatically
+     * switch audio route to the speaker. Applications that are controlling
+     * audio streams may consider pausing, reducing volume or some other action
+     * on receipt of this intent so as not to surprise the user with audio
+     * from the speaker.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_AUDIO_BECOMING_NOISY = "android.media.AUDIO_BECOMING_NOISY";
+
+    /**
+     * Sticky broadcast intent action indicating that the ringer mode has
+     * changed. Includes the new ringer mode.
+     *
+     * @see #EXTRA_RINGER_MODE
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String RINGER_MODE_CHANGED_ACTION = "android.media.RINGER_MODE_CHANGED";
+
+    /**
+     * The new ringer mode.
+     *
+     * @see #RINGER_MODE_CHANGED_ACTION
+     * @see #RINGER_MODE_NORMAL
+     * @see #RINGER_MODE_SILENT
+     * @see #RINGER_MODE_VIBRATE
+     */
+    public static final String EXTRA_RINGER_MODE = "android.media.EXTRA_RINGER_MODE";
+
+    /**
+     * Broadcast intent action indicating that the vibrate setting has
+     * changed. Includes the vibrate type and its new setting.
+     *
+     * @see #EXTRA_VIBRATE_TYPE
+     * @see #EXTRA_VIBRATE_SETTING
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String VIBRATE_SETTING_CHANGED_ACTION =
+        "android.media.VIBRATE_SETTING_CHANGED";
+
+    /**
+     * @hide Broadcast intent when the volume for a particular stream type changes.
+     * Includes the stream, the new volume and previous volumes.
+     * Notes:
+     *  - for internal platform use only, do not make public,
+     *  - never used for "remote" volume changes
+     *
+     * @see #EXTRA_VOLUME_STREAM_TYPE
+     * @see #EXTRA_VOLUME_STREAM_VALUE
+     * @see #EXTRA_PREV_VOLUME_STREAM_VALUE
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String VOLUME_CHANGED_ACTION = "android.media.VOLUME_CHANGED_ACTION";
+
+    /**
+     * @hide Broadcast intent when the master volume changes.
+     * Includes the new volume
+     *
+     * @see #EXTRA_MASTER_VOLUME_VALUE
+     * @see #EXTRA_PREV_MASTER_VOLUME_VALUE
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String MASTER_VOLUME_CHANGED_ACTION =
+        "android.media.MASTER_VOLUME_CHANGED_ACTION";
+
+    /**
+     * @hide Broadcast intent when the master mute state changes.
+     * Includes the the new volume
+     *
+     * @see #EXTRA_MASTER_VOLUME_MUTED
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String MASTER_MUTE_CHANGED_ACTION =
+        "android.media.MASTER_MUTE_CHANGED_ACTION";
+
+    /**
+     * The new vibrate setting for a particular type.
+     *
+     * @see #VIBRATE_SETTING_CHANGED_ACTION
+     * @see #EXTRA_VIBRATE_TYPE
+     * @see #VIBRATE_SETTING_ON
+     * @see #VIBRATE_SETTING_OFF
+     * @see #VIBRATE_SETTING_ONLY_SILENT
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
+     */
+    public static final String EXTRA_VIBRATE_SETTING = "android.media.EXTRA_VIBRATE_SETTING";
+
+    /**
+     * The vibrate type whose setting has changed.
+     *
+     * @see #VIBRATE_SETTING_CHANGED_ACTION
+     * @see #VIBRATE_TYPE_NOTIFICATION
+     * @see #VIBRATE_TYPE_RINGER
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode and listen to {@link #RINGER_MODE_CHANGED_ACTION} instead.
+     */
+    public static final String EXTRA_VIBRATE_TYPE = "android.media.EXTRA_VIBRATE_TYPE";
+
+    /**
+     * @hide The stream type for the volume changed intent.
+     */
+    public static final String EXTRA_VOLUME_STREAM_TYPE = "android.media.EXTRA_VOLUME_STREAM_TYPE";
+
+    /**
+     * @hide The volume associated with the stream for the volume changed intent.
+     */
+    public static final String EXTRA_VOLUME_STREAM_VALUE =
+        "android.media.EXTRA_VOLUME_STREAM_VALUE";
+
+    /**
+     * @hide The previous volume associated with the stream for the volume changed intent.
+     */
+    public static final String EXTRA_PREV_VOLUME_STREAM_VALUE =
+        "android.media.EXTRA_PREV_VOLUME_STREAM_VALUE";
+
+    /**
+     * @hide The new master volume value for the master volume changed intent.
+     * Value is integer between 0 and 100 inclusive.
+     */
+    public static final String EXTRA_MASTER_VOLUME_VALUE =
+        "android.media.EXTRA_MASTER_VOLUME_VALUE";
+
+    /**
+     * @hide The previous master volume value for the master volume changed intent.
+     * Value is integer between 0 and 100 inclusive.
+     */
+    public static final String EXTRA_PREV_MASTER_VOLUME_VALUE =
+        "android.media.EXTRA_PREV_MASTER_VOLUME_VALUE";
+
+    /**
+     * @hide The new master volume mute state for the master mute changed intent.
+     * Value is boolean
+     */
+    public static final String EXTRA_MASTER_VOLUME_MUTED =
+        "android.media.EXTRA_MASTER_VOLUME_MUTED";
+
+    /** The audio stream for phone calls */
+    public static final int STREAM_VOICE_CALL = AudioSystem.STREAM_VOICE_CALL;
+    /** The audio stream for system sounds */
+    public static final int STREAM_SYSTEM = AudioSystem.STREAM_SYSTEM;
+    /** The audio stream for the phone ring */
+    public static final int STREAM_RING = AudioSystem.STREAM_RING;
+    /** The audio stream for music playback */
+    public static final int STREAM_MUSIC = AudioSystem.STREAM_MUSIC;
+    /** The audio stream for alarms */
+    public static final int STREAM_ALARM = AudioSystem.STREAM_ALARM;
+    /** The audio stream for notifications */
+    public static final int STREAM_NOTIFICATION = AudioSystem.STREAM_NOTIFICATION;
+    /** @hide The audio stream for phone calls when connected to bluetooth */
+    public static final int STREAM_BLUETOOTH_SCO = AudioSystem.STREAM_BLUETOOTH_SCO;
+    /** @hide The audio stream for enforced system sounds in certain countries (e.g camera in Japan) */
+    public static final int STREAM_SYSTEM_ENFORCED = AudioSystem.STREAM_SYSTEM_ENFORCED;
+    /** The audio stream for DTMF Tones */
+    public static final int STREAM_DTMF = AudioSystem.STREAM_DTMF;
+    /** @hide The audio stream for text to speech (TTS) */
+    public static final int STREAM_TTS = AudioSystem.STREAM_TTS;
+    /** @hide The audio stream for FM Radio (FM) */
+    public static final int STREAM_FM = AudioSystem.STREAM_FM;
+    /** Number of audio streams */
+    /**
+     * @deprecated Use AudioSystem.getNumStreamTypes() instead
+     */
+    @Deprecated public static final int NUM_STREAMS = AudioSystem.NUM_STREAMS;
+
+
+    /**  @hide Default volume index values for audio streams */
+    public static final int[] DEFAULT_STREAM_VOLUME = new int[] {
+        4,  // STREAM_VOICE_CALL
+        7,  // STREAM_SYSTEM
+        5,  // STREAM_RING
+        11, // STREAM_MUSIC
+        6,  // STREAM_ALARM
+        5,  // STREAM_NOTIFICATION
+        7,  // STREAM_BLUETOOTH_SCO
+        7,  // STREAM_SYSTEM_ENFORCED
+        11, // STREAM_DTMF
+        11, // STREAM_TTS
+        11  // STREAM_FM
+    };
+
+    /**
+     * Increase the ringer volume.
+     *
+     * @see #adjustVolume(int, int)
+     * @see #adjustStreamVolume(int, int, int)
+     */
+    public static final int ADJUST_RAISE = 1;
+
+    /**
+     * Decrease the ringer volume.
+     *
+     * @see #adjustVolume(int, int)
+     * @see #adjustStreamVolume(int, int, int)
+     */
+    public static final int ADJUST_LOWER = -1;
+
+    /**
+     * Maintain the previous ringer volume. This may be useful when needing to
+     * show the volume toast without actually modifying the volume.
+     *
+     * @see #adjustVolume(int, int)
+     * @see #adjustStreamVolume(int, int, int)
+     */
+    public static final int ADJUST_SAME = 0;
+
+    // Flags should be powers of 2!
+
+    /**
+     * Show a toast containing the current volume.
+     *
+     * @see #adjustStreamVolume(int, int, int)
+     * @see #adjustVolume(int, int)
+     * @see #setStreamVolume(int, int, int)
+     * @see #setRingerMode(int)
+     */
+    public static final int FLAG_SHOW_UI = 1 << 0;
+
+    /**
+     * Whether to include ringer modes as possible options when changing volume.
+     * For example, if true and volume level is 0 and the volume is adjusted
+     * with {@link #ADJUST_LOWER}, then the ringer mode may switch the silent or
+     * vibrate mode.
+     * <p>
+     * By default this is on for the ring stream. If this flag is included,
+     * this behavior will be present regardless of the stream type being
+     * affected by the ringer mode.
+     *
+     * @see #adjustVolume(int, int)
+     * @see #adjustStreamVolume(int, int, int)
+     */
+    public static final int FLAG_ALLOW_RINGER_MODES = 1 << 1;
+
+    /**
+     * Whether to play a sound when changing the volume.
+     * <p>
+     * If this is given to {@link #adjustVolume(int, int)} or
+     * {@link #adjustSuggestedStreamVolume(int, int, int)}, it may be ignored
+     * in some cases (for example, the decided stream type is not
+     * {@link AudioManager#STREAM_RING}, or the volume is being adjusted
+     * downward).
+     *
+     * @see #adjustStreamVolume(int, int, int)
+     * @see #adjustVolume(int, int)
+     * @see #setStreamVolume(int, int, int)
+     */
+    public static final int FLAG_PLAY_SOUND = 1 << 2;
+
+    /**
+     * Removes any sounds/vibrate that may be in the queue, or are playing (related to
+     * changing volume).
+     */
+    public static final int FLAG_REMOVE_SOUND_AND_VIBRATE = 1 << 3;
+
+    /**
+     * Whether to vibrate if going into the vibrate ringer mode.
+     */
+    public static final int FLAG_VIBRATE = 1 << 4;
+
+    /**
+     * Indicates to VolumePanel that the volume slider should be disabled as user
+     * cannot change the stream volume
+     * @hide
+     */
+    public static final int FLAG_FIXED_VOLUME = 1 << 5;
+
+    /**
+     * Ringer mode that will be silent and will not vibrate. (This overrides the
+     * vibrate setting.)
+     *
+     * @see #setRingerMode(int)
+     * @see #getRingerMode()
+     */
+    public static final int RINGER_MODE_SILENT = 0;
+
+    /**
+     * Ringer mode that will be silent and will vibrate. (This will cause the
+     * phone ringer to always vibrate, but the notification vibrate to only
+     * vibrate if set.)
+     *
+     * @see #setRingerMode(int)
+     * @see #getRingerMode()
+     */
+    public static final int RINGER_MODE_VIBRATE = 1;
+
+    /**
+     * Ringer mode that may be audible and may vibrate. It will be audible if
+     * the volume before changing out of this mode was audible. It will vibrate
+     * if the vibrate setting is on.
+     *
+     * @see #setRingerMode(int)
+     * @see #getRingerMode()
+     */
+    public static final int RINGER_MODE_NORMAL = 2;
+
+    // maximum valid ringer mode value. Values must start from 0 and be contiguous.
+    private static final int RINGER_MODE_MAX = RINGER_MODE_NORMAL;
+
+    /**
+     * Vibrate type that corresponds to the ringer.
+     *
+     * @see #setVibrateSetting(int, int)
+     * @see #getVibrateSetting(int)
+     * @see #shouldVibrate(int)
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode that can be queried via {@link #getRingerMode()}.
+     */
+    public static final int VIBRATE_TYPE_RINGER = 0;
+
+    /**
+     * Vibrate type that corresponds to notifications.
+     *
+     * @see #setVibrateSetting(int, int)
+     * @see #getVibrateSetting(int)
+     * @see #shouldVibrate(int)
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode that can be queried via {@link #getRingerMode()}.
+     */
+    public static final int VIBRATE_TYPE_NOTIFICATION = 1;
+
+    /**
+     * Vibrate setting that suggests to never vibrate.
+     *
+     * @see #setVibrateSetting(int, int)
+     * @see #getVibrateSetting(int)
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode that can be queried via {@link #getRingerMode()}.
+     */
+    public static final int VIBRATE_SETTING_OFF = 0;
+
+    /**
+     * Vibrate setting that suggests to vibrate when possible.
+     *
+     * @see #setVibrateSetting(int, int)
+     * @see #getVibrateSetting(int)
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode that can be queried via {@link #getRingerMode()}.
+     */
+    public static final int VIBRATE_SETTING_ON = 1;
+
+    /**
+     * Vibrate setting that suggests to only vibrate when in the vibrate ringer
+     * mode.
+     *
+     * @see #setVibrateSetting(int, int)
+     * @see #getVibrateSetting(int)
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode that can be queried via {@link #getRingerMode()}.
+     */
+    public static final int VIBRATE_SETTING_ONLY_SILENT = 2;
+
+    /**
+     * Suggests using the default stream type. This may not be used in all
+     * places a stream type is needed.
+     */
+    public static final int USE_DEFAULT_STREAM_TYPE = Integer.MIN_VALUE;
+
+    private static IAudioService sService;
+
+    /**
+     * @hide
+     */
+    public AudioManager(Context context) {
+        mContext = context;
+        mUseMasterVolume = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_useMasterVolume);
+        mUseVolumeKeySounds = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_useVolumeKeySounds);
+        mProfileManager = (ProfileManager) context.getSystemService(Context.PROFILE_SERVICE);
+        mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    }
+
+    private static IAudioService getService()
+    {
+        if (sService != null) {
+            return sService;
+        }
+        IBinder b = ServiceManager.getService(Context.AUDIO_SERVICE);
+        sService = IAudioService.Stub.asInterface(b);
+        return sService;
+    }
+
+    /**
+     * @hide
+     */
+    public void preDispatchKeyEvent(KeyEvent event, int stream) {
+        /*
+         * If the user hits another key within the play sound delay, then
+         * cancel the sound
+         */
+        int keyCode = event.getKeyCode();
+        if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP
+                && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE
+                && mVolumeKeyUpTime + VolumePanel.PLAY_SOUND_DELAY
+                        > SystemClock.uptimeMillis()) {
+            /*
+             * The user has hit another key during the delay (e.g., 300ms)
+             * since the last volume key up, so cancel any sounds.
+             */
+            if (mUseMasterVolume) {
+                adjustMasterVolume(ADJUST_SAME, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
+            } else {
+                adjustSuggestedStreamVolume(ADJUST_SAME,
+                        stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
+            }
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public void handleKeyDown(KeyEvent event, int stream) {
+        int keyCode = event.getKeyCode();
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_VOLUME_UP:
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+                /*
+                 * Adjust the volume in on key down since it is more
+                 * responsive to the user.
+                 */
+                int direction;
+                int swapKeys = Settings.System.getInt(mContext.getContentResolver(),
+                        Settings.System.SWAP_VOLUME_KEYS_ON_ROTATION, 0);
+                int rotation = mWindowManager.getDefaultDisplay().getRotation();
+                if (swapKeys == 1 // phone or hybrid
+                        && (rotation == Surface.ROTATION_90
+                        || rotation == Surface.ROTATION_180)) {
+                    direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP
+                            ? ADJUST_LOWER
+                            : ADJUST_RAISE;
+                } else if (swapKeys == 2 // tablet
+                        && (rotation == Surface.ROTATION_180
+                        || rotation == Surface.ROTATION_270)) {
+                    direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP
+                            ? ADJUST_LOWER
+                            : ADJUST_RAISE;
+                } else {
+                    direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP
+                            ? ADJUST_RAISE
+                            : ADJUST_LOWER;
+                }
+                int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
+
+                if (mUseMasterVolume) {
+                    adjustMasterVolume(direction, flags);
+                } else {
+                    adjustSuggestedStreamVolume(direction, stream, flags);
+                }
+                break;
+            case KeyEvent.KEYCODE_VOLUME_MUTE:
+                if (event.getRepeatCount() == 0) {
+                    if (mUseMasterVolume) {
+                        setMasterMute(!isMasterMute());
+                    } else {
+                        // TODO: Actually handle MUTE.
+                    }
+                }
+                break;
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public void handleKeyUp(KeyEvent event, int stream) {
+        int keyCode = event.getKeyCode();
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_VOLUME_UP:
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+                /*
+                 * Play a sound. This is done on key up since we don't want the
+                 * sound to play when a user holds down volume down to mute.
+                 */
+                if (mUseVolumeKeySounds) {
+                    if (mUseMasterVolume) {
+                        adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
+                    } else {
+                        int flags = FLAG_PLAY_SOUND;
+                        adjustSuggestedStreamVolume(
+                                ADJUST_SAME,
+                                stream,
+                                flags);
+                    }
+                }
+                mVolumeKeyUpTime = SystemClock.uptimeMillis();
+                break;
+        }
+    }
+
+    /**
+     * Adjusts the volume of a particular stream by one step in a direction.
+     * <p>
+     * This method should only be used by applications that replace the platform-wide
+     * management of audio settings or the main telephony application.
+     *
+     * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},
+     * {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC} or
+     * {@link #STREAM_ALARM}
+     * @param direction The direction to adjust the volume. One of
+     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
+     *            {@link #ADJUST_SAME}.
+     * @param flags One or more flags.
+     * @see #adjustVolume(int, int)
+     * @see #setStreamVolume(int, int, int)
+     */
+    public void adjustStreamVolume(int streamType, int direction, int flags) {
+        IAudioService service = getService();
+        try {
+            if (mUseMasterVolume) {
+                service.adjustMasterVolume(direction, flags);
+            } else {
+                service.adjustStreamVolume(streamType, direction, flags);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in adjustStreamVolume", e);
+        }
+    }
+
+    /**
+     * Adjusts the volume of the most relevant stream. For example, if a call is
+     * active, it will have the highest priority regardless of if the in-call
+     * screen is showing. Another example, if music is playing in the background
+     * and a call is not active, the music stream will be adjusted.
+     * <p>
+     * This method should only be used by applications that replace the platform-wide
+     * management of audio settings or the main telephony application.
+     *
+     * @param direction The direction to adjust the volume. One of
+     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
+     *            {@link #ADJUST_SAME}.
+     * @param flags One or more flags.
+     * @see #adjustSuggestedStreamVolume(int, int, int)
+     * @see #adjustStreamVolume(int, int, int)
+     * @see #setStreamVolume(int, int, int)
+     */
+    public void adjustVolume(int direction, int flags) {
+        IAudioService service = getService();
+        try {
+            if (mUseMasterVolume) {
+                service.adjustMasterVolume(direction, flags);
+            } else {
+                service.adjustVolume(direction, flags);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in adjustVolume", e);
+        }
+    }
+
+    /**
+     * Adjusts the volume of the most relevant stream, or the given fallback
+     * stream.
+     * <p>
+     * This method should only be used by applications that replace the platform-wide
+     * management of audio settings or the main telephony application.
+     *
+     * @param direction The direction to adjust the volume. One of
+     *            {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
+     *            {@link #ADJUST_SAME}.
+     * @param suggestedStreamType The stream type that will be used if there
+     *            isn't a relevant stream. {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
+     * @param flags One or more flags.
+     * @see #adjustVolume(int, int)
+     * @see #adjustStreamVolume(int, int, int)
+     * @see #setStreamVolume(int, int, int)
+     */
+    public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags) {
+        IAudioService service = getService();
+        try {
+            if (mUseMasterVolume) {
+                service.adjustMasterVolume(direction, flags);
+            } else {
+                service.adjustSuggestedStreamVolume(direction, suggestedStreamType, flags);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in adjustSuggestedStreamVolume", e);
+        }
+    }
+
+    /**
+     * Adjusts the master volume for the device's audio amplifier.
+     * <p>
+     *
+     * @param steps The number of volume steps to adjust. A positive
+     *            value will raise the volume.
+     * @param flags One or more flags.
+     * @hide
+     */
+    public void adjustMasterVolume(int steps, int flags) {
+        IAudioService service = getService();
+        try {
+            service.adjustMasterVolume(steps, flags);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in adjustMasterVolume", e);
+        }
+    }
+
+    /**
+     * Returns the current ringtone mode.
+     *
+     * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},
+     *         {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
+     * @see #setRingerMode(int)
+     */
+    public int getRingerMode() {
+        IAudioService service = getService();
+        try {
+            return service.getRingerMode();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getRingerMode", e);
+            return RINGER_MODE_NORMAL;
+        }
+    }
+
+    /**
+     * Checks valid ringer mode values.
+     *
+     * @return true if the ringer mode indicated is valid, false otherwise.
+     *
+     * @see #setRingerMode(int)
+     * @hide
+     */
+    public static boolean isValidRingerMode(int ringerMode) {
+        if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Returns the maximum volume index for a particular stream.
+     *
+     * @param streamType The stream type whose maximum volume index is returned.
+     * @return The maximum valid volume index for the stream.
+     * @see #getStreamVolume(int)
+     */
+    public int getStreamMaxVolume(int streamType) {
+        IAudioService service = getService();
+        try {
+            if (mUseMasterVolume) {
+                return service.getMasterMaxVolume();
+            } else {
+                return service.getStreamMaxVolume(streamType);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getStreamMaxVolume", e);
+            return 0;
+        }
+    }
+
+    /**
+     * Returns the current volume index for a particular stream.
+     *
+     * @param streamType The stream type whose volume index is returned.
+     * @return The current volume index for the stream.
+     * @see #getStreamMaxVolume(int)
+     * @see #setStreamVolume(int, int, int)
+     */
+    public int getStreamVolume(int streamType) {
+        IAudioService service = getService();
+        try {
+            if (mUseMasterVolume) {
+                return service.getMasterVolume();
+            } else {
+                return service.getStreamVolume(streamType);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getStreamVolume", e);
+            return 0;
+        }
+    }
+
+    /**
+     * Get last audible volume before stream was muted.
+     *
+     * @hide
+     */
+    public int getLastAudibleStreamVolume(int streamType) {
+        IAudioService service = getService();
+        try {
+            if (mUseMasterVolume) {
+                return service.getLastAudibleMasterVolume();
+            } else {
+                return service.getLastAudibleStreamVolume(streamType);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getLastAudibleStreamVolume", e);
+            return 0;
+        }
+    }
+
+    /**
+     * Get the stream type whose volume is driving the UI sounds volume.
+     * UI sounds are screen lock/unlock, camera shutter, key clicks...
+     * @hide
+     */
+    public int getMasterStreamType() {
+        IAudioService service = getService();
+        try {
+            return service.getMasterStreamType();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getMasterStreamType", e);
+            return STREAM_RING;
+        }
+    }
+
+    /**
+     * Sets the ringer mode.
+     * <p>
+     * Silent mode will mute the volume and will not vibrate. Vibrate mode will
+     * mute the volume and vibrate. Normal mode will be audible and may vibrate
+     * according to user settings.
+     *
+     * @param ringerMode The ringer mode, one of {@link #RINGER_MODE_NORMAL},
+     *            {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
+     * @see #getRingerMode()
+     */
+    public void setRingerMode(int ringerMode) {
+        if (!isValidRingerMode(ringerMode)) {
+            return;
+        }
+        IAudioService service = getService();
+        try {
+            service.setRingerMode(ringerMode);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setRingerMode", e);
+        }
+    }
+
+    /**
+     * Sets the volume index for a particular stream.
+     *
+     * @param streamType The stream whose volume index should be set.
+     * @param index The volume index to set. See
+     *            {@link #getStreamMaxVolume(int)} for the largest valid value.
+     * @param flags One or more flags.
+     * @see #getStreamMaxVolume(int)
+     * @see #getStreamVolume(int)
+     */
+    public void setStreamVolume(int streamType, int index, int flags) {
+        IAudioService service = getService();
+        try {
+            if (mUseMasterVolume) {
+                service.setMasterVolume(index, flags);
+            } else {
+                service.setStreamVolume(streamType, index, flags);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setStreamVolume", e);
+        }
+    }
+
+    /**
+     * Returns the maximum volume index for master volume.
+     *
+     * @hide
+     */
+    public int getMasterMaxVolume() {
+        IAudioService service = getService();
+        try {
+            return service.getMasterMaxVolume();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getMasterMaxVolume", e);
+            return 0;
+        }
+    }
+
+    /**
+     * Returns the current volume index for master volume.
+     *
+     * @return The current volume index for master volume.
+     * @hide
+     */
+    public int getMasterVolume() {
+        IAudioService service = getService();
+        try {
+            return service.getMasterVolume();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getMasterVolume", e);
+            return 0;
+        }
+    }
+
+    /**
+     * Get last audible volume before master volume was muted.
+     *
+     * @hide
+     */
+    public int getLastAudibleMasterVolume() {
+        IAudioService service = getService();
+        try {
+            return service.getLastAudibleMasterVolume();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getLastAudibleMasterVolume", e);
+            return 0;
+        }
+    }
+
+    /**
+     * Sets the volume index for master volume.
+     *
+     * @param index The volume index to set. See
+     *            {@link #getMasterMaxVolume(int)} for the largest valid value.
+     * @param flags One or more flags.
+     * @see #getMasterMaxVolume(int)
+     * @see #getMasterVolume(int)
+     * @hide
+     */
+    public void setMasterVolume(int index, int flags) {
+        IAudioService service = getService();
+        try {
+            service.setMasterVolume(index, flags);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setMasterVolume", e);
+        }
+    }
+
+    /**
+     * Solo or unsolo a particular stream. All other streams are muted.
+     * <p>
+     * The solo command is protected against client process death: if a process
+     * with an active solo request on a stream dies, all streams that were muted
+     * because of this request will be unmuted automatically.
+     * <p>
+     * The solo requests for a given stream are cumulative: the AudioManager
+     * can receive several solo requests from one or more clients and the stream
+     * will be unsoloed only when the same number of unsolo requests are received.
+     * <p>
+     * For a better user experience, applications MUST unsolo a soloed stream
+     * in onPause() and solo is again in onResume() if appropriate.
+     *
+     * @param streamType The stream to be soloed/unsoloed.
+     * @param state The required solo state: true for solo ON, false for solo OFF
+     */
+    public void setStreamSolo(int streamType, boolean state) {
+        IAudioService service = getService();
+        try {
+            service.setStreamSolo(streamType, state, mICallBack);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setStreamSolo", e);
+        }
+    }
+
+    /**
+     * Mute or unmute an audio stream.
+     * <p>
+     * The mute command is protected against client process death: if a process
+     * with an active mute request on a stream dies, this stream will be unmuted
+     * automatically.
+     * <p>
+     * The mute requests for a given stream are cumulative: the AudioManager
+     * can receive several mute requests from one or more clients and the stream
+     * will be unmuted only when the same number of unmute requests are received.
+     * <p>
+     * For a better user experience, applications MUST unmute a muted stream
+     * in onPause() and mute is again in onResume() if appropriate.
+     * <p>
+     * This method should only be used by applications that replace the platform-wide
+     * management of audio settings or the main telephony application.
+     *
+     * @param streamType The stream to be muted/unmuted.
+     * @param state The required mute state: true for mute ON, false for mute OFF
+     */
+    public void setStreamMute(int streamType, boolean state) {
+        IAudioService service = getService();
+        try {
+            service.setStreamMute(streamType, state, mICallBack);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setStreamMute", e);
+        }
+    }
+
+    /**
+     * get stream mute state.
+     *
+     * @hide
+     */
+    public boolean isStreamMute(int streamType) {
+        IAudioService service = getService();
+        try {
+            return service.isStreamMute(streamType);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in isStreamMute", e);
+            return false;
+        }
+    }
+
+    /**
+     * set master mute state.
+     *
+     * @hide
+     */
+    public void setMasterMute(boolean state) {
+        setMasterMute(state, FLAG_SHOW_UI);
+    }
+
+    /**
+     * set master mute state with optional flags.
+     *
+     * @hide
+     */
+    public void setMasterMute(boolean state, int flags) {
+        IAudioService service = getService();
+        try {
+            service.setMasterMute(state, flags, mICallBack);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setMasterMute", e);
+        }
+    }
+
+    /**
+     * get master mute state.
+     *
+     * @hide
+     */
+    public boolean isMasterMute() {
+        IAudioService service = getService();
+        try {
+            return service.isMasterMute();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in isMasterMute", e);
+            return false;
+        }
+    }
+
+    /**
+     * forces the stream controlled by hard volume keys
+     * specifying streamType == -1 releases control to the
+     * logic.
+     *
+     * @hide
+     */
+    public void forceVolumeControlStream(int streamType) {
+        IAudioService service = getService();
+        try {
+            service.forceVolumeControlStream(streamType, mICallBack);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in forceVolumeControlStream", e);
+        }
+    }
+
+    /**
+     * Returns whether a particular type should vibrate according to user
+     * settings and the current ringer mode.
+     * <p>
+     * This shouldn't be needed by most clients that use notifications to
+     * vibrate. The notification manager will not vibrate if the policy doesn't
+     * allow it, so the client should always set a vibrate pattern and let the
+     * notification manager control whether or not to actually vibrate.
+     *
+     * @param vibrateType The type of vibrate. One of
+     *            {@link #VIBRATE_TYPE_NOTIFICATION} or
+     *            {@link #VIBRATE_TYPE_RINGER}.
+     * @return Whether the type should vibrate at the instant this method is
+     *         called.
+     * @see #setVibrateSetting(int, int)
+     * @see #getVibrateSetting(int)
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode that can be queried via {@link #getRingerMode()}.
+     */
+    public boolean shouldVibrate(int vibrateType) {
+        String packageName = mContext.getPackageName();
+        // Don't apply profiles for "android" context, as these could
+        // come from the NotificationManager, and originate from a real package.
+        if (!packageName.equals("android")) {
+            ProfileGroup profileGroup = mProfileManager.getActiveProfileGroup(packageName);
+            if (profileGroup != null) {
+                Log.v(TAG, "shouldVibrate, group: " + profileGroup.getUuid()
+                        + " mode: " + profileGroup.getVibrateMode());
+                switch (profileGroup.getVibrateMode()) {
+                    case OVERRIDE :
+                        return true;
+                    case SUPPRESS :
+                        return false;
+                    case DEFAULT :
+                        // Drop through
+                }
+            }
+        } else {
+            Log.v(TAG, "Not applying override for 'android' package");
+        }
+        IAudioService service = getService();
+        try {
+            return service.shouldVibrate(vibrateType);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in shouldVibrate", e);
+            return false;
+        }
+    }
+
+    /**
+     * Returns whether the user's vibrate setting for a vibrate type.
+     * <p>
+     * This shouldn't be needed by most clients that want to vibrate, instead
+     * see {@link #shouldVibrate(int)}.
+     *
+     * @param vibrateType The type of vibrate. One of
+     *            {@link #VIBRATE_TYPE_NOTIFICATION} or
+     *            {@link #VIBRATE_TYPE_RINGER}.
+     * @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},
+     *         {@link #VIBRATE_SETTING_OFF}, or
+     *         {@link #VIBRATE_SETTING_ONLY_SILENT}.
+     * @see #setVibrateSetting(int, int)
+     * @see #shouldVibrate(int)
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode that can be queried via {@link #getRingerMode()}.
+     */
+    public int getVibrateSetting(int vibrateType) {
+        IAudioService service = getService();
+        try {
+            return service.getVibrateSetting(vibrateType);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getVibrateSetting", e);
+            return VIBRATE_SETTING_OFF;
+        }
+    }
+
+    /**
+     * Sets the setting for when the vibrate type should vibrate.
+     * <p>
+     * This method should only be used by applications that replace the platform-wide
+     * management of audio settings or the main telephony application.
+     *
+     * @param vibrateType The type of vibrate. One of
+     *            {@link #VIBRATE_TYPE_NOTIFICATION} or
+     *            {@link #VIBRATE_TYPE_RINGER}.
+     * @param vibrateSetting The vibrate setting, one of
+     *            {@link #VIBRATE_SETTING_ON},
+     *            {@link #VIBRATE_SETTING_OFF}, or
+     *            {@link #VIBRATE_SETTING_ONLY_SILENT}.
+     * @see #getVibrateSetting(int)
+     * @see #shouldVibrate(int)
+     * @deprecated Applications should maintain their own vibrate policy based on
+     * current ringer mode that can be queried via {@link #getRingerMode()}.
+     */
+    public void setVibrateSetting(int vibrateType, int vibrateSetting) {
+        IAudioService service = getService();
+        try {
+            service.setVibrateSetting(vibrateType, vibrateSetting);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setVibrateSetting", e);
+        }
+    }
+
+    /**
+     * Sets the speakerphone on or off.
+     * <p>
+     * This method should only be used by applications that replace the platform-wide
+     * management of audio settings or the main telephony application.
+     *
+     * @param on set <var>true</var> to turn on speakerphone;
+     *           <var>false</var> to turn it off
+     */
+    public void setSpeakerphoneOn(boolean on){
+        IAudioService service = getService();
+        try {
+            service.setSpeakerphoneOn(on);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setSpeakerphoneOn", e);
+        }
+    }
+
+    /**
+     * Checks whether the speakerphone is on or off.
+     *
+     * @return true if speakerphone is on, false if it's off
+     */
+    public boolean isSpeakerphoneOn() {
+        IAudioService service = getService();
+        try {
+            return service.isSpeakerphoneOn();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in isSpeakerphoneOn", e);
+            return false;
+        }
+     }
+
+    //====================================================================
+    // Bluetooth SCO control
+    /**
+     * Sticky broadcast intent action indicating that the bluetoooth SCO audio
+     * connection state has changed. The intent contains on extra {@link #EXTRA_SCO_AUDIO_STATE}
+     * indicating the new state which is either {@link #SCO_AUDIO_STATE_DISCONNECTED}
+     * or {@link #SCO_AUDIO_STATE_CONNECTED}
+     *
+     * @see #startBluetoothSco()
+     * @deprecated Use  {@link #ACTION_SCO_AUDIO_STATE_UPDATED} instead
+     */
+    @Deprecated
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_SCO_AUDIO_STATE_CHANGED =
+            "android.media.SCO_AUDIO_STATE_CHANGED";
+
+     /**
+     * Sticky broadcast intent action indicating that the bluetoooth SCO audio
+     * connection state has been updated.
+     * <p>This intent has two extras:
+     * <ul>
+     *   <li> {@link #EXTRA_SCO_AUDIO_STATE} - The new SCO audio state. </li>
+     *   <li> {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}- The previous SCO audio state. </li>
+     * </ul>
+     * <p> EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE can be any of:
+     * <ul>
+     *   <li> {@link #SCO_AUDIO_STATE_DISCONNECTED}, </li>
+     *   <li> {@link #SCO_AUDIO_STATE_CONNECTING} or </li>
+     *   <li> {@link #SCO_AUDIO_STATE_CONNECTED}, </li>
+     * </ul>
+     * @see #startBluetoothSco()
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_SCO_AUDIO_STATE_UPDATED =
+            "android.media.ACTION_SCO_AUDIO_STATE_UPDATED";
+
+    /**
+     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_CHANGED} or
+     * {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the new bluetooth SCO connection state.
+     */
+    public static final String EXTRA_SCO_AUDIO_STATE =
+            "android.media.extra.SCO_AUDIO_STATE";
+
+    /**
+     * Extra for intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED} containing the previous
+     * bluetooth SCO connection state.
+     */
+    public static final String EXTRA_SCO_AUDIO_PREVIOUS_STATE =
+            "android.media.extra.SCO_AUDIO_PREVIOUS_STATE";
+
+    /**
+     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
+     * indicating that the SCO audio channel is not established
+     */
+    public static final int SCO_AUDIO_STATE_DISCONNECTED = 0;
+    /**
+     * Value for extra {@link #EXTRA_SCO_AUDIO_STATE} or {@link #EXTRA_SCO_AUDIO_PREVIOUS_STATE}
+     * indicating that the SCO audio channel is established
+     */
+    public static final int SCO_AUDIO_STATE_CONNECTED = 1;
+    /**
+     * Value for extra EXTRA_SCO_AUDIO_STATE or EXTRA_SCO_AUDIO_PREVIOUS_STATE
+     * indicating that the SCO audio channel is being established
+     */
+    public static final int SCO_AUDIO_STATE_CONNECTING = 2;
+    /**
+     * Value for extra EXTRA_SCO_AUDIO_STATE indicating that
+     * there was an error trying to obtain the state
+     */
+    public static final int SCO_AUDIO_STATE_ERROR = -1;
+
+
+    /**
+     * Indicates if current platform supports use of SCO for off call use cases.
+     * Application wanted to use bluetooth SCO audio when the phone is not in call
+     * must first call this method to make sure that the platform supports this
+     * feature.
+     * @return true if bluetooth SCO can be used for audio when not in call
+     *         false otherwise
+     * @see #startBluetoothSco()
+    */
+    public boolean isBluetoothScoAvailableOffCall() {
+        return mContext.getResources().getBoolean(
+               com.android.internal.R.bool.config_bluetooth_sco_off_call);
+    }
+
+    /**
+     * Start bluetooth SCO audio connection.
+     * <p>Requires Permission:
+     *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
+     * <p>This method can be used by applications wanting to send and received audio
+     * to/from a bluetooth SCO headset while the phone is not in call.
+     * <p>As the SCO connection establishment can take several seconds,
+     * applications should not rely on the connection to be available when the method
+     * returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}
+     * and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.
+     * <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO
+     * audio state before calling startBluetoothSco() by reading the intent returned by the receiver
+     * registration. If the state is already CONNECTED, no state change will be received via the
+     * intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
+     * so that the connection stays active in case the current initiator stops the connection.
+     * <p>Unless the connection is already active as described above, the state will always
+     * transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
+     * succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).
+     * <p>When finished with the SCO connection or if the establishment fails, the application must
+     * call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.
+     * <p>Even if a SCO connection is established, the following restrictions apply on audio
+     * output streams so that they can be routed to SCO headset:
+     * <ul>
+     *   <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>
+     *   <li> the format must be mono </li>
+     *   <li> the sampling must be 16kHz or 8kHz </li>
+     * </ul>
+     * <p>The following restrictions apply on input streams:
+     * <ul>
+     *   <li> the format must be mono </li>
+     *   <li> the sampling must be 8kHz </li>
+     * </ul>
+     * <p>Note that the phone application always has the priority on the usage of the SCO
+     * connection for telephony. If this method is called while the phone is in call
+     * it will be ignored. Similarly, if a call is received or sent while an application
+     * is using the SCO connection, the connection will be lost for the application and NOT
+     * returned automatically when the call ends.
+     * @see #stopBluetoothSco()
+     * @see #ACTION_SCO_AUDIO_STATE_UPDATED
+     */
+    public void startBluetoothSco(){
+        IAudioService service = getService();
+        try {
+            service.startBluetoothSco(mICallBack);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in startBluetoothSco", e);
+        }
+    }
+
+    /**
+     * Stop bluetooth SCO audio connection.
+     * <p>Requires Permission:
+     *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
+     * <p>This method must be called by applications having requested the use of
+     * bluetooth SCO audio with {@link #startBluetoothSco()}
+     * when finished with the SCO connection or if connection fails.
+     * @see #startBluetoothSco()
+     */
+    public void stopBluetoothSco(){
+        IAudioService service = getService();
+        try {
+            service.stopBluetoothSco(mICallBack);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in stopBluetoothSco", e);
+        }
+    }
+
+    /**
+     * Request use of Bluetooth SCO headset for communications.
+     * <p>
+     * This method should only be used by applications that replace the platform-wide
+     * management of audio settings or the main telephony application.
+     *
+     * @param on set <var>true</var> to use bluetooth SCO for communications;
+     *               <var>false</var> to not use bluetooth SCO for communications
+     */
+    public void setBluetoothScoOn(boolean on){
+        IAudioService service = getService();
+        try {
+            service.setBluetoothScoOn(on);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setBluetoothScoOn", e);
+        }
+    }
+
+    /**
+     * Checks whether communications use Bluetooth SCO.
+     *
+     * @return true if SCO is used for communications;
+     *         false if otherwise
+     */
+    public boolean isBluetoothScoOn() {
+        IAudioService service = getService();
+        try {
+            return service.isBluetoothScoOn();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in isBluetoothScoOn", e);
+            return false;
+        }
+    }
+
+    /**
+     * @param on set <var>true</var> to route A2DP audio to/from Bluetooth
+     *           headset; <var>false</var> disable A2DP audio
+     * @deprecated Do not use.
+     */
+    @Deprecated public void setBluetoothA2dpOn(boolean on){
+    }
+
+    /**
+     * Checks whether A2DP audio routing to the Bluetooth headset is on or off.
+     *
+     * @return true if A2DP audio is being routed to/from Bluetooth headset;
+     *         false if otherwise
+     */
+    public boolean isBluetoothA2dpOn() {
+        if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_BLUETOOTH_A2DP,"")
+            == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    /**
+     * @hide
+     * Signals whether remote submix audio rerouting is enabled.
+     */
+    public void setRemoteSubmixOn(boolean on, int address) {
+        IAudioService service = getService();
+        try {
+            service.setRemoteSubmixOn(on, address);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setRemoteSubmixOn", e);
+        }
+    }
+
+    /**
+     * Sets audio routing to the wired headset on or off.
+     *
+     * @param on set <var>true</var> to route audio to/from wired
+     *           headset; <var>false</var> disable wired headset audio
+     * @deprecated Do not use.
+     */
+    @Deprecated public void setWiredHeadsetOn(boolean on){
+    }
+
+    /**
+     * Checks whether a wired headset is connected or not.
+     * <p>This is not a valid indication that audio playback is
+     * actually over the wired headset as audio routing depends on other conditions.
+     *
+     * @return true if a wired headset is connected.
+     *         false if otherwise
+     * @deprecated Use only to check is a headset is connected or not.
+     */
+    public boolean isWiredHeadsetOn() {
+        if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_WIRED_HEADSET,"")
+                == AudioSystem.DEVICE_STATE_UNAVAILABLE &&
+            AudioSystem.getDeviceConnectionState(DEVICE_OUT_WIRED_HEADPHONE,"")
+                == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    /**
+     * Sets the microphone mute on or off.
+     * <p>
+     * This method should only be used by applications that replace the platform-wide
+     * management of audio settings or the main telephony application.
+     *
+     * @param on set <var>true</var> to mute the microphone;
+     *           <var>false</var> to turn mute off
+     */
+    public void setMicrophoneMute(boolean on){
+        AudioSystem.muteMicrophone(on);
+    }
+
+    /**
+     * Checks whether the microphone mute is on or off.
+     *
+     * @return true if microphone is muted, false if it's not
+     */
+    public boolean isMicrophoneMute() {
+        return AudioSystem.isMicrophoneMuted();
+    }
+
+    /**
+     * Sets the audio mode.
+     * <p>
+     * The audio mode encompasses audio routing AND the behavior of
+     * the telephony layer. Therefore this method should only be used by applications that
+     * replace the platform-wide management of audio settings or the main telephony application.
+     * In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony
+     * application when it places a phone call, as it will cause signals from the radio layer
+     * to feed the platform mixer.
+     *
+     * @param mode  the requested audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
+     *              {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
+     *              Informs the HAL about the current audio state so that
+     *              it can route the audio appropriately.
+     */
+    public void setMode(int mode) {
+        IAudioService service = getService();
+        try {
+            service.setMode(mode, mICallBack);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setMode", e);
+        }
+    }
+
+    /**
+     * Returns the current audio mode.
+     *
+     * @return      the current audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
+     *              {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
+     *              Returns the current current audio state from the HAL.
+     */
+    public int getMode() {
+        IAudioService service = getService();
+        try {
+            return service.getMode();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getMode", e);
+            return MODE_INVALID;
+        }
+    }
+
+    /* modes for setMode/getMode/setRoute/getRoute */
+    /**
+     * Audio harware modes.
+     */
+    /**
+     * Invalid audio mode.
+     */
+    public static final int MODE_INVALID            = AudioSystem.MODE_INVALID;
+    /**
+     * Current audio mode. Used to apply audio routing to current mode.
+     */
+    public static final int MODE_CURRENT            = AudioSystem.MODE_CURRENT;
+    /**
+     * Normal audio mode: not ringing and no call established.
+     */
+    public static final int MODE_NORMAL             = AudioSystem.MODE_NORMAL;
+    /**
+     * Ringing audio mode. An incoming is being signaled.
+     */
+    public static final int MODE_RINGTONE           = AudioSystem.MODE_RINGTONE;
+    /**
+     * In call audio mode. A telephony call is established.
+     */
+    public static final int MODE_IN_CALL            = AudioSystem.MODE_IN_CALL;
+    /**
+     * In communication audio mode. An audio/video chat or VoIP call is established.
+     */
+    public static final int MODE_IN_COMMUNICATION   = AudioSystem.MODE_IN_COMMUNICATION;
+
+    /* Routing bits for setRouting/getRouting API */
+    /**
+     * Routing audio output to earpiece
+     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
+     * setBluetoothScoOn() methods instead.
+     */
+    @Deprecated public static final int ROUTE_EARPIECE          = AudioSystem.ROUTE_EARPIECE;
+    /**
+     * Routing audio output to speaker
+     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
+     * setBluetoothScoOn() methods instead.
+     */
+    @Deprecated public static final int ROUTE_SPEAKER           = AudioSystem.ROUTE_SPEAKER;
+    /**
+     * @deprecated use {@link #ROUTE_BLUETOOTH_SCO}
+     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
+     * setBluetoothScoOn() methods instead.
+     */
+    @Deprecated public static final int ROUTE_BLUETOOTH = AudioSystem.ROUTE_BLUETOOTH_SCO;
+    /**
+     * Routing audio output to bluetooth SCO
+     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
+     * setBluetoothScoOn() methods instead.
+     */
+    @Deprecated public static final int ROUTE_BLUETOOTH_SCO     = AudioSystem.ROUTE_BLUETOOTH_SCO;
+    /**
+     * Routing audio output to headset
+     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
+     * setBluetoothScoOn() methods instead.
+     */
+    @Deprecated public static final int ROUTE_HEADSET           = AudioSystem.ROUTE_HEADSET;
+    /**
+     * Routing audio output to bluetooth A2DP
+     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
+     * setBluetoothScoOn() methods instead.
+     */
+    @Deprecated public static final int ROUTE_BLUETOOTH_A2DP    = AudioSystem.ROUTE_BLUETOOTH_A2DP;
+    /**
+     * Used for mask parameter of {@link #setRouting(int,int,int)}.
+     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
+     * setBluetoothScoOn() methods instead.
+     */
+    @Deprecated public static final int ROUTE_ALL               = AudioSystem.ROUTE_ALL;
+
+    /**
+     * Sets the audio routing for a specified mode
+     *
+     * @param mode   audio mode to change route. E.g., MODE_RINGTONE.
+     * @param routes bit vector of routes requested, created from one or
+     *               more of ROUTE_xxx types. Set bits indicate that route should be on
+     * @param mask   bit vector of routes to change, created from one or more of
+     * ROUTE_xxx types. Unset bits indicate the route should be left unchanged
+     *
+     * @deprecated   Do not set audio routing directly, use setSpeakerphoneOn(),
+     * setBluetoothScoOn() methods instead.
+     */
+    @Deprecated
+    public void setRouting(int mode, int routes, int mask) {
+    }
+
+    /**
+     * Returns the current audio routing bit vector for a specified mode.
+     *
+     * @param mode audio mode to get route (e.g., MODE_RINGTONE)
+     * @return an audio route bit vector that can be compared with ROUTE_xxx
+     * bits
+     * @deprecated   Do not query audio routing directly, use isSpeakerphoneOn(),
+     * isBluetoothScoOn(), isBluetoothA2dpOn() and isWiredHeadsetOn() methods instead.
+     */
+    @Deprecated
+    public int getRouting(int mode) {
+        return -1;
+    }
+ 
+     /**
+      * Checks whether FM stream is active.
+      *
+      * @return true if FM is active.
+      * @hide
+      */
+    public boolean isFMActive() {
+        return AudioSystem.isStreamActive(STREAM_FM, 0);
+    }
+
+    /**
+     * Checks whether any music is active.
+     *
+     * @return true if any music tracks are active.
+     */
+    public boolean isMusicActive() {
+        return AudioSystem.isStreamActive(STREAM_MUSIC, 0);
+    }
+
+    /**
+     * @hide
+     * Checks whether speech recognition is active
+     * @return true if a recording with source {@link MediaRecorder.AudioSource#VOICE_RECOGNITION}
+     *    is underway.
+     */
+    public boolean isSpeechRecognitionActive() {
+        return AudioSystem.isSourceActive(MediaRecorder.AudioSource.VOICE_RECOGNITION);
+    }
+
+    /**
+     * @hide
+     * If the stream is active locally or remotely, adjust its volume according to the enforced
+     * priority rules.
+     * Note: only AudioManager.STREAM_MUSIC is supported at the moment
+     */
+    public void adjustLocalOrRemoteStreamVolume(int streamType, int direction) {
+        if (streamType != STREAM_MUSIC && streamType != STREAM_FM) {
+            Log.w(TAG, "adjustLocalOrRemoteStreamVolume() doesn't support stream " + streamType);
+        }
+        IAudioService service = getService();
+        try {
+            service.adjustLocalOrRemoteStreamVolume(streamType, direction);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in adjustLocalOrRemoteStreamVolume", e);
+        }
+    }
+
+    /*
+     * Sets a generic audio configuration parameter. The use of these parameters
+     * are platform dependant, see libaudio
+     *
+     * ** Temporary interface - DO NOT USE
+     *
+     * TODO: Replace with a more generic key:value get/set mechanism
+     *
+     * param key   name of parameter to set. Must not be null.
+     * param value value of parameter. Must not be null.
+     */
+    /**
+     * @hide
+     * @deprecated Use {@link #setPrameters(String)} instead
+     */
+    @Deprecated public void setParameter(String key, String value) {
+        setParameters(key+"="+value);
+    }
+
+    /**
+     * Sets a variable number of parameter values to audio hardware.
+     *
+     * @param keyValuePairs list of parameters key value pairs in the form:
+     *    key1=value1;key2=value2;...
+     *
+     */
+    public void setParameters(String keyValuePairs) {
+        AudioSystem.setParameters(keyValuePairs);
+    }
+
+    /**
+     * Sets a varaible number of parameter values to audio hardware.
+     *
+     * @param keys list of parameters
+     * @return list of parameters key value pairs in the form:
+     *    key1=value1;key2=value2;...
+     */
+    public String getParameters(String keys) {
+        return AudioSystem.getParameters(keys);
+    }
+
+    /* Sound effect identifiers */
+    /**
+     * Keyboard and direction pad click sound
+     * @see #playSoundEffect(int)
+     */
+    public static final int FX_KEY_CLICK = 0;
+    /**
+     * Focus has moved up
+     * @see #playSoundEffect(int)
+     */
+    public static final int FX_FOCUS_NAVIGATION_UP = 1;
+    /**
+     * Focus has moved down
+     * @see #playSoundEffect(int)
+     */
+    public static final int FX_FOCUS_NAVIGATION_DOWN = 2;
+    /**
+     * Focus has moved left
+     * @see #playSoundEffect(int)
+     */
+    public static final int FX_FOCUS_NAVIGATION_LEFT = 3;
+    /**
+     * Focus has moved right
+     * @see #playSoundEffect(int)
+     */
+    public static final int FX_FOCUS_NAVIGATION_RIGHT = 4;
+    /**
+     * IME standard keypress sound
+     * @see #playSoundEffect(int)
+     */
+    public static final int FX_KEYPRESS_STANDARD = 5;
+    /**
+     * IME spacebar keypress sound
+     * @see #playSoundEffect(int)
+     */
+    public static final int FX_KEYPRESS_SPACEBAR = 6;
+    /**
+     * IME delete keypress sound
+     * @see #playSoundEffect(int)
+     */
+    public static final int FX_KEYPRESS_DELETE = 7;
+    /**
+     * IME return_keypress sound
+     * @see #playSoundEffect(int)
+     */
+    public static final int FX_KEYPRESS_RETURN = 8;
+    /**
+     * @hide Number of sound effects
+     */
+    public static final int NUM_SOUND_EFFECTS = 9;
+
+    /**
+     * Plays a sound effect (Key clicks, lid open/close...)
+     * @param effectType The type of sound effect. One of
+     *            {@link #FX_KEY_CLICK},
+     *            {@link #FX_FOCUS_NAVIGATION_UP},
+     *            {@link #FX_FOCUS_NAVIGATION_DOWN},
+     *            {@link #FX_FOCUS_NAVIGATION_LEFT},
+     *            {@link #FX_FOCUS_NAVIGATION_RIGHT},
+     *            {@link #FX_KEYPRESS_STANDARD},
+     *            {@link #FX_KEYPRESS_SPACEBAR},
+     *            {@link #FX_KEYPRESS_DELETE},
+     *            {@link #FX_KEYPRESS_RETURN},
+     * NOTE: This version uses the UI settings to determine
+     * whether sounds are heard or not.
+     */
+    public void  playSoundEffect(int effectType) {
+        if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
+            return;
+        }
+
+        if (!querySoundEffectsEnabled()) {
+            return;
+        }
+
+        IAudioService service = getService();
+        try {
+            service.playSoundEffect(effectType);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in playSoundEffect"+e);
+        }
+    }
+
+    /**
+     * Plays a sound effect (Key clicks, lid open/close...)
+     * @param effectType The type of sound effect. One of
+     *            {@link #FX_KEY_CLICK},
+     *            {@link #FX_FOCUS_NAVIGATION_UP},
+     *            {@link #FX_FOCUS_NAVIGATION_DOWN},
+     *            {@link #FX_FOCUS_NAVIGATION_LEFT},
+     *            {@link #FX_FOCUS_NAVIGATION_RIGHT},
+     *            {@link #FX_KEYPRESS_STANDARD},
+     *            {@link #FX_KEYPRESS_SPACEBAR},
+     *            {@link #FX_KEYPRESS_DELETE},
+     *            {@link #FX_KEYPRESS_RETURN},
+     * @param volume Sound effect volume.
+     * The volume value is a raw scalar so UI controls should be scaled logarithmically.
+     * If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used.
+     * NOTE: This version is for applications that have their own
+     * settings panel for enabling and controlling volume.
+     */
+    public void  playSoundEffect(int effectType, float volume) {
+        if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
+            return;
+        }
+
+        IAudioService service = getService();
+        try {
+            service.playSoundEffectVolume(effectType, volume);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in playSoundEffect"+e);
+        }
+    }
+
+    /**
+     * Settings has an in memory cache, so this is fast.
+     */
+    private boolean querySoundEffectsEnabled() {
+        return Settings.System.getInt(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0) != 0;
+    }
+
+
+    /**
+     *  Load Sound effects.
+     *  This method must be called when sound effects are enabled.
+     */
+    public void loadSoundEffects() {
+        IAudioService service = getService();
+        try {
+            service.loadSoundEffects();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in loadSoundEffects"+e);
+        }
+    }
+
+    /**
+     *  Unload Sound effects.
+     *  This method can be called to free some memory when
+     *  sound effects are disabled.
+     */
+    public void unloadSoundEffects() {
+        IAudioService service = getService();
+        try {
+            service.unloadSoundEffects();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in unloadSoundEffects"+e);
+        }
+    }
+
+    /**
+     * Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration.
+     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
+     */
+    public static final int AUDIOFOCUS_GAIN = 1;
+    /**
+     * Used to indicate a temporary gain or request of audio focus, anticipated to last a short
+     * amount of time. Examples of temporary changes are the playback of driving directions, or an
+     * event notification.
+     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
+     */
+    public static final int AUDIOFOCUS_GAIN_TRANSIENT = 2;
+    /**
+     * Used to indicate a temporary request of audio focus, anticipated to last a short
+     * amount of time, and where it is acceptable for other audio applications to keep playing
+     * after having lowered their output level (also referred to as "ducking").
+     * Examples of temporary changes are the playback of driving directions where playback of music
+     * in the background is acceptable.
+     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+     * @see #requestAudioFocus(OnAudioFocusChangeListener, int, int)
+     */
+    public static final int AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK = 3;
+    /**
+     * Used to indicate a loss of audio focus of unknown duration.
+     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+     */
+    public static final int AUDIOFOCUS_LOSS = -1 * AUDIOFOCUS_GAIN;
+    /**
+     * Used to indicate a transient loss of audio focus.
+     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+     */
+    public static final int AUDIOFOCUS_LOSS_TRANSIENT = -1 * AUDIOFOCUS_GAIN_TRANSIENT;
+    /**
+     * Used to indicate a transient loss of audio focus where the loser of the audio focus can
+     * lower its output volume if it wants to continue playing (also referred to as "ducking"), as
+     * the new focus owner doesn't require others to be silent.
+     * @see OnAudioFocusChangeListener#onAudioFocusChange(int)
+     */
+    public static final int AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK =
+            -1 * AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
+
+    /**
+     * Interface definition for a callback to be invoked when the audio focus of the system is
+     * updated.
+     */
+    public interface OnAudioFocusChangeListener {
+        /**
+         * Called on the listener to notify it the audio focus for this listener has been changed.
+         * The focusChange value indicates whether the focus was gained,
+         * whether the focus was lost, and whether that loss is transient, or whether the new focus
+         * holder will hold it for an unknown amount of time.
+         * When losing focus, listeners can use the focus change information to decide what
+         * behavior to adopt when losing focus. A music player could for instance elect to lower
+         * the volume of its music stream (duck) for transient focus losses, and pause otherwise.
+         * @param focusChange the type of focus change, one of {@link AudioManager#AUDIOFOCUS_GAIN},
+         *   {@link AudioManager#AUDIOFOCUS_LOSS}, {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT}
+         *   and {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}.
+         */
+        public void onAudioFocusChange(int focusChange);
+    }
+
+    /**
+     * Map to convert focus event listener IDs, as used in the AudioService audio focus stack,
+     * to actual listener objects.
+     */
+    private final HashMap<String, OnAudioFocusChangeListener> mAudioFocusIdListenerMap =
+            new HashMap<String, OnAudioFocusChangeListener>();
+    /**
+     * Lock to prevent concurrent changes to the list of focus listeners for this AudioManager
+     * instance.
+     */
+    private final Object mFocusListenerLock = new Object();
+
+    private OnAudioFocusChangeListener findFocusListener(String id) {
+        return mAudioFocusIdListenerMap.get(id);
+    }
+
+    /**
+     * Handler for audio focus events coming from the audio service.
+     */
+    private final FocusEventHandlerDelegate mAudioFocusEventHandlerDelegate =
+            new FocusEventHandlerDelegate();
+
+    /**
+     * Helper class to handle the forwarding of audio focus events to the appropriate listener
+     */
+    private class FocusEventHandlerDelegate {
+        private final Handler mHandler;
+
+        FocusEventHandlerDelegate() {
+            Looper looper;
+            if ((looper = Looper.myLooper()) == null) {
+                looper = Looper.getMainLooper();
+            }
+
+            if (looper != null) {
+                // implement the event handler delegate to receive audio focus events
+                mHandler = new Handler(looper) {
+                    @Override
+                    public void handleMessage(Message msg) {
+                        OnAudioFocusChangeListener listener = null;
+                        synchronized(mFocusListenerLock) {
+                            listener = findFocusListener((String)msg.obj);
+                        }
+                        if (listener != null) {
+                            listener.onAudioFocusChange(msg.what);
+                        }
+                    }
+                };
+            } else {
+                mHandler = null;
+            }
+        }
+
+        Handler getHandler() {
+            return mHandler;
+        }
+    }
+
+    private final IAudioFocusDispatcher mAudioFocusDispatcher = new IAudioFocusDispatcher.Stub() {
+
+        public void dispatchAudioFocusChange(int focusChange, String id) {
+            Message m = mAudioFocusEventHandlerDelegate.getHandler().obtainMessage(focusChange, id);
+            mAudioFocusEventHandlerDelegate.getHandler().sendMessage(m);
+        }
+
+    };
+
+    private String getIdForAudioFocusListener(OnAudioFocusChangeListener l) {
+        if (l == null) {
+            return new String(this.toString());
+        } else {
+            return new String(this.toString() + l.toString());
+        }
+    }
+
+    /**
+     * @hide
+     * Registers a listener to be called when audio focus changes. Calling this method is optional
+     * before calling {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, as it
+     * will register the listener as well if it wasn't registered already.
+     * @param l the listener to be notified of audio focus changes.
+     */
+    public void registerAudioFocusListener(OnAudioFocusChangeListener l) {
+        synchronized(mFocusListenerLock) {
+            if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
+                return;
+            }
+            mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l), l);
+        }
+    }
+
+    /**
+     * @hide
+     * Causes the specified listener to not be called anymore when focus is gained or lost.
+     * @param l the listener to unregister.
+     */
+    public void unregisterAudioFocusListener(OnAudioFocusChangeListener l) {
+
+        // remove locally
+        synchronized(mFocusListenerLock) {
+            mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
+        }
+    }
+
+
+    /**
+     * A failed focus change request.
+     */
+    public static final int AUDIOFOCUS_REQUEST_FAILED = 0;
+    /**
+     * A successful focus change request.
+     */
+    public static final int AUDIOFOCUS_REQUEST_GRANTED = 1;
+
+
+    /**
+     *  Request audio focus.
+     *  Send a request to obtain the audio focus
+     *  @param l the listener to be notified of audio focus changes
+     *  @param streamType the main audio stream type affected by the focus request
+     *  @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request
+     *      is temporary, and focus will be abandonned shortly. Examples of transient requests are
+     *      for the playback of driving directions, or notifications sounds.
+     *      Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for
+     *      the previous focus owner to keep playing if it ducks its audio output.
+     *      Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such
+     *      as the playback of a song or a video.
+     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
+     */
+    public int requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint) {
+        int status = AUDIOFOCUS_REQUEST_FAILED;
+        if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK))
+        {
+            Log.e(TAG, "Invalid duration hint, audio focus request denied");
+            return status;
+        }
+        registerAudioFocusListener(l);
+        //TODO protect request by permission check?
+        IAudioService service = getService();
+        try {
+            status = service.requestAudioFocus(streamType, durationHint, mICallBack,
+                    mAudioFocusDispatcher, getIdForAudioFocusListener(l),
+                    mContext.getPackageName() /* package name */);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Can't call requestAudioFocus() on AudioService due to "+e);
+        }
+        return status;
+    }
+
+    /**
+     * @hide
+     * Used internally by telephony package to request audio focus. Will cause the focus request
+     * to be associated with the "voice communication" identifier only used in AudioService
+     * to identify this use case.
+     * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
+     *    the establishment of the call
+     * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
+     *    media applications resume after a call
+     */
+    public void requestAudioFocusForCall(int streamType, int durationHint) {
+        IAudioService service = getService();
+        try {
+            service.requestAudioFocus(streamType, durationHint, mICallBack, null,
+                    AudioService.IN_VOICE_COMM_FOCUS_ID,
+                    "system" /* dump-friendly package name */);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService due to "+e);
+        }
+    }
+
+    /**
+     * @hide
+     * Used internally by telephony package to abandon audio focus, typically after a call or
+     * when ringing ends and the call is rejected or not answered.
+     * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.
+     */
+    public void abandonAudioFocusForCall() {
+        IAudioService service = getService();
+        try {
+            service.abandonAudioFocus(null, AudioService.IN_VOICE_COMM_FOCUS_ID);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Can't call abandonAudioFocusForCall() on AudioService due to "+e);
+        }
+    }
+
+    /**
+     *  Abandon audio focus. Causes the previous focus owner, if any, to receive focus.
+     *  @param l the listener with which focus was requested.
+     *  @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
+     */
+    public int abandonAudioFocus(OnAudioFocusChangeListener l) {
+        int status = AUDIOFOCUS_REQUEST_FAILED;
+        unregisterAudioFocusListener(l);
+        IAudioService service = getService();
+        try {
+            status = service.abandonAudioFocus(mAudioFocusDispatcher,
+                    getIdForAudioFocusListener(l));
+        } catch (RemoteException e) {
+            Log.e(TAG, "Can't call abandonAudioFocus() on AudioService due to "+e);
+        }
+        return status;
+    }
+
+
+    //====================================================================
+    // Remote Control
+    /**
+     * Register a component to be the sole receiver of MEDIA_BUTTON intents.
+     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
+     *      that will receive the media button intent. This broadcast receiver must be declared
+     *      in the application manifest. The package of the component must match that of
+     *      the context you're registering from.
+     */
+    public void registerMediaButtonEventReceiver(ComponentName eventReceiver) {
+        if (eventReceiver == null) {
+            return;
+        }
+        if (!eventReceiver.getPackageName().equals(mContext.getPackageName())) {
+            Log.e(TAG, "registerMediaButtonEventReceiver() error: " +
+                    "receiver and context package names don't match");
+            return;
+        }
+        // construct a PendingIntent for the media button and register it
+        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
+        //     the associated intent will be handled by the component being registered
+        mediaButtonIntent.setComponent(eventReceiver);
+        PendingIntent pi = PendingIntent.getBroadcast(mContext,
+                0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);
+        registerMediaButtonIntent(pi, eventReceiver);
+    }
+
+    /**
+     * @hide
+     * no-op if (pi == null) or (eventReceiver == null)
+     */
+    public void registerMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver) {
+        if ((pi == null) || (eventReceiver == null)) {
+            Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
+            return;
+        }
+        IAudioService service = getService();
+        try {
+            // pi != null
+            service.registerMediaButtonIntent(pi, eventReceiver);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in registerMediaButtonIntent"+e);
+        }
+    }
+
+    /**
+     * @hide
+     * Used internally by telephony package to register an intent receiver for ACTION_MEDIA_BUTTON.
+     * @param eventReceiver the component that will receive the media button key events,
+     *          no-op if eventReceiver is null
+     */
+    public void registerMediaButtonEventReceiverForCalls(ComponentName eventReceiver) {
+        if (eventReceiver == null) {
+            return;
+        }
+        IAudioService service = getService();
+        try {
+            // eventReceiver != null
+            service.registerMediaButtonEventReceiverForCalls(eventReceiver);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in registerMediaButtonEventReceiverForCalls", e);
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public void unregisterMediaButtonEventReceiverForCalls() {
+        IAudioService service = getService();
+        try {
+            service.unregisterMediaButtonEventReceiverForCalls();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in unregisterMediaButtonEventReceiverForCalls", e);
+        }
+    }
+
+    /**
+     * Unregister the receiver of MEDIA_BUTTON intents.
+     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
+     *      that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.
+     */
+    public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver) {
+        if (eventReceiver == null) {
+            return;
+        }
+        // construct a PendingIntent for the media button and unregister it
+        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
+        //     the associated intent will be handled by the component being registered
+        mediaButtonIntent.setComponent(eventReceiver);
+        PendingIntent pi = PendingIntent.getBroadcast(mContext,
+                0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);
+        unregisterMediaButtonIntent(pi, eventReceiver);
+    }
+
+    /**
+     * @hide
+     */
+    public void unregisterMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver) {
+        IAudioService service = getService();
+        try {
+            service.unregisterMediaButtonIntent(pi, eventReceiver);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in unregisterMediaButtonIntent"+e);
+        }
+    }
+
+    /**
+     * Registers the remote control client for providing information to display on the remote
+     * controls.
+     * @param rcClient The remote control client from which remote controls will receive
+     *      information to display.
+     * @see RemoteControlClient
+     */
+    public void registerRemoteControlClient(RemoteControlClient rcClient) {
+        if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
+            return;
+        }
+        IAudioService service = getService();
+        try {
+            int rcseId = service.registerRemoteControlClient(
+                    rcClient.getRcMediaIntent(),       /* mediaIntent   */
+                    rcClient.getIRemoteControlClient(),/* rcClient      */
+                    // used to match media button event receiver and audio focus
+                    mContext.getPackageName());        /* packageName   */
+            rcClient.setRcseId(rcseId);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in registerRemoteControlClient"+e);
+        }
+    }
+
+    /**
+     * Unregisters the remote control client that was providing information to display on the
+     * remote controls.
+     * @param rcClient The remote control client to unregister.
+     * @see #registerRemoteControlClient(RemoteControlClient)
+     */
+    public void unregisterRemoteControlClient(RemoteControlClient rcClient) {
+        if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
+            return;
+        }
+        IAudioService service = getService();
+        try {
+            service.unregisterRemoteControlClient(rcClient.getRcMediaIntent(), /* mediaIntent   */
+                    rcClient.getIRemoteControlClient());                       /* rcClient      */
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in unregisterRemoteControlClient"+e);
+        }
+    }
+
+    /**
+     * @hide
+     * Registers a remote control display that will be sent information by remote control clients.
+     * @param rcd
+     */
+    public void registerRemoteControlDisplay(IRemoteControlDisplay rcd) {
+        if (rcd == null) {
+            return;
+        }
+        IAudioService service = getService();
+        try {
+            service.registerRemoteControlDisplay(rcd);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in registerRemoteControlDisplay " + e);
+        }
+    }
+
+    /**
+     * @hide
+     * Unregisters a remote control display that was sent information by remote control clients.
+     * @param rcd
+     */
+    public void unregisterRemoteControlDisplay(IRemoteControlDisplay rcd) {
+        if (rcd == null) {
+            return;
+        }
+        IAudioService service = getService();
+        try {
+            service.unregisterRemoteControlDisplay(rcd);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in unregisterRemoteControlDisplay " + e);
+        }
+    }
+
+    /**
+     * @hide
+     * Sets the artwork size a remote control display expects when receiving bitmaps.
+     * @param rcd
+     * @param w the maximum width of the expected bitmap. Negative values indicate it is
+     *   useless to send artwork.
+     * @param h the maximum height of the expected bitmap. Negative values indicate it is
+     *   useless to send artwork.
+     */
+    public void remoteControlDisplayUsesBitmapSize(IRemoteControlDisplay rcd, int w, int h) {
+        if (rcd == null) {
+            return;
+        }
+        IAudioService service = getService();
+        try {
+            service.remoteControlDisplayUsesBitmapSize(rcd, w, h);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in remoteControlDisplayUsesBitmapSize " + e);
+        }
+    }
+
+    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
+    /**
+     * @hide
+     * Broadcast intent action indicating that the displays on the remote controls
+     * should be updated because a new remote control client is now active. If there is no
+     * {@link #EXTRA_REMOTE_CONTROL_CLIENT}, the remote control display should be cleared
+     * because there is no valid client to supply it with information.
+     *
+     * @see #EXTRA_REMOTE_CONTROL_CLIENT
+     */
+    public static final String REMOTE_CONTROL_CLIENT_CHANGED =
+            "android.media.REMOTE_CONTROL_CLIENT_CHANGED";
+
+    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
+    /**
+     * @hide
+     * The IRemoteControlClientDispatcher monotonically increasing generation counter.
+     *
+     * @see #REMOTE_CONTROL_CLIENT_CHANGED_ACTION
+     */
+    public static final String EXTRA_REMOTE_CONTROL_CLIENT_GENERATION =
+            "android.media.EXTRA_REMOTE_CONTROL_CLIENT_GENERATION";
+
+    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
+    /**
+     * @hide
+     * The name of the RemoteControlClient.
+     * This String is passed as the client name when calling methods from the
+     * IRemoteControlClientDispatcher interface.
+     *
+     * @see #REMOTE_CONTROL_CLIENT_CHANGED_ACTION
+     */
+    public static final String EXTRA_REMOTE_CONTROL_CLIENT_NAME =
+            "android.media.EXTRA_REMOTE_CONTROL_CLIENT_NAME";
+
+    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
+    /**
+     * @hide
+     * The media button event receiver associated with the RemoteControlClient.
+     * The {@link android.content.ComponentName} value of the event receiver can be retrieved with
+     * {@link android.content.ComponentName#unflattenFromString(String)}
+     *
+     * @see #REMOTE_CONTROL_CLIENT_CHANGED_ACTION
+     */
+    public static final String EXTRA_REMOTE_CONTROL_EVENT_RECEIVER =
+            "android.media.EXTRA_REMOTE_CONTROL_EVENT_RECEIVER";
+
+    // FIXME remove because we are not using intents anymore between AudioService and RcDisplay
+    /**
+     * @hide
+     * The flags describing what information has changed in the current remote control client.
+     *
+     * @see #REMOTE_CONTROL_CLIENT_CHANGED_ACTION
+     */
+    public static final String EXTRA_REMOTE_CONTROL_CLIENT_INFO_CHANGED =
+            "android.media.EXTRA_REMOTE_CONTROL_CLIENT_INFO_CHANGED";
+
+    /**
+     *  @hide
+     *  Reload audio settings. This method is called by Settings backup
+     *  agent when audio settings are restored and causes the AudioService
+     *  to read and apply restored settings.
+     */
+    public void reloadAudioSettings() {
+        IAudioService service = getService();
+        try {
+            service.reloadAudioSettings();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in reloadAudioSettings"+e);
+        }
+    }
+
+     /**
+      * {@hide}
+      */
+     private final IBinder mICallBack = new Binder();
+
+    /**
+     * Checks whether the phone is in silent mode, with or without vibrate.
+     *
+     * @return true if phone is in silent mode, with or without vibrate.
+     *
+     * @see #getRingerMode()
+     *
+     * @hide pending API Council approval
+     */
+    public boolean isSilentMode() {
+        int ringerMode = getRingerMode();
+        boolean silentMode =
+            (ringerMode == RINGER_MODE_SILENT) ||
+            (ringerMode == RINGER_MODE_VIBRATE);
+        return silentMode;
+    }
+
+    // This section re-defines new output device constants from AudioSystem, because the AudioSystem
+    // class is not used by other parts of the framework, which instead use definitions and methods
+    // from AudioManager. AudioSystem is an internal class used by AudioManager and AudioService.
+
+    /** {@hide} The audio output device code for the small speaker at the front of the device used
+     *  when placing calls.  Does not refer to an in-ear headphone without attached microphone,
+     *  such as earbuds, earphones, or in-ear monitors (IEM). Those would be handled as a
+     *  {@link #DEVICE_OUT_WIRED_HEADPHONE}.
+     */
+    public static final int DEVICE_OUT_EARPIECE = AudioSystem.DEVICE_OUT_EARPIECE;
+    /** {@hide} The audio output device code for the built-in speaker */
+    public static final int DEVICE_OUT_SPEAKER = AudioSystem.DEVICE_OUT_SPEAKER;
+    /** {@hide} The audio output device code for a wired headset with attached microphone */
+    public static final int DEVICE_OUT_WIRED_HEADSET = AudioSystem.DEVICE_OUT_WIRED_HEADSET;
+    /** {@hide} The audio output device code for a wired headphone without attached microphone */
+    public static final int DEVICE_OUT_WIRED_HEADPHONE = AudioSystem.DEVICE_OUT_WIRED_HEADPHONE;
+    /** {@hide} The audio output device code for generic Bluetooth SCO, for voice */
+    public static final int DEVICE_OUT_BLUETOOTH_SCO = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
+    /** {@hide} The audio output device code for Bluetooth SCO Headset Profile (HSP) and
+     *  Hands-Free Profile (HFP), for voice
+     */
+    public static final int DEVICE_OUT_BLUETOOTH_SCO_HEADSET =
+            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
+    /** {@hide} The audio output device code for Bluetooth SCO car audio, for voice */
+    public static final int DEVICE_OUT_BLUETOOTH_SCO_CARKIT =
+            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
+    /** {@hide} The audio output device code for generic Bluetooth A2DP, for music */
+    public static final int DEVICE_OUT_BLUETOOTH_A2DP = AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP;
+    /** {@hide} The audio output device code for Bluetooth A2DP headphones, for music */
+    public static final int DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES =
+            AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;
+    /** {@hide} The audio output device code for Bluetooth A2DP external speaker, for music */
+    public static final int DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER =
+            AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER;
+    /** {@hide} The audio output device code for S/PDIF or HDMI */
+    public static final int DEVICE_OUT_AUX_DIGITAL = AudioSystem.DEVICE_OUT_AUX_DIGITAL;
+    /** {@hide} The audio output device code for an analog wired headset attached via a
+     *  docking station
+     */
+    public static final int DEVICE_OUT_ANLG_DOCK_HEADSET = AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET;
+    /** {@hide} The audio output device code for a digital wired headset attached via a
+     *  docking station
+     */
+    public static final int DEVICE_OUT_DGTL_DOCK_HEADSET = AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET;
+    /** {@hide} The audio output device code for a USB audio accessory. The accessory is in USB host
+     * mode and the Android device in USB device mode
+     */
+    public static final int DEVICE_OUT_USB_ACCESSORY = AudioSystem.DEVICE_OUT_USB_ACCESSORY;
+    /** {@hide} The audio output device code for a USB audio device. The device is in USB device
+     * mode and the Android device in USB host mode
+     */
+    public static final int DEVICE_OUT_USB_DEVICE = AudioSystem.DEVICE_OUT_USB_DEVICE;
+    /** {@hide} This is not used as a returned value from {@link #getDevicesForStream}, but could be
+     *  used in the future in a set method to select whatever default device is chosen by the
+     *  platform-specific implementation.
+     */
+    public static final int DEVICE_OUT_DEFAULT = AudioSystem.DEVICE_OUT_DEFAULT;
+
+    /**
+     * Return the enabled devices for the specified output stream type.
+     *
+     * @param streamType The stream type to query. One of
+     *            {@link #STREAM_VOICE_CALL},
+     *            {@link #STREAM_SYSTEM},
+     *            {@link #STREAM_RING},
+     *            {@link #STREAM_MUSIC},
+     *            {@link #STREAM_ALARM},
+     *            {@link #STREAM_NOTIFICATION},
+     *            {@link #STREAM_DTMF}.
+     *
+     * @return The bit-mask "or" of audio output device codes for all enabled devices on this
+     *         stream. Zero or more of
+     *            {@link #DEVICE_OUT_EARPIECE},
+     *            {@link #DEVICE_OUT_SPEAKER},
+     *            {@link #DEVICE_OUT_WIRED_HEADSET},
+     *            {@link #DEVICE_OUT_WIRED_HEADPHONE},
+     *            {@link #DEVICE_OUT_BLUETOOTH_SCO},
+     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_HEADSET},
+     *            {@link #DEVICE_OUT_BLUETOOTH_SCO_CARKIT},
+     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP},
+     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES},
+     *            {@link #DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER},
+     *            {@link #DEVICE_OUT_AUX_DIGITAL},
+     *            {@link #DEVICE_OUT_ANLG_DOCK_HEADSET},
+     *            {@link #DEVICE_OUT_DGTL_DOCK_HEADSET}.
+     *            {@link #DEVICE_OUT_DEFAULT} is not used here.
+     *
+     * The implementation may support additional device codes beyond those listed, so
+     * the application should ignore any bits which it does not recognize.
+     * Note that the information may be imprecise when the implementation
+     * cannot distinguish whether a particular device is enabled.
+     *
+     * {@hide}
+     */
+    public int getDevicesForStream(int streamType) {
+        switch (streamType) {
+        case STREAM_VOICE_CALL:
+        case STREAM_SYSTEM:
+        case STREAM_RING:
+        case STREAM_MUSIC:
+        case STREAM_ALARM:
+        case STREAM_NOTIFICATION:
+        case STREAM_DTMF:
+            return AudioSystem.getDevicesForStream(streamType);
+        default:
+            return 0;
+        }
+    }
+
+     /**
+     * Indicate wired accessory connection state change.
+     * @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)
+     * @param state  new connection state: 1 connected, 0 disconnected
+     * @param name   device name
+     * {@hide}
+     */
+    public void setWiredDeviceConnectionState(int device, int state, String name) {
+        IAudioService service = getService();
+        try {
+            service.setWiredDeviceConnectionState(device, state, name);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setWiredDeviceConnectionState "+e);
+        }
+    }
+
+     /**
+     * Indicate A2DP sink connection state change.
+     * @param device Bluetooth device connected/disconnected
+     * @param state  new connection state (BluetoothProfile.STATE_xxx)
+     * @return a delay in ms that the caller should wait before broadcasting
+     * BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED intent.
+     * {@hide}
+     */
+    public int setBluetoothA2dpDeviceConnectionState(BluetoothDevice device, int state) {
+        IAudioService service = getService();
+        int delay = 0;
+        try {
+            delay = service.setBluetoothA2dpDeviceConnectionState(device, state);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setBluetoothA2dpDeviceConnectionState "+e);
+        } finally {
+            return delay;
+        }
+    }
+
+    /** {@hide} */
+    public IRingtonePlayer getRingtonePlayer() {
+        try {
+            return getService().getRingtonePlayer();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Used as a key for {@link #getProperty} to request the native or optimal output sample rate
+     * for this device's primary output stream, in decimal Hz.
+     */
+    public static final String PROPERTY_OUTPUT_SAMPLE_RATE =
+            "android.media.property.OUTPUT_SAMPLE_RATE";
+
+    /**
+     * Used as a key for {@link #getProperty} to request the native or optimal output buffer size
+     * for this device's primary output stream, in decimal PCM frames.
+     */
+    public static final String PROPERTY_OUTPUT_FRAMES_PER_BUFFER =
+            "android.media.property.OUTPUT_FRAMES_PER_BUFFER";
+
+    /**
+     * Returns the value of the property with the specified key.
+     * @param key One of the strings corresponding to a property key: either
+     *            {@link #PROPERTY_OUTPUT_SAMPLE_RATE} or
+     *            {@link #PROPERTY_OUTPUT_FRAMES_PER_BUFFER}
+     * @return A string representing the associated value for that property key,
+     *         or null if there is no value for that key.
+     */
+    public String getProperty(String key) {
+        if (PROPERTY_OUTPUT_SAMPLE_RATE.equals(key)) {
+            int outputSampleRate = AudioSystem.getPrimaryOutputSamplingRate();
+            return outputSampleRate > 0 ? Integer.toString(outputSampleRate) : null;
+        } else if (PROPERTY_OUTPUT_FRAMES_PER_BUFFER.equals(key)) {
+            int outputFramesPerBuffer = AudioSystem.getPrimaryOutputFrameCount();
+            return outputFramesPerBuffer > 0 ? Integer.toString(outputFramesPerBuffer) : null;
+        } else {
+            // null or unknown key
+            return null;
+        }
+    }
+
+}
diff --git a/media/java/android/media/AudioService.java b/media/java/android/media/AudioService.java
index e9bd455..28626c9 100644
--- a/media/java/android/media/AudioService.java
+++ b/media/java/android/media/AudioService.java
@@ -1,6341 +1,6397 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.media;
-
-import static android.Manifest.permission.REMOTE_AUDIO_PLAYBACK;
-import static android.media.AudioManager.RINGER_MODE_NORMAL;
-import static android.media.AudioManager.RINGER_MODE_SILENT;
-import static android.media.AudioManager.RINGER_MODE_VIBRATE;
-
-import android.app.Activity;
-import android.app.ActivityManagerNative;
-import android.app.KeyguardManager;
-import android.app.PendingIntent;
-import android.app.PendingIntent.CanceledException;
-import android.app.PendingIntent.OnFinished;
-import android.bluetooth.BluetoothA2dp;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothClass;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothHeadset;
-import android.bluetooth.BluetoothProfile;
-import android.content.ActivityNotFoundException;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.PackageManager;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.database.ContentObserver;
-import android.media.MediaPlayer.OnCompletionListener;
-import android.media.MediaPlayer.OnErrorListener;
-import android.net.Uri;
-import android.os.Binder;
-import android.os.Bundle;
-import android.os.Environment;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.Message;
-import android.os.PowerManager;
-import android.os.RemoteCallbackList;
-import android.os.RemoteException;
-import android.os.ServiceManager;
-import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.os.Vibrator;
-import android.provider.Settings;
-import android.provider.Settings.System;
-import android.provider.Settings.SettingNotFoundException;
-import android.speech.RecognizerIntent;
-import android.telephony.PhoneStateListener;
-import android.telephony.ServiceState;
-import android.telephony.TelephonyManager;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.VolumePanel;
-
-import com.android.internal.app.ThemeUtils;
-import com.android.internal.telephony.ITelephony;
-
-import java.io.FileDescriptor;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Set;
-import java.util.Stack;
-
-/**
- * The implementation of the volume manager service.
- * <p>
- * This implementation focuses on delivering a responsive UI. Most methods are
- * asynchronous to external calls. For example, the task of setting a volume
- * will update our internal state, but in a separate thread will set the system
- * volume and later persist to the database. Similarly, setting the ringer mode
- * will update the state and broadcast a change and in a separate thread later
- * persist the ringer mode.
- *
- * @hide
- */
-public class AudioService extends IAudioService.Stub implements OnFinished {
-
-    private static final String TAG = "AudioService";
-
-    /** Debug remote control client/display feature */
-    protected static final boolean DEBUG_RC = false;
-    /** Debug volumes */
-    protected static final boolean DEBUG_VOL = false;
-
-    /** How long to delay before persisting a change in volume/ringer mode. */
-    private static final int PERSIST_DELAY = 500;
-
-    private Context mContext;
-    private ContentResolver mContentResolver;
-    private boolean mVoiceCapable;
-
-    /** The UI */
-    private VolumePanel mVolumePanel;
-    private Context mUiContext;
-    private Handler mHandler;
-
-    // sendMsg() flags
-    /** If the msg is already queued, replace it with this one. */
-    private static final int SENDMSG_REPLACE = 0;
-    /** If the msg is already queued, ignore this one and leave the old. */
-    private static final int SENDMSG_NOOP = 1;
-    /** If the msg is already queued, queue this one and leave the old. */
-    private static final int SENDMSG_QUEUE = 2;
-
-    // AudioHandler messages
-    private static final int MSG_SET_DEVICE_VOLUME = 0;
-    private static final int MSG_PERSIST_VOLUME = 1;
-    private static final int MSG_PERSIST_MASTER_VOLUME = 2;
-    private static final int MSG_PERSIST_RINGER_MODE = 3;
-    private static final int MSG_MEDIA_SERVER_DIED = 4;
-    private static final int MSG_MEDIA_SERVER_STARTED = 5;
-    private static final int MSG_PLAY_SOUND_EFFECT = 6;
-    private static final int MSG_BTA2DP_DOCK_TIMEOUT = 7;
-    private static final int MSG_LOAD_SOUND_EFFECTS = 8;
-    private static final int MSG_SET_FORCE_USE = 9;
-    private static final int MSG_PERSIST_MEDIABUTTONRECEIVER = 10;
-    private static final int MSG_BT_HEADSET_CNCT_FAILED = 11;
-    private static final int MSG_RCDISPLAY_CLEAR = 12;
-    private static final int MSG_RCDISPLAY_UPDATE = 13;
-    private static final int MSG_SET_ALL_VOLUMES = 14;
-    private static final int MSG_PERSIST_MASTER_VOLUME_MUTE = 15;
-    private static final int MSG_REPORT_NEW_ROUTES = 16;
-    private static final int MSG_REEVALUATE_REMOTE = 17;
-    private static final int MSG_RCC_NEW_PLAYBACK_INFO = 18;
-    private static final int MSG_RCC_NEW_VOLUME_OBS = 19;
-    private static final int MSG_SET_FORCE_BT_A2DP_USE = 20;
-    // start of messages handled under wakelock
-    //   these messages can only be queued, i.e. sent with queueMsgUnderWakeLock(),
-    //   and not with sendMsg(..., ..., SENDMSG_QUEUE, ...)
-    private static final int MSG_SET_WIRED_DEVICE_CONNECTION_STATE = 21;
-    private static final int MSG_SET_A2DP_CONNECTION_STATE = 22;
-    // end of messages handled under wakelock
-    private static final int MSG_SET_RSX_CONNECTION_STATE = 23; // change remote submix connection
-    private static final int MSG_CHECK_MUSIC_ACTIVE = 24;
-    private static final int MSG_BROADCAST_AUDIO_BECOMING_NOISY = 25;
-    private static final int MSG_CONFIGURE_SAFE_MEDIA_VOLUME = 26;
-    private static final int MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED = 27;
-    private static final int MSG_PERSIST_SAFE_VOLUME_STATE = 28;
-
-    // flags for MSG_PERSIST_VOLUME indicating if current and/or last audible volume should be
-    // persisted
-    private static final int PERSIST_CURRENT = 0x1;
-    private static final int PERSIST_LAST_AUDIBLE = 0x2;
-
-    private static final int BTA2DP_DOCK_TIMEOUT_MILLIS = 8000;
-    // Timeout for connection to bluetooth headset service
-    private static final int BT_HEADSET_CNCT_TIMEOUT_MS = 3000;
-
-    /** @see AudioSystemThread */
-    private AudioSystemThread mAudioSystemThread;
-    /** @see AudioHandler */
-    private AudioHandler mAudioHandler;
-    /** @see VolumeStreamState */
-    private VolumeStreamState[] mStreamStates;
-    private SettingsObserver mSettingsObserver;
-    private boolean noDelayInATwoDP =
-            Resources.getSystem().getBoolean(com.android.internal.R.bool.config_noDelayInATwoDP);
-
-    private int mMode;
-    // protects mRingerMode
-    private final Object mSettingsLock = new Object();
-
-    private boolean mMediaServerOk;
-
-    private SoundPool mSoundPool;
-    private final Object mSoundEffectsLock = new Object();
-    private static final int NUM_SOUNDPOOL_CHANNELS = 4;
-
-    // Internally master volume is a float in the 0.0 - 1.0 range,
-    // but to support integer based AudioManager API we translate it to 0 - 100
-    private static final int MAX_MASTER_VOLUME = 100;
-
-    // Maximum volume adjust steps allowed in a single batch call.
-    private static final int MAX_BATCH_VOLUME_ADJUST_STEPS = 4;
-
-    /* Sound effect file names  */
-    private static final String SOUND_EFFECTS_PATH = "/media/audio/ui/";
-    private static final String[] SOUND_EFFECT_FILES = new String[] {
-        "Effect_Tick.ogg",
-        "KeypressStandard.ogg",
-        "KeypressSpacebar.ogg",
-        "KeypressDelete.ogg",
-        "KeypressReturn.ogg"
-    };
-
-    /* Sound effect file name mapping sound effect id (AudioManager.FX_xxx) to
-     * file index in SOUND_EFFECT_FILES[] (first column) and indicating if effect
-     * uses soundpool (second column) */
-    private final int[][] SOUND_EFFECT_FILES_MAP = new int[][] {
-        {0, -1},  // FX_KEY_CLICK
-        {0, -1},  // FX_FOCUS_NAVIGATION_UP
-        {0, -1},  // FX_FOCUS_NAVIGATION_DOWN
-        {0, -1},  // FX_FOCUS_NAVIGATION_LEFT
-        {0, -1},  // FX_FOCUS_NAVIGATION_RIGHT
-        {1, -1},  // FX_KEYPRESS_STANDARD
-        {2, -1},  // FX_KEYPRESS_SPACEBAR
-        {3, -1},  // FX_FOCUS_DELETE
-        {4, -1}   // FX_FOCUS_RETURN
-    };
-
-   /** @hide Maximum volume index values for audio streams */
-    private final int[] MAX_STREAM_VOLUME = new int[] {
-        5,  // STREAM_VOICE_CALL
-        7,  // STREAM_SYSTEM
-        7,  // STREAM_RING
-        15, // STREAM_MUSIC
-        7,  // STREAM_ALARM
-        7,  // STREAM_NOTIFICATION
-        15, // STREAM_BLUETOOTH_SCO
-        7,  // STREAM_SYSTEM_ENFORCED
-        15, // STREAM_DTMF
-        15  // STREAM_TTS
-    };
-    /* mStreamVolumeAlias[] indicates for each stream if it uses the volume settings
-     * of another stream: This avoids multiplying the volume settings for hidden
-     * stream types that follow other stream behavior for volume settings
-     * NOTE: do not create loops in aliases!
-     * Some streams alias to different streams according to device category (phone or tablet) or
-     * use case (in call s off call...).See updateStreamVolumeAlias() for more details
-     *  STREAM_VOLUME_ALIAS contains the default aliases for a voice capable device (phone) and
-     *  STREAM_VOLUME_ALIAS_NON_VOICE for a non voice capable device (tablet).*/
-    private final int[] STREAM_VOLUME_ALIAS = new int[] {
-        AudioSystem.STREAM_VOICE_CALL,      // STREAM_VOICE_CALL
-        AudioSystem.STREAM_RING,            // STREAM_SYSTEM
-        AudioSystem.STREAM_RING,            // STREAM_RING
-        AudioSystem.STREAM_MUSIC,           // STREAM_MUSIC
-        AudioSystem.STREAM_ALARM,           // STREAM_ALARM
-        AudioSystem.STREAM_RING,            // STREAM_NOTIFICATION
-        AudioSystem.STREAM_BLUETOOTH_SCO,   // STREAM_BLUETOOTH_SCO
-        AudioSystem.STREAM_RING,            // STREAM_SYSTEM_ENFORCED
-        AudioSystem.STREAM_RING,            // STREAM_DTMF
-        AudioSystem.STREAM_MUSIC            // STREAM_TTS
-    };
-    private final int[] STREAM_VOLUME_ALIAS_NON_VOICE = new int[] {
-        AudioSystem.STREAM_VOICE_CALL,      // STREAM_VOICE_CALL
-        AudioSystem.STREAM_MUSIC,           // STREAM_SYSTEM
-        AudioSystem.STREAM_RING,            // STREAM_RING
-        AudioSystem.STREAM_MUSIC,           // STREAM_MUSIC
-        AudioSystem.STREAM_ALARM,           // STREAM_ALARM
-        AudioSystem.STREAM_RING,            // STREAM_NOTIFICATION
-        AudioSystem.STREAM_BLUETOOTH_SCO,   // STREAM_BLUETOOTH_SCO
-        AudioSystem.STREAM_MUSIC,           // STREAM_SYSTEM_ENFORCED
-        AudioSystem.STREAM_MUSIC,           // STREAM_DTMF
-        AudioSystem.STREAM_MUSIC            // STREAM_TTS
-    };
-    private int[] mStreamVolumeAlias;
-
-    // stream names used by dumpStreamStates()
-    private final String[] STREAM_NAMES = new String[] {
-            "STREAM_VOICE_CALL",
-            "STREAM_SYSTEM",
-            "STREAM_RING",
-            "STREAM_MUSIC",
-            "STREAM_ALARM",
-            "STREAM_NOTIFICATION",
-            "STREAM_BLUETOOTH_SCO",
-            "STREAM_SYSTEM_ENFORCED",
-            "STREAM_DTMF",
-            "STREAM_TTS"
-    };
-
-    private boolean mLinkNotificationWithVolume;
-
-    private final AudioSystem.ErrorCallback mAudioSystemCallback = new AudioSystem.ErrorCallback() {
-        public void onError(int error) {
-            switch (error) {
-            case AudioSystem.AUDIO_STATUS_SERVER_DIED:
-                if (mMediaServerOk) {
-                    sendMsg(mAudioHandler, MSG_MEDIA_SERVER_DIED, SENDMSG_NOOP, 0, 0,
-                            null, 1500);
-                    mMediaServerOk = false;
-                }
-                break;
-            case AudioSystem.AUDIO_STATUS_OK:
-                if (!mMediaServerOk) {
-                    sendMsg(mAudioHandler, MSG_MEDIA_SERVER_STARTED, SENDMSG_NOOP, 0, 0,
-                            null, 0);
-                    mMediaServerOk = true;
-                }
-                break;
-            default:
-                break;
-            }
-       }
-    };
-
-    /**
-     * Current ringer mode from one of {@link AudioManager#RINGER_MODE_NORMAL},
-     * {@link AudioManager#RINGER_MODE_SILENT}, or
-     * {@link AudioManager#RINGER_MODE_VIBRATE}.
-     */
-    // protected by mSettingsLock
-    private int mRingerMode;
-    // last non-normal ringer mode
-    private int mLastSilentRingerMode = -1;
-
-    /** @see System#MODE_RINGER_STREAMS_AFFECTED */
-    private int mRingerModeAffectedStreams;
-
-    // Streams currently muted by ringer mode
-    private int mRingerModeMutedStreams;
-
-    /** @see System#MUTE_STREAMS_AFFECTED */
-    private int mMuteAffectedStreams;
-
-    /**
-     * NOTE: setVibrateSetting(), getVibrateSetting(), shouldVibrate() are deprecated.
-     * mVibrateSetting is just maintained during deprecation period but vibration policy is
-     * now only controlled by mHasVibrator and mRingerMode
-     */
-    private int mVibrateSetting;
-
-    // Is there a vibrator
-    private final boolean mHasVibrator;
-
-    // Broadcast receiver for device connections intent broadcasts
-    private final BroadcastReceiver mReceiver = new AudioServiceBroadcastReceiver();
-
-    // Used to alter media button redirection when the phone is ringing.
-    private boolean mIsRinging = false;
-
-    // Devices currently connected
-    private final HashMap <Integer, String> mConnectedDevices = new HashMap <Integer, String>();
-
-    // Forced device usage for communications
-    private int mForcedUseForComm;
-
-    // True if we have master volume support
-    private final boolean mUseMasterVolume;
-
-    private final int[] mMasterVolumeRamp;
-
-    // List of binder death handlers for setMode() client processes.
-    // The last process to have called setMode() is at the top of the list.
-    private final ArrayList <SetModeDeathHandler> mSetModeDeathHandlers = new ArrayList <SetModeDeathHandler>();
-
-    // List of clients having issued a SCO start request
-    private final ArrayList <ScoClient> mScoClients = new ArrayList <ScoClient>();
-
-    // BluetoothHeadset API to control SCO connection
-    private BluetoothHeadset mBluetoothHeadset;
-
-    // Bluetooth headset device
-    private BluetoothDevice mBluetoothHeadsetDevice;
-
-    // Indicate if SCO audio connection is currently active and if the initiator is
-    // audio service (internal) or bluetooth headset (external)
-    private int mScoAudioState;
-    // SCO audio state is not active
-    private static final int SCO_STATE_INACTIVE = 0;
-    // SCO audio activation request waiting for headset service to connect
-    private static final int SCO_STATE_ACTIVATE_REQ = 1;
-    // SCO audio state is active or starting due to a local request to start a virtual call
-    private static final int SCO_STATE_ACTIVE_INTERNAL = 3;
-    // SCO audio deactivation request waiting for headset service to connect
-    private static final int SCO_STATE_DEACTIVATE_REQ = 5;
-
-    // SCO audio state is active due to an action in BT handsfree (either voice recognition or
-    // in call audio)
-    private static final int SCO_STATE_ACTIVE_EXTERNAL = 2;
-    // Deactivation request for all SCO connections (initiated by audio mode change)
-    // waiting for headset service to connect
-    private static final int SCO_STATE_DEACTIVATE_EXT_REQ = 4;
-
-    // Current connection state indicated by bluetooth headset
-    private int mScoConnectionState;
-
-    // true if boot sequence has been completed
-    private boolean mBootCompleted;
-    // listener for SoundPool sample load completion indication
-    private SoundPoolCallback mSoundPoolCallBack;
-    // thread for SoundPool listener
-    private SoundPoolListenerThread mSoundPoolListenerThread;
-    // message looper for SoundPool listener
-    private Looper mSoundPoolLooper = null;
-    // volume applied to sound played with playSoundEffect()
-    private static int sSoundEffectVolumeDb;
-    // getActiveStreamType() will return:
-    // - STREAM_NOTIFICATION on tablets during this period after a notification stopped
-    // - STREAM_MUSIC on phones during this period after music or talkback/voice search prompt
-    // stopped
-    private static final int DEFAULT_STREAM_TYPE_OVERRIDE_DELAY_MS = 5000;
-    // previous volume adjustment direction received by checkForRingerModeChange()
-    private int mPrevVolDirection = AudioManager.ADJUST_SAME;
-    // Keyguard manager proxy
-    private KeyguardManager mKeyguardManager;
-    // mVolumeControlStream is set by VolumePanel to temporarily force the stream type which volume
-    // is controlled by Vol keys.
-    private int  mVolumeControlStream = -1;
-    private final Object mForceControlStreamLock = new Object();
-    // VolumePanel is currently the only client of forceVolumeControlStream() and runs in system
-    // server process so in theory it is not necessary to monitor the client death.
-    // However it is good to be ready for future evolutions.
-    private ForceControlStreamClient mForceControlStreamClient = null;
-    // Used to play ringtones outside system_server
-    private volatile IRingtonePlayer mRingtonePlayer;
-
-    private int mDeviceOrientation = Configuration.ORIENTATION_UNDEFINED;
-
-    // Request to override default use of A2DP for media.
-    private boolean mBluetoothA2dpEnabled;
-    private final Object mBluetoothA2dpEnabledLock = new Object();
-
-    // Monitoring of audio routes.  Protected by mCurAudioRoutes.
-    final AudioRoutesInfo mCurAudioRoutes = new AudioRoutesInfo();
-    final RemoteCallbackList<IAudioRoutesObserver> mRoutesObservers
-            = new RemoteCallbackList<IAudioRoutesObserver>();
-
-    /**
-     * A fake stream type to match the notion of remote media playback
-     */
-    public final static int STREAM_REMOTE_MUSIC = -200;
-
-    // Devices for which the volume is fixed and VolumePanel slider should be disabled
-    final int mFixedVolumeDevices = AudioSystem.DEVICE_OUT_AUX_DIGITAL |
-            AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
-            AudioSystem.DEVICE_OUT_ALL_USB;
-
-    private final boolean mMonitorOrientation;
-
-    private boolean mDockAudioMediaEnabled = true;
-
-    private boolean mForceAnalogDeskDock;
-    private boolean mForceAnalogCarDock;
-
-    private int mDockState = Intent.EXTRA_DOCK_STATE_UNDOCKED;
-
-    private boolean mVolumeKeysControlRingStream;
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Construction
-    ///////////////////////////////////////////////////////////////////////////
-
-    /** @hide */
-    public AudioService(Context context) {
-        mContext = context;
-        mContentResolver = context.getContentResolver();
-        mHandler = new Handler();
-        mVoiceCapable = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_voice_capable);
-
-        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
-        mMediaEventWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "handleMediaEvent");
-
-        Vibrator vibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
-        mHasVibrator = vibrator == null ? false : vibrator.hasVibrator();
-
-       // Intialized volume
-        MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL] = SystemProperties.getInt(
-            "ro.config.vc_call_vol_steps",
-           MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
-
-        sSoundEffectVolumeDb = context.getResources().getInteger(
-                com.android.internal.R.integer.config_soundEffectVolumeDb);
-
-        mMode = AudioSystem.MODE_NORMAL;
-        mForcedUseForComm = AudioSystem.FORCE_NONE;
-
-        createAudioSystemThread();
-
-        boolean cameraSoundForced = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_camera_sound_forced);
-        mCameraSoundForced = new Boolean(cameraSoundForced);
-        sendMsg(mAudioHandler,
-                MSG_SET_FORCE_USE,
-                SENDMSG_QUEUE,
-                AudioSystem.FOR_SYSTEM,
-                cameraSoundForced ?
-                        AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE,
-                null,
-                0);
-
-        mSafeMediaVolumeState = new Integer(Settings.Global.getInt(mContentResolver,
-                                                        Settings.Global.AUDIO_SAFE_VOLUME_STATE,
-                                                        SAFE_MEDIA_VOLUME_NOT_CONFIGURED));
-        // The default safe volume index read here will be replaced by the actual value when
-        // the mcc is read by onConfigureSafeVolume()
-        mSafeMediaVolumeIndex = mContext.getResources().getInteger(
-                com.android.internal.R.integer.config_safe_media_volume_index) * 10;
-
-        readPersistedSettings();
-        mSettingsObserver = new SettingsObserver();
-        updateStreamVolumeAlias(false /*updateVolumes*/);
-        createStreamStates();
-
-        mMediaServerOk = true;
-
-        // Call setRingerModeInt() to apply correct mute
-        // state on streams affected by ringer mode.
-        mRingerModeMutedStreams = 0;
-        setRingerModeInt(getRingerMode(), false);
-
-        AudioSystem.setErrorCallback(mAudioSystemCallback);
-
-        // Register for device connection intent broadcasts.
-        IntentFilter intentFilter =
-                new IntentFilter(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
-        if (noDelayInATwoDP) {
-            intentFilter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
-        }
-        intentFilter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
-        intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
-        intentFilter.addAction(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG);
-        intentFilter.addAction(Intent.ACTION_USB_AUDIO_DEVICE_PLUG);
-        intentFilter.addAction(Intent.ACTION_BOOT_COMPLETED);
-        intentFilter.addAction(Intent.ACTION_SCREEN_ON);
-        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
-        intentFilter.addAction(Intent.ACTION_USER_BACKGROUND);
-        intentFilter.addAction(Intent.ACTION_USER_SWITCHED);
-        intentFilter.addAction(Intent.ACTION_WIFI_DISPLAY_AUDIO);
-        intentFilter.addAction(Intent.ACTION_HEADSET_PLUG);
-
-        intentFilter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
-        // Register a configuration change listener only if requested by system properties
-        // to monitor orientation changes (off by default)
-        mMonitorOrientation = SystemProperties.getBoolean("ro.audio.monitorOrientation", false);
-        if (mMonitorOrientation) {
-            Log.v(TAG, "monitoring device orientation");
-            // initialize orientation in AudioSystem
-            setOrientationForAudioSystem();
-        }
-
-        context.registerReceiver(mReceiver, intentFilter);
-
-        // Register for package removal intent broadcasts for media button receiver persistence
-        IntentFilter pkgFilter = new IntentFilter();
-        pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
-        pkgFilter.addDataScheme("package");
-        context.registerReceiver(mReceiver, pkgFilter);
-
-        ThemeUtils.registerThemeChangeReceiver(context, new BroadcastReceiver() {
-            @Override
-            public void onReceive(Context context, Intent intent) {
-                mUiContext = null;
-            }
-        });
-
-        // Register for phone state monitoring
-        TelephonyManager tmgr = (TelephonyManager)
-                context.getSystemService(Context.TELEPHONY_SERVICE);
-        tmgr.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);
-
-        mUseMasterVolume = context.getResources().getBoolean(
-                com.android.internal.R.bool.config_useMasterVolume);
-        restoreMasterVolume();
-
-        mMasterVolumeRamp = context.getResources().getIntArray(
-                com.android.internal.R.array.config_masterVolumeRamp);
-
-        mForceAnalogDeskDock = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_forceAnalogDeskDock);
-
-        mForceAnalogCarDock = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_forceAnalogCarDock);
-
-        mMainRemote = new RemotePlaybackState(-1, MAX_STREAM_VOLUME[AudioManager.STREAM_MUSIC],
-                MAX_STREAM_VOLUME[AudioManager.STREAM_MUSIC]);
-        mHasRemotePlayback = false;
-        mMainRemoteIsActive = false;
-        postReevaluateRemote();
-    }
-
-    private void createAudioSystemThread() {
-        mAudioSystemThread = new AudioSystemThread();
-        mAudioSystemThread.start();
-        waitForAudioHandlerCreation();
-    }
-
-    /** Waits for the volume handler to be created by the other thread. */
-    private void waitForAudioHandlerCreation() {
-        synchronized(this) {
-            while (mAudioHandler == null) {
-                try {
-                    // Wait for mAudioHandler to be set by the other thread
-                    wait();
-                } catch (InterruptedException e) {
-                    Log.e(TAG, "Interrupted while waiting on volume handler.");
-                }
-            }
-        }
-    }
-
-    private void checkAllAliasStreamVolumes() {
-        int numStreamTypes = AudioSystem.getNumStreamTypes();
-        for (int streamType = 0; streamType < numStreamTypes; streamType++) {
-            if (streamType != mStreamVolumeAlias[streamType]) {
-                mStreamStates[streamType].
-                                    setAllIndexes(mStreamStates[mStreamVolumeAlias[streamType]],
-                                                  false /*lastAudible*/);
-                mStreamStates[streamType].
-                                    setAllIndexes(mStreamStates[mStreamVolumeAlias[streamType]],
-                                                  true /*lastAudible*/);
-            }
-            // apply stream volume
-            if (mStreamStates[streamType].muteCount() == 0) {
-                mStreamStates[streamType].applyAllVolumes();
-            }
-        }
-    }
-
-    private void createStreamStates() {
-        int numStreamTypes = AudioSystem.getNumStreamTypes();
-        VolumeStreamState[] streams = mStreamStates = new VolumeStreamState[numStreamTypes];
-
-        for (int i = 0; i < numStreamTypes; i++) {
-            streams[i] = new VolumeStreamState(System.VOLUME_SETTINGS[mStreamVolumeAlias[i]], i);
-        }
-
-        checkAllAliasStreamVolumes();
-    }
-
-    private void dumpStreamStates(PrintWriter pw) {
-        pw.println("\nStream volumes (device: index)");
-        int numStreamTypes = AudioSystem.getNumStreamTypes();
-        for (int i = 0; i < numStreamTypes; i++) {
-            pw.println("- "+STREAM_NAMES[i]+":");
-            mStreamStates[i].dump(pw);
-            pw.println("");
-        }
-        pw.print("\n- mute affected streams = 0x");
-        pw.println(Integer.toHexString(mMuteAffectedStreams));
-    }
-
-
-    private void updateStreamVolumeAlias(boolean updateVolumes) {
-        int dtmfStreamAlias;
-        if (mVoiceCapable) {
-            mStreamVolumeAlias = STREAM_VOLUME_ALIAS;
-            dtmfStreamAlias = AudioSystem.STREAM_RING;
-        } else {
-            mStreamVolumeAlias = STREAM_VOLUME_ALIAS_NON_VOICE;
-            dtmfStreamAlias = AudioSystem.STREAM_MUSIC;
-        }
-        if (isInCommunication()) {
-            dtmfStreamAlias = AudioSystem.STREAM_VOICE_CALL;
-        }
-        mStreamVolumeAlias[AudioSystem.STREAM_DTMF] = dtmfStreamAlias;
-
-        if (mLinkNotificationWithVolume) {
-            mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_RING;
-        } else {
-            mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_NOTIFICATION;
-        }
-
-        if (updateVolumes) {
-            mStreamStates[AudioSystem.STREAM_DTMF].setAllIndexes(mStreamStates[dtmfStreamAlias],
-                                                                 false /*lastAudible*/);
-            mStreamStates[AudioSystem.STREAM_DTMF].setAllIndexes(mStreamStates[dtmfStreamAlias],
-                                                                 true /*lastAudible*/);
-            sendMsg(mAudioHandler,
-                    MSG_SET_ALL_VOLUMES,
-                    SENDMSG_QUEUE,
-                    0,
-                    0,
-                    mStreamStates[AudioSystem.STREAM_DTMF], 0);
-        }
-    }
-
-    private void readDockAudioSettings(ContentResolver cr)
-    {
-        mDockAudioMediaEnabled = Settings.Global.getInt(
-                                        cr, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED, 0) == 1;
-
-        if (mDockAudioMediaEnabled) {
-            mBecomingNoisyIntentDevices |= AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET;
-        } else {
-            mBecomingNoisyIntentDevices &= ~AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET;
-        }
-
-        sendMsg(mAudioHandler,
-                MSG_SET_FORCE_USE,
-                SENDMSG_QUEUE,
-                AudioSystem.FOR_DOCK,
-                mDockAudioMediaEnabled ?
-                        AudioSystem.FORCE_ANALOG_DOCK : AudioSystem.FORCE_NONE,
-                null,
-                0);
-    }
-
-    private boolean safeVolumeEnabled(ContentResolver cr) {
-        boolean safeMediaVolumeEnabled = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_safe_media_volume_enabled);
-        boolean safeHeadsetVolumeEnabled = Settings.System.getIntForUser(cr,
-                Settings.System.SAFE_HEADSET_VOLUME, safeMediaVolumeEnabled ? 1 : 0,
-                UserHandle.USER_CURRENT_OR_SELF) != 0;
-        return safeHeadsetVolumeEnabled;
-    }
-
-    private void readPersistedSettings() {
-        final ContentResolver cr = mContentResolver;
-
-        int ringerModeFromSettings =
-                Settings.Global.getInt(
-                        cr, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
-        int ringerMode = ringerModeFromSettings;
-        // sanity check in case the settings are restored from a device with incompatible
-        // ringer modes
-        if (!AudioManager.isValidRingerMode(ringerMode)) {
-            ringerMode = AudioManager.RINGER_MODE_NORMAL;
-        }
-        if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
-            ringerMode = AudioManager.RINGER_MODE_SILENT;
-        }
-        if (ringerMode != ringerModeFromSettings) {
-            Settings.Global.putInt(cr, Settings.Global.MODE_RINGER, ringerMode);
-        }
-        synchronized(mSettingsLock) {
-            mRingerMode = ringerMode;
-
-            // System.VIBRATE_ON is not used any more but defaults for mVibrateSetting
-            // are still needed while setVibrateSetting() and getVibrateSetting() are being
-            // deprecated.
-            mVibrateSetting = getValueForVibrateSetting(0,
-                                            AudioManager.VIBRATE_TYPE_NOTIFICATION,
-                                            mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT
-                                                            : AudioManager.VIBRATE_SETTING_OFF);
-            mVibrateSetting = getValueForVibrateSetting(mVibrateSetting,
-                                            AudioManager.VIBRATE_TYPE_RINGER,
-                                            mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT
-                                                            : AudioManager.VIBRATE_SETTING_OFF);
-
-            // make sure settings for ringer mode are consistent with device type: non voice capable
-            // devices (tablets) include media stream in silent mode whereas phones don't.
-            mRingerModeAffectedStreams = Settings.System.getIntForUser(cr,
-                    Settings.System.MODE_RINGER_STREAMS_AFFECTED,
-                    ((1 << AudioSystem.STREAM_RING)|(1 << AudioSystem.STREAM_NOTIFICATION)|
-                     (1 << AudioSystem.STREAM_SYSTEM)|(1 << AudioSystem.STREAM_SYSTEM_ENFORCED)),
-                     UserHandle.USER_CURRENT);
-
-            // ringtone and system streams are always affected by ringer mode
-            mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_RING)|
-                                            (1 << AudioSystem.STREAM_SYSTEM);
-
-            if (mVoiceCapable) {
-                mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_MUSIC);
-            } else {
-                mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_MUSIC);
-            }
-            synchronized (mCameraSoundForced) {
-                if (mCameraSoundForced) {
-                    mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
-                } else {
-                    mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
-                }
-            }
-
-            Settings.System.putIntForUser(cr,
-                    Settings.System.MODE_RINGER_STREAMS_AFFECTED,
-                    mRingerModeAffectedStreams,
-                    UserHandle.USER_CURRENT);
-
-            readDockAudioSettings(cr);
-
-            mSafeVolumeEnabled = new Boolean(safeVolumeEnabled(cr));
-
-            mVolumeKeysControlRingStream = Settings.System.getIntForUser(cr,
-                    Settings.System.VOLUME_KEYS_CONTROL_RING_STREAM, 1, UserHandle.USER_CURRENT) == 1;
-        }
-
-        mLinkNotificationWithVolume = Settings.System.getIntForUser(cr,
-                Settings.System.VOLUME_LINK_NOTIFICATION, 1, UserHandle.USER_CURRENT) == 1;
-
-        mMuteAffectedStreams = System.getIntForUser(cr,
-                System.MUTE_STREAMS_AFFECTED,
-                ((1 << AudioSystem.STREAM_MUSIC)|
-                 (1 << AudioSystem.STREAM_RING)|
-                 (1 << AudioSystem.STREAM_SYSTEM)),
-                 UserHandle.USER_CURRENT);
-
-        boolean masterMute = System.getIntForUser(cr, System.VOLUME_MASTER_MUTE,
-                                                  0, UserHandle.USER_CURRENT) == 1;
-        AudioSystem.setMasterMute(masterMute);
-        broadcastMasterMuteStatus(masterMute);
-
-        // Each stream will read its own persisted settings
-
-        // Broadcast the sticky intent
-        broadcastRingerMode(ringerMode);
-
-        // Broadcast vibrate settings
-        broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
-        broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
-
-        // Restore the default media button receiver from the system settings
-        restoreMediaButtonReceiver();
-    }
-
-    private int rescaleIndex(int index, int srcStream, int dstStream) {
-        return (index * mStreamStates[dstStream].getMaxIndex() + mStreamStates[srcStream].getMaxIndex() / 2) / mStreamStates[srcStream].getMaxIndex();
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // IPC methods
-    ///////////////////////////////////////////////////////////////////////////
-
-    /** @see AudioManager#adjustVolume(int, int) */
-    public void adjustVolume(int direction, int flags) {
-        adjustSuggestedStreamVolume(direction, AudioManager.USE_DEFAULT_STREAM_TYPE, flags);
-    }
-
-    /** @see AudioManager#adjustLocalOrRemoteStreamVolume(int, int) with current assumption
-     *  on streamType: fixed to STREAM_MUSIC */
-    public void adjustLocalOrRemoteStreamVolume(int streamType, int direction) {
-        if (DEBUG_VOL) Log.d(TAG, "adjustLocalOrRemoteStreamVolume(dir="+direction+")");
-        if (checkUpdateRemoteStateIfActive(AudioSystem.STREAM_MUSIC)) {
-            adjustRemoteVolume(AudioSystem.STREAM_MUSIC, direction, 0);
-        } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0)) {
-            adjustStreamVolume(AudioSystem.STREAM_MUSIC, direction, 0);
-        }
-    }
-
-    /** @see AudioManager#adjustVolume(int, int, int) */
-    public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags) {
-        if (DEBUG_VOL) Log.d(TAG, "adjustSuggestedStreamVolume() stream="+suggestedStreamType);
-        int streamType;
-        if (mVolumeControlStream != -1) {
-            streamType = mVolumeControlStream;
-        } else {
-            streamType = getActiveStreamType(suggestedStreamType);
-        }
-
-        // Play sounds on STREAM_RING only and if lock screen is not on.
-        if ((streamType != STREAM_REMOTE_MUSIC) &&
-                (flags & AudioManager.FLAG_PLAY_SOUND) != 0 &&
-                ((mStreamVolumeAlias[streamType] != AudioSystem.STREAM_RING)
-                 || (mKeyguardManager != null && mKeyguardManager.isKeyguardLocked()))) {
-            flags &= ~AudioManager.FLAG_PLAY_SOUND;
-        }
-
-        if (streamType == STREAM_REMOTE_MUSIC) {
-            // don't play sounds for remote
-            flags &= ~(AudioManager.FLAG_PLAY_SOUND|AudioManager.FLAG_FIXED_VOLUME);
-            //if (DEBUG_VOL) Log.i(TAG, "Need to adjust remote volume: calling adjustRemoteVolume()");
-            adjustRemoteVolume(AudioSystem.STREAM_MUSIC, direction, flags);
-        } else {
-            adjustStreamVolume(streamType, direction, flags);
-        }
-    }
-
-    /** @see AudioManager#adjustStreamVolume(int, int, int) */
-    public void adjustStreamVolume(int streamType, int direction, int flags) {
-        if (DEBUG_VOL) Log.d(TAG, "adjustStreamVolume() stream="+streamType+", dir="+direction);
-
-        ensureValidDirection(direction);
-        ensureValidStreamType(streamType);
-
-        // use stream type alias here so that streams with same alias have the same behavior,
-        // including with regard to silent mode control (e.g the use of STREAM_RING below and in
-        // checkForRingerModeChange() in place of STREAM_RING or STREAM_NOTIFICATION)
-        int streamTypeAlias = mStreamVolumeAlias[streamType];
-        VolumeStreamState streamState = mStreamStates[streamTypeAlias];
-
-        final int device = getDeviceForStream(streamTypeAlias);
-        // get last audible index if stream is muted, current index otherwise
-        final int aliasIndex = streamState.getIndex(device,
-                                                  (streamState.muteCount() != 0) /* lastAudible */);
-        boolean adjustVolume = true;
-
-        // convert one UI step (+/-1) into a number of internal units on the stream alias
-        int step = rescaleIndex(10, streamType, streamTypeAlias);
-
-        int index;
-        int oldIndex;
-
-        if ((direction == AudioManager.ADJUST_RAISE) &&
-                !checkSafeMediaVolume(streamTypeAlias, aliasIndex + step, device)) {
-            index = mStreamStates[streamType].getIndex(device,
-                                                 (streamState.muteCount() != 0)  /* lastAudible */);
-            oldIndex = index;
-        } else {
-            flags &= ~AudioManager.FLAG_FIXED_VOLUME;
-            if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) &&
-                   ((device & mFixedVolumeDevices) != 0)) {
-                flags |= AudioManager.FLAG_FIXED_VOLUME;
-                index = mStreamStates[streamType].getMaxIndex();
-                oldIndex = index;
-            } else {
-                // If either the client forces allowing ringer modes for this adjustment,
-                // or the stream type is one that is affected by ringer modes
-                if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) ||
-                        (streamTypeAlias == getMasterStreamType())) {
-                    int ringerMode = getRingerMode();
-                    // do not vibrate if already in vibrate mode
-                    if (ringerMode == AudioManager.RINGER_MODE_VIBRATE) {
-                        flags &= ~AudioManager.FLAG_VIBRATE;
-                    }
-                    // Check if the ringer mode changes with this volume adjustment. If
-                    // it does, it will handle adjusting the volume, so we won't below
-                    adjustVolume = checkForRingerModeChange(aliasIndex, direction, step);
-                    if ((streamTypeAlias == getMasterStreamType()) &&
-                            (mRingerMode == AudioManager.RINGER_MODE_SILENT)) {
-                        streamState.setLastAudibleIndex(0, device);
-                    }
-                }
-
-                // If stream is muted, adjust last audible index only
-                oldIndex = mStreamStates[streamType].getIndex(device,
-                        (mStreamStates[streamType].muteCount() != 0) /* lastAudible */);
-
-                if (streamState.muteCount() != 0) {
-                    if (adjustVolume) {
-                        // Post a persist volume msg
-                        // no need to persist volume on all streams sharing the same alias
-                        streamState.adjustLastAudibleIndex(direction * step, device);
-                        sendMsg(mAudioHandler,
-                                MSG_PERSIST_VOLUME,
-                                SENDMSG_QUEUE,
-                                PERSIST_LAST_AUDIBLE,
-                                device,
-                                streamState,
-                                PERSIST_DELAY);
-                    }
-                    index = mStreamStates[streamType].getIndex(device, true  /* lastAudible */);
-                } else {
-                    if (adjustVolume && streamState.adjustIndex(direction * step, device)) {
-                        // Post message to set system volume (it in turn will post a message
-                        // to persist). Do not change volume if stream is muted.
-                        sendMsg(mAudioHandler,
-                                MSG_SET_DEVICE_VOLUME,
-                                SENDMSG_QUEUE,
-                                device,
-                                0,
-                                streamState,
-                                0);
-                    }
-                    index = mStreamStates[streamType].getIndex(device, false  /* lastAudible */);
-                }
-            }
-        }
-        sendVolumeUpdate(streamType, oldIndex, index, flags);
-    }
-
-    /** @see AudioManager#adjustMasterVolume(int) */
-    public void adjustMasterVolume(int steps, int flags) {
-        ensureValidSteps(steps);
-        int volume = Math.round(AudioSystem.getMasterVolume() * MAX_MASTER_VOLUME);
-        int delta = 0;
-        int numSteps = Math.abs(steps);
-        int direction = steps > 0 ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER;
-        for (int i = 0; i < numSteps; ++i) {
-            delta = findVolumeDelta(direction, volume);
-            volume += delta;
-        }
-
-        //Log.d(TAG, "adjustMasterVolume volume: " + volume + " steps: " + steps);
-        setMasterVolume(volume, flags);
-    }
-
-    /** @see AudioManager#setStreamVolume(int, int, int) */
-    public void setStreamVolume(int streamType, int index, int flags) {
-        ensureValidStreamType(streamType);
-        VolumeStreamState streamState = mStreamStates[mStreamVolumeAlias[streamType]];
-
-        final int device = getDeviceForStream(streamType);
-        int oldIndex;
-
-        flags &= ~AudioManager.FLAG_FIXED_VOLUME;
-        if ((mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) &&
-                ((device & mFixedVolumeDevices) != 0)) {
-            flags |= AudioManager.FLAG_FIXED_VOLUME;
-            index = mStreamStates[streamType].getMaxIndex();
-            oldIndex = index;
-        } else {
-            // get last audible index if stream is muted, current index otherwise
-            oldIndex = streamState.getIndex(device,
-                                            (streamState.muteCount() != 0) /* lastAudible */);
-
-            index = rescaleIndex(index * 10, streamType, mStreamVolumeAlias[streamType]);
-
-            if (!checkSafeMediaVolume(mStreamVolumeAlias[streamType], index, device)) {
-                return;
-            }
-
-            // setting volume on master stream type also controls silent mode
-            if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) ||
-                    (mStreamVolumeAlias[streamType] == getMasterStreamType())) {
-                int newRingerMode;
-                if (index == 0) {
-                    synchronized (mSettingsLock) {
-                        if (mLastSilentRingerMode != -1) {
-                            newRingerMode = mLastSilentRingerMode;
-                        } else {
-                            newRingerMode = mHasVibrator ? AudioManager.RINGER_MODE_VIBRATE
-                                                         : AudioManager.RINGER_MODE_SILENT;
-                        }
-                    }
-                    setStreamVolumeInt(mStreamVolumeAlias[streamType],
-                                       index,
-                                       device,
-                                       false,
-                                       true);
-                } else {
-                    newRingerMode = AudioManager.RINGER_MODE_NORMAL;
-                }
-                setRingerMode(newRingerMode);
-            }
-
-            setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, false, true);
-            // get last audible index if stream is muted, current index otherwise
-            index = mStreamStates[streamType].getIndex(device,
-                                    (mStreamStates[streamType].muteCount() != 0) /* lastAudible */);
-        }
-        sendVolumeUpdate(streamType, oldIndex, index, flags);
-    }
-
-    /** @see AudioManager#forceVolumeControlStream(int) */
-    public void forceVolumeControlStream(int streamType, IBinder cb) {
-        synchronized(mForceControlStreamLock) {
-            mVolumeControlStream = streamType;
-            if (mVolumeControlStream == -1) {
-                if (mForceControlStreamClient != null) {
-                    mForceControlStreamClient.release();
-                    mForceControlStreamClient = null;
-                }
-            } else {
-                mForceControlStreamClient = new ForceControlStreamClient(cb);
-            }
-        }
-    }
-
-    private class ForceControlStreamClient implements IBinder.DeathRecipient {
-        private IBinder mCb; // To be notified of client's death
-
-        ForceControlStreamClient(IBinder cb) {
-            if (cb != null) {
-                try {
-                    cb.linkToDeath(this, 0);
-                } catch (RemoteException e) {
-                    // Client has died!
-                    Log.w(TAG, "ForceControlStreamClient() could not link to "+cb+" binder death");
-                    cb = null;
-                }
-            }
-            mCb = cb;
-        }
-
-        public void binderDied() {
-            synchronized(mForceControlStreamLock) {
-                Log.w(TAG, "SCO client died");
-                if (mForceControlStreamClient != this) {
-                    Log.w(TAG, "unregistered control stream client died");
-                } else {
-                    mForceControlStreamClient = null;
-                    mVolumeControlStream = -1;
-                }
-            }
-        }
-
-        public void release() {
-            if (mCb != null) {
-                mCb.unlinkToDeath(this, 0);
-                mCb = null;
-            }
-        }
-    }
-
-    private int findVolumeDelta(int direction, int volume) {
-        int delta = 0;
-        if (direction == AudioManager.ADJUST_RAISE) {
-            if (volume == MAX_MASTER_VOLUME) {
-                return 0;
-            }
-            // This is the default value if we make it to the end
-            delta = mMasterVolumeRamp[1];
-            // If we're raising the volume move down the ramp array until we
-            // find the volume we're above and use that groups delta.
-            for (int i = mMasterVolumeRamp.length - 1; i > 1; i -= 2) {
-                if (volume >= mMasterVolumeRamp[i - 1]) {
-                    delta = mMasterVolumeRamp[i];
-                    break;
-                }
-            }
-        } else if (direction == AudioManager.ADJUST_LOWER){
-            if (volume == 0) {
-                return 0;
-            }
-            int length = mMasterVolumeRamp.length;
-            // This is the default value if we make it to the end
-            delta = -mMasterVolumeRamp[length - 1];
-            // If we're lowering the volume move up the ramp array until we
-            // find the volume we're below and use the group below it's delta
-            for (int i = 2; i < length; i += 2) {
-                if (volume <= mMasterVolumeRamp[i]) {
-                    delta = -mMasterVolumeRamp[i - 1];
-                    break;
-                }
-            }
-        }
-        return delta;
-    }
-
-    private void sendBroadcastToAll(Intent intent) {
-        final long ident = Binder.clearCallingIdentity();
-        try {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-        } finally {
-            Binder.restoreCallingIdentity(ident);
-        }
-    }
-
-    private void sendStickyBroadcastToAll(Intent intent) {
-        final long ident = Binder.clearCallingIdentity();
-        try {
-            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
-        } finally {
-            Binder.restoreCallingIdentity(ident);
-        }
-    }
-
-    // UI update and Broadcast Intent
-    private void sendVolumeUpdate(int streamType, int oldIndex, int index, int flags) {
-        if (!mVoiceCapable && (streamType == AudioSystem.STREAM_RING)) {
-            streamType = AudioSystem.STREAM_NOTIFICATION;
-        }
-
-        showVolumeChangeUi(streamType, flags);
-
-        if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
-            oldIndex = (oldIndex + 5) / 10;
-            index = (index + 5) / 10;
-            Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
-            intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
-            intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
-            intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
-            sendBroadcastToAll(intent);
-        }
-    }
-
-    // UI update and Broadcast Intent
-    private void sendMasterVolumeUpdate(int flags, int oldVolume, int newVolume) {
-        masterVolumeChanged(flags);
-
-        Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
-        intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
-        intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
-        sendBroadcastToAll(intent);
-    }
-
-    // UI update and Broadcast Intent
-    private void sendMasterMuteUpdate(boolean muted, int flags) {
-        masterMuteChanged(flags);
-        broadcastMasterMuteStatus(muted);
-    }
-
-    private void broadcastMasterMuteStatus(boolean muted) {
-        Intent intent = new Intent(AudioManager.MASTER_MUTE_CHANGED_ACTION);
-        intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_MUTED, muted);
-        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
-                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
-        sendStickyBroadcastToAll(intent);
-    }
-
-    /**
-     * Sets the stream state's index, and posts a message to set system volume.
-     * This will not call out to the UI. Assumes a valid stream type.
-     *
-     * @param streamType Type of the stream
-     * @param index Desired volume index of the stream
-     * @param device the device whose volume must be changed
-     * @param force If true, set the volume even if the desired volume is same
-     * as the current volume.
-     * @param lastAudible If true, stores new index as last audible one
-     */
-    private void setStreamVolumeInt(int streamType,
-                                    int index,
-                                    int device,
-                                    boolean force,
-                                    boolean lastAudible) {
-        VolumeStreamState streamState = mStreamStates[streamType];
-
-        // If stream is muted, set last audible index only
-        if (streamState.muteCount() != 0) {
-            // Do not allow last audible index to be 0
-            if (index != 0) {
-                streamState.setLastAudibleIndex(index, device);
-                // Post a persist volume msg
-                sendMsg(mAudioHandler,
-                        MSG_PERSIST_VOLUME,
-                        SENDMSG_QUEUE,
-                        PERSIST_LAST_AUDIBLE,
-                        device,
-                        streamState,
-                        PERSIST_DELAY);
-            }
-        } else {
-            if (streamState.setIndex(index, device, lastAudible) || force) {
-                // Post message to set system volume (it in turn will post a message
-                // to persist).
-                sendMsg(mAudioHandler,
-                        MSG_SET_DEVICE_VOLUME,
-                        SENDMSG_QUEUE,
-                        device,
-                        0,
-                        streamState,
-                        0);
-            }
-        }
-    }
-
-    /** @see AudioManager#setStreamSolo(int, boolean) */
-    public void setStreamSolo(int streamType, boolean state, IBinder cb) {
-        for (int stream = 0; stream < mStreamStates.length; stream++) {
-            if (!isStreamAffectedByMute(stream) || stream == streamType) continue;
-            // Bring back last audible volume
-            mStreamStates[stream].mute(cb, state);
-         }
-    }
-
-    /** @see AudioManager#setStreamMute(int, boolean) */
-    public void setStreamMute(int streamType, boolean state, IBinder cb) {
-        if (isStreamAffectedByMute(streamType)) {
-            mStreamStates[streamType].mute(cb, state);
-        }
-    }
-
-    /** get stream mute state. */
-    public boolean isStreamMute(int streamType) {
-        return (mStreamStates[streamType].muteCount() != 0);
-    }
-
-    /** @see AudioManager#setMasterMute(boolean, IBinder) */
-    public void setMasterMute(boolean state, int flags, IBinder cb) {
-        if (state != AudioSystem.getMasterMute()) {
-            AudioSystem.setMasterMute(state);
-            // Post a persist master volume msg
-            sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1
-                    : 0, 0, null, PERSIST_DELAY);
-            sendMasterMuteUpdate(state, flags);
-        }
-    }
-
-    /** get master mute state. */
-    public boolean isMasterMute() {
-        return AudioSystem.getMasterMute();
-    }
-
-    /** @see AudioManager#getStreamVolume(int) */
-    public int getStreamVolume(int streamType) {
-        ensureValidStreamType(streamType);
-        int device = getDeviceForStream(streamType);
-        int index;
-
-        if ((mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) &&
-                (device & mFixedVolumeDevices) != 0) {
-            index = mStreamStates[streamType].getMaxIndex();
-        } else {
-            index = mStreamStates[streamType].getIndex(device, false  /* lastAudible */);
-        }
-        return (index + 5) / 10;
-    }
-
-    public int getMasterVolume() {
-        if (isMasterMute()) return 0;
-        return getLastAudibleMasterVolume();
-    }
-
-    public void setMasterVolume(int volume, int flags) {
-        if (volume < 0) {
-            volume = 0;
-        } else if (volume > MAX_MASTER_VOLUME) {
-            volume = MAX_MASTER_VOLUME;
-        }
-        doSetMasterVolume((float)volume / MAX_MASTER_VOLUME, flags);
-    }
-
-    private void doSetMasterVolume(float volume, int flags) {
-        // don't allow changing master volume when muted
-        if (!AudioSystem.getMasterMute()) {
-            int oldVolume = getMasterVolume();
-            AudioSystem.setMasterVolume(volume);
-
-            int newVolume = getMasterVolume();
-            if (newVolume != oldVolume) {
-                // Post a persist master volume msg
-                sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME, SENDMSG_REPLACE,
-                        Math.round(volume * (float)1000.0), 0, null, PERSIST_DELAY);
-            }
-            // Send the volume update regardless whether there was a change.
-            sendMasterVolumeUpdate(flags, oldVolume, newVolume);
-        }
-    }
-
-    /** @see AudioManager#getStreamMaxVolume(int) */
-    public int getStreamMaxVolume(int streamType) {
-        ensureValidStreamType(streamType);
-        return (mStreamStates[streamType].getMaxIndex() + 5) / 10;
-    }
-
-    public int getMasterMaxVolume() {
-        return MAX_MASTER_VOLUME;
-    }
-
-    /** Get last audible volume before stream was muted. */
-    public int getLastAudibleStreamVolume(int streamType) {
-        ensureValidStreamType(streamType);
-        int device = getDeviceForStream(streamType);
-        return (mStreamStates[streamType].getIndex(device, true  /* lastAudible */) + 5) / 10;
-    }
-
-    /** Get last audible master volume before it was muted. */
-    public int getLastAudibleMasterVolume() {
-        return Math.round(AudioSystem.getMasterVolume() * MAX_MASTER_VOLUME);
-    }
-
-    /** @see AudioManager#getMasterStreamType(int) */
-    public int getMasterStreamType() {
-        if (mVoiceCapable) {
-            return AudioSystem.STREAM_RING;
-        } else {
-            return AudioSystem.STREAM_MUSIC;
-        }
-    }
-
-    /** @see AudioManager#getRingerMode() */
-    public int getRingerMode() {
-        synchronized(mSettingsLock) {
-            return mRingerMode;
-        }
-    }
-
-    private void ensureValidRingerMode(int ringerMode) {
-        if (!AudioManager.isValidRingerMode(ringerMode)) {
-            throw new IllegalArgumentException("Bad ringer mode " + ringerMode);
-        }
-    }
-
-    /** @see AudioManager#setRingerMode(int) */
-    public void setRingerMode(int ringerMode) {
-        if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
-            ringerMode = AudioManager.RINGER_MODE_SILENT;
-        }
-        if (ringerMode != getRingerMode()) {
-            setRingerModeInt(ringerMode, true);
-            // Send sticky broadcast
-            broadcastRingerMode(ringerMode);
-        }
-    }
-
-    private void setRingerModeInt(int ringerMode, boolean persist) {
-        synchronized(mSettingsLock) {
-            mRingerMode = ringerMode;
-            if (ringerMode != AudioManager.RINGER_MODE_NORMAL) {
-                mLastSilentRingerMode = ringerMode;
-            }
-        }
-
-        // Mute stream if not previously muted by ringer mode and ringer mode
-        // is not RINGER_MODE_NORMAL and stream is affected by ringer mode.
-        // Unmute stream if previously muted by ringer mode and ringer mode
-        // is RINGER_MODE_NORMAL or stream is not affected by ringer mode.
-        int numStreamTypes = AudioSystem.getNumStreamTypes();
-        for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
-            if (isStreamMutedByRingerMode(streamType)) {
-                if (!isStreamAffectedByRingerMode(streamType) ||
-                    ringerMode == AudioManager.RINGER_MODE_NORMAL) {
-                    // ring and notifications volume should never be 0 when not silenced
-                    // on voice capable devices
-                    if (mVoiceCapable &&
-                            mStreamVolumeAlias[streamType] == AudioSystem.STREAM_RING) {
-                        synchronized (mStreamStates[streamType]) {
-                            Set set = mStreamStates[streamType].mLastAudibleIndex.entrySet();
-                            Iterator i = set.iterator();
-                            while (i.hasNext()) {
-                                Map.Entry entry = (Map.Entry)i.next();
-                                if ((Integer)entry.getValue() == 0) {
-                                    entry.setValue(10);
-                                }
-                            }
-                        }
-                    }
-                    mStreamStates[streamType].mute(null, false);
-                    mRingerModeMutedStreams &= ~(1 << streamType);
-                }
-            } else {
-                if (isStreamAffectedByRingerMode(streamType) &&
-                    ringerMode != AudioManager.RINGER_MODE_NORMAL) {
-                   mStreamStates[streamType].mute(null, true);
-                   mRingerModeMutedStreams |= (1 << streamType);
-               }
-            }
-        }
-
-        // Post a persist ringer mode msg
-        if (persist) {
-            sendMsg(mAudioHandler, MSG_PERSIST_RINGER_MODE,
-                    SENDMSG_REPLACE, 0, 0, null, PERSIST_DELAY);
-        }
-    }
-
-    private void restoreMasterVolume() {
-        if (mUseMasterVolume) {
-            float volume = Settings.System.getFloatForUser(mContentResolver,
-                    Settings.System.VOLUME_MASTER, -1.0f, UserHandle.USER_CURRENT);
-            if (volume >= 0.0f) {
-                AudioSystem.setMasterVolume(volume);
-            }
-        }
-    }
-
-    /** @see AudioManager#shouldVibrate(int) */
-    public boolean shouldVibrate(int vibrateType) {
-        if (!mHasVibrator) return false;
-
-        switch (getVibrateSetting(vibrateType)) {
-
-            case AudioManager.VIBRATE_SETTING_ON:
-                return getRingerMode() != AudioManager.RINGER_MODE_SILENT;
-
-            case AudioManager.VIBRATE_SETTING_ONLY_SILENT:
-                return getRingerMode() == AudioManager.RINGER_MODE_VIBRATE;
-
-            case AudioManager.VIBRATE_SETTING_OFF:
-                // return false, even for incoming calls
-                return false;
-
-            default:
-                return false;
-        }
-    }
-
-    /** @see AudioManager#getVibrateSetting(int) */
-    public int getVibrateSetting(int vibrateType) {
-        if (!mHasVibrator) return AudioManager.VIBRATE_SETTING_OFF;
-        return (mVibrateSetting >> (vibrateType * 2)) & 3;
-    }
-
-    /** @see AudioManager#setVibrateSetting(int, int) */
-    public void setVibrateSetting(int vibrateType, int vibrateSetting) {
-
-        if (!mHasVibrator) return;
-
-        mVibrateSetting = getValueForVibrateSetting(mVibrateSetting, vibrateType, vibrateSetting);
-
-        // Broadcast change
-        broadcastVibrateSetting(vibrateType);
-
-    }
-
-    /**
-     * @see #setVibrateSetting(int, int)
-     */
-    public static int getValueForVibrateSetting(int existingValue, int vibrateType,
-            int vibrateSetting) {
-
-        // First clear the existing setting. Each vibrate type has two bits in
-        // the value. Note '3' is '11' in binary.
-        existingValue &= ~(3 << (vibrateType * 2));
-
-        // Set into the old value
-        existingValue |= (vibrateSetting & 3) << (vibrateType * 2);
-
-        return existingValue;
-    }
-
-    private class SetModeDeathHandler implements IBinder.DeathRecipient {
-        private IBinder mCb; // To be notified of client's death
-        private int mPid;
-        private int mMode = AudioSystem.MODE_NORMAL; // Current mode set by this client
-
-        SetModeDeathHandler(IBinder cb, int pid) {
-            mCb = cb;
-            mPid = pid;
-        }
-
-        public void binderDied() {
-            int newModeOwnerPid = 0;
-            synchronized(mSetModeDeathHandlers) {
-                Log.w(TAG, "setMode() client died");
-                int index = mSetModeDeathHandlers.indexOf(this);
-                if (index < 0) {
-                    Log.w(TAG, "unregistered setMode() client died");
-                } else {
-                    newModeOwnerPid = setModeInt(AudioSystem.MODE_NORMAL, mCb, mPid);
-                }
-            }
-            // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
-            // SCO connections not started by the application changing the mode
-            if (newModeOwnerPid != 0) {
-                 disconnectBluetoothSco(newModeOwnerPid);
-            }
-        }
-
-        public int getPid() {
-            return mPid;
-        }
-
-        public void setMode(int mode) {
-            mMode = mode;
-        }
-
-        public int getMode() {
-            return mMode;
-        }
-
-        public IBinder getBinder() {
-            return mCb;
-        }
-    }
-
-    /** @see AudioManager#setMode(int) */
-    public void setMode(int mode, IBinder cb) {
-        if (!checkAudioSettingsPermission("setMode()")) {
-            return;
-        }
-
-        if (mode < AudioSystem.MODE_CURRENT || mode >= AudioSystem.NUM_MODES) {
-            return;
-        }
-
-        int newModeOwnerPid = 0;
-        synchronized(mSetModeDeathHandlers) {
-            if (mode == AudioSystem.MODE_CURRENT) {
-                mode = mMode;
-            }
-            newModeOwnerPid = setModeInt(mode, cb, Binder.getCallingPid());
-        }
-        // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
-        // SCO connections not started by the application changing the mode
-        if (newModeOwnerPid != 0) {
-             disconnectBluetoothSco(newModeOwnerPid);
-        }
-    }
-
-    // must be called synchronized on mSetModeDeathHandlers
-    // setModeInt() returns a valid PID if the audio mode was successfully set to
-    // any mode other than NORMAL.
-    int setModeInt(int mode, IBinder cb, int pid) {
-        int newModeOwnerPid = 0;
-        if (cb == null) {
-            Log.e(TAG, "setModeInt() called with null binder");
-            return newModeOwnerPid;
-        }
-
-        SetModeDeathHandler hdlr = null;
-        Iterator iter = mSetModeDeathHandlers.iterator();
-        while (iter.hasNext()) {
-            SetModeDeathHandler h = (SetModeDeathHandler)iter.next();
-            if (h.getPid() == pid) {
-                hdlr = h;
-                // Remove from client list so that it is re-inserted at top of list
-                iter.remove();
-                hdlr.getBinder().unlinkToDeath(hdlr, 0);
-                break;
-            }
-        }
-        int status = AudioSystem.AUDIO_STATUS_OK;
-        do {
-            if (mode == AudioSystem.MODE_NORMAL) {
-                // get new mode from client at top the list if any
-                if (!mSetModeDeathHandlers.isEmpty()) {
-                    hdlr = mSetModeDeathHandlers.get(0);
-                    cb = hdlr.getBinder();
-                    mode = hdlr.getMode();
-                }
-            } else {
-                if (hdlr == null) {
-                    hdlr = new SetModeDeathHandler(cb, pid);
-                }
-                // Register for client death notification
-                try {
-                    cb.linkToDeath(hdlr, 0);
-                } catch (RemoteException e) {
-                    // Client has died!
-                    Log.w(TAG, "setMode() could not link to "+cb+" binder death");
-                }
-
-                // Last client to call setMode() is always at top of client list
-                // as required by SetModeDeathHandler.binderDied()
-                mSetModeDeathHandlers.add(0, hdlr);
-                hdlr.setMode(mode);
-            }
-
-            if (mode != mMode) {
-                status = AudioSystem.setPhoneState(mode);
-                if (status == AudioSystem.AUDIO_STATUS_OK) {
-                    mMode = mode;
-                } else {
-                    if (hdlr != null) {
-                        mSetModeDeathHandlers.remove(hdlr);
-                        cb.unlinkToDeath(hdlr, 0);
-                    }
-                    // force reading new top of mSetModeDeathHandlers stack
-                    mode = AudioSystem.MODE_NORMAL;
-                }
-            } else {
-                status = AudioSystem.AUDIO_STATUS_OK;
-            }
-        } while (status != AudioSystem.AUDIO_STATUS_OK && !mSetModeDeathHandlers.isEmpty());
-
-        if (status == AudioSystem.AUDIO_STATUS_OK) {
-            if (mode != AudioSystem.MODE_NORMAL) {
-                if (mSetModeDeathHandlers.isEmpty()) {
-                    Log.e(TAG, "setMode() different from MODE_NORMAL with empty mode client stack");
-                } else {
-                    newModeOwnerPid = mSetModeDeathHandlers.get(0).getPid();
-                }
-            }
-            int streamType = getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
-            if (streamType == STREAM_REMOTE_MUSIC) {
-                // here handle remote media playback the same way as local playback
-                streamType = AudioManager.STREAM_MUSIC;
-            }
-            int device = getDeviceForStream(streamType);
-            int index = mStreamStates[mStreamVolumeAlias[streamType]].getIndex(device, false);
-            setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, true, false);
-
-            updateStreamVolumeAlias(true /*updateVolumes*/);
-        }
-        return newModeOwnerPid;
-    }
-
-    /** @see AudioManager#getMode() */
-    public int getMode() {
-        return mMode;
-    }
-
-    /** @see AudioManager#playSoundEffect(int) */
-    public void playSoundEffect(int effectType) {
-        sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_NOOP,
-                effectType, -1, null, 0);
-    }
-
-    /** @see AudioManager#playSoundEffect(int, float) */
-    public void playSoundEffectVolume(int effectType, float volume) {
-        loadSoundEffects();
-        sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_NOOP,
-                effectType, (int) (volume * 1000), null, 0);
-    }
-
-    /**
-     * Loads samples into the soundpool.
-     * This method must be called at first when sound effects are enabled
-     */
-    public boolean loadSoundEffects() {
-        int status;
-
-        synchronized (mSoundEffectsLock) {
-            if (!mBootCompleted) {
-                Log.w(TAG, "loadSoundEffects() called before boot complete");
-                return false;
-            }
-
-            if (mSoundPool != null) {
-                return true;
-            }
-            mSoundPool = new SoundPool(NUM_SOUNDPOOL_CHANNELS, AudioSystem.STREAM_SYSTEM, 0);
-
-            try {
-                mSoundPoolCallBack = null;
-                mSoundPoolListenerThread = new SoundPoolListenerThread();
-                mSoundPoolListenerThread.start();
-                // Wait for mSoundPoolCallBack to be set by the other thread
-                mSoundEffectsLock.wait();
-            } catch (InterruptedException e) {
-                Log.w(TAG, "Interrupted while waiting sound pool listener thread.");
-            }
-
-            if (mSoundPoolCallBack == null) {
-                Log.w(TAG, "loadSoundEffects() could not create SoundPool listener or thread");
-                if (mSoundPoolLooper != null) {
-                    mSoundPoolLooper.quit();
-                    mSoundPoolLooper = null;
-                }
-                mSoundPoolListenerThread = null;
-                mSoundPool.release();
-                mSoundPool = null;
-                return false;
-            }
-            /*
-             * poolId table: The value -1 in this table indicates that corresponding
-             * file (same index in SOUND_EFFECT_FILES[] has not been loaded.
-             * Once loaded, the value in poolId is the sample ID and the same
-             * sample can be reused for another effect using the same file.
-             */
-            int[] poolId = new int[SOUND_EFFECT_FILES.length];
-            for (int fileIdx = 0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
-                poolId[fileIdx] = -1;
-            }
-            /*
-             * Effects whose value in SOUND_EFFECT_FILES_MAP[effect][1] is -1 must be loaded.
-             * If load succeeds, value in SOUND_EFFECT_FILES_MAP[effect][1] is > 0:
-             * this indicates we have a valid sample loaded for this effect.
-             */
-
-            int lastSample = 0;
-            for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
-                // Do not load sample if this effect uses the MediaPlayer
-                if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
-                    continue;
-                }
-                if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
-                    String filePath = Environment.getRootDirectory()
-                            + SOUND_EFFECTS_PATH
-                            + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effect][0]];
-                    int sampleId = mSoundPool.load(filePath, 0);
-                    if (sampleId <= 0) {
-                        Log.w(TAG, "Soundpool could not load file: "+filePath);
-                    } else {
-                        SOUND_EFFECT_FILES_MAP[effect][1] = sampleId;
-                        poolId[SOUND_EFFECT_FILES_MAP[effect][0]] = sampleId;
-                        lastSample = sampleId;
-                    }
-                } else {
-                    SOUND_EFFECT_FILES_MAP[effect][1] = poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
-                }
-            }
-            // wait for all samples to be loaded
-            if (lastSample != 0) {
-                mSoundPoolCallBack.setLastSample(lastSample);
-
-                try {
-                    mSoundEffectsLock.wait();
-                    status = mSoundPoolCallBack.status();
-                } catch (java.lang.InterruptedException e) {
-                    Log.w(TAG, "Interrupted while waiting sound pool callback.");
-                    status = -1;
-                }
-            } else {
-                status = -1;
-            }
-
-            if (mSoundPoolLooper != null) {
-                mSoundPoolLooper.quit();
-                mSoundPoolLooper = null;
-            }
-            mSoundPoolListenerThread = null;
-            if (status != 0) {
-                Log.w(TAG,
-                        "loadSoundEffects(), Error "
-                                + ((lastSample != 0) ? mSoundPoolCallBack.status() : -1)
-                                + " while loading samples");
-                for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
-                    if (SOUND_EFFECT_FILES_MAP[effect][1] > 0) {
-                        SOUND_EFFECT_FILES_MAP[effect][1] = -1;
-                    }
-                }
-
-                mSoundPool.release();
-                mSoundPool = null;
-            }
-        }
-        return (status == 0);
-    }
-
-    /**
-     *  Unloads samples from the sound pool.
-     *  This method can be called to free some memory when
-     *  sound effects are disabled.
-     */
-    public void unloadSoundEffects() {
-        synchronized (mSoundEffectsLock) {
-            if (mSoundPool == null) {
-                return;
-            }
-
-            mAudioHandler.removeMessages(MSG_LOAD_SOUND_EFFECTS);
-            mAudioHandler.removeMessages(MSG_PLAY_SOUND_EFFECT);
-
-            int[] poolId = new int[SOUND_EFFECT_FILES.length];
-            for (int fileIdx = 0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
-                poolId[fileIdx] = 0;
-            }
-
-            for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
-                if (SOUND_EFFECT_FILES_MAP[effect][1] <= 0) {
-                    continue;
-                }
-                if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == 0) {
-                    mSoundPool.unload(SOUND_EFFECT_FILES_MAP[effect][1]);
-                    SOUND_EFFECT_FILES_MAP[effect][1] = -1;
-                    poolId[SOUND_EFFECT_FILES_MAP[effect][0]] = -1;
-                }
-            }
-            mSoundPool.release();
-            mSoundPool = null;
-        }
-    }
-
-    class SoundPoolListenerThread extends Thread {
-        public SoundPoolListenerThread() {
-            super("SoundPoolListenerThread");
-        }
-
-        @Override
-        public void run() {
-
-            Looper.prepare();
-            mSoundPoolLooper = Looper.myLooper();
-
-            synchronized (mSoundEffectsLock) {
-                if (mSoundPool != null) {
-                    mSoundPoolCallBack = new SoundPoolCallback();
-                    mSoundPool.setOnLoadCompleteListener(mSoundPoolCallBack);
-                }
-                mSoundEffectsLock.notify();
-            }
-            Looper.loop();
-        }
-    }
-
-    private final class SoundPoolCallback implements
-            android.media.SoundPool.OnLoadCompleteListener {
-
-        int mStatus;
-        int mLastSample;
-
-        public int status() {
-            return mStatus;
-        }
-
-        public void setLastSample(int sample) {
-            mLastSample = sample;
-        }
-
-        public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
-            synchronized (mSoundEffectsLock) {
-                if (status != 0) {
-                    mStatus = status;
-                }
-                if (sampleId == mLastSample) {
-                    mSoundEffectsLock.notify();
-                }
-            }
-        }
-    }
-
-    /** @see AudioManager#reloadAudioSettings() */
-    public void reloadAudioSettings() {
-        readAudioSettings(false /*userSwitch*/);
-    }
-
-    private void readAudioSettings(boolean userSwitch) {
-        // restore ringer mode, ringer mode affected streams, mute affected streams and vibrate settings
-        readPersistedSettings();
-
-        // restore volume settings
-        int numStreamTypes = AudioSystem.getNumStreamTypes();
-        for (int streamType = 0; streamType < numStreamTypes; streamType++) {
-            VolumeStreamState streamState = mStreamStates[streamType];
-
-            if (userSwitch && mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) {
-                continue;
-            }
-
-            synchronized (streamState) {
-                streamState.readSettings();
-
-                // unmute stream that was muted but is not affect by mute anymore
-                if (streamState.muteCount() != 0 && !isStreamAffectedByMute(streamType) &&
-                        !isStreamMutedByRingerMode(streamType)) {
-                    int size = streamState.mDeathHandlers.size();
-                    for (int i = 0; i < size; i++) {
-                        streamState.mDeathHandlers.get(i).mMuteCount = 1;
-                        streamState.mDeathHandlers.get(i).mute(false);
-                    }
-                }
-            }
-        }
-
-        // apply new ringer mode before checking volume for alias streams so that streams
-        // muted by ringer mode have the correct volume
-        setRingerModeInt(getRingerMode(), false);
-
-        checkAllAliasStreamVolumes();
-
-        synchronized (mSafeMediaVolumeState) {
-            if (mSafeVolumeEnabled &&
-                    mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE) {
-                enforceSafeMediaVolume();
-            }
-        }
-    }
-
-    /** @see AudioManager#setSpeakerphoneOn() */
-    public void setSpeakerphoneOn(boolean on){
-        if (!checkAudioSettingsPermission("setSpeakerphoneOn()")) {
-            return;
-        }
-        mForcedUseForComm = on ? AudioSystem.FORCE_SPEAKER : AudioSystem.FORCE_NONE;
-
-        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
-                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, null, 0);
-    }
-
-    /** @see AudioManager#isSpeakerphoneOn() */
-    public boolean isSpeakerphoneOn() {
-        return (mForcedUseForComm == AudioSystem.FORCE_SPEAKER);
-    }
-
-    /** @see AudioManager#setBluetoothScoOn() */
-    public void setBluetoothScoOn(boolean on){
-        if (!checkAudioSettingsPermission("setBluetoothScoOn()")) {
-            return;
-        }
-        mForcedUseForComm = on ? AudioSystem.FORCE_BT_SCO : AudioSystem.FORCE_NONE;
-
-        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
-                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, null, 0);
-        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
-                AudioSystem.FOR_RECORD, mForcedUseForComm, null, 0);
-    }
-
-    /** @see AudioManager#isBluetoothScoOn() */
-    public boolean isBluetoothScoOn() {
-        return (mForcedUseForComm == AudioSystem.FORCE_BT_SCO);
-    }
-
-    /** @see AudioManager#setBluetoothA2dpOn() */
-    public void setBluetoothA2dpOn(boolean on) {
-        if (!checkAudioSettingsPermission("setBluetoothA2dpOn()") && noDelayInATwoDP) {
-            return;
-        }
-        synchronized (mBluetoothA2dpEnabledLock) {
-            mBluetoothA2dpEnabled = on;
-            sendMsg(mAudioHandler, MSG_SET_FORCE_BT_A2DP_USE, SENDMSG_QUEUE,
-                    AudioSystem.FOR_MEDIA,
-                    mBluetoothA2dpEnabled ? AudioSystem.FORCE_NONE : AudioSystem.FORCE_NO_BT_A2DP,
-                    null, 0);
-        }
-    }
-
-    /** @see AudioManager#isBluetoothA2dpOn() */
-    public boolean isBluetoothA2dpOn() {
-        synchronized (mBluetoothA2dpEnabledLock) {
-            return mBluetoothA2dpEnabled;
-        }
-    }
-
-    /** @see AudioManager#startBluetoothSco() */
-    public void startBluetoothSco(IBinder cb){
-        if (!checkAudioSettingsPermission("startBluetoothSco()") ||
-                !mBootCompleted) {
-            return;
-        }
-        ScoClient client = getScoClient(cb, true);
-        client.incCount();
-    }
-
-    /** @see AudioManager#stopBluetoothSco() */
-    public void stopBluetoothSco(IBinder cb){
-        if (!checkAudioSettingsPermission("stopBluetoothSco()") ||
-                !mBootCompleted) {
-            return;
-        }
-        ScoClient client = getScoClient(cb, false);
-        if (client != null) {
-            client.decCount();
-        }
-    }
-
-
-    private class ScoClient implements IBinder.DeathRecipient {
-        private IBinder mCb; // To be notified of client's death
-        private int mCreatorPid;
-        private int mStartcount; // number of SCO connections started by this client
-
-        ScoClient(IBinder cb) {
-            mCb = cb;
-            mCreatorPid = Binder.getCallingPid();
-            mStartcount = 0;
-        }
-
-        public void binderDied() {
-            synchronized(mScoClients) {
-                Log.w(TAG, "SCO client died");
-                int index = mScoClients.indexOf(this);
-                if (index < 0) {
-                    Log.w(TAG, "unregistered SCO client died");
-                } else {
-                    clearCount(true);
-                    mScoClients.remove(this);
-                }
-            }
-        }
-
-        public void incCount() {
-            synchronized(mScoClients) {
-                requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED);
-                if (mStartcount == 0) {
-                    try {
-                        mCb.linkToDeath(this, 0);
-                    } catch (RemoteException e) {
-                        // client has already died!
-                        Log.w(TAG, "ScoClient  incCount() could not link to "+mCb+" binder death");
-                    }
-                }
-                mStartcount++;
-            }
-        }
-
-        public void decCount() {
-            synchronized(mScoClients) {
-                if (mStartcount == 0) {
-                    Log.w(TAG, "ScoClient.decCount() already 0");
-                } else {
-                    mStartcount--;
-                    if (mStartcount == 0) {
-                        try {
-                            mCb.unlinkToDeath(this, 0);
-                        } catch (NoSuchElementException e) {
-                            Log.w(TAG, "decCount() going to 0 but not registered to binder");
-                        }
-                    }
-                    requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
-                }
-            }
-        }
-
-        public void clearCount(boolean stopSco) {
-            synchronized(mScoClients) {
-                if (mStartcount != 0) {
-                    try {
-                        mCb.unlinkToDeath(this, 0);
-                    } catch (NoSuchElementException e) {
-                        Log.w(TAG, "clearCount() mStartcount: "+mStartcount+" != 0 but not registered to binder");
-                    }
-                }
-                mStartcount = 0;
-                if (stopSco) {
-                    requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
-                }
-            }
-        }
-
-        public int getCount() {
-            return mStartcount;
-        }
-
-        public IBinder getBinder() {
-            return mCb;
-        }
-
-        public int getPid() {
-            return mCreatorPid;
-        }
-
-        public int totalCount() {
-            synchronized(mScoClients) {
-                int count = 0;
-                int size = mScoClients.size();
-                for (int i = 0; i < size; i++) {
-                    count += mScoClients.get(i).getCount();
-                }
-                return count;
-            }
-        }
-
-        private void requestScoState(int state) {
-            checkScoAudioState();
-            if (totalCount() == 0) {
-                if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
-                    // Make sure that the state transitions to CONNECTING even if we cannot initiate
-                    // the connection.
-                    broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTING);
-                    // Accept SCO audio activation only in NORMAL audio mode or if the mode is
-                    // currently controlled by the same client process.
-                    synchronized(mSetModeDeathHandlers) {
-                        if ((mSetModeDeathHandlers.isEmpty() ||
-                                mSetModeDeathHandlers.get(0).getPid() == mCreatorPid) &&
-                                (mScoAudioState == SCO_STATE_INACTIVE ||
-                                 mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
-                            if (mScoAudioState == SCO_STATE_INACTIVE) {
-                                if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null) {
-                                    if (mBluetoothHeadset.startScoUsingVirtualVoiceCall(
-                                            mBluetoothHeadsetDevice)) {
-                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
-                                    } else {
-                                        broadcastScoConnectionState(
-                                                AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
-                                    }
-                                } else if (getBluetoothHeadset()) {
-                                    mScoAudioState = SCO_STATE_ACTIVATE_REQ;
-                                }
-                            } else {
-                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
-                                broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTED);
-                            }
-                        } else {
-                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
-                        }
-                    }
-                } else if (state == BluetoothHeadset.STATE_AUDIO_DISCONNECTED &&
-                              (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL ||
-                               mScoAudioState == SCO_STATE_ACTIVATE_REQ)) {
-                    if (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL) {
-                        if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null) {
-                            if (!mBluetoothHeadset.stopScoUsingVirtualVoiceCall(
-                                    mBluetoothHeadsetDevice)) {
-                                mScoAudioState = SCO_STATE_INACTIVE;
-                                broadcastScoConnectionState(
-                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
-                            }
-                        } else if (getBluetoothHeadset()) {
-                            mScoAudioState = SCO_STATE_DEACTIVATE_REQ;
-                        }
-                    } else {
-                        mScoAudioState = SCO_STATE_INACTIVE;
-                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
-                    }
-                }
-            }
-        }
-    }
-
-    private void checkScoAudioState() {
-        if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null &&
-                mScoAudioState == SCO_STATE_INACTIVE &&
-                mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
-                != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
-            mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
-        }
-    }
-
-    private ScoClient getScoClient(IBinder cb, boolean create) {
-        synchronized(mScoClients) {
-            ScoClient client = null;
-            int size = mScoClients.size();
-            for (int i = 0; i < size; i++) {
-                client = mScoClients.get(i);
-                if (client.getBinder() == cb)
-                    return client;
-            }
-            if (create) {
-                client = new ScoClient(cb);
-                mScoClients.add(client);
-            }
-            return client;
-        }
-    }
-
-    public void clearAllScoClients(int exceptPid, boolean stopSco) {
-        synchronized(mScoClients) {
-            ScoClient savedClient = null;
-            int size = mScoClients.size();
-            for (int i = 0; i < size; i++) {
-                ScoClient cl = mScoClients.get(i);
-                if (cl.getPid() != exceptPid) {
-                    cl.clearCount(stopSco);
-                } else {
-                    savedClient = cl;
-                }
-            }
-            mScoClients.clear();
-            if (savedClient != null) {
-                mScoClients.add(savedClient);
-            }
-        }
-    }
-
-    private boolean getBluetoothHeadset() {
-        boolean result = false;
-        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-        if (adapter != null) {
-            result = adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
-                                    BluetoothProfile.HEADSET);
-        }
-        // If we could not get a bluetooth headset proxy, send a failure message
-        // without delay to reset the SCO audio state and clear SCO clients.
-        // If we could get a proxy, send a delayed failure message that will reset our state
-        // in case we don't receive onServiceConnected().
-        sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
-                SENDMSG_REPLACE, 0, 0, null, result ? BT_HEADSET_CNCT_TIMEOUT_MS : 0);
-        return result;
-    }
-
-    private void disconnectBluetoothSco(int exceptPid) {
-        synchronized(mScoClients) {
-            checkScoAudioState();
-            if (mScoAudioState == SCO_STATE_ACTIVE_EXTERNAL ||
-                    mScoAudioState == SCO_STATE_DEACTIVATE_EXT_REQ) {
-                if (mBluetoothHeadsetDevice != null) {
-                    if (mBluetoothHeadset != null) {
-                        if (!mBluetoothHeadset.stopVoiceRecognition(
-                                mBluetoothHeadsetDevice)) {
-                            sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
-                                    SENDMSG_REPLACE, 0, 0, null, 0);
-                        }
-                    } else if (mScoAudioState == SCO_STATE_ACTIVE_EXTERNAL &&
-                            getBluetoothHeadset()) {
-                        mScoAudioState = SCO_STATE_DEACTIVATE_EXT_REQ;
-                    }
-                }
-            } else {
-                clearAllScoClients(exceptPid, true);
-            }
-        }
-    }
-
-    private void resetBluetoothSco() {
-        synchronized(mScoClients) {
-            clearAllScoClients(0, false);
-            mScoAudioState = SCO_STATE_INACTIVE;
-            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
-        }
-    }
-
-    private void broadcastScoConnectionState(int state) {
-        if (state != mScoConnectionState) {
-            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_UPDATED);
-            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, state);
-            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_PREVIOUS_STATE,
-                    mScoConnectionState);
-            sendStickyBroadcastToAll(newIntent);
-            mScoConnectionState = state;
-        }
-    }
-
-    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
-        new BluetoothProfile.ServiceListener() {
-        public void onServiceConnected(int profile, BluetoothProfile proxy) {
-            BluetoothDevice btDevice;
-            List<BluetoothDevice> deviceList;
-            switch(profile) {
-            case BluetoothProfile.A2DP:
-                BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
-                deviceList = a2dp.getConnectedDevices();
-                if (deviceList.size() > 0) {
-                    btDevice = deviceList.get(0);
-                    if (!noDelayInATwoDP) {
-                        synchronized (mConnectedDevices) {
-                            int state = a2dp.getConnectionState(btDevice);
-                            int delay = checkSendBecomingNoisyIntent(
-                                                AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
-                                                (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0);
-                            queueMsgUnderWakeLock(mAudioHandler,
-                                    MSG_SET_A2DP_CONNECTION_STATE,
-                                    state,
-                                    0,
-                                    btDevice,
-                                    delay);
-                        }
-                    } else {
-                        onSetA2dpConnectionState(btDevice, a2dp.getConnectionState(btDevice));
-                    }
-                }
-                break;
-
-            case BluetoothProfile.HEADSET:
-                synchronized (mScoClients) {
-                    // Discard timeout message
-                    mAudioHandler.removeMessages(MSG_BT_HEADSET_CNCT_FAILED);
-                    mBluetoothHeadset = (BluetoothHeadset) proxy;
-                    deviceList = mBluetoothHeadset.getConnectedDevices();
-                    if (deviceList.size() > 0) {
-                        mBluetoothHeadsetDevice = deviceList.get(0);
-                    } else {
-                        mBluetoothHeadsetDevice = null;
-                    }
-                    // Refresh SCO audio state
-                    checkScoAudioState();
-                    // Continue pending action if any
-                    if (mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
-                            mScoAudioState == SCO_STATE_DEACTIVATE_REQ ||
-                            mScoAudioState == SCO_STATE_DEACTIVATE_EXT_REQ) {
-                        boolean status = false;
-                        if (mBluetoothHeadsetDevice != null) {
-                            switch (mScoAudioState) {
-                            case SCO_STATE_ACTIVATE_REQ:
-                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
-                                status = mBluetoothHeadset.startScoUsingVirtualVoiceCall(
-                                        mBluetoothHeadsetDevice);
-                                break;
-                            case SCO_STATE_DEACTIVATE_REQ:
-                                status = mBluetoothHeadset.stopScoUsingVirtualVoiceCall(
-                                        mBluetoothHeadsetDevice);
-                                break;
-                            case SCO_STATE_DEACTIVATE_EXT_REQ:
-                                status = mBluetoothHeadset.stopVoiceRecognition(
-                                        mBluetoothHeadsetDevice);
-                            }
-                        }
-                        if (!status) {
-                            sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
-                                    SENDMSG_REPLACE, 0, 0, null, 0);
-                        }
-                    }
-                }
-                break;
-
-            default:
-                break;
-            }
-        }
-        public void onServiceDisconnected(int profile) {
-            switch(profile) {
-            case BluetoothProfile.A2DP:
-                synchronized (mConnectedDevices) {
-                    if (mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)) {
-                        makeA2dpDeviceUnavailableNow(
-                                mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP));
-                    }
-                }
-                break;
-
-            case BluetoothProfile.HEADSET:
-                synchronized (mScoClients) {
-                    mBluetoothHeadset = null;
-                }
-                break;
-
-            default:
-                break;
-            }
-        }
-    };
-
-    /** see AudioManager.setRemoteSubmixOn(boolean on) */
-    public void setRemoteSubmixOn(boolean on, int address) {
-        sendMsg(mAudioHandler, MSG_SET_RSX_CONNECTION_STATE,
-                SENDMSG_REPLACE /* replace with QUEUE when multiple addresses are supported */,
-                on ? 1 : 0 /*arg1*/,
-                address /*arg2*/,
-                null/*obj*/, 0/*delay*/);
-    }
-
-    private void onSetRsxConnectionState(int available, int address) {
-        AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_REMOTE_SUBMIX,
-                available == 1 ?
-                        AudioSystem.DEVICE_STATE_AVAILABLE : AudioSystem.DEVICE_STATE_UNAVAILABLE,
-                String.valueOf(address) /*device_address*/);
-        AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_REMOTE_SUBMIX,
-                available == 1 ?
-                        AudioSystem.DEVICE_STATE_AVAILABLE : AudioSystem.DEVICE_STATE_UNAVAILABLE,
-                String.valueOf(address) /*device_address*/);
-    }
-
-    private void onCheckMusicActive() {
-        synchronized (mSafeMediaVolumeState) {
-            if (mSafeVolumeEnabled &&
-                    mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_INACTIVE) {
-                int device = getDeviceForStream(AudioSystem.STREAM_MUSIC);
-
-                if ((device & mSafeMediaVolumeDevices) != 0) {
-                    sendMsg(mAudioHandler,
-                            MSG_CHECK_MUSIC_ACTIVE,
-                            SENDMSG_REPLACE,
-                            0,
-                            0,
-                            null,
-                            MUSIC_ACTIVE_POLL_PERIOD_MS);
-                    int index = mStreamStates[AudioSystem.STREAM_MUSIC].getIndex(device,
-                                                                            false /*lastAudible*/);
-                    if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0) &&
-                            (index > mSafeMediaVolumeIndex)) {
-                        // Approximate cumulative active music time
-                        mMusicActiveMs += MUSIC_ACTIVE_POLL_PERIOD_MS;
-                        if (mMusicActiveMs > UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX) {
-                            setSafeMediaVolumeEnabled(true);
-                            mMusicActiveMs = 0;
-                            displaySafeVolumeWarning();
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private void onConfigureSafeVolume(boolean force) {
-        synchronized (mSafeMediaVolumeState) {
-            int mcc = mContext.getResources().getConfiguration().mcc;
-            if ((mMcc != mcc) || ((mMcc == 0) && force)) {
-                mSafeMediaVolumeIndex = mContext.getResources().getInteger(
-                        com.android.internal.R.integer.config_safe_media_volume_index) * 10;
-                boolean safeMediaVolumeEnabled = mContext.getResources().getBoolean(
-                        com.android.internal.R.bool.config_safe_media_volume_enabled);
-
-                // The persisted state is either "disabled" or "active": this is the state applied
-                // next time we boot and cannot be "inactive"
-                int persistedState;
-                if (safeMediaVolumeEnabled) {
-                    persistedState = SAFE_MEDIA_VOLUME_ACTIVE;
-                    // The state can already be "inactive" here if the user has forced it before
-                    // the 30 seconds timeout for forced configuration. In this case we don't reset
-                    // it to "active".
-                    if (mSafeMediaVolumeState != SAFE_MEDIA_VOLUME_INACTIVE) {
-                        mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_ACTIVE;
-                        enforceSafeMediaVolume();
-                    }
-                } else {
-                    persistedState = SAFE_MEDIA_VOLUME_DISABLED;
-                    mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_DISABLED;
-                }
-                mMcc = mcc;
-                sendMsg(mAudioHandler,
-                        MSG_PERSIST_SAFE_VOLUME_STATE,
-                        SENDMSG_QUEUE,
-                        persistedState,
-                        0,
-                        null,
-                        0);
-            }
-        }
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Internal methods
-    ///////////////////////////////////////////////////////////////////////////
-
-    /**
-     * Checks if the adjustment should change ringer mode instead of just
-     * adjusting volume. If so, this will set the proper ringer mode and volume
-     * indices on the stream states.
-     */
-    private boolean checkForRingerModeChange(int oldIndex, int direction,  int step) {
-        boolean adjustVolumeIndex = true;
-        int ringerMode = getRingerMode();
-
-        switch (ringerMode) {
-        case RINGER_MODE_NORMAL:
-            if (direction == AudioManager.ADJUST_LOWER) {
-                if (mHasVibrator) {
-                    // "step" is the delta in internal index units corresponding to a
-                    // change of 1 in UI index units.
-                    // Because of rounding when rescaling from one stream index range to its alias
-                    // index range, we cannot simply test oldIndex == step:
-                    //   (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
-                    if (step <= oldIndex && oldIndex < 2 * step) {
-                        ringerMode = RINGER_MODE_VIBRATE;
-                        if (mVoiceCapable)
-                            adjustVolumeIndex = false;
-                    }
-                } else {
-                    // (oldIndex < step) is equivalent to (old UI index == 0)
-                    if ((oldIndex < step) && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
-                        ringerMode = RINGER_MODE_SILENT;
-                        if (mVoiceCapable)
-                            adjustVolumeIndex = false;
-                    }
-                }
-            }
-            break;
-        case RINGER_MODE_VIBRATE:
-            if (!mHasVibrator) {
-                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" +
-                        "but no vibrator is present");
-                break;
-            }
-            if ((direction == AudioManager.ADJUST_LOWER)) {
-                if (mPrevVolDirection != AudioManager.ADJUST_LOWER) {
-                    ringerMode = RINGER_MODE_SILENT;
-                }
-            } else if (direction == AudioManager.ADJUST_RAISE) {
-                ringerMode = RINGER_MODE_NORMAL;
-            }
-            adjustVolumeIndex = false;
-            break;
-        case RINGER_MODE_SILENT:
-            if (direction == AudioManager.ADJUST_RAISE) {
-                if (mHasVibrator) {
-                    ringerMode = RINGER_MODE_VIBRATE;
-                } else {
-                    ringerMode = RINGER_MODE_NORMAL;
-                }
-            }
-            adjustVolumeIndex = false;
-            break;
-        default:
-            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: "+ringerMode);
-            break;
-        }
-
-        setRingerMode(ringerMode);
-
-        mPrevVolDirection = direction;
-
-        return adjustVolumeIndex;
-    }
-
-    public boolean isStreamAffectedByRingerMode(int streamType) {
-        return (mRingerModeAffectedStreams & (1 << streamType)) != 0;
-    }
-
-    private boolean isStreamMutedByRingerMode(int streamType) {
-        return (mRingerModeMutedStreams & (1 << streamType)) != 0;
-    }
-
-    public boolean isStreamAffectedByMute(int streamType) {
-        return (mMuteAffectedStreams & (1 << streamType)) != 0;
-    }
-
-    private void ensureValidDirection(int direction) {
-        if (direction < AudioManager.ADJUST_LOWER || direction > AudioManager.ADJUST_RAISE) {
-            throw new IllegalArgumentException("Bad direction " + direction);
-        }
-    }
-
-    private void ensureValidSteps(int steps) {
-        if (Math.abs(steps) > MAX_BATCH_VOLUME_ADJUST_STEPS) {
-            throw new IllegalArgumentException("Bad volume adjust steps " + steps);
-        }
-    }
-
-    private void ensureValidStreamType(int streamType) {
-        if (streamType < 0 || streamType >= mStreamStates.length) {
-            throw new IllegalArgumentException("Bad stream type " + streamType);
-        }
-    }
-
-    private boolean isInCommunication() {
-        boolean isOffhook = false;
-
-        if (mVoiceCapable) {
-            try {
-                ITelephony phone = ITelephony.Stub.asInterface(ServiceManager.checkService("phone"));
-                if (phone != null) isOffhook = phone.isOffhook();
-            } catch (RemoteException e) {
-                Log.w(TAG, "Couldn't connect to phone service", e);
-            }
-        }
-        return (isOffhook || getMode() == AudioManager.MODE_IN_COMMUNICATION);
-    }
-
-    private int getActiveStreamType(int suggestedStreamType) {
-        if (mVoiceCapable) {
-            if (isInCommunication()) {
-                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION)
-                        == AudioSystem.FORCE_BT_SCO) {
-                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO...");
-                    return AudioSystem.STREAM_BLUETOOTH_SCO;
-                } else {
-                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL...");
-                    return AudioSystem.STREAM_VOICE_CALL;
-                }
-            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
-                // Having the suggested stream be USE_DEFAULT_STREAM_TYPE is how remote control
-                // volume can have priority over STREAM_MUSIC
-                if (checkUpdateRemoteStateIfActive(AudioSystem.STREAM_MUSIC)) {
-                    if (DEBUG_VOL)
-                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_REMOTE_MUSIC");
-                    return STREAM_REMOTE_MUSIC;
-                } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC,
-                            DEFAULT_STREAM_TYPE_OVERRIDE_DELAY_MS)) {
-                    if (DEBUG_VOL)
-                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
-                    return AudioSystem.STREAM_MUSIC;
-                } else {
-                    if (mVolumeKeysControlRingStream) {
-                        if (DEBUG_VOL)
-                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_RING b/c default");
-                        return AudioSystem.STREAM_RING;
-                    } else {
-                        if (DEBUG_VOL)
-                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC b/c default setting");
-                        return AudioSystem.STREAM_MUSIC;
-                    }
-                }
-            } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0)) {
-                if (DEBUG_VOL)
-                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
-                return AudioSystem.STREAM_MUSIC;
-            } else {
-                if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Returning suggested type "
-                        + suggestedStreamType);
-                return suggestedStreamType;
-            }
-        } else {
-            if (isInCommunication()) {
-                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION)
-                        == AudioSystem.FORCE_BT_SCO) {
-                    if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO");
-                    return AudioSystem.STREAM_BLUETOOTH_SCO;
-                } else {
-                    if (DEBUG_VOL)  Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL");
-                    return AudioSystem.STREAM_VOICE_CALL;
-                }
-            } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_NOTIFICATION,
-                    DEFAULT_STREAM_TYPE_OVERRIDE_DELAY_MS) ||
-                    AudioSystem.isStreamActive(AudioSystem.STREAM_RING,
-                            DEFAULT_STREAM_TYPE_OVERRIDE_DELAY_MS)) {
-                if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Forcing STREAM_NOTIFICATION");
-                return AudioSystem.STREAM_NOTIFICATION;
-            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
-                if (checkUpdateRemoteStateIfActive(AudioSystem.STREAM_MUSIC)) {
-                    // Having the suggested stream be USE_DEFAULT_STREAM_TYPE is how remote control
-                    // volume can have priority over STREAM_MUSIC
-                    if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Forcing STREAM_REMOTE_MUSIC");
-                    return STREAM_REMOTE_MUSIC;
-                } else {
-                    if (DEBUG_VOL)
-                        Log.v(TAG, "getActiveStreamType: using STREAM_MUSIC as default");
-                    return AudioSystem.STREAM_MUSIC;
-                }
-            } else {
-                if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Returning suggested type "
-                        + suggestedStreamType);
-                return suggestedStreamType;
-            }
-        }
-    }
-
-    private void broadcastRingerMode(int ringerMode) {
-        // Send sticky broadcast
-        Intent broadcast = new Intent(AudioManager.RINGER_MODE_CHANGED_ACTION);
-        broadcast.putExtra(AudioManager.EXTRA_RINGER_MODE, ringerMode);
-        broadcast.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
-                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
-        sendStickyBroadcastToAll(broadcast);
-    }
-
-    private void broadcastVibrateSetting(int vibrateType) {
-        // Send broadcast
-        if (ActivityManagerNative.isSystemReady()) {
-            Intent broadcast = new Intent(AudioManager.VIBRATE_SETTING_CHANGED_ACTION);
-            broadcast.putExtra(AudioManager.EXTRA_VIBRATE_TYPE, vibrateType);
-            broadcast.putExtra(AudioManager.EXTRA_VIBRATE_SETTING, getVibrateSetting(vibrateType));
-            sendBroadcastToAll(broadcast);
-        }
-    }
-
-    // Message helper methods
-    /**
-     * Queue a message on the given handler's message queue, after acquiring the service wake lock.
-     * Note that the wake lock needs to be released after the message has been handled.
-     */
-    private void queueMsgUnderWakeLock(Handler handler, int msg,
-            int arg1, int arg2, Object obj, int delay) {
-        mMediaEventWakeLock.acquire();
-        sendMsg(handler, msg, SENDMSG_QUEUE, arg1, arg2, obj, delay);
-    }
-
-    private static void sendMsg(Handler handler, int msg,
-            int existingMsgPolicy, int arg1, int arg2, Object obj, int delay) {
-
-        if (existingMsgPolicy == SENDMSG_REPLACE) {
-            handler.removeMessages(msg);
-        } else if (existingMsgPolicy == SENDMSG_NOOP && handler.hasMessages(msg)) {
-            return;
-        }
-
-        handler.sendMessageDelayed(handler.obtainMessage(msg, arg1, arg2, obj), delay);
-    }
-
-    boolean checkAudioSettingsPermission(String method) {
-        if (mContext.checkCallingOrSelfPermission("android.permission.MODIFY_AUDIO_SETTINGS")
-                == PackageManager.PERMISSION_GRANTED) {
-            return true;
-        }
-        String msg = "Audio Settings Permission Denial: " + method + " from pid="
-                + Binder.getCallingPid()
-                + ", uid=" + Binder.getCallingUid();
-        Log.w(TAG, msg);
-        return false;
-    }
-
-    private int getDeviceForStream(int stream) {
-        int device = AudioSystem.getDevicesForStream(stream);
-        if ((device & (device - 1)) != 0) {
-            // Multiple device selection is either:
-            //  - speaker + one other device: give priority to speaker in this case.
-            //  - one A2DP device + another device: happens with duplicated output. In this case
-            // retain the device on the A2DP output as the other must not correspond to an active
-            // selection if not the speaker.
-            if ((device & AudioSystem.DEVICE_OUT_SPEAKER) != 0) {
-                device = AudioSystem.DEVICE_OUT_SPEAKER;
-            } else {
-                device &= AudioSystem.DEVICE_OUT_ALL_A2DP;
-            }
-        }
-        return device;
-    }
-
-    public void setWiredDeviceConnectionState(int device, int state, String name) {
-        synchronized (mConnectedDevices) {
-            int delay = checkSendBecomingNoisyIntent(device, state);
-            queueMsgUnderWakeLock(mAudioHandler,
-                    MSG_SET_WIRED_DEVICE_CONNECTION_STATE,
-                    device,
-                    state,
-                    name,
-                    delay);
-        }
-    }
-
-    public int setBluetoothA2dpDeviceConnectionState(BluetoothDevice device, int state) {
-        int delay;
-        if (!noDelayInATwoDP) {
-            synchronized (mConnectedDevices) {
-                delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
-                                                (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0);
-                queueMsgUnderWakeLock(mAudioHandler,
-                        MSG_SET_A2DP_CONNECTION_STATE,
-                        state,
-                        0,
-                        device,
-                        delay);
-            }
-        } else {
-            delay = 0;
-        }
-        return delay;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Inner classes
-    ///////////////////////////////////////////////////////////////////////////
-
-    public class VolumeStreamState {
-        private final int mStreamType;
-
-        private String mVolumeIndexSettingName;
-        private String mLastAudibleVolumeIndexSettingName;
-        private int mIndexMax;
-        private final ConcurrentHashMap<Integer, Integer> mIndex =
-                                            new ConcurrentHashMap<Integer, Integer>(8, 0.75f, 4);
-        private final ConcurrentHashMap<Integer, Integer> mLastAudibleIndex =
-                                            new ConcurrentHashMap<Integer, Integer>(8, 0.75f, 4);
-        private ArrayList<VolumeDeathHandler> mDeathHandlers; //handles mute/solo clients death
-
-        private VolumeStreamState(String settingName, int streamType) {
-
-            mVolumeIndexSettingName = settingName;
-            mLastAudibleVolumeIndexSettingName = settingName + System.APPEND_FOR_LAST_AUDIBLE;
-
-            mStreamType = streamType;
-            mIndexMax = MAX_STREAM_VOLUME[streamType];
-            AudioSystem.initStreamVolume(streamType, 0, mIndexMax);
-            mIndexMax *= 10;
-
-            // mDeathHandlers must be created before calling readSettings()
-            mDeathHandlers = new ArrayList<VolumeDeathHandler>();
-
-            readSettings();
-        }
-
-        public String getSettingNameForDevice(boolean lastAudible, int device) {
-            String name = lastAudible ?
-                            mLastAudibleVolumeIndexSettingName :
-                            mVolumeIndexSettingName;
-            String suffix = AudioSystem.getDeviceName(device);
-            if (suffix.isEmpty()) {
-                return name;
-            }
-            return name + "_" + suffix;
-        }
-
-        public synchronized void readSettings() {
-            int remainingDevices = AudioSystem.DEVICE_OUT_ALL;
-
-            // do not read system stream volume from settings: this stream is always aliased
-            // to another stream type and its volume is never persisted. Values in settings can
-            // only be stale values
-            // on first call to readSettings() at init time, muteCount() is always 0 so we will
-            // always create entries for default device
-            if ((mStreamType == AudioSystem.STREAM_SYSTEM) ||
-                    (mStreamType == AudioSystem.STREAM_SYSTEM_ENFORCED)) {
-                int index = 10 * AudioManager.DEFAULT_STREAM_VOLUME[mStreamType];
-                synchronized (mCameraSoundForced) {
-                    if (mCameraSoundForced) {
-                        index = mIndexMax;
-                    }
-                }
-                if (muteCount() == 0) {
-                    mIndex.put(AudioSystem.DEVICE_OUT_DEFAULT, index);
-                }
-                mLastAudibleIndex.put(AudioSystem.DEVICE_OUT_DEFAULT, index);
-                return;
-            }
-
-            for (int i = 0; remainingDevices != 0; i++) {
-                int device = (1 << i);
-                if ((device & remainingDevices) == 0) {
-                    continue;
-                }
-                remainingDevices &= ~device;
-
-                // ignore settings for fixed volume devices: volume should always be at max
-                if ((mStreamVolumeAlias[mStreamType] == AudioSystem.STREAM_MUSIC) &&
-                        ((device & mFixedVolumeDevices) != 0)) {
-                    if (muteCount() == 0) {
-                        mIndex.put(device, mIndexMax);
-                    }
-                    mLastAudibleIndex.put(device, mIndexMax);
-                    continue;
-                }
-                // retrieve current volume for device
-                String name = getSettingNameForDevice(false /* lastAudible */, device);
-                // if no volume stored for current stream and device, use default volume if default
-                // device, continue otherwise
-                int defaultIndex = (device == AudioSystem.DEVICE_OUT_DEFAULT) ?
-                                        AudioManager.DEFAULT_STREAM_VOLUME[mStreamType] : -1;
-                int index = Settings.System.getIntForUser(
-                        mContentResolver, name, defaultIndex, UserHandle.USER_CURRENT);
-                if (index == -1) {
-                    continue;
-                }
-
-                // retrieve last audible volume for device
-                name = getSettingNameForDevice(true  /* lastAudible */, device);
-                // use stored last audible index if present, otherwise use current index if not 0
-                // or default index
-                defaultIndex = (index > 0) ?
-                                    index : AudioManager.DEFAULT_STREAM_VOLUME[mStreamType];
-                int lastAudibleIndex = Settings.System.getIntForUser(
-                        mContentResolver, name, defaultIndex, UserHandle.USER_CURRENT);
-
-                // a last audible index of 0 should never be stored for ring and notification
-                // streams on phones (voice capable devices).
-                if ((lastAudibleIndex == 0) && mVoiceCapable &&
-                                (mStreamVolumeAlias[mStreamType] == AudioSystem.STREAM_RING)) {
-                    lastAudibleIndex = AudioManager.DEFAULT_STREAM_VOLUME[mStreamType];
-                    // Correct the data base
-                    sendMsg(mAudioHandler,
-                            MSG_PERSIST_VOLUME,
-                            SENDMSG_QUEUE,
-                            PERSIST_LAST_AUDIBLE,
-                            device,
-                            this,
-                            PERSIST_DELAY);
-                }
-                mLastAudibleIndex.put(device, getValidIndex(10 * lastAudibleIndex));
-                // the initial index should never be 0 for ring and notification streams on phones
-                // (voice capable devices) if not in silent or vibrate mode.
-                if ((index == 0) && (mRingerMode == AudioManager.RINGER_MODE_NORMAL) &&
-                        mVoiceCapable &&
-                        (mStreamVolumeAlias[mStreamType] == AudioSystem.STREAM_RING)) {
-                    index = lastAudibleIndex;
-                    // Correct the data base
-                    sendMsg(mAudioHandler,
-                            MSG_PERSIST_VOLUME,
-                            SENDMSG_QUEUE,
-                            PERSIST_CURRENT,
-                            device,
-                            this,
-                            PERSIST_DELAY);
-                }
-                if (muteCount() == 0) {
-                    mIndex.put(device, getValidIndex(10 * index));
-                }
-            }
-        }
-
-        public void applyDeviceVolume(int device) {
-            AudioSystem.setStreamVolumeIndex(mStreamType,
-                                             (getIndex(device, false  /* lastAudible */) + 5)/10,
-                                             device);
-        }
-
-        public synchronized void applyAllVolumes() {
-            // apply default volume first: by convention this will reset all
-            // devices volumes in audio policy manager to the supplied value
-            AudioSystem.setStreamVolumeIndex(mStreamType,
-                    (getIndex(AudioSystem.DEVICE_OUT_DEFAULT, false /* lastAudible */) + 5)/10,
-                    AudioSystem.DEVICE_OUT_DEFAULT);
-            // then apply device specific volumes
-            Set set = mIndex.entrySet();
-            Iterator i = set.iterator();
-            while (i.hasNext()) {
-                Map.Entry entry = (Map.Entry)i.next();
-                int device = ((Integer)entry.getKey()).intValue();
-                if (device != AudioSystem.DEVICE_OUT_DEFAULT) {
-                    AudioSystem.setStreamVolumeIndex(mStreamType,
-                                                     ((Integer)entry.getValue() + 5)/10,
-                                                     device);
-                }
-            }
-        }
-
-        public boolean adjustIndex(int deltaIndex, int device) {
-            return setIndex(getIndex(device,
-                                     false  /* lastAudible */) + deltaIndex,
-                            device,
-                            true  /* lastAudible */);
-        }
-
-        public synchronized boolean setIndex(int index, int device, boolean lastAudible) {
-            int oldIndex = getIndex(device, false  /* lastAudible */);
-            index = getValidIndex(index);
-            synchronized (mCameraSoundForced) {
-                if ((mStreamType == AudioSystem.STREAM_SYSTEM_ENFORCED) && mCameraSoundForced) {
-                    index = mIndexMax;
-                }
-            }
-            mIndex.put(device, getValidIndex(index));
-
-            if (oldIndex != index) {
-                if (lastAudible) {
-                    mLastAudibleIndex.put(device, index);
-                }
-                // Apply change to all streams using this one as alias
-                // if changing volume of current device, also change volume of current
-                // device on aliased stream
-                boolean currentDevice = (device == getDeviceForStream(mStreamType));
-                int numStreamTypes = AudioSystem.getNumStreamTypes();
-                for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
-                    if (streamType != mStreamType &&
-                            mStreamVolumeAlias[streamType] == mStreamType) {
-                        int scaledIndex = rescaleIndex(index, mStreamType, streamType);
-                        mStreamStates[streamType].setIndex(scaledIndex,
-                                                           device,
-                                                           lastAudible);
-                        if (currentDevice) {
-                            mStreamStates[streamType].setIndex(scaledIndex,
-                                                               getDeviceForStream(streamType),
-                                                               lastAudible);
-                        }
-                    }
-                }
-                return true;
-            } else {
-                return false;
-            }
-        }
-
-        public synchronized int getIndex(int device, boolean lastAudible) {
-            ConcurrentHashMap <Integer, Integer> indexes;
-            if (lastAudible) {
-                indexes = mLastAudibleIndex;
-            } else {
-                indexes = mIndex;
-            }
-            Integer index = indexes.get(device);
-            if (index == null) {
-                // there is always an entry for AudioSystem.DEVICE_OUT_DEFAULT
-                index = indexes.get(AudioSystem.DEVICE_OUT_DEFAULT);
-            }
-            return index.intValue();
-        }
-
-        public synchronized void setLastAudibleIndex(int index, int device) {
-            // Apply change to all streams using this one as alias
-            // if changing volume of current device, also change volume of current
-            // device on aliased stream
-            boolean currentDevice = (device == getDeviceForStream(mStreamType));
-            int numStreamTypes = AudioSystem.getNumStreamTypes();
-            for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
-                if (streamType != mStreamType &&
-                        mStreamVolumeAlias[streamType] == mStreamType) {
-                    int scaledIndex = rescaleIndex(index, mStreamType, streamType);
-                    mStreamStates[streamType].setLastAudibleIndex(scaledIndex, device);
-                    if (currentDevice) {
-                        mStreamStates[streamType].setLastAudibleIndex(scaledIndex,
-                                                                   getDeviceForStream(streamType));
-                    }
-                }
-            }
-            mLastAudibleIndex.put(device, getValidIndex(index));
-        }
-
-        public synchronized void adjustLastAudibleIndex(int deltaIndex, int device) {
-            setLastAudibleIndex(getIndex(device,
-                                         true  /* lastAudible */) + deltaIndex,
-                                device);
-        }
-
-        public int getMaxIndex() {
-            return mIndexMax;
-        }
-
-        // only called by setAllIndexes() which is already synchronized
-        public ConcurrentHashMap <Integer, Integer> getAllIndexes(boolean lastAudible) {
-            if (lastAudible) {
-                return mLastAudibleIndex;
-            } else {
-                return mIndex;
-            }
-        }
-
-        public synchronized void setAllIndexes(VolumeStreamState srcStream, boolean lastAudible) {
-            ConcurrentHashMap <Integer, Integer> indexes = srcStream.getAllIndexes(lastAudible);
-            Set set = indexes.entrySet();
-            Iterator i = set.iterator();
-            while (i.hasNext()) {
-                Map.Entry entry = (Map.Entry)i.next();
-                int device = ((Integer)entry.getKey()).intValue();
-                int index = ((Integer)entry.getValue()).intValue();
-                index = rescaleIndex(index, srcStream.getStreamType(), mStreamType);
-
-                if (lastAudible) {
-                    setLastAudibleIndex(index, device);
-                } else {
-                    setIndex(index, device, false /* lastAudible */);
-                }
-            }
-        }
-
-        public synchronized void setAllIndexesToMax() {
-            Set set = mIndex.entrySet();
-            Iterator i = set.iterator();
-            while (i.hasNext()) {
-                Map.Entry entry = (Map.Entry)i.next();
-                entry.setValue(mIndexMax);
-            }
-            set = mLastAudibleIndex.entrySet();
-            i = set.iterator();
-            while (i.hasNext()) {
-                Map.Entry entry = (Map.Entry)i.next();
-                entry.setValue(mIndexMax);
-            }
-        }
-
-        public synchronized void mute(IBinder cb, boolean state) {
-            VolumeDeathHandler handler = getDeathHandler(cb, state);
-            if (handler == null) {
-                Log.e(TAG, "Could not get client death handler for stream: "+mStreamType);
-                return;
-            }
-            handler.mute(state);
-        }
-
-        public int getStreamType() {
-            return mStreamType;
-        }
-
-        private int getValidIndex(int index) {
-            if (index < 0) {
-                return 0;
-            } else if (index > mIndexMax) {
-                return mIndexMax;
-            }
-
-            return index;
-        }
-
-        private class VolumeDeathHandler implements IBinder.DeathRecipient {
-            private IBinder mICallback; // To be notified of client's death
-            private int mMuteCount; // Number of active mutes for this client
-
-            VolumeDeathHandler(IBinder cb) {
-                mICallback = cb;
-            }
-
-            // must be called while synchronized on parent VolumeStreamState
-            public void mute(boolean state) {
-                if (state) {
-                    if (mMuteCount == 0) {
-                        // Register for client death notification
-                        try {
-                            // mICallback can be 0 if muted by AudioService
-                            if (mICallback != null) {
-                                mICallback.linkToDeath(this, 0);
-                            }
-                            mDeathHandlers.add(this);
-                            // If the stream is not yet muted by any client, set level to 0
-                            if (muteCount() == 0) {
-                                Set set = mIndex.entrySet();
-                                Iterator i = set.iterator();
-                                while (i.hasNext()) {
-                                    Map.Entry entry = (Map.Entry)i.next();
-                                    int device = ((Integer)entry.getKey()).intValue();
-                                    setIndex(0, device, false /* lastAudible */);
-                                }
-                                sendMsg(mAudioHandler,
-                                        MSG_SET_ALL_VOLUMES,
-                                        SENDMSG_QUEUE,
-                                        0,
-                                        0,
-                                        VolumeStreamState.this, 0);
-                            }
-                        } catch (RemoteException e) {
-                            // Client has died!
-                            binderDied();
-                            return;
-                        }
-                    } else {
-                        Log.w(TAG, "stream: "+mStreamType+" was already muted by this client");
-                    }
-                    mMuteCount++;
-                } else {
-                    if (mMuteCount == 0) {
-                        Log.e(TAG, "unexpected unmute for stream: "+mStreamType);
-                    } else {
-                        mMuteCount--;
-                        if (mMuteCount == 0) {
-                            // Unregister from client death notification
-                            mDeathHandlers.remove(this);
-                            // mICallback can be 0 if muted by AudioService
-                            if (mICallback != null) {
-                                mICallback.unlinkToDeath(this, 0);
-                            }
-                            if (muteCount() == 0) {
-                                // If the stream is not muted any more, restore its volume if
-                                // ringer mode allows it
-                                if (!isStreamAffectedByRingerMode(mStreamType) ||
-                                        mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
-                                    Set set = mIndex.entrySet();
-                                    Iterator i = set.iterator();
-                                    while (i.hasNext()) {
-                                        Map.Entry entry = (Map.Entry)i.next();
-                                        int device = ((Integer)entry.getKey()).intValue();
-                                        setIndex(getIndex(device,
-                                                          true  /* lastAudible */),
-                                                 device,
-                                                 false  /* lastAudible */);
-                                    }
-                                    sendMsg(mAudioHandler,
-                                            MSG_SET_ALL_VOLUMES,
-                                            SENDMSG_QUEUE,
-                                            0,
-                                            0,
-                                            VolumeStreamState.this, 0);
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            public void binderDied() {
-                Log.w(TAG, "Volume service client died for stream: "+mStreamType);
-                if (mMuteCount != 0) {
-                    // Reset all active mute requests from this client.
-                    mMuteCount = 1;
-                    mute(false);
-                }
-            }
-        }
-
-        private synchronized int muteCount() {
-            int count = 0;
-            int size = mDeathHandlers.size();
-            for (int i = 0; i < size; i++) {
-                count += mDeathHandlers.get(i).mMuteCount;
-            }
-            return count;
-        }
-
-        // only called by mute() which is already synchronized
-        private VolumeDeathHandler getDeathHandler(IBinder cb, boolean state) {
-            VolumeDeathHandler handler;
-            int size = mDeathHandlers.size();
-            for (int i = 0; i < size; i++) {
-                handler = mDeathHandlers.get(i);
-                if (cb == handler.mICallback) {
-                    return handler;
-                }
-            }
-            // If this is the first mute request for this client, create a new
-            // client death handler. Otherwise, it is an out of sequence unmute request.
-            if (state) {
-                handler = new VolumeDeathHandler(cb);
-            } else {
-                Log.w(TAG, "stream was not muted by this client");
-                handler = null;
-            }
-            return handler;
-        }
-
-        private void dump(PrintWriter pw) {
-            pw.print("   Mute count: ");
-            pw.println(muteCount());
-            pw.print("   Current: ");
-            Set set = mIndex.entrySet();
-            Iterator i = set.iterator();
-            while (i.hasNext()) {
-                Map.Entry entry = (Map.Entry)i.next();
-                pw.print(Integer.toHexString(((Integer)entry.getKey()).intValue())
-                             + ": " + ((((Integer)entry.getValue()).intValue() + 5) / 10)+", ");
-            }
-            pw.print("\n   Last audible: ");
-            set = mLastAudibleIndex.entrySet();
-            i = set.iterator();
-            while (i.hasNext()) {
-                Map.Entry entry = (Map.Entry)i.next();
-                pw.print(Integer.toHexString(((Integer)entry.getKey()).intValue())
-                             + ": " + ((((Integer)entry.getValue()).intValue() + 5) / 10)+", ");
-            }
-        }
-    }
-
-    /** Thread that handles native AudioSystem control. */
-    private class AudioSystemThread extends Thread {
-        AudioSystemThread() {
-            super("AudioService");
-        }
-
-        @Override
-        public void run() {
-            // Set this thread up so the handler will work on it
-            Looper.prepare();
-
-            synchronized(AudioService.this) {
-                mAudioHandler = new AudioHandler();
-
-                // Notify that the handler has been created
-                AudioService.this.notify();
-            }
-
-            // Listen for volume change requests that are set by VolumePanel
-            Looper.loop();
-        }
-    }
-
-    /** Handles internal volume messages in separate volume thread. */
-    private class AudioHandler extends Handler {
-
-        private void setDeviceVolume(VolumeStreamState streamState, int device) {
-
-            // Apply volume
-            streamState.applyDeviceVolume(device);
-
-            // Apply change to all streams using this one as alias
-            int numStreamTypes = AudioSystem.getNumStreamTypes();
-            for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
-                if (streamType != streamState.mStreamType &&
-                        mStreamVolumeAlias[streamType] == streamState.mStreamType) {
-                    mStreamStates[streamType].applyDeviceVolume(getDeviceForStream(streamType));
-                }
-            }
-
-            // Post a persist volume msg
-            sendMsg(mAudioHandler,
-                    MSG_PERSIST_VOLUME,
-                    SENDMSG_QUEUE,
-                    PERSIST_CURRENT|PERSIST_LAST_AUDIBLE,
-                    device,
-                    streamState,
-                    PERSIST_DELAY);
-
-        }
-
-        private void setAllVolumes(VolumeStreamState streamState) {
-
-            // Apply volume
-            streamState.applyAllVolumes();
-
-            // Apply change to all streams using this one as alias
-            int numStreamTypes = AudioSystem.getNumStreamTypes();
-            for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
-                if (streamType != streamState.mStreamType &&
-                        mStreamVolumeAlias[streamType] == streamState.mStreamType) {
-                    mStreamStates[streamType].applyAllVolumes();
-                }
-            }
-        }
-
-        private void persistVolume(VolumeStreamState streamState,
-                                   int persistType,
-                                   int device) {
-            if ((persistType & PERSIST_CURRENT) != 0) {
-                System.putIntForUser(mContentResolver,
-                          streamState.getSettingNameForDevice(false /* lastAudible */, device),
-                          (streamState.getIndex(device, false /* lastAudible */) + 5)/ 10,
-                          UserHandle.USER_CURRENT);
-            }
-            if ((persistType & PERSIST_LAST_AUDIBLE) != 0) {
-                System.putIntForUser(mContentResolver,
-                        streamState.getSettingNameForDevice(true /* lastAudible */, device),
-                        (streamState.getIndex(device, true  /* lastAudible */) + 5) / 10,
-                        UserHandle.USER_CURRENT);
-            }
-        }
-
-        private void persistRingerMode(int ringerMode) {
-            Settings.Global.putInt(mContentResolver, Settings.Global.MODE_RINGER, ringerMode);
-        }
-
-        private void playSoundEffect(int effectType, int volume) {
-            synchronized (mSoundEffectsLock) {
-                if (mSoundPool == null) {
-                    return;
-                }
-                float volFloat;
-                // use default if volume is not specified by caller
-                if (volume < 0) {
-                    volFloat = (float)Math.pow(10, (float)sSoundEffectVolumeDb/20);
-                } else {
-                    volFloat = (float) volume / 1000.0f;
-                }
-
-                if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
-                    mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1], volFloat, volFloat, 0, 0, 1.0f);
-                } else {
-                    MediaPlayer mediaPlayer = new MediaPlayer();
-                    try {
-                        String filePath = Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effectType][0]];
-                        mediaPlayer.setDataSource(filePath);
-                        mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
-                        mediaPlayer.prepare();
-                        mediaPlayer.setVolume(volFloat, volFloat);
-                        mediaPlayer.setOnCompletionListener(new OnCompletionListener() {
-                            public void onCompletion(MediaPlayer mp) {
-                                cleanupPlayer(mp);
-                            }
-                        });
-                        mediaPlayer.setOnErrorListener(new OnErrorListener() {
-                            public boolean onError(MediaPlayer mp, int what, int extra) {
-                                cleanupPlayer(mp);
-                                return true;
-                            }
-                        });
-                        mediaPlayer.start();
-                    } catch (IOException ex) {
-                        Log.w(TAG, "MediaPlayer IOException: "+ex);
-                    } catch (IllegalArgumentException ex) {
-                        Log.w(TAG, "MediaPlayer IllegalArgumentException: "+ex);
-                    } catch (IllegalStateException ex) {
-                        Log.w(TAG, "MediaPlayer IllegalStateException: "+ex);
-                    }
-                }
-            }
-        }
-
-        private void onHandlePersistMediaButtonReceiver(ComponentName receiver) {
-            Settings.System.putStringForUser(mContentResolver,
-                                             Settings.System.MEDIA_BUTTON_RECEIVER,
-                                             receiver == null ? "" : receiver.flattenToString(),
-                                             UserHandle.USER_CURRENT);
-        }
-
-        private void cleanupPlayer(MediaPlayer mp) {
-            if (mp != null) {
-                try {
-                    mp.stop();
-                    mp.release();
-                } catch (IllegalStateException ex) {
-                    Log.w(TAG, "MediaPlayer IllegalStateException: "+ex);
-                }
-            }
-        }
-
-        private void setForceUse(int usage, int config) {
-            AudioSystem.setForceUse(usage, config);
-        }
-
-        private void onPersistSafeVolumeState(int state) {
-            Settings.Global.putInt(mContentResolver,
-                    Settings.Global.AUDIO_SAFE_VOLUME_STATE,
-                    state);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-
-            switch (msg.what) {
-
-                case MSG_SET_DEVICE_VOLUME:
-                    setDeviceVolume((VolumeStreamState) msg.obj, msg.arg1);
-                    break;
-
-                case MSG_SET_ALL_VOLUMES:
-                    setAllVolumes((VolumeStreamState) msg.obj);
-                    break;
-
-                case MSG_PERSIST_VOLUME:
-                    persistVolume((VolumeStreamState) msg.obj, msg.arg1, msg.arg2);
-                    break;
-
-                case MSG_PERSIST_MASTER_VOLUME:
-                    Settings.System.putFloatForUser(mContentResolver,
-                                                    Settings.System.VOLUME_MASTER,
-                                                    (float)msg.arg1 / (float)1000.0,
-                                                    UserHandle.USER_CURRENT);
-                    break;
-
-                case MSG_PERSIST_MASTER_VOLUME_MUTE:
-                    Settings.System.putIntForUser(mContentResolver,
-                                                 Settings.System.VOLUME_MASTER_MUTE,
-                                                 msg.arg1,
-                                                 UserHandle.USER_CURRENT);
-                    break;
-
-                case MSG_PERSIST_RINGER_MODE:
-                    // note that the value persisted is the current ringer mode, not the
-                    // value of ringer mode as of the time the request was made to persist
-                    persistRingerMode(getRingerMode());
-                    break;
-
-                case MSG_MEDIA_SERVER_DIED:
-                    if (!mMediaServerOk) {
-                        Log.e(TAG, "Media server died.");
-                        // Force creation of new IAudioFlinger interface so that we are notified
-                        // when new media_server process is back to life.
-                        AudioSystem.setErrorCallback(mAudioSystemCallback);
-                        sendMsg(mAudioHandler, MSG_MEDIA_SERVER_DIED, SENDMSG_NOOP, 0, 0,
-                                null, 500);
-                    }
-                    break;
-
-                case MSG_MEDIA_SERVER_STARTED:
-                    Log.e(TAG, "Media server started.");
-                    // indicate to audio HAL that we start the reconfiguration phase after a media
-                    // server crash
-                    // Note that MSG_MEDIA_SERVER_STARTED message is only received when the media server
-                    // process restarts after a crash, not the first time it is started.
-                    AudioSystem.setParameters("restarting=true");
-
-                    // Restore device connection states
-                    synchronized (mConnectedDevices) {
-                        Set set = mConnectedDevices.entrySet();
-                        Iterator i = set.iterator();
-                        while (i.hasNext()) {
-                            Map.Entry device = (Map.Entry)i.next();
-                            AudioSystem.setDeviceConnectionState(
-                                                            ((Integer)device.getKey()).intValue(),
-                                                            AudioSystem.DEVICE_STATE_AVAILABLE,
-                                                            (String)device.getValue());
-                        }
-                    }
-                    // Restore call state
-                    AudioSystem.setPhoneState(mMode);
-
-                    // Restore forced usage for communcations and record
-                    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION, mForcedUseForComm);
-                    AudioSystem.setForceUse(AudioSystem.FOR_RECORD, mForcedUseForComm);
-                    AudioSystem.setForceUse(AudioSystem.FOR_SYSTEM, mCameraSoundForced ?
-                                    AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE);
-
-                    // Restore stream volumes
-                    int numStreamTypes = AudioSystem.getNumStreamTypes();
-                    for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
-                        VolumeStreamState streamState = mStreamStates[streamType];
-                        AudioSystem.initStreamVolume(streamType, 0, (streamState.mIndexMax + 5) / 10);
-
-                        streamState.applyAllVolumes();
-                    }
-
-                    // Restore ringer mode
-                    setRingerModeInt(getRingerMode(), false);
-
-                    // Restore master volume
-                    restoreMasterVolume();
-
-                    // Reset device orientation (if monitored for this device)
-                    if (mMonitorOrientation) {
-                        setOrientationForAudioSystem();
-                    }
-
-                    synchronized (mBluetoothA2dpEnabledLock) {
-                        AudioSystem.setForceUse(AudioSystem.FOR_MEDIA,
-                                mBluetoothA2dpEnabled ?
-                                        AudioSystem.FORCE_NONE : AudioSystem.FORCE_NO_BT_A2DP);
-                    }
-
-                    synchronized (mSettingsLock) {
-                        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,
-                                mDockAudioMediaEnabled ?
-                                        AudioSystem.FORCE_ANALOG_DOCK : AudioSystem.FORCE_NONE);
-                    }
-
-                    // indicate the end of reconfiguration phase to audio HAL
-                    AudioSystem.setParameters("restarting=false");
-                    break;
-
-                case MSG_LOAD_SOUND_EFFECTS:
-                    loadSoundEffects();
-                    break;
-
-                case MSG_PLAY_SOUND_EFFECT:
-                    playSoundEffect(msg.arg1, msg.arg2);
-                    break;
-
-                case MSG_BTA2DP_DOCK_TIMEOUT:
-                    // msg.obj  == address of BTA2DP device
-                    synchronized (mConnectedDevices) {
-                        makeA2dpDeviceUnavailableNow( (String) msg.obj );
-                    }
-                    break;
-
-                case MSG_SET_FORCE_USE:
-                case MSG_SET_FORCE_BT_A2DP_USE:
-                    setForceUse(msg.arg1, msg.arg2);
-                    break;
-
-                case MSG_PERSIST_MEDIABUTTONRECEIVER:
-                    onHandlePersistMediaButtonReceiver( (ComponentName) msg.obj );
-                    break;
-
-                case MSG_RCDISPLAY_CLEAR:
-                    onRcDisplayClear();
-                    break;
-
-                case MSG_RCDISPLAY_UPDATE:
-                    // msg.obj is guaranteed to be non null
-                    onRcDisplayUpdate( (RemoteControlStackEntry) msg.obj, msg.arg1);
-                    break;
-
-                case MSG_BT_HEADSET_CNCT_FAILED:
-                    resetBluetoothSco();
-                    break;
-
-                case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
-                    onSetWiredDeviceConnectionState(msg.arg1, msg.arg2, (String)msg.obj);
-                    mMediaEventWakeLock.release();
-                    break;
-
-                case MSG_SET_A2DP_CONNECTION_STATE:
-                    onSetA2dpConnectionState((BluetoothDevice)msg.obj, msg.arg1);
-                    mMediaEventWakeLock.release();
-                    break;
-
-                case MSG_REPORT_NEW_ROUTES: {
-                    int N = mRoutesObservers.beginBroadcast();
-                    if (N > 0) {
-                        AudioRoutesInfo routes;
-                        synchronized (mCurAudioRoutes) {
-                            routes = new AudioRoutesInfo(mCurAudioRoutes);
-                        }
-                        while (N > 0) {
-                            N--;
-                            IAudioRoutesObserver obs = mRoutesObservers.getBroadcastItem(N);
-                            try {
-                                obs.dispatchAudioRoutesChanged(routes);
-                            } catch (RemoteException e) {
-                            }
-                        }
-                    }
-                    mRoutesObservers.finishBroadcast();
-                    break;
-                }
-
-                case MSG_REEVALUATE_REMOTE:
-                    onReevaluateRemote();
-                    break;
-
-                case MSG_RCC_NEW_PLAYBACK_INFO:
-                    onNewPlaybackInfoForRcc(msg.arg1 /* rccId */, msg.arg2 /* key */,
-                            ((Integer)msg.obj).intValue() /* value */);
-                    break;
-                case MSG_RCC_NEW_VOLUME_OBS:
-                    onRegisterVolumeObserverForRcc(msg.arg1 /* rccId */,
-                            (IRemoteVolumeObserver)msg.obj /* rvo */);
-                    break;
-
-                case MSG_SET_RSX_CONNECTION_STATE:
-                    onSetRsxConnectionState(msg.arg1/*available*/, msg.arg2/*address*/);
-                    break;
-
-                case MSG_CHECK_MUSIC_ACTIVE:
-                    onCheckMusicActive();
-                    break;
-
-                case MSG_BROADCAST_AUDIO_BECOMING_NOISY:
-                    onSendBecomingNoisyIntent();
-                    break;
-
-                case MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED:
-                case MSG_CONFIGURE_SAFE_MEDIA_VOLUME:
-                    onConfigureSafeVolume((msg.what == MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED));
-                    break;
-                case MSG_PERSIST_SAFE_VOLUME_STATE:
-                    onPersistSafeVolumeState(msg.arg1);
-                    break;
-            }
-        }
-    }
-
-    private class SettingsObserver extends ContentObserver {
-
-        SettingsObserver() {
-            super(new Handler());
-            mContentResolver.registerContentObserver(Settings.System.getUriFor(
-                Settings.System.MODE_RINGER_STREAMS_AFFECTED), false, this);
-            mContentResolver.registerContentObserver(Settings.Global.getUriFor(
-                Settings.Global.DOCK_AUDIO_MEDIA_ENABLED), false, this);
-            mContentResolver.registerContentObserver(Settings.System.getUriFor(
-                Settings.System.VOLUME_LINK_NOTIFICATION), false, this);
-            mContentResolver.registerContentObserver(Settings.System.getUriFor(
-                Settings.System.SAFE_HEADSET_VOLUME), false, this);
-            mContentResolver.registerContentObserver(Settings.System.getUriFor(
-                Settings.System.VOLUME_KEYS_CONTROL_RING_STREAM), false, this);
-        }
-
-        @Override
-        public void onChange(boolean selfChange, Uri uri) {
-            super.onChange(selfChange, uri);
-            // FIXME This synchronized is not necessary if mSettingsLock only protects mRingerMode.
-            //       However there appear to be some missing locks around mRingerModeMutedStreams
-            //       and mRingerModeAffectedStreams, so will leave this synchronized for now.
-            //       mRingerModeMutedStreams and mMuteAffectedStreams are safe (only accessed once).
-            synchronized (mSettingsLock) {
-                if (uri.equals(Settings.System.getUriFor(Settings.System.MODE_RINGER_STREAMS_AFFECTED))) {
-                    int ringerModeAffectedStreams = Settings.System.getIntForUser(mContentResolver,
-                           Settings.System.MODE_RINGER_STREAMS_AFFECTED,
-                           ((1 << AudioSystem.STREAM_RING)|(1 << AudioSystem.STREAM_NOTIFICATION)|
-                           (1 << AudioSystem.STREAM_SYSTEM)|(1 << AudioSystem.STREAM_SYSTEM_ENFORCED)),
-                           UserHandle.USER_CURRENT);
-                    if (mVoiceCapable) {
-                        ringerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_MUSIC);
-                    } else {
-                        ringerModeAffectedStreams |= (1 << AudioSystem.STREAM_MUSIC);
-                    }
-                    synchronized (mCameraSoundForced) {
-                        if (mCameraSoundForced) {
-                            ringerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
-                        } else {
-                            ringerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
-                        }
-                    }
-                    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
-                        /*
-                         * Ensure all stream types that should be affected by ringer mode
-                         * are in the proper state.
-                         */
-                        mRingerModeAffectedStreams = ringerModeAffectedStreams;
-                        setRingerModeInt(getRingerMode(), false);
-                    }
-
-                } else if (uri.equals(Settings.Global.getUriFor(Settings.Global.DOCK_AUDIO_MEDIA_ENABLED))) {
-                    readDockAudioSettings(mContentResolver);
-
-                } else if (uri.equals(Settings.System.getUriFor(Settings.System.VOLUME_LINK_NOTIFICATION))) {
-                    mLinkNotificationWithVolume = Settings.System.getInt(mContentResolver,
-                            Settings.System.VOLUME_LINK_NOTIFICATION, 1) == 1;
-                    if (mLinkNotificationWithVolume) {
-                        mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_RING;
-                    } else {
-                        mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_NOTIFICATION;
-                    }
-
-                } else if (uri.equals(Settings.System.getUriFor(Settings.System.SAFE_HEADSET_VOLUME))) {
-                    mSafeVolumeEnabled = safeVolumeEnabled(mContentResolver);
-                } else if (uri.equals(Settings.System.getUriFor(Settings.System.VOLUME_KEYS_CONTROL_RING_STREAM))) {
-                    mVolumeKeysControlRingStream = Settings.System.getIntForUser(mContentResolver,
-                            Settings.System.VOLUME_KEYS_CONTROL_RING_STREAM, 1, UserHandle.USER_CURRENT) == 1;
-                }
-            }
-        }
-    }
-
-    // must be called synchronized on mConnectedDevices
-    private void makeA2dpDeviceAvailable(String address) {
-        // enable A2DP before notifying A2DP connection to avoid unecessary processing in
-        // audio policy manager
-        setBluetoothA2dpOnInt(true);
-        AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
-                AudioSystem.DEVICE_STATE_AVAILABLE,
-                address);
-        // Reset A2DP suspend state each time a new sink is connected
-        AudioSystem.setParameters("A2dpSuspended=false");
-        mConnectedDevices.put( new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),
-                address);
-    }
-
-    private void onSendBecomingNoisyIntent() {
-        sendBroadcastToAll(new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY));
-    }
-
-    // must be called synchronized on mConnectedDevices
-    private void makeA2dpDeviceUnavailableNow(String address) {
-        if (noDelayInATwoDP) {
-            onSendBecomingNoisyIntent();
-        }
-        AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
-                AudioSystem.DEVICE_STATE_UNAVAILABLE,
-                address);
-        mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
-    }
-
-    // must be called synchronized on mConnectedDevices
-    private void makeA2dpDeviceUnavailableLater(String address) {
-        // prevent any activity on the A2DP audio output to avoid unwanted
-        // reconnection of the sink.
-        AudioSystem.setParameters("A2dpSuspended=true");
-        // the device will be made unavailable later, so consider it disconnected right away
-        mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
-        // send the delayed message to make the device unavailable later
-        Message msg = mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT, address);
-        mAudioHandler.sendMessageDelayed(msg, BTA2DP_DOCK_TIMEOUT_MILLIS);
-
-    }
-
-    // must be called synchronized on mConnectedDevices
-    private void cancelA2dpDeviceTimeout() {
-        mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
-    }
-
-    // must be called synchronized on mConnectedDevices
-    private boolean hasScheduledA2dpDockTimeout() {
-        return mAudioHandler.hasMessages(MSG_BTA2DP_DOCK_TIMEOUT);
-    }
-
-    private void onSetA2dpConnectionState(BluetoothDevice btDevice, int state)
-    {
-        if (btDevice == null) {
-            return;
-        }
-        String address = btDevice.getAddress();
-        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
-            address = "";
-        }
-        synchronized (mConnectedDevices) {
-            boolean isConnected =
-                (mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) &&
-                 mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP).equals(address));
-
-            if (isConnected && state != BluetoothProfile.STATE_CONNECTED) {
-                if (btDevice.isBluetoothDock()) {
-                    if (state == BluetoothProfile.STATE_DISCONNECTED) {
-                        // introduction of a delay for transient disconnections of docks when
-                        // power is rapidly turned off/on, this message will be canceled if
-                        // we reconnect the dock under a preset delay
-                        makeA2dpDeviceUnavailableLater(address);
-                        // the next time isConnected is evaluated, it will be false for the dock
-                    }
-                } else {
-                    makeA2dpDeviceUnavailableNow(address);
-                }
-                synchronized (mCurAudioRoutes) {
-                    if (mCurAudioRoutes.mBluetoothName != null) {
-                        mCurAudioRoutes.mBluetoothName = null;
-                        sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES,
-                                SENDMSG_NOOP, 0, 0, null, 0);
-                    }
-                }
-            } else if (!isConnected && state == BluetoothProfile.STATE_CONNECTED) {
-                if (btDevice.isBluetoothDock()) {
-                    // this could be a reconnection after a transient disconnection
-                    cancelA2dpDeviceTimeout();
-                    mDockAddress = address;
-                } else {
-                    // this could be a connection of another A2DP device before the timeout of
-                    // a dock: cancel the dock timeout, and make the dock unavailable now
-                    if(hasScheduledA2dpDockTimeout()) {
-                        cancelA2dpDeviceTimeout();
-                        makeA2dpDeviceUnavailableNow(mDockAddress);
-                    }
-                }
-                makeA2dpDeviceAvailable(address);
-                synchronized (mCurAudioRoutes) {
-                    String name = btDevice.getAliasName();
-                    if (!TextUtils.equals(mCurAudioRoutes.mBluetoothName, name)) {
-                        mCurAudioRoutes.mBluetoothName = name;
-                        sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES,
-                                SENDMSG_NOOP, 0, 0, null, 0);
-                    }
-                }
-            }
-        }
-    }
-
-    private boolean handleDeviceConnection(boolean connected, int device, String params) {
-        synchronized (mConnectedDevices) {
-            boolean isConnected = (mConnectedDevices.containsKey(device) &&
-                    (params.isEmpty() || mConnectedDevices.get(device).equals(params)));
-
-            if (isConnected && !connected) {
-                AudioSystem.setDeviceConnectionState(device,
-                                              AudioSystem.DEVICE_STATE_UNAVAILABLE,
-                                              mConnectedDevices.get(device));
-                 mConnectedDevices.remove(device);
-                 return true;
-            } else if (!isConnected && connected) {
-                 AudioSystem.setDeviceConnectionState(device,
-                                                      AudioSystem.DEVICE_STATE_AVAILABLE,
-                                                      params);
-                 mConnectedDevices.put(new Integer(device), params);
-                 return true;
-            }
-        }
-        return false;
-    }
-
-    // Devices which removal triggers intent ACTION_AUDIO_BECOMING_NOISY. The intent is only
-    // sent if none of these devices is connected.
-    int mBecomingNoisyIntentDevices =
-            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
-            AudioSystem.DEVICE_OUT_ALL_A2DP | AudioSystem.DEVICE_OUT_AUX_DIGITAL |
-            AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET | AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
-            AudioSystem.DEVICE_OUT_ALL_USB;
-
-    // must be called before removing the device from mConnectedDevices
-    private int checkSendBecomingNoisyIntent(int device, int state) {
-        int delay = 0;
-        if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
-            int devices = 0;
-            for (int dev : mConnectedDevices.keySet()) {
-                if ((dev & mBecomingNoisyIntentDevices) != 0) {
-                   devices |= dev;
-                }
-            }
-            if (devices == device) {
-                sendMsg(mAudioHandler,
-                        MSG_BROADCAST_AUDIO_BECOMING_NOISY,
-                        SENDMSG_REPLACE,
-                        0,
-                        0,
-                        null,
-                        0);
-                delay = 1000;
-            }
-        }
-
-        if (mAudioHandler.hasMessages(MSG_SET_A2DP_CONNECTION_STATE) ||
-                mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
-            delay = 1000;
-        }
-        return delay;
-    }
-
-    private void sendDeviceConnectionIntent(int device, int state, String name)
-    {
-        Intent intent = new Intent();
-
-        intent.putExtra("state", state);
-        intent.putExtra("name", name);
-        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
-
-        int connType = 0;
-
-        if (device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) {
-            connType = AudioRoutesInfo.MAIN_HEADSET;
-            intent.setAction(Intent.ACTION_HEADSET_PLUG);
-            intent.putExtra("microphone", 1);
-        } else if (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE) {
-            connType = AudioRoutesInfo.MAIN_HEADPHONES;
-            intent.setAction(Intent.ACTION_HEADSET_PLUG);
-            intent.putExtra("microphone", 0);
-        } else if (device == AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET) {
-            connType = AudioRoutesInfo.MAIN_DOCK_SPEAKERS;
-            intent.setAction(Intent.ACTION_ANALOG_AUDIO_DOCK_PLUG);
-        } else if (device == AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET) {
-            connType = AudioRoutesInfo.MAIN_DOCK_SPEAKERS;
-            intent.setAction(Intent.ACTION_DIGITAL_AUDIO_DOCK_PLUG);
-        } else if (device == AudioSystem.DEVICE_OUT_AUX_DIGITAL) {
-            connType = AudioRoutesInfo.MAIN_HDMI;
-            intent.setAction(Intent.ACTION_HDMI_AUDIO_PLUG);
-        }
-
-        synchronized (mCurAudioRoutes) {
-            if (connType != 0) {
-                int newConn = mCurAudioRoutes.mMainType;
-                if (state != 0) {
-                    newConn |= connType;
-                } else {
-                    newConn &= ~connType;
-                }
-                if (newConn != mCurAudioRoutes.mMainType) {
-                    mCurAudioRoutes.mMainType = newConn;
-                    sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES,
-                            SENDMSG_NOOP, 0, 0, null, 0);
-                }
-            }
-        }
-
-        final long ident = Binder.clearCallingIdentity();
-        try {
-            ActivityManagerNative.broadcastStickyIntent(intent, null, UserHandle.USER_ALL);
-        } finally {
-            Binder.restoreCallingIdentity(ident);
-        }
-    }
-
-    private void onSetWiredDeviceConnectionState(int device, int state, String name)
-    {
-        synchronized (mConnectedDevices) {
-            if ((state == 0) && ((device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) ||
-                    (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE))) {
-                setBluetoothA2dpOnInt(true);
-            }
-            boolean isUsb = ((device & AudioSystem.DEVICE_OUT_ALL_USB) != 0);
-            handleDeviceConnection((state == 1), device, (isUsb ? name : ""));
-            if (state != 0) {
-                if ((device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) ||
-                    (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE)) {
-                    setBluetoothA2dpOnInt(false);
-                }
-                if ((device & mSafeMediaVolumeDevices) != 0) {
-                    sendMsg(mAudioHandler,
-                            MSG_CHECK_MUSIC_ACTIVE,
-                            SENDMSG_REPLACE,
-                            0,
-                            0,
-                            null,
-                            MUSIC_ACTIVE_POLL_PERIOD_MS);
-                }
-            }
-            if (!isUsb) {
-                sendDeviceConnectionIntent(device, state, name);
-            }
-        }
-    }
-
-    /* cache of the address of the last dock the device was connected to */
-    private String mDockAddress;
-
-    /**
-     * Receiver for misc intent broadcasts the Phone app cares about.
-     */
-    private class AudioServiceBroadcastReceiver extends BroadcastReceiver {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-            int device;
-            int state;
-
-            if (action.equals(Intent.ACTION_DOCK_EVENT)) {
-                int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
-                        Intent.EXTRA_DOCK_STATE_UNDOCKED);
-                int config;
-                switch (dockState) {
-                    case Intent.EXTRA_DOCK_STATE_DESK:
-                        config = mForceAnalogDeskDock ? AudioSystem.FORCE_ANALOG_DOCK : AudioSystem.FORCE_BT_DESK_DOCK;
-                        break;
-                    case Intent.EXTRA_DOCK_STATE_CAR:
-                        config = mForceAnalogCarDock ? AudioSystem.FORCE_ANALOG_DOCK : AudioSystem.FORCE_BT_CAR_DOCK;
-                        break;
-                    case Intent.EXTRA_DOCK_STATE_LE_DESK:
-                        config = AudioSystem.FORCE_ANALOG_DOCK;
-                        break;
-                    case Intent.EXTRA_DOCK_STATE_HE_DESK:
-                        config = AudioSystem.FORCE_DIGITAL_DOCK;
-                        break;
-                    case Intent.EXTRA_DOCK_STATE_UNDOCKED:
-                    default:
-                        config = AudioSystem.FORCE_NONE;
-                }
-
-                // Low end docks have a menu to enable or disable audio
-                // (see mDockAudioMediaEnabled)
-                if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) ||
-                      ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) &&
-                       (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
-                    AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
-                }
-                mDockState = dockState;
-            } else if (action.equals(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED) && noDelayInATwoDP) {
-                state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE,
-                                           BluetoothProfile.STATE_DISCONNECTED);
-                BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-
-                onSetA2dpConnectionState(btDevice, state);
-            } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
-                state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE,
-                                               BluetoothProfile.STATE_DISCONNECTED);
-                device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
-                String address = null;
-
-                BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-                if (btDevice == null) {
-                    return;
-                }
-
-                address = btDevice.getAddress();
-                BluetoothClass btClass = btDevice.getBluetoothClass();
-                if (btClass != null) {
-                    switch (btClass.getDeviceClass()) {
-                    case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
-                    case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
-                        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
-                        break;
-                    case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
-                        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
-                        break;
-                    }
-                }
-
-                if (!BluetoothAdapter.checkBluetoothAddress(address)) {
-                    address = "";
-                }
-
-                boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
-                if (handleDeviceConnection(connected, device, address)) {
-                    synchronized (mScoClients) {
-                        if (connected) {
-                            mBluetoothHeadsetDevice = btDevice;
-                        } else {
-                            mBluetoothHeadsetDevice = null;
-                            resetBluetoothSco();
-                        }
-                    }
-                }
-            } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
-                state = intent.getIntExtra("state", 0);
-                if (state == 1) {
-                    // Headset plugged in
-                    adjustCurrentStreamVolume();
-                    // TODO: Cap volume at safe levels
-                } else {
-                    // Headset disconnected
-                    adjustCurrentStreamVolume();
-                }
-            } else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ||
-                           action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
-                state = intent.getIntExtra("state", 0);
-                int alsaCard = intent.getIntExtra("card", -1);
-                int alsaDevice = intent.getIntExtra("device", -1);
-                String params = (alsaCard == -1 && alsaDevice == -1 ? ""
-                                    : "card=" + alsaCard + ";device=" + alsaDevice);
-                device = action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ?
-                        AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
-                Log.v(TAG, "Broadcast Receiver: Got "
-                        + (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ?
-                              "ACTION_USB_AUDIO_ACCESSORY_PLUG" : "ACTION_USB_AUDIO_DEVICE_PLUG")
-                        + ", state = " + state + ", card: " + alsaCard + ", device: " + alsaDevice);
-                setWiredDeviceConnectionState(device, state, params);
-            } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
-                boolean broadcast = false;
-                int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
-                synchronized (mScoClients) {
-                    int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
-                    // broadcast intent if the connection was initated by AudioService
-                    if (!mScoClients.isEmpty() &&
-                            (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL ||
-                             mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
-                             mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
-                        broadcast = true;
-                    }
-                    switch (btState) {
-                    case BluetoothHeadset.STATE_AUDIO_CONNECTED:
-                        scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
-                        if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
-                            mScoAudioState != SCO_STATE_DEACTIVATE_REQ &&
-                            mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
-                            mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
-                        }
-                        break;
-                    case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
-                        scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
-                        mScoAudioState = SCO_STATE_INACTIVE;
-                        clearAllScoClients(0, false);
-                        break;
-                    case BluetoothHeadset.STATE_AUDIO_CONNECTING:
-                        if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
-                            mScoAudioState != SCO_STATE_DEACTIVATE_REQ &&
-                            mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
-                            mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
-                        }
-                    default:
-                        // do not broadcast CONNECTING or invalid state
-                        broadcast = false;
-                        break;
-                    }
-                }
-                if (broadcast) {
-                    broadcastScoConnectionState(scoAudioState);
-                    //FIXME: this is to maintain compatibility with deprecated intent
-                    // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
-                    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
-                    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
-                    sendStickyBroadcastToAll(newIntent);
-                }
-            } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
-                mBootCompleted = true;
-                sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_NOOP,
-                        0, 0, null, 0);
-
-                mKeyguardManager =
-                        (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
-                mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
-                resetBluetoothSco();
-                getBluetoothHeadset();
-                //FIXME: this is to maintain compatibility with deprecated intent
-                // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
-                Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
-                newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,
-                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
-                sendStickyBroadcastToAll(newIntent);
-
-                BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-                if (adapter != null) {
-                    adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
-                                            BluetoothProfile.A2DP);
-                }
-
-                sendMsg(mAudioHandler,
-                        MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED,
-                        SENDMSG_REPLACE,
-                        0,
-                        0,
-                        null,
-                        SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
-
-                adjustCurrentStreamVolume();
-            } else if (action.equals(Intent.ACTION_PACKAGE_REMOVED)) {
-                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {
-                    // a package is being removed, not replaced
-                    String packageName = intent.getData().getSchemeSpecificPart();
-                    if (packageName != null) {
-                        removeMediaButtonReceiverForPackage(packageName);
-                    }
-                }
-            } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
-                AudioSystem.setParameters("screen_state=on");
-            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
-                AudioSystem.setParameters("screen_state=off");
-            } else if (action.equalsIgnoreCase(Intent.ACTION_CONFIGURATION_CHANGED)) {
-                handleConfigurationChanged(context);
-            } else if (action.equals(Intent.ACTION_USER_BACKGROUND)) {
-                // attempt to stop music playback for background user
-                sendMsg(mAudioHandler,
-                        MSG_BROADCAST_AUDIO_BECOMING_NOISY,
-                        SENDMSG_REPLACE,
-                        0,
-                        0,
-                        null,
-                        0);
-            } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
-                // the current audio focus owner is no longer valid
-                discardAudioFocusOwner();
-
-                // load volume settings for new user
-                readAudioSettings(true /*userSwitch*/);
-                // preserve STREAM_MUSIC volume from one user to the next.
-                sendMsg(mAudioHandler,
-                        MSG_SET_ALL_VOLUMES,
-                        SENDMSG_QUEUE,
-                        0,
-                        0,
-                        mStreamStates[AudioSystem.STREAM_MUSIC], 0);
-            } else if (action.equals(Intent.ACTION_WIFI_DISPLAY_AUDIO)) {
-                state = intent.getIntExtra("state", 0);
-                Log.v(TAG, "WiFi Display device state "+state);
-                boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_PROXY);
-                if(state == 1 && !isConnected){
-                    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_PROXY,
-                            AudioSystem.DEVICE_STATE_AVAILABLE,
-                            "");
-                    mConnectedDevices.put( new Integer(AudioSystem.DEVICE_OUT_PROXY), "");
-                }else if(state == 0 && isConnected){
-                    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_PROXY,
-                            AudioSystem.DEVICE_STATE_UNAVAILABLE,
-                            "");
-                    mConnectedDevices.remove(AudioSystem.DEVICE_OUT_PROXY);
-                }
-            }
-        }
-
-        private void adjustCurrentStreamVolume() {
-            VolumeStreamState streamState;
-            int device;
-
-            for (int stream = 0; stream < AudioSystem.getNumStreamTypes(); stream++) {
-                if (stream == mStreamVolumeAlias[stream]) {
-                    streamState = mStreamStates[mStreamVolumeAlias[stream]];
-                    device = getDeviceForStream(stream);
-                    // apply stored value for device
-                    streamState.applyDeviceVolume(device);
-                }
-            }
-        }
-    }
-
-    private void masterVolumeChanged(final int flags) {
-        if (mUiContext != null && mVolumePanel != null) {
-            mVolumePanel.postMasterVolumeChanged(flags);
-        } else {
-            mHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    if (mUiContext == null) {
-                        mUiContext = ThemeUtils.createUiContext(mContext);
-                    }
-
-                    final Context context = mUiContext != null ? mUiContext : mContext;
-                    mVolumePanel = new VolumePanel(context, AudioService.this);
-                    mVolumePanel.postMasterVolumeChanged(flags);
-                }
-            });
-        }
-    }
-
-    private void masterMuteChanged(final int flags) {
-        if (mUiContext != null && mVolumePanel != null) {
-            mVolumePanel.postMasterMuteChanged(flags);
-        } else {
-            mHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    if (mUiContext == null) {
-                        mUiContext = ThemeUtils.createUiContext(mContext);
-                    }
-
-                    final Context context = mUiContext != null ? mUiContext : mContext;
-                    mVolumePanel = new VolumePanel(context, AudioService.this);
-                    mVolumePanel.postMasterMuteChanged(flags);
-                }
-            });
-        }
-    }
-
-    private void remoteSliderVisibility(final boolean hasRemotePlayback) {
-        if (mUiContext != null && mVolumePanel != null) {
-            mVolumePanel.postRemoteSliderVisibility(hasRemotePlayback);
-        } else {
-            mHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    if (mUiContext == null) {
-                        mUiContext = ThemeUtils.createUiContext(mContext);
-                    }
-
-                    final Context context = mUiContext != null ? mUiContext : mContext;
-                    mVolumePanel = new VolumePanel(context, AudioService.this);
-                    mVolumePanel.postRemoteSliderVisibility(hasRemotePlayback);
-                }
-            });
-        }
-    }
-
-    private void showVolumeChangeUi(final int streamType, final int flags) {
-        if (mUiContext != null && mVolumePanel != null) {
-            mVolumePanel.postVolumeChanged(streamType, flags);
-        } else {
-            mHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    if (mUiContext == null) {
-                        mUiContext = ThemeUtils.createUiContext(mContext);
-                    }
-
-                    final Context context = mUiContext != null ? mUiContext : mContext;
-                    mVolumePanel = new VolumePanel(context, AudioService.this);
-                    mVolumePanel.postVolumeChanged(streamType, flags);
-                }
-            });
-        }
-    }
-
-    private void remoteVolumeChanged(final int streamType, final int flags) {
-        if (mUiContext != null && mVolumePanel != null) {
-            mVolumePanel.postRemoteVolumeChanged(streamType, flags);
-        } else {
-            mHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    if (mUiContext == null) {
-                        mUiContext = ThemeUtils.createUiContext(mContext);
-                    }
-
-                    final Context context = mUiContext != null ? mUiContext : mContext;
-                    mVolumePanel = new VolumePanel(context, AudioService.this);
-                    mVolumePanel.postRemoteVolumeChanged(streamType, flags);
-                }
-            });
-        }
-    }
-
-    private void displaySafeVolumeWarning() {
-        if (mUiContext != null && mVolumePanel != null) {
-            mVolumePanel.postDisplaySafeVolumeWarning();
-        } else {
-            mHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    if (mUiContext == null) {
-                        mUiContext = ThemeUtils.createUiContext(mContext);
-                    }
-
-                    final Context context = mUiContext != null ? mUiContext : mContext;
-                    mVolumePanel = new VolumePanel(context, AudioService.this);
-                    mVolumePanel.postDisplaySafeVolumeWarning();
-                }
-            });
-        }
-    }
-
-    private void hasNewRemotePlaybackInfo() {
-        if (mUiContext != null && mVolumePanel != null) {
-            mVolumePanel.postHasNewRemotePlaybackInfo();
-        } else {
-            mHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    if (mUiContext == null) {
-                        mUiContext = ThemeUtils.createUiContext(mContext);
-                    }
-
-                    final Context context = mUiContext != null ? mUiContext : mContext;
-                    mVolumePanel = new VolumePanel(context, AudioService.this);
-                    mVolumePanel.postHasNewRemotePlaybackInfo();
-                }
-            });
-        }
-    }
-
-    //==========================================================================================
-    // AudioFocus
-    //==========================================================================================
-
-    /* constant to identify focus stack entry that is used to hold the focus while the phone
-     * is ringing or during a call. Used by com.android.internal.telephony.CallManager when
-     * entering and exiting calls.
-     */
-    public final static String IN_VOICE_COMM_FOCUS_ID = "AudioFocus_For_Phone_Ring_And_Calls";
-
-    private final static Object mAudioFocusLock = new Object();
-
-    private final static Object mRingingLock = new Object();
-
-    private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
-        @Override
-        public void onCallStateChanged(int state, String incomingNumber) {
-            if (state == TelephonyManager.CALL_STATE_RINGING) {
-                //Log.v(TAG, " CALL_STATE_RINGING");
-                synchronized(mRingingLock) {
-                    mIsRinging = true;
-                }
-            } else if ((state == TelephonyManager.CALL_STATE_OFFHOOK)
-                    || (state == TelephonyManager.CALL_STATE_IDLE)) {
-                synchronized(mRingingLock) {
-                    mIsRinging = false;
-                }
-            }
-        }
-    };
-
-    /**
-     * Discard the current audio focus owner.
-     * Notify top of audio focus stack that it lost focus (regardless of possibility to reassign
-     * focus), remove it from the stack, and clear the remote control display.
-     */
-    private void discardAudioFocusOwner() {
-        synchronized(mAudioFocusLock) {
-            if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
-                // notify the current focus owner it lost focus after removing it from stack
-                FocusStackEntry focusOwner = mFocusStack.pop();
-                try {
-                    focusOwner.mFocusDispatcher.dispatchAudioFocusChange(
-                            AudioManager.AUDIOFOCUS_LOSS, focusOwner.mClientId);
-                } catch (RemoteException e) {
-                    Log.e(TAG, "Failure to signal loss of audio focus due to "+ e);
-                    e.printStackTrace();
-                }
-                focusOwner.unlinkToDeath();
-                // clear RCD
-                synchronized(mRCStack) {
-                    clearRemoteControlDisplay_syncAfRcs();
-                }
-            }
-        }
-    }
-
-    private void notifyTopOfAudioFocusStack() {
-        // notify the top of the stack it gained focus
-        if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
-            String clientId = mFocusStack.peek().mClientId;
-            if (canReassignAudioFocusTo(clientId)) {
-                try {
-                    mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(
-                            AudioManager.AUDIOFOCUS_GAIN, clientId);
-                } catch (RemoteException e) {
-                    Log.e(TAG, "Failure to signal gain of audio control focus due to "+ e);
-                    e.printStackTrace();
-                }
-            }
-        }
-    }
-
-    private static class FocusStackEntry {
-        public int mStreamType = -1;// no stream type
-        public IAudioFocusDispatcher mFocusDispatcher = null;
-        public IBinder mSourceRef = null;
-        public String mClientId;
-        public int mFocusChangeType;
-        public AudioFocusDeathHandler mHandler;
-        public String mPackageName;
-        public int mCallingUid;
-
-        public FocusStackEntry() {
-        }
-
-        public FocusStackEntry(int streamType, int duration,
-                IAudioFocusDispatcher afl, IBinder source, String id, AudioFocusDeathHandler hdlr,
-                String pn, int uid) {
-            mStreamType = streamType;
-            mFocusDispatcher = afl;
-            mSourceRef = source;
-            mClientId = id;
-            mFocusChangeType = duration;
-            mHandler = hdlr;
-            mPackageName = pn;
-            mCallingUid = uid;
-        }
-
-        public void unlinkToDeath() {
-            try {
-                if (mSourceRef != null && mHandler != null) {
-                    mSourceRef.unlinkToDeath(mHandler, 0);
-                    mHandler = null;
-                }
-            } catch (java.util.NoSuchElementException e) {
-                Log.e(TAG, "Encountered " + e + " in FocusStackEntry.unlinkToDeath()");
-            }
-        }
-
-        @Override
-        protected void finalize() throws Throwable {
-            unlinkToDeath(); // unlink exception handled inside method
-            super.finalize();
-        }
-    }
-
-    private final Stack<FocusStackEntry> mFocusStack = new Stack<FocusStackEntry>();
-
-    /**
-     * Helper function:
-     * Display in the log the current entries in the audio focus stack
-     */
-    private void dumpFocusStack(PrintWriter pw) {
-        pw.println("\nAudio Focus stack entries:");
-        synchronized(mAudioFocusLock) {
-            Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
-            while(stackIterator.hasNext()) {
-                FocusStackEntry fse = stackIterator.next();
-                pw.println("  source:" + fse.mSourceRef
-                        + " -- pack: " + fse.mPackageName
-                        + " -- client: " + fse.mClientId
-                        + " -- duration: " + fse.mFocusChangeType
-                        + " -- uid: " + fse.mCallingUid
-                        + " -- stream: " + fse.mStreamType);
-            }
-        }
-    }
-
-    /**
-     * Helper function:
-     * Called synchronized on mAudioFocusLock
-     * Remove a focus listener from the focus stack.
-     * @param focusListenerToRemove the focus listener
-     * @param signal if true and the listener was at the top of the focus stack, i.e. it was holding
-     *   focus, notify the next item in the stack it gained focus.
-     */
-    private void removeFocusStackEntry(String clientToRemove, boolean signal) {
-        // is the current top of the focus stack abandoning focus? (because of request, not death)
-        if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove))
-        {
-            //Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
-            FocusStackEntry fse = mFocusStack.pop();
-            fse.unlinkToDeath();
-            if (signal) {
-                // notify the new top of the stack it gained focus
-                notifyTopOfAudioFocusStack();
-                // there's a new top of the stack, let the remote control know
-                synchronized(mRCStack) {
-                    checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-                }
-            }
-        } else {
-            // focus is abandoned by a client that's not at the top of the stack,
-            // no need to update focus.
-            Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
-            while(stackIterator.hasNext()) {
-                FocusStackEntry fse = (FocusStackEntry)stackIterator.next();
-                if(fse.mClientId.equals(clientToRemove)) {
-                    Log.i(TAG, " AudioFocus  abandonAudioFocus(): removing entry for "
-                            + fse.mClientId);
-                    stackIterator.remove();
-                    fse.unlinkToDeath();
-                }
-            }
-        }
-    }
-
-    /**
-     * Helper function:
-     * Called synchronized on mAudioFocusLock
-     * Remove focus listeners from the focus stack for a particular client when it has died.
-     */
-    private void removeFocusStackEntryForClient(IBinder cb) {
-        // is the owner of the audio focus part of the client to remove?
-        boolean isTopOfStackForClientToRemove = !mFocusStack.isEmpty() &&
-                mFocusStack.peek().mSourceRef.equals(cb);
-        Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
-        while(stackIterator.hasNext()) {
-            FocusStackEntry fse = (FocusStackEntry)stackIterator.next();
-            if(fse.mSourceRef.equals(cb)) {
-                Log.i(TAG, " AudioFocus  abandonAudioFocus(): removing entry for "
-                        + fse.mClientId);
-                stackIterator.remove();
-                // the client just died, no need to unlink to its death
-            }
-        }
-        if (isTopOfStackForClientToRemove) {
-            // we removed an entry at the top of the stack:
-            //  notify the new top of the stack it gained focus.
-            notifyTopOfAudioFocusStack();
-            // there's a new top of the stack, let the remote control know
-            synchronized(mRCStack) {
-                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-            }
-        }
-    }
-
-    /**
-     * Helper function:
-     * Returns true if the system is in a state where the focus can be reevaluated, false otherwise.
-     */
-    private boolean canReassignAudioFocusTo(String clientId) {
-        // focus requests are rejected during a phone call or when the phone is ringing
-        // this is equivalent to IN_VOICE_COMM_FOCUS_ID having the focus
-        if (IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
-            return true;
-        }
-        if (!mFocusStack.isEmpty() && IN_VOICE_COMM_FOCUS_ID.equals(mFocusStack.peek().mClientId)) {
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * Inner class to monitor audio focus client deaths, and remove them from the audio focus
-     * stack if necessary.
-     */
-    private class AudioFocusDeathHandler implements IBinder.DeathRecipient {
-        private IBinder mCb; // To be notified of client's death
-
-        AudioFocusDeathHandler(IBinder cb) {
-            mCb = cb;
-        }
-
-        public void binderDied() {
-            synchronized(mAudioFocusLock) {
-                Log.w(TAG, "  AudioFocus   audio focus client died");
-                removeFocusStackEntryForClient(mCb);
-            }
-        }
-
-        public IBinder getBinder() {
-            return mCb;
-        }
-    }
-
-
-    /** @see AudioManager#requestAudioFocus(IAudioFocusDispatcher, int, int) */
-    public int requestAudioFocus(int mainStreamType, int focusChangeHint, IBinder cb,
-            IAudioFocusDispatcher fd, String clientId, String callingPackageName) {
-        Log.i(TAG, " AudioFocus  requestAudioFocus() from " + clientId);
-        // the main stream type for the audio focus request is currently not used. It may
-        // potentially be used to handle multiple stream type-dependent audio focuses.
-
-        // we need a valid binder callback for clients
-        if (!cb.pingBinder()) {
-            Log.e(TAG, " AudioFocus DOA client for requestAudioFocus(), aborting.");
-            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
-        }
-
-        synchronized(mAudioFocusLock) {
-            if (!canReassignAudioFocusTo(clientId)) {
-                return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
-            }
-
-            // handle the potential premature death of the new holder of the focus
-            // (premature death == death before abandoning focus)
-            // Register for client death notification
-            AudioFocusDeathHandler afdh = new AudioFocusDeathHandler(cb);
-            try {
-                cb.linkToDeath(afdh, 0);
-            } catch (RemoteException e) {
-                // client has already died!
-                Log.w(TAG, "AudioFocus  requestAudioFocus() could not link to "+cb+" binder death");
-                return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
-            }
-
-            if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
-                // if focus is already owned by this client and the reason for acquiring the focus
-                // hasn't changed, don't do anything
-                if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
-                    // unlink death handler so it can be gc'ed.
-                    // linkToDeath() creates a JNI global reference preventing collection.
-                    cb.unlinkToDeath(afdh, 0);
-                    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
-                }
-                // the reason for the audio focus request has changed: remove the current top of
-                // stack and respond as if we had a new focus owner
-                FocusStackEntry fse = mFocusStack.pop();
-                fse.unlinkToDeath();
-            }
-
-            // notify current top of stack it is losing focus
-            if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
-                try {
-                    mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(
-                            -1 * focusChangeHint, // loss and gain codes are inverse of each other
-                            mFocusStack.peek().mClientId);
-                } catch (RemoteException e) {
-                    Log.e(TAG, " Failure to signal loss of focus due to "+ e);
-                    e.printStackTrace();
-                }
-            }
-
-            // focus requester might already be somewhere below in the stack, remove it
-            removeFocusStackEntry(clientId, false /* signal */);
-
-            // push focus requester at the top of the audio focus stack
-            mFocusStack.push(new FocusStackEntry(mainStreamType, focusChangeHint, fd, cb,
-                    clientId, afdh, callingPackageName, Binder.getCallingUid()));
-
-            // there's a new top of the stack, let the remote control know
-            synchronized(mRCStack) {
-                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-            }
-        }//synchronized(mAudioFocusLock)
-
-        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
-    }
-
-    /** @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) */
-    public int abandonAudioFocus(IAudioFocusDispatcher fl, String clientId) {
-        Log.i(TAG, " AudioFocus  abandonAudioFocus() from " + clientId);
-        try {
-            // this will take care of notifying the new focus owner if needed
-            synchronized(mAudioFocusLock) {
-                removeFocusStackEntry(clientId, true);
-            }
-        } catch (java.util.ConcurrentModificationException cme) {
-            // Catching this exception here is temporary. It is here just to prevent
-            // a crash seen when the "Silent" notification is played. This is believed to be fixed
-            // but this try catch block is left just to be safe.
-            Log.e(TAG, "FATAL EXCEPTION AudioFocus  abandonAudioFocus() caused " + cme);
-            cme.printStackTrace();
-        }
-
-        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
-    }
-
-
-    public void unregisterAudioFocusClient(String clientId) {
-        synchronized(mAudioFocusLock) {
-            removeFocusStackEntry(clientId, false);
-        }
-    }
-
-
-    //==========================================================================================
-    // RemoteControl
-    //==========================================================================================
-    public void dispatchMediaKeyEvent(KeyEvent keyEvent) {
-        filterMediaKeyEvent(keyEvent, false /*needWakeLock*/);
-    }
-
-    public void dispatchMediaKeyEventUnderWakelock(KeyEvent keyEvent) {
-        filterMediaKeyEvent(keyEvent, true /*needWakeLock*/);
-    }
-
-    private void filterMediaKeyEvent(KeyEvent keyEvent, boolean needWakeLock) {
-        // sanity check on the incoming key event
-        if (!isValidMediaKeyEvent(keyEvent)) {
-            Log.e(TAG, "not dispatching invalid media key event " + keyEvent);
-            return;
-        }
-        // event filtering for telephony
-        synchronized(mRingingLock) {
-            synchronized(mRCStack) {
-                if ((mMediaReceiverForCalls != null) &&
-                        (mIsRinging || (getMode() == AudioSystem.MODE_IN_CALL))) {
-                    dispatchMediaKeyEventForCalls(keyEvent, needWakeLock);
-                    return;
-                }
-            }
-        }
-        // event filtering based on voice-based interactions
-        if (isValidVoiceInputKeyCode(keyEvent.getKeyCode())) {
-            filterVoiceInputKeyEvent(keyEvent, needWakeLock);
-        } else {
-            dispatchMediaKeyEvent(keyEvent, needWakeLock);
-        }
-    }
-
-    /**
-     * Handles the dispatching of the media button events to the telephony package.
-     * Precondition: mMediaReceiverForCalls != null
-     * @param keyEvent a non-null KeyEvent whose key code is one of the supported media buttons
-     * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held while this key event
-     *     is dispatched.
-     */
-    private void dispatchMediaKeyEventForCalls(KeyEvent keyEvent, boolean needWakeLock) {
-        Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
-        keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
-        keyIntent.setPackage(mMediaReceiverForCalls.getPackageName());
-        if (needWakeLock) {
-            mMediaEventWakeLock.acquire();
-            keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
-        }
-        final long ident = Binder.clearCallingIdentity();
-        try {
-            mContext.sendOrderedBroadcastAsUser(keyIntent, UserHandle.ALL,
-                    null, mKeyEventDone, mAudioHandler, Activity.RESULT_OK, null, null);
-        } finally {
-            Binder.restoreCallingIdentity(ident);
-        }
-    }
-
-    /**
-     * Handles the dispatching of the media button events to one of the registered listeners,
-     * or if there was none, broadcast an ACTION_MEDIA_BUTTON intent to the rest of the system.
-     * @param keyEvent a non-null KeyEvent whose key code is one of the supported media buttons
-     * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held while this key event
-     *     is dispatched.
-     */
-    private void dispatchMediaKeyEvent(KeyEvent keyEvent, boolean needWakeLock) {
-        if (needWakeLock) {
-            mMediaEventWakeLock.acquire();
-        }
-        Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
-        keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
-        synchronized(mRCStack) {
-            if (!mRCStack.empty()) {
-                // send the intent that was registered by the client
-                try {
-                    mRCStack.peek().mMediaIntent.send(mContext,
-                            needWakeLock ? WAKELOCK_RELEASE_ON_FINISHED : 0 /*code*/,
-                            keyIntent, AudioService.this, mAudioHandler);
-                } catch (CanceledException e) {
-                    Log.e(TAG, "Error sending pending intent " + mRCStack.peek());
-                    e.printStackTrace();
-                }
-            } else {
-                // legacy behavior when nobody registered their media button event receiver
-                //    through AudioManager
-                if (needWakeLock) {
-                    keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
-                }
-                final long ident = Binder.clearCallingIdentity();
-                try {
-                    mContext.sendOrderedBroadcastAsUser(keyIntent, UserHandle.ALL,
-                            null, mKeyEventDone,
-                            mAudioHandler, Activity.RESULT_OK, null, null);
-                } finally {
-                    Binder.restoreCallingIdentity(ident);
-                }
-            }
-        }
-    }
-
-    /**
-     * The different actions performed in response to a voice button key event.
-     */
-    private final static int VOICEBUTTON_ACTION_DISCARD_CURRENT_KEY_PRESS = 1;
-    private final static int VOICEBUTTON_ACTION_START_VOICE_INPUT = 2;
-    private final static int VOICEBUTTON_ACTION_SIMULATE_KEY_PRESS = 3;
-
-    private final Object mVoiceEventLock = new Object();
-    private boolean mVoiceButtonDown;
-    private boolean mVoiceButtonHandled;
-
-    /**
-     * Filter key events that may be used for voice-based interactions
-     * @param keyEvent a non-null KeyEvent whose key code is that of one of the supported
-     *    media buttons that can be used to trigger voice-based interactions.
-     * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held while this key event
-     *     is dispatched.
-     */
-    private void filterVoiceInputKeyEvent(KeyEvent keyEvent, boolean needWakeLock) {
-        if (DEBUG_RC) {
-            Log.v(TAG, "voice input key event: " + keyEvent + ", needWakeLock=" + needWakeLock);
-        }
-
-        int voiceButtonAction = VOICEBUTTON_ACTION_DISCARD_CURRENT_KEY_PRESS;
-        int keyAction = keyEvent.getAction();
-        synchronized (mVoiceEventLock) {
-            if (keyAction == KeyEvent.ACTION_DOWN) {
-                if (keyEvent.getRepeatCount() == 0) {
-                    // initial down
-                    mVoiceButtonDown = true;
-                    mVoiceButtonHandled = false;
-                } else if (mVoiceButtonDown && !mVoiceButtonHandled
-                        && (keyEvent.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
-                    // long-press, start voice-based interactions
-                    mVoiceButtonHandled = true;
-                    voiceButtonAction = VOICEBUTTON_ACTION_START_VOICE_INPUT;
-                }
-            } else if (keyAction == KeyEvent.ACTION_UP) {
-                if (mVoiceButtonDown) {
-                    // voice button up
-                    mVoiceButtonDown = false;
-                    if (!mVoiceButtonHandled && !keyEvent.isCanceled()) {
-                        voiceButtonAction = VOICEBUTTON_ACTION_SIMULATE_KEY_PRESS;
-                    }
-                }
-            }
-        }//synchronized (mVoiceEventLock)
-
-        // take action after media button event filtering for voice-based interactions
-        switch (voiceButtonAction) {
-            case VOICEBUTTON_ACTION_DISCARD_CURRENT_KEY_PRESS:
-                if (DEBUG_RC) Log.v(TAG, "   ignore key event");
-                break;
-            case VOICEBUTTON_ACTION_START_VOICE_INPUT:
-                if (DEBUG_RC) Log.v(TAG, "   start voice-based interactions");
-                // then start the voice-based interactions
-                startVoiceBasedInteractions(needWakeLock);
-                break;
-            case VOICEBUTTON_ACTION_SIMULATE_KEY_PRESS:
-                if (DEBUG_RC) Log.v(TAG, "   send simulated key event, wakelock=" + needWakeLock);
-                sendSimulatedMediaButtonEvent(keyEvent, needWakeLock);
-                break;
-        }
-    }
-
-    private void sendSimulatedMediaButtonEvent(KeyEvent originalKeyEvent, boolean needWakeLock) {
-        // send DOWN event
-        KeyEvent keyEvent = KeyEvent.changeAction(originalKeyEvent, KeyEvent.ACTION_DOWN);
-        dispatchMediaKeyEvent(keyEvent, needWakeLock);
-        // send UP event
-        keyEvent = KeyEvent.changeAction(originalKeyEvent, KeyEvent.ACTION_UP);
-        dispatchMediaKeyEvent(keyEvent, needWakeLock);
-
-    }
-
-
-    private static boolean isValidMediaKeyEvent(KeyEvent keyEvent) {
-        if (keyEvent == null) {
-            return false;
-        }
-        final int keyCode = keyEvent.getKeyCode();
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_MUTE:
-            case KeyEvent.KEYCODE_HEADSETHOOK:
-            case KeyEvent.KEYCODE_MEDIA_PLAY:
-            case KeyEvent.KEYCODE_MEDIA_PAUSE:
-            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-            case KeyEvent.KEYCODE_MEDIA_STOP:
-            case KeyEvent.KEYCODE_MEDIA_NEXT:
-            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
-            case KeyEvent.KEYCODE_MEDIA_REWIND:
-            case KeyEvent.KEYCODE_MEDIA_RECORD:
-            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
-            case KeyEvent.KEYCODE_MEDIA_CLOSE:
-            case KeyEvent.KEYCODE_MEDIA_EJECT:
-                break;
-            default:
-                return false;
-        }
-        return true;
-    }
-
-    /**
-     * Checks whether the given key code is one that can trigger the launch of voice-based
-     *   interactions.
-     * @param keyCode the key code associated with the key event
-     * @return true if the key is one of the supported voice-based interaction triggers
-     */
-    private static boolean isValidVoiceInputKeyCode(int keyCode) {
-        if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK) {
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    /**
-     * Tell the system to start voice-based interactions / voice commands
-     */
-    private void startVoiceBasedInteractions(boolean needWakeLock) {
-        Intent voiceIntent = null;
-        // select which type of search to launch:
-        // - screen on and device unlocked: action is ACTION_WEB_SEARCH
-        // - device locked or screen off: action is ACTION_VOICE_SEARCH_HANDS_FREE
-        //    with EXTRA_SECURE set to true if the device is securely locked
-        PowerManager pm = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
-        boolean isLocked = mKeyguardManager != null && mKeyguardManager.isKeyguardLocked();
-        if (!isLocked && pm.isScreenOn()) {
-            voiceIntent = new Intent(android.speech.RecognizerIntent.ACTION_WEB_SEARCH);
-        } else {
-            voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
-            voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE,
-                    isLocked && mKeyguardManager.isKeyguardSecure());
-        }
-        // start the search activity
-        if (needWakeLock) {
-            mMediaEventWakeLock.acquire();
-        }
-        try {
-            if (voiceIntent != null) {
-                voiceIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                        | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
-                mContext.startActivity(voiceIntent);
-            }
-        } catch (ActivityNotFoundException e) {
-            Log.w(TAG, "No activity for search: " + e);
-        } finally {
-            if (needWakeLock) {
-                mMediaEventWakeLock.release();
-            }
-        }
-    }
-
-    private PowerManager.WakeLock mMediaEventWakeLock;
-
-    private static final int WAKELOCK_RELEASE_ON_FINISHED = 1980; //magic number
-
-    // only set when wakelock was acquired, no need to check value when received
-    private static final String EXTRA_WAKELOCK_ACQUIRED =
-            "android.media.AudioService.WAKELOCK_ACQUIRED";
-
-    public void onSendFinished(PendingIntent pendingIntent, Intent intent,
-            int resultCode, String resultData, Bundle resultExtras) {
-        if (resultCode == WAKELOCK_RELEASE_ON_FINISHED) {
-            mMediaEventWakeLock.release();
-        }
-    }
-
-    BroadcastReceiver mKeyEventDone = new BroadcastReceiver() {
-        public void onReceive(Context context, Intent intent) {
-            if (intent == null) {
-                return;
-            }
-            Bundle extras = intent.getExtras();
-            if (extras == null) {
-                return;
-            }
-            if (extras.containsKey(EXTRA_WAKELOCK_ACQUIRED)) {
-                mMediaEventWakeLock.release();
-            }
-        }
-    };
-
-    private final Object mCurrentRcLock = new Object();
-    /**
-     * The one remote control client which will receive a request for display information.
-     * This object may be null.
-     * Access protected by mCurrentRcLock.
-     */
-    private IRemoteControlClient mCurrentRcClient = null;
-
-    private final static int RC_INFO_NONE = 0;
-    private final static int RC_INFO_ALL =
-        RemoteControlClient.FLAG_INFORMATION_REQUEST_ALBUM_ART |
-        RemoteControlClient.FLAG_INFORMATION_REQUEST_KEY_MEDIA |
-        RemoteControlClient.FLAG_INFORMATION_REQUEST_METADATA |
-        RemoteControlClient.FLAG_INFORMATION_REQUEST_PLAYSTATE;
-
-    /**
-     * A monotonically increasing generation counter for mCurrentRcClient.
-     * Only accessed with a lock on mCurrentRcLock.
-     * No value wrap-around issues as we only act on equal values.
-     */
-    private int mCurrentRcClientGen = 0;
-
-    /**
-     * Inner class to monitor remote control client deaths, and remove the client for the
-     * remote control stack if necessary.
-     */
-    private class RcClientDeathHandler implements IBinder.DeathRecipient {
-        private IBinder mCb; // To be notified of client's death
-        private PendingIntent mMediaIntent;
-
-        RcClientDeathHandler(IBinder cb, PendingIntent pi) {
-            mCb = cb;
-            mMediaIntent = pi;
-        }
-
-        public void binderDied() {
-            Log.w(TAG, "  RemoteControlClient died");
-            // remote control client died, make sure the displays don't use it anymore
-            //  by setting its remote control client to null
-            registerRemoteControlClient(mMediaIntent, null/*rcClient*/, null/*ignored*/);
-            // the dead client was maybe handling remote playback, reevaluate
-            postReevaluateRemote();
-        }
-
-        public IBinder getBinder() {
-            return mCb;
-        }
-    }
-
-    /**
-     * A global counter for RemoteControlClient identifiers
-     */
-    private static int sLastRccId = 0;
-
-    private class RemotePlaybackState {
-        int mRccId;
-        int mVolume;
-        int mVolumeMax;
-        int mVolumeHandling;
-
-        private RemotePlaybackState(int id, int vol, int volMax) {
-            mRccId = id;
-            mVolume = vol;
-            mVolumeMax = volMax;
-            mVolumeHandling = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME_HANDLING;
-        }
-    }
-
-    /**
-     * Internal cache for the playback information of the RemoteControlClient whose volume gets to
-     * be controlled by the volume keys ("main"), so we don't have to iterate over the RC stack
-     * every time we need this info.
-     */
-    private RemotePlaybackState mMainRemote;
-    /**
-     * Indicates whether the "main" RemoteControlClient is considered active.
-     * Use synchronized on mMainRemote.
-     */
-    private boolean mMainRemoteIsActive;
-    /**
-     * Indicates whether there is remote playback going on. True even if there is no "active"
-     * remote playback (mMainRemoteIsActive is false), but a RemoteControlClient has declared it
-     * handles remote playback.
-     * Use synchronized on mMainRemote.
-     */
-    private boolean mHasRemotePlayback;
-
-    private static class RemoteControlStackEntry {
-        public int mRccId = RemoteControlClient.RCSE_ID_UNREGISTERED;
-        /**
-         * The target for the ACTION_MEDIA_BUTTON events.
-         * Always non null.
-         */
-        public PendingIntent mMediaIntent;
-        /**
-         * The registered media button event receiver.
-         * Always non null.
-         */
-        public ComponentName mReceiverComponent;
-        public String mCallingPackageName;
-        public int mCallingUid;
-        /**
-         * Provides access to the information to display on the remote control.
-         * May be null (when a media button event receiver is registered,
-         *     but no remote control client has been registered) */
-        public IRemoteControlClient mRcClient;
-        public RcClientDeathHandler mRcClientDeathHandler;
-        /**
-         * Information only used for non-local playback
-         */
-        public int mPlaybackType;
-        public int mPlaybackVolume;
-        public int mPlaybackVolumeMax;
-        public int mPlaybackVolumeHandling;
-        public int mPlaybackStream;
-        public int mPlaybackState;
-        public IRemoteVolumeObserver mRemoteVolumeObs;
-
-        public void resetPlaybackInfo() {
-            mPlaybackType = RemoteControlClient.PLAYBACK_TYPE_LOCAL;
-            mPlaybackVolume = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME;
-            mPlaybackVolumeMax = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME;
-            mPlaybackVolumeHandling = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME_HANDLING;
-            mPlaybackStream = AudioManager.STREAM_MUSIC;
-            mPlaybackState = RemoteControlClient.PLAYSTATE_STOPPED;
-            mRemoteVolumeObs = null;
-        }
-
-        /** precondition: mediaIntent != null, eventReceiver != null */
-        public RemoteControlStackEntry(PendingIntent mediaIntent, ComponentName eventReceiver) {
-            mMediaIntent = mediaIntent;
-            mReceiverComponent = eventReceiver;
-            mCallingUid = -1;
-            mRcClient = null;
-            mRccId = ++sLastRccId;
-
-            resetPlaybackInfo();
-        }
-
-        public void unlinkToRcClientDeath() {
-            if ((mRcClientDeathHandler != null) && (mRcClientDeathHandler.mCb != null)) {
-                try {
-                    mRcClientDeathHandler.mCb.unlinkToDeath(mRcClientDeathHandler, 0);
-                    mRcClientDeathHandler = null;
-                } catch (java.util.NoSuchElementException e) {
-                    // not much we can do here
-                    Log.e(TAG, "Encountered " + e + " in unlinkToRcClientDeath()");
-                    e.printStackTrace();
-                }
-            }
-        }
-
-        @Override
-        protected void finalize() throws Throwable {
-            unlinkToRcClientDeath();// unlink exception handled inside method
-            super.finalize();
-        }
-    }
-
-    /**
-     *  The stack of remote control event receivers.
-     *  Code sections and methods that modify the remote control event receiver stack are
-     *  synchronized on mRCStack, but also BEFORE on mFocusLock as any change in either
-     *  stack, audio focus or RC, can lead to a change in the remote control display
-     */
-    private final Stack<RemoteControlStackEntry> mRCStack = new Stack<RemoteControlStackEntry>();
-
-    /**
-     * The component the telephony package can register so telephony calls have priority to
-     * handle media button events
-     */
-    private ComponentName mMediaReceiverForCalls = null;
-
-    /**
-     * Helper function:
-     * Display in the log the current entries in the remote control focus stack
-     */
-    private void dumpRCStack(PrintWriter pw) {
-        pw.println("\nRemote Control stack entries:");
-        synchronized(mRCStack) {
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-            while(stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                pw.println("  pi: " + rcse.mMediaIntent +
-                        " -- pack: " + rcse.mCallingPackageName +
-                        "  -- ercvr: " + rcse.mReceiverComponent +
-                        "  -- client: " + rcse.mRcClient +
-                        "  -- uid: " + rcse.mCallingUid +
-                        "  -- type: " + rcse.mPlaybackType +
-                        "  state: " + rcse.mPlaybackState);
-            }
-        }
-    }
-
-    /**
-     * Helper function:
-     * Display in the log the current entries in the remote control stack, focusing
-     * on RemoteControlClient data
-     */
-    private void dumpRCCStack(PrintWriter pw) {
-        pw.println("\nRemote Control Client stack entries:");
-        synchronized(mRCStack) {
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-            while(stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                pw.println("  uid: " + rcse.mCallingUid +
-                        "  -- id: " + rcse.mRccId +
-                        "  -- type: " + rcse.mPlaybackType +
-                        "  -- state: " + rcse.mPlaybackState +
-                        "  -- vol handling: " + rcse.mPlaybackVolumeHandling +
-                        "  -- vol: " + rcse.mPlaybackVolume +
-                        "  -- volMax: " + rcse.mPlaybackVolumeMax +
-                        "  -- volObs: " + rcse.mRemoteVolumeObs);
-
-            }
-        }
-        synchronized (mMainRemote) {
-            pw.println("\nRemote Volume State:");
-            pw.println("  has remote: " + mHasRemotePlayback);
-            pw.println("  is remote active: " + mMainRemoteIsActive);
-            pw.println("  rccId: " + mMainRemote.mRccId);
-            pw.println("  volume handling: "
-                    + ((mMainRemote.mVolumeHandling == RemoteControlClient.PLAYBACK_VOLUME_FIXED) ?
-                            "PLAYBACK_VOLUME_FIXED(0)" : "PLAYBACK_VOLUME_VARIABLE(1)"));
-            pw.println("  volume: " + mMainRemote.mVolume);
-            pw.println("  volume steps: " + mMainRemote.mVolumeMax);
-        }
-    }
-
-    /**
-     * Helper function:
-     * Remove any entry in the remote control stack that has the same package name as packageName
-     * Pre-condition: packageName != null
-     */
-    private void removeMediaButtonReceiverForPackage(String packageName) {
-        synchronized(mRCStack) {
-            if (mRCStack.empty()) {
-                return;
-            } else {
-                RemoteControlStackEntry oldTop = mRCStack.peek();
-                Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-                // iterate over the stack entries
-                while(stackIterator.hasNext()) {
-                    RemoteControlStackEntry rcse = (RemoteControlStackEntry)stackIterator.next();
-                    if (packageName.equalsIgnoreCase(rcse.mReceiverComponent.getPackageName())) {
-                        // a stack entry is from the package being removed, remove it from the stack
-                        stackIterator.remove();
-                        rcse.unlinkToRcClientDeath();
-                    }
-                }
-                if (mRCStack.empty()) {
-                    // no saved media button receiver
-                    mAudioHandler.sendMessage(
-                            mAudioHandler.obtainMessage(MSG_PERSIST_MEDIABUTTONRECEIVER, 0, 0,
-                                    null));
-                } else if (oldTop != mRCStack.peek()) {
-                    // the top of the stack has changed, save it in the system settings
-                    // by posting a message to persist it
-                    mAudioHandler.sendMessage(
-                            mAudioHandler.obtainMessage(MSG_PERSIST_MEDIABUTTONRECEIVER, 0, 0,
-                                    mRCStack.peek().mReceiverComponent));
-                }
-            }
-        }
-    }
-
-    /**
-     * Helper function:
-     * Restore remote control receiver from the system settings.
-     */
-    private void restoreMediaButtonReceiver() {
-        String receiverName = Settings.System.getStringForUser(mContentResolver,
-                Settings.System.MEDIA_BUTTON_RECEIVER, UserHandle.USER_CURRENT);
-        if ((null != receiverName) && !receiverName.isEmpty()) {
-            ComponentName eventReceiver = ComponentName.unflattenFromString(receiverName);
-            // construct a PendingIntent targeted to the restored component name
-            // for the media button and register it
-            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
-            //     the associated intent will be handled by the component being registered
-            mediaButtonIntent.setComponent(eventReceiver);
-            PendingIntent pi = PendingIntent.getBroadcast(mContext,
-                    0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);
-            registerMediaButtonIntent(pi, eventReceiver);
-        }
-    }
-
-    /**
-     * Helper function:
-     * Set the new remote control receiver at the top of the RC focus stack.
-     * precondition: mediaIntent != null, target != null
-     */
-    private void pushMediaButtonReceiver(PendingIntent mediaIntent, ComponentName target) {
-        // already at top of stack?
-        if (!mRCStack.empty() && mRCStack.peek().mMediaIntent.equals(mediaIntent)) {
-            return;
-        }
-        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-        RemoteControlStackEntry rcse = null;
-        boolean wasInsideStack = false;
-        while(stackIterator.hasNext()) {
-            rcse = (RemoteControlStackEntry)stackIterator.next();
-            if(rcse.mMediaIntent.equals(mediaIntent)) {
-                wasInsideStack = true;
-                stackIterator.remove();
-                break;
-            }
-        }
-        if (!wasInsideStack) {
-            rcse = new RemoteControlStackEntry(mediaIntent, target);
-        }
-        mRCStack.push(rcse);
-
-        // post message to persist the default media button receiver
-        mAudioHandler.sendMessage( mAudioHandler.obtainMessage(
-                MSG_PERSIST_MEDIABUTTONRECEIVER, 0, 0, target/*obj*/) );
-    }
-
-    /**
-     * Helper function:
-     * Remove the remote control receiver from the RC focus stack.
-     * precondition: pi != null
-     */
-    private void removeMediaButtonReceiver(PendingIntent pi) {
-        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-        while(stackIterator.hasNext()) {
-            RemoteControlStackEntry rcse = (RemoteControlStackEntry)stackIterator.next();
-            if(rcse.mMediaIntent.equals(pi)) {
-                stackIterator.remove();
-                rcse.unlinkToRcClientDeath();
-                break;
-            }
-        }
-    }
-
-    /**
-     * Helper function:
-     * Called synchronized on mRCStack
-     */
-    private boolean isCurrentRcController(PendingIntent pi) {
-        if (!mRCStack.empty() && mRCStack.peek().mMediaIntent.equals(pi)) {
-            return true;
-        }
-        return false;
-    }
-
-    //==========================================================================================
-    // Remote control display / client
-    //==========================================================================================
-    /**
-     * Update the remote control displays with the new "focused" client generation
-     */
-    private void setNewRcClientOnDisplays_syncRcsCurrc(int newClientGeneration,
-            PendingIntent newMediaIntent, boolean clearing) {
-        // NOTE: Only one IRemoteControlDisplay supported in this implementation
-        if (mRcDisplay != null) {
-            try {
-                mRcDisplay.setCurrentClientId(
-                        newClientGeneration, newMediaIntent, clearing);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Dead display in setNewRcClientOnDisplays_syncRcsCurrc() "+e);
-                // if we had a display before, stop monitoring its death
-                rcDisplay_stopDeathMonitor_syncRcStack();
-                mRcDisplay = null;
-            }
-        }
-    }
-
-    /**
-     * Update the remote control clients with the new "focused" client generation
-     */
-    private void setNewRcClientGenerationOnClients_syncRcsCurrc(int newClientGeneration) {
-        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-        while(stackIterator.hasNext()) {
-            RemoteControlStackEntry se = stackIterator.next();
-            if ((se != null) && (se.mRcClient != null)) {
-                try {
-                    se.mRcClient.setCurrentClientGenerationId(newClientGeneration);
-                } catch (RemoteException e) {
-                    Log.w(TAG, "Dead client in setNewRcClientGenerationOnClients_syncRcsCurrc()"+e);
-                    stackIterator.remove();
-                    se.unlinkToRcClientDeath();
-                }
-            }
-        }
-    }
-
-    /**
-     * Update the displays and clients with the new "focused" client generation and name
-     * @param newClientGeneration the new generation value matching a client update
-     * @param newClientEventReceiver the media button event receiver associated with the client.
-     *    May be null, which implies there is no registered media button event receiver.
-     * @param clearing true if the new client generation value maps to a remote control update
-     *    where the display should be cleared.
-     */
-    private void setNewRcClient_syncRcsCurrc(int newClientGeneration,
-            PendingIntent newMediaIntent, boolean clearing) {
-        // send the new valid client generation ID to all displays
-        setNewRcClientOnDisplays_syncRcsCurrc(newClientGeneration, newMediaIntent, clearing);
-        // send the new valid client generation ID to all clients
-        setNewRcClientGenerationOnClients_syncRcsCurrc(newClientGeneration);
-    }
-
-    /**
-     * Called when processing MSG_RCDISPLAY_CLEAR event
-     */
-    private void onRcDisplayClear() {
-        if (DEBUG_RC) Log.i(TAG, "Clear remote control display");
-
-        synchronized(mRCStack) {
-            synchronized(mCurrentRcLock) {
-                mCurrentRcClientGen++;
-                // synchronously update the displays and clients with the new client generation
-                setNewRcClient_syncRcsCurrc(mCurrentRcClientGen,
-                        null /*newMediaIntent*/, true /*clearing*/);
-            }
-        }
-    }
-
-    /**
-     * Called when processing MSG_RCDISPLAY_UPDATE event
-     */
-    private void onRcDisplayUpdate(RemoteControlStackEntry rcse, int flags /* USED ?*/) {
-        synchronized(mRCStack) {
-            synchronized(mCurrentRcLock) {
-                if ((mCurrentRcClient != null) && (mCurrentRcClient.equals(rcse.mRcClient))) {
-                    if (DEBUG_RC) Log.i(TAG, "Display/update remote control ");
-
-                    mCurrentRcClientGen++;
-                    // synchronously update the displays and clients with
-                    //      the new client generation
-                    setNewRcClient_syncRcsCurrc(mCurrentRcClientGen,
-                            rcse.mMediaIntent /*newMediaIntent*/,
-                            false /*clearing*/);
-
-                    // tell the current client that it needs to send info
-                    try {
-                        mCurrentRcClient.onInformationRequested(mCurrentRcClientGen,
-                                flags, mArtworkExpectedWidth, mArtworkExpectedHeight);
-                    } catch (RemoteException e) {
-                        Log.e(TAG, "Current valid remote client is dead: "+e);
-                        mCurrentRcClient = null;
-                    }
-                } else {
-                    // the remote control display owner has changed between the
-                    // the message to update the display was sent, and the time it
-                    // gets to be processed (now)
-                }
-            }
-        }
-    }
-
-
-    /**
-     * Helper function:
-     * Called synchronized on mRCStack
-     */
-    private void clearRemoteControlDisplay_syncAfRcs() {
-        synchronized(mCurrentRcLock) {
-            mCurrentRcClient = null;
-        }
-        // will cause onRcDisplayClear() to be called in AudioService's handler thread
-        mAudioHandler.sendMessage( mAudioHandler.obtainMessage(MSG_RCDISPLAY_CLEAR) );
-    }
-
-    /**
-     * Helper function for code readability: only to be called from
-     *    checkUpdateRemoteControlDisplay_syncAfRcs() which checks the preconditions for
-     *    this method.
-     * Preconditions:
-     *    - called synchronized mAudioFocusLock then on mRCStack
-     *    - mRCStack.isEmpty() is false
-     */
-    private void updateRemoteControlDisplay_syncAfRcs(int infoChangedFlags) {
-        RemoteControlStackEntry rcse = mRCStack.peek();
-        int infoFlagsAboutToBeUsed = infoChangedFlags;
-        // this is where we enforce opt-in for information display on the remote controls
-        //   with the new AudioManager.registerRemoteControlClient() API
-        if (rcse.mRcClient == null) {
-            //Log.w(TAG, "Can't update remote control display with null remote control client");
-            clearRemoteControlDisplay_syncAfRcs();
-            return;
-        }
-        synchronized(mCurrentRcLock) {
-            if (!rcse.mRcClient.equals(mCurrentRcClient)) {
-                // new RC client, assume every type of information shall be queried
-                infoFlagsAboutToBeUsed = RC_INFO_ALL;
-            }
-            mCurrentRcClient = rcse.mRcClient;
-        }
-        // will cause onRcDisplayUpdate() to be called in AudioService's handler thread
-        mAudioHandler.sendMessage( mAudioHandler.obtainMessage(MSG_RCDISPLAY_UPDATE,
-                infoFlagsAboutToBeUsed /* arg1 */, 0, rcse /* obj, != null */) );
-    }
-
-    /**
-     * Helper function:
-     * Called synchronized on mAudioFocusLock, then mRCStack
-     * Check whether the remote control display should be updated, triggers the update if required
-     * @param infoChangedFlags the flags corresponding to the remote control client information
-     *     that has changed, if applicable (checking for the update conditions might trigger a
-     *     clear, rather than an update event).
-     */
-    private void checkUpdateRemoteControlDisplay_syncAfRcs(int infoChangedFlags) {
-        // determine whether the remote control display should be refreshed
-        // if either stack is empty, there is a mismatch, so clear the RC display
-        if (mRCStack.isEmpty() || mFocusStack.isEmpty()) {
-            clearRemoteControlDisplay_syncAfRcs();
-            return;
-        }
-
-        // determine which entry in the AudioFocus stack to consider, and compare against the
-        // top of the stack for the media button event receivers : simply using the top of the
-        // stack would make the entry disappear from the RemoteControlDisplay in conditions such as
-        // notifications playing during music playback.
-        // Crawl the AudioFocus stack from the top until an entry is found with the following
-        // characteristics:
-        // - focus gain on STREAM_MUSIC stream
-        // - non-transient focus gain on a stream other than music
-        FocusStackEntry af = null;
-        try {
-            for (int index = mFocusStack.size()-1; index >= 0; index--) {
-                FocusStackEntry fse = mFocusStack.elementAt(index);
-                if ((fse.mStreamType == AudioManager.STREAM_MUSIC)
-                        || (fse.mFocusChangeType == AudioManager.AUDIOFOCUS_GAIN)) {
-                    af = fse;
-                    break;
-                }
-            }
-        } catch (ArrayIndexOutOfBoundsException e) {
-            Log.e(TAG, "Wrong index accessing audio focus stack when updating RCD: " + e);
-            af = null;
-        }
-        if (af == null) {
-            clearRemoteControlDisplay_syncAfRcs();
-            return;
-        }
-
-        // if the audio focus and RC owners belong to different packages, there is a mismatch, clear
-        if ((mRCStack.peek().mCallingPackageName != null)
-                && (af.mPackageName != null)
-                && !(mRCStack.peek().mCallingPackageName.compareTo(
-                        af.mPackageName) == 0)) {
-            clearRemoteControlDisplay_syncAfRcs();
-            return;
-        }
-        // if the audio focus didn't originate from the same Uid as the one in which the remote
-        //   control information will be retrieved, clear
-        if (mRCStack.peek().mCallingUid != af.mCallingUid) {
-            clearRemoteControlDisplay_syncAfRcs();
-            return;
-        }
-
-        // refresh conditions were verified: update the remote controls
-        // ok to call: synchronized mAudioFocusLock then on mRCStack, mRCStack is not empty
-        updateRemoteControlDisplay_syncAfRcs(infoChangedFlags);
-    }
-
-    /**
-     * see AudioManager.registerMediaButtonIntent(PendingIntent pi, ComponentName c)
-     * precondition: mediaIntent != null, target != null
-     */
-    public void registerMediaButtonIntent(PendingIntent mediaIntent, ComponentName eventReceiver) {
-        Log.i(TAG, "  Remote Control   registerMediaButtonIntent() for " + mediaIntent);
-
-        synchronized(mAudioFocusLock) {
-            synchronized(mRCStack) {
-                pushMediaButtonReceiver(mediaIntent, eventReceiver);
-                // new RC client, assume every type of information shall be queried
-                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-            }
-        }
-    }
-
-    /**
-     * see AudioManager.unregisterMediaButtonIntent(PendingIntent mediaIntent)
-     * precondition: mediaIntent != null, eventReceiver != null
-     */
-    public void unregisterMediaButtonIntent(PendingIntent mediaIntent, ComponentName eventReceiver)
-    {
-        Log.i(TAG, "  Remote Control   unregisterMediaButtonIntent() for " + mediaIntent);
-
-        synchronized(mAudioFocusLock) {
-            synchronized(mRCStack) {
-                boolean topOfStackWillChange = isCurrentRcController(mediaIntent);
-                removeMediaButtonReceiver(mediaIntent);
-                if (topOfStackWillChange) {
-                    // current RC client will change, assume every type of info needs to be queried
-                    checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-                }
-            }
-        }
-    }
-
-    /**
-     * see AudioManager.registerMediaButtonEventReceiverForCalls(ComponentName c)
-     * precondition: c != null
-     */
-    public void registerMediaButtonEventReceiverForCalls(ComponentName c) {
-        if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE")
-                != PackageManager.PERMISSION_GRANTED) {
-            Log.e(TAG, "Invalid permissions to register media button receiver for calls");
-            return;
-        }
-        synchronized(mRCStack) {
-            mMediaReceiverForCalls = c;
-        }
-    }
-
-    /**
-     * see AudioManager.unregisterMediaButtonEventReceiverForCalls()
-     */
-    public void unregisterMediaButtonEventReceiverForCalls() {
-        if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE")
-                != PackageManager.PERMISSION_GRANTED) {
-            Log.e(TAG, "Invalid permissions to unregister media button receiver for calls");
-            return;
-        }
-        synchronized(mRCStack) {
-            mMediaReceiverForCalls = null;
-        }
-    }
-
-    /**
-     * see AudioManager.registerRemoteControlClient(ComponentName eventReceiver, ...)
-     * @return the unique ID of the RemoteControlStackEntry associated with the RemoteControlClient
-     * Note: using this method with rcClient == null is a way to "disable" the IRemoteControlClient
-     *     without modifying the RC stack, but while still causing the display to refresh (will
-     *     become blank as a result of this)
-     */
-    public int registerRemoteControlClient(PendingIntent mediaIntent,
-            IRemoteControlClient rcClient, String callingPackageName) {
-        if (DEBUG_RC) Log.i(TAG, "Register remote control client rcClient="+rcClient);
-        int rccId = RemoteControlClient.RCSE_ID_UNREGISTERED;
-        synchronized(mAudioFocusLock) {
-            synchronized(mRCStack) {
-                // store the new display information
-                Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-                while(stackIterator.hasNext()) {
-                    RemoteControlStackEntry rcse = stackIterator.next();
-                    if(rcse.mMediaIntent.equals(mediaIntent)) {
-                        // already had a remote control client?
-                        if (rcse.mRcClientDeathHandler != null) {
-                            // stop monitoring the old client's death
-                            rcse.unlinkToRcClientDeath();
-                        }
-                        // save the new remote control client
-                        rcse.mRcClient = rcClient;
-                        rcse.mCallingPackageName = callingPackageName;
-                        rcse.mCallingUid = Binder.getCallingUid();
-                        if (rcClient == null) {
-                            // here rcse.mRcClientDeathHandler is null;
-                            rcse.resetPlaybackInfo();
-                            break;
-                        }
-                        rccId = rcse.mRccId;
-
-                        // there is a new (non-null) client:
-                        // 1/ give the new client the current display (if any)
-                        if (mRcDisplay != null) {
-                            try {
-                                rcse.mRcClient.plugRemoteControlDisplay(mRcDisplay);
-                            } catch (RemoteException e) {
-                                Log.e(TAG, "Error connecting remote control display to client: "+e);
-                                e.printStackTrace();
-                            }
-                        }
-                        // 2/ monitor the new client's death
-                        IBinder b = rcse.mRcClient.asBinder();
-                        RcClientDeathHandler rcdh =
-                                new RcClientDeathHandler(b, rcse.mMediaIntent);
-                        try {
-                            b.linkToDeath(rcdh, 0);
-                        } catch (RemoteException e) {
-                            // remote control client is DOA, disqualify it
-                            Log.w(TAG, "registerRemoteControlClient() has a dead client " + b);
-                            rcse.mRcClient = null;
-                        }
-                        rcse.mRcClientDeathHandler = rcdh;
-                        break;
-                    }
-                }
-                // if the eventReceiver is at the top of the stack
-                // then check for potential refresh of the remote controls
-                if (isCurrentRcController(mediaIntent)) {
-                    checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-                }
-            }
-        }
-        return rccId;
-    }
-
-    /**
-     * see AudioManager.unregisterRemoteControlClient(PendingIntent pi, ...)
-     * rcClient is guaranteed non-null
-     */
-    public void unregisterRemoteControlClient(PendingIntent mediaIntent,
-            IRemoteControlClient rcClient) {
-        synchronized(mAudioFocusLock) {
-            synchronized(mRCStack) {
-                Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-                while(stackIterator.hasNext()) {
-                    RemoteControlStackEntry rcse = stackIterator.next();
-                    if ((rcse.mMediaIntent.equals(mediaIntent))
-                            && rcClient.equals(rcse.mRcClient)) {
-                        // we found the IRemoteControlClient to unregister
-                        // stop monitoring its death
-                        rcse.unlinkToRcClientDeath();
-                        // reset the client-related fields
-                        rcse.mRcClient = null;
-                        rcse.mCallingPackageName = null;
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * The remote control displays.
-     * Access synchronized on mRCStack
-     * NOTE: Only one IRemoteControlDisplay supported in this implementation
-     */
-    private IRemoteControlDisplay mRcDisplay;
-    private RcDisplayDeathHandler mRcDisplayDeathHandler;
-    private int mArtworkExpectedWidth = -1;
-    private int mArtworkExpectedHeight = -1;
-    /**
-     * Inner class to monitor remote control display deaths, and unregister them from the list
-     * of displays if necessary.
-     */
-    private class RcDisplayDeathHandler implements IBinder.DeathRecipient {
-        private IBinder mCb; // To be notified of client's death
-
-        public RcDisplayDeathHandler(IBinder b) {
-            if (DEBUG_RC) Log.i(TAG, "new RcDisplayDeathHandler for "+b);
-            mCb = b;
-        }
-
-        public void binderDied() {
-            synchronized(mRCStack) {
-                Log.w(TAG, "RemoteControl: display died");
-                mRcDisplay = null;
-            }
-        }
-
-        public void unlinkToRcDisplayDeath() {
-            if (DEBUG_RC) Log.i(TAG, "unlinkToRcDisplayDeath for "+mCb);
-            try {
-                mCb.unlinkToDeath(this, 0);
-            } catch (java.util.NoSuchElementException e) {
-                // not much we can do here, the display was being unregistered anyway
-                Log.e(TAG, "Encountered " + e + " in unlinkToRcDisplayDeath()");
-                e.printStackTrace();
-            }
-        }
-
-    }
-
-    private void rcDisplay_stopDeathMonitor_syncRcStack() {
-        if (mRcDisplay != null) { // implies (mRcDisplayDeathHandler != null)
-            // we had a display before, stop monitoring its death
-            mRcDisplayDeathHandler.unlinkToRcDisplayDeath();
-        }
-    }
-
-    private void rcDisplay_startDeathMonitor_syncRcStack() {
-        if (mRcDisplay != null) {
-            // new non-null display, monitor its death
-            IBinder b = mRcDisplay.asBinder();
-            mRcDisplayDeathHandler = new RcDisplayDeathHandler(b);
-            try {
-                b.linkToDeath(mRcDisplayDeathHandler, 0);
-            } catch (RemoteException e) {
-                // remote control display is DOA, disqualify it
-                Log.w(TAG, "registerRemoteControlDisplay() has a dead client " + b);
-                mRcDisplay = null;
-            }
-        }
-    }
-
-    /**
-     * Register an IRemoteControlDisplay.
-     * Notify all IRemoteControlClient of the new display and cause the RemoteControlClient
-     * at the top of the stack to update the new display with its information.
-     * Since only one IRemoteControlDisplay is supported, this will unregister the previous display.
-     * @param rcd the IRemoteControlDisplay to register. No effect if null.
-     */
-    public void registerRemoteControlDisplay(IRemoteControlDisplay rcd) {
-        if (DEBUG_RC) Log.d(TAG, ">>> registerRemoteControlDisplay("+rcd+")");
-        synchronized(mAudioFocusLock) {
-            synchronized(mRCStack) {
-                if ((mRcDisplay == rcd) || (rcd == null)) {
-                    return;
-                }
-                // if we had a display before, stop monitoring its death
-                rcDisplay_stopDeathMonitor_syncRcStack();
-                mRcDisplay = rcd;
-                // new display, start monitoring its death
-                rcDisplay_startDeathMonitor_syncRcStack();
-
-                // let all the remote control clients there is a new display
-                // no need to unplug the previous because we only support one display
-                // and the clients don't track the death of the display
-                Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-                while(stackIterator.hasNext()) {
-                    RemoteControlStackEntry rcse = stackIterator.next();
-                    if(rcse.mRcClient != null) {
-                        try {
-                            rcse.mRcClient.plugRemoteControlDisplay(mRcDisplay);
-                        } catch (RemoteException e) {
-                            Log.e(TAG, "Error connecting remote control display to client: " + e);
-                            e.printStackTrace();
-                        }
-                    }
-                }
-
-                // we have a new display, of which all the clients are now aware: have it be updated
-                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-            }
-        }
-    }
-
-    /**
-     * Unregister an IRemoteControlDisplay.
-     * Since only one IRemoteControlDisplay is supported, this has no effect if the one to
-     *    unregister is not the current one.
-     * @param rcd the IRemoteControlDisplay to unregister. No effect if null.
-     */
-    public void unregisterRemoteControlDisplay(IRemoteControlDisplay rcd) {
-        if (DEBUG_RC) Log.d(TAG, "<<< unregisterRemoteControlDisplay("+rcd+")");
-        synchronized(mRCStack) {
-            // only one display here, so you can only unregister the current display
-            if ((rcd == null) || (rcd != mRcDisplay)) {
-                if (DEBUG_RC) Log.w(TAG, "    trying to unregister unregistered RCD");
-                return;
-            }
-            // if we had a display before, stop monitoring its death
-            rcDisplay_stopDeathMonitor_syncRcStack();
-            mRcDisplay = null;
-
-            // disconnect this remote control display from all the clients
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-            while(stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                if(rcse.mRcClient != null) {
-                    try {
-                        rcse.mRcClient.unplugRemoteControlDisplay(rcd);
-                    } catch (RemoteException e) {
-                        Log.e(TAG, "Error disconnecting remote control display to client: " + e);
-                        e.printStackTrace();
-                    }
-                }
-            }
-        }
-    }
-
-    public void remoteControlDisplayUsesBitmapSize(IRemoteControlDisplay rcd, int w, int h) {
-        synchronized(mRCStack) {
-            // NOTE: Only one IRemoteControlDisplay supported in this implementation
-            mArtworkExpectedWidth = w;
-            mArtworkExpectedHeight = h;
-        }
-    }
-
-    public void setPlaybackInfoForRcc(int rccId, int what, int value) {
-        sendMsg(mAudioHandler, MSG_RCC_NEW_PLAYBACK_INFO, SENDMSG_QUEUE,
-                rccId /* arg1 */, what /* arg2 */, Integer.valueOf(value) /* obj */, 0 /* delay */);
-    }
-
-    // handler for MSG_RCC_NEW_PLAYBACK_INFO
-    private void onNewPlaybackInfoForRcc(int rccId, int key, int value) {
-        if(DEBUG_RC) Log.d(TAG, "onNewPlaybackInfoForRcc(id=" + rccId +
-                ", what=" + key + ",val=" + value + ")");
-        synchronized(mRCStack) {
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-            while(stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                if (rcse.mRccId == rccId) {
-                    switch (key) {
-                        case RemoteControlClient.PLAYBACKINFO_PLAYBACK_TYPE:
-                            rcse.mPlaybackType = value;
-                            postReevaluateRemote();
-                            break;
-                        case RemoteControlClient.PLAYBACKINFO_VOLUME:
-                            rcse.mPlaybackVolume = value;
-                            synchronized (mMainRemote) {
-                                if (rccId == mMainRemote.mRccId) {
-                                    mMainRemote.mVolume = value;
-                                    hasNewRemotePlaybackInfo();
-                                }
-                            }
-                            break;
-                        case RemoteControlClient.PLAYBACKINFO_VOLUME_MAX:
-                            rcse.mPlaybackVolumeMax = value;
-                            synchronized (mMainRemote) {
-                                if (rccId == mMainRemote.mRccId) {
-                                    mMainRemote.mVolumeMax = value;
-                                    hasNewRemotePlaybackInfo();
-                                }
-                            }
-                            break;
-                        case RemoteControlClient.PLAYBACKINFO_VOLUME_HANDLING:
-                            rcse.mPlaybackVolumeHandling = value;
-                            synchronized (mMainRemote) {
-                                if (rccId == mMainRemote.mRccId) {
-                                    mMainRemote.mVolumeHandling = value;
-                                    hasNewRemotePlaybackInfo();
-                                }
-                            }
-                            break;
-                        case RemoteControlClient.PLAYBACKINFO_USES_STREAM:
-                            rcse.mPlaybackStream = value;
-                            break;
-                        case RemoteControlClient.PLAYBACKINFO_PLAYSTATE:
-                            rcse.mPlaybackState = value;
-                            synchronized (mMainRemote) {
-                                if (rccId == mMainRemote.mRccId) {
-                                    mMainRemoteIsActive = isPlaystateActive(value);
-                                    postReevaluateRemote();
-                                }
-                            }
-                            break;
-                        default:
-                            Log.e(TAG, "unhandled key " + key + " for RCC " + rccId);
-                            break;
-                    }
-                    return;
-                }
-            }
-        }
-    }
-
-    public void registerRemoteVolumeObserverForRcc(int rccId, IRemoteVolumeObserver rvo) {
-        sendMsg(mAudioHandler, MSG_RCC_NEW_VOLUME_OBS, SENDMSG_QUEUE,
-                rccId /* arg1 */, 0, rvo /* obj */, 0 /* delay */);
-    }
-
-    // handler for MSG_RCC_NEW_VOLUME_OBS
-    private void onRegisterVolumeObserverForRcc(int rccId, IRemoteVolumeObserver rvo) {
-        synchronized(mRCStack) {
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-            while(stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                if (rcse.mRccId == rccId) {
-                    rcse.mRemoteVolumeObs = rvo;
-                    break;
-                }
-            }
-        }
-    }
-
-    /**
-     * Checks if a remote client is active on the supplied stream type. Update the remote stream
-     * volume state if found and playing
-     * @param streamType
-     * @return false if no remote playing is currently playing
-     */
-    private boolean checkUpdateRemoteStateIfActive(int streamType) {
-        synchronized(mRCStack) {
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-            while(stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                if ((rcse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE)
-                        && isPlaystateActive(rcse.mPlaybackState)
-                        && (rcse.mPlaybackStream == streamType)) {
-                    if (DEBUG_RC) Log.d(TAG, "remote playback active on stream " + streamType
-                            + ", vol =" + rcse.mPlaybackVolume);
-                    synchronized (mMainRemote) {
-                        mMainRemote.mRccId = rcse.mRccId;
-                        mMainRemote.mVolume = rcse.mPlaybackVolume;
-                        mMainRemote.mVolumeMax = rcse.mPlaybackVolumeMax;
-                        mMainRemote.mVolumeHandling = rcse.mPlaybackVolumeHandling;
-                        mMainRemoteIsActive = true;
-                    }
-                    return true;
-                }
-            }
-        }
-        synchronized (mMainRemote) {
-            mMainRemoteIsActive = false;
-        }
-        return false;
-    }
-
-    /**
-     * Returns true if the given playback state is considered "active", i.e. it describes a state
-     * where playback is happening, or about to
-     * @param playState the playback state to evaluate
-     * @return true if active, false otherwise (inactive or unknown)
-     */
-    private static boolean isPlaystateActive(int playState) {
-        switch (playState) {
-            case RemoteControlClient.PLAYSTATE_PLAYING:
-            case RemoteControlClient.PLAYSTATE_BUFFERING:
-            case RemoteControlClient.PLAYSTATE_FAST_FORWARDING:
-            case RemoteControlClient.PLAYSTATE_REWINDING:
-            case RemoteControlClient.PLAYSTATE_SKIPPING_BACKWARDS:
-            case RemoteControlClient.PLAYSTATE_SKIPPING_FORWARDS:
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    private void adjustRemoteVolume(int streamType, int direction, int flags) {
-        int rccId = RemoteControlClient.RCSE_ID_UNREGISTERED;
-        boolean volFixed = false;
-        synchronized (mMainRemote) {
-            if (!mMainRemoteIsActive) {
-                if (DEBUG_VOL) Log.w(TAG, "adjustRemoteVolume didn't find an active client");
-                return;
-            }
-            rccId = mMainRemote.mRccId;
-            volFixed = (mMainRemote.mVolumeHandling ==
-                    RemoteControlClient.PLAYBACK_VOLUME_FIXED);
-        }
-        // unlike "local" stream volumes, we can't compute the new volume based on the direction,
-        // we can only notify the remote that volume needs to be updated, and we'll get an async'
-        // update through setPlaybackInfoForRcc()
-        if (!volFixed) {
-            sendVolumeUpdateToRemote(rccId, direction);
-        }
-
-        // fire up the UI
-        remoteVolumeChanged(streamType, flags);
-    }
-
-    private void sendVolumeUpdateToRemote(int rccId, int direction) {
-        if (DEBUG_VOL) { Log.d(TAG, "sendVolumeUpdateToRemote(rccId="+rccId+" , dir="+direction); }
-        if (direction == 0) {
-            // only handling discrete events
-            return;
-        }
-        IRemoteVolumeObserver rvo = null;
-        synchronized (mRCStack) {
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-            while(stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                //FIXME OPTIMIZE store this info in mMainRemote so we don't have to iterate?
-                if (rcse.mRccId == rccId) {
-                    rvo = rcse.mRemoteVolumeObs;
-                    break;
-                }
-            }
-        }
-        if (rvo != null) {
-            try {
-                rvo.dispatchRemoteVolumeUpdate(direction, -1);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Error dispatching relative volume update", e);
-            }
-        }
-    }
-
-    public int getRemoteStreamMaxVolume() {
-        synchronized (mMainRemote) {
-            if (mMainRemote.mRccId == RemoteControlClient.RCSE_ID_UNREGISTERED) {
-                return 0;
-            }
-            return mMainRemote.mVolumeMax;
-        }
-    }
-
-    public int getRemoteStreamVolume() {
-        synchronized (mMainRemote) {
-            if (mMainRemote.mRccId == RemoteControlClient.RCSE_ID_UNREGISTERED) {
-                return 0;
-            }
-            return mMainRemote.mVolume;
-        }
-    }
-
-    public void setRemoteStreamVolume(int vol) {
-        if (DEBUG_VOL) { Log.d(TAG, "setRemoteStreamVolume(vol="+vol+")"); }
-        int rccId = RemoteControlClient.RCSE_ID_UNREGISTERED;
-        synchronized (mMainRemote) {
-            if (mMainRemote.mRccId == RemoteControlClient.RCSE_ID_UNREGISTERED) {
-                return;
-            }
-            rccId = mMainRemote.mRccId;
-        }
-        IRemoteVolumeObserver rvo = null;
-        synchronized (mRCStack) {
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-            while(stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                if (rcse.mRccId == rccId) {
-                    //FIXME OPTIMIZE store this info in mMainRemote so we don't have to iterate?
-                    rvo = rcse.mRemoteVolumeObs;
-                    break;
-                }
-            }
-        }
-        if (rvo != null) {
-            try {
-                rvo.dispatchRemoteVolumeUpdate(0, vol);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Error dispatching absolute volume update", e);
-            }
-        }
-    }
-
-    /**
-     * Call to make AudioService reevaluate whether it's in a mode where remote players should
-     * have their volume controlled. In this implementation this is only to reset whether
-     * VolumePanel should display remote volumes
-     */
-    private void postReevaluateRemote() {
-        sendMsg(mAudioHandler, MSG_REEVALUATE_REMOTE, SENDMSG_QUEUE, 0, 0, null, 0);
-    }
-
-    private void onReevaluateRemote() {
-        if (DEBUG_VOL) { Log.w(TAG, "onReevaluateRemote()"); }
-        // is there a registered RemoteControlClient that is handling remote playback
-        boolean hasRemotePlayback = false;
-        synchronized (mRCStack) {
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
-            while(stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                if (rcse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE) {
-                    hasRemotePlayback = true;
-                    break;
-                }
-            }
-        }
-        synchronized (mMainRemote) {
-            if (mHasRemotePlayback != hasRemotePlayback) {
-                mHasRemotePlayback = hasRemotePlayback;
-                remoteSliderVisibility(hasRemotePlayback);
-            }
-        }
-    }
-
-    //==========================================================================================
-    // Device orientation
-    //==========================================================================================
-    /**
-     * Handles device configuration changes that may map to a change in the orientation.
-     * This feature is optional, and is defined by the definition and value of the
-     * "ro.audio.monitorOrientation" system property.
-     */
-    private void handleConfigurationChanged(Context context) {
-        try {
-            // reading new orientation "safely" (i.e. under try catch) in case anything
-            // goes wrong when obtaining resources and configuration
-            Configuration config = context.getResources().getConfiguration();
-            if (mMonitorOrientation) {
-                int newOrientation = config.orientation;
-                if (newOrientation != mDeviceOrientation) {
-                    mDeviceOrientation = newOrientation;
-                    setOrientationForAudioSystem();
-                }
-            }
-            sendMsg(mAudioHandler,
-                    MSG_CONFIGURE_SAFE_MEDIA_VOLUME,
-                    SENDMSG_REPLACE,
-                    0,
-                    0,
-                    null,
-                    0);
-
-            boolean cameraSoundForced = mContext.getResources().getBoolean(
-                    com.android.internal.R.bool.config_camera_sound_forced);
-            synchronized (mSettingsLock) {
-                synchronized (mCameraSoundForced) {
-                    if (cameraSoundForced != mCameraSoundForced) {
-                        mCameraSoundForced = cameraSoundForced;
-
-                        VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
-                        if (cameraSoundForced) {
-                            s.setAllIndexesToMax();
-                            mRingerModeAffectedStreams &=
-                                    ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
-                        } else {
-                            s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM],
-                                            false /*lastAudible*/);
-                            s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM],
-                                            true /*lastAudible*/);
-                            mRingerModeAffectedStreams |=
-                                    (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
-                        }
-                        // take new state into account for streams muted by ringer mode
-                        setRingerModeInt(getRingerMode(), false);
-
-                        sendMsg(mAudioHandler,
-                                MSG_SET_FORCE_USE,
-                                SENDMSG_QUEUE,
-                                AudioSystem.FOR_SYSTEM,
-                                cameraSoundForced ?
-                                        AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE,
-                                null,
-                                0);
-
-                        sendMsg(mAudioHandler,
-                                MSG_SET_ALL_VOLUMES,
-                                SENDMSG_QUEUE,
-                                0,
-                                0,
-                                mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
-                    }
-                }
-            }
-        } catch (Exception e) {
-            Log.e(TAG, "Error retrieving device orientation: " + e);
-        }
-    }
-
-    private void setOrientationForAudioSystem() {
-        switch (mDeviceOrientation) {
-            case Configuration.ORIENTATION_LANDSCAPE:
-                //Log.i(TAG, "orientation is landscape");
-                AudioSystem.setParameters("orientation=landscape");
-                break;
-            case Configuration.ORIENTATION_PORTRAIT:
-                //Log.i(TAG, "orientation is portrait");
-                AudioSystem.setParameters("orientation=portrait");
-                break;
-            case Configuration.ORIENTATION_SQUARE:
-                //Log.i(TAG, "orientation is square");
-                AudioSystem.setParameters("orientation=square");
-                break;
-            case Configuration.ORIENTATION_UNDEFINED:
-                //Log.i(TAG, "orientation is undefined");
-                AudioSystem.setParameters("orientation=undefined");
-                break;
-            default:
-                Log.e(TAG, "Unknown orientation");
-        }
-    }
-
-
-    // Handles request to override default use of A2DP for media.
-    public void setBluetoothA2dpOnInt(boolean on) {
-        synchronized (mBluetoothA2dpEnabledLock) {
-            mBluetoothA2dpEnabled = on;
-            mAudioHandler.removeMessages(MSG_SET_FORCE_BT_A2DP_USE);
-            AudioSystem.setForceUse(AudioSystem.FOR_MEDIA,
-                    mBluetoothA2dpEnabled ? AudioSystem.FORCE_NONE : AudioSystem.FORCE_NO_BT_A2DP);
-        }
-    }
-
-    @Override
-    public void setRingtonePlayer(IRingtonePlayer player) {
-        mContext.enforceCallingOrSelfPermission(REMOTE_AUDIO_PLAYBACK, null);
-        mRingtonePlayer = player;
-    }
-
-    @Override
-    public IRingtonePlayer getRingtonePlayer() {
-        return mRingtonePlayer;
-    }
-
-    @Override
-    public AudioRoutesInfo startWatchingRoutes(IAudioRoutesObserver observer) {
-        synchronized (mCurAudioRoutes) {
-            AudioRoutesInfo routes = new AudioRoutesInfo(mCurAudioRoutes);
-            mRoutesObservers.register(observer);
-            return routes;
-        }
-    }
-
-
-    //==========================================================================================
-    // Safe media volume management.
-    // MUSIC stream volume level is limited when headphones are connected according to safety
-    // regulation. When the user attempts to raise the volume above the limit, a warning is
-    // displayed and the user has to acknowlegde before the volume is actually changed.
-    // The volume index corresponding to the limit is stored in config_safe_media_volume_index
-    // property. Platforms with a different limit must set this property accordingly in their
-    // overlay.
-    //==========================================================================================
-
-    // mSafeMediaVolumeState indicates whether the media volume is limited over headphones.
-    // It is SAFE_MEDIA_VOLUME_NOT_CONFIGURED at boot time until a network service is connected
-    // or the configure time is elapsed. It is then set to SAFE_MEDIA_VOLUME_ACTIVE or
-    // SAFE_MEDIA_VOLUME_DISABLED according to country option. If not SAFE_MEDIA_VOLUME_DISABLED, it
-    // can be set to SAFE_MEDIA_VOLUME_INACTIVE by calling AudioService.disableSafeMediaVolume()
-    // (when user opts out).
-    private final int SAFE_MEDIA_VOLUME_NOT_CONFIGURED = 0;
-    private final int SAFE_MEDIA_VOLUME_DISABLED = 1;
-    private final int SAFE_MEDIA_VOLUME_INACTIVE = 2;
-    private final int SAFE_MEDIA_VOLUME_ACTIVE = 3;
-    private Integer mSafeMediaVolumeState;
-
-    private int mMcc = 0;
-    // mSafeVolumeEnabled indicates whether to check the volume of media play via headset
-    private boolean mSafeVolumeEnabled;
-    // mSafeMediaVolumeIndex is the cached value of config_safe_media_volume_index property
-    private int mSafeMediaVolumeIndex;
-    // mSafeMediaVolumeDevices lists the devices for which safe media volume is enforced,
-    private final int mSafeMediaVolumeDevices = AudioSystem.DEVICE_OUT_WIRED_HEADSET |
-                                                AudioSystem.DEVICE_OUT_WIRED_HEADPHONE;
-    // mMusicActiveMs is the cumulative time of music activity since safe volume was disabled.
-    // When this time reaches UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX, the safe media volume is re-enabled
-    // automatically. mMusicActiveMs is rounded to a multiple of MUSIC_ACTIVE_POLL_PERIOD_MS.
-    private int mMusicActiveMs;
-    private static final int UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX = (20 * 3600 * 1000); // 20 hours
-    private static final int MUSIC_ACTIVE_POLL_PERIOD_MS = 60000;  // 1 minute polling interval
-    private static final int SAFE_VOLUME_CONFIGURE_TIMEOUT_MS = 30000;  // 30s after boot completed
-
-    private void setSafeMediaVolumeEnabled(boolean on) {
-        synchronized (mSafeMediaVolumeState) {
-            if (mSafeVolumeEnabled &&
-                    (mSafeMediaVolumeState != SAFE_MEDIA_VOLUME_NOT_CONFIGURED) &&
-                    (mSafeMediaVolumeState != SAFE_MEDIA_VOLUME_DISABLED)) {
-                if (on && (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_INACTIVE)) {
-                    mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_ACTIVE;
-                    enforceSafeMediaVolume();
-                } else if (!on && (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE)) {
-                    mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_INACTIVE;
-                    mMusicActiveMs = 0;
-                    sendMsg(mAudioHandler,
-                            MSG_CHECK_MUSIC_ACTIVE,
-                            SENDMSG_REPLACE,
-                            0,
-                            0,
-                            null,
-                            MUSIC_ACTIVE_POLL_PERIOD_MS);
-                }
-            }
-        }
-    }
-
-    private void enforceSafeMediaVolume() {
-        VolumeStreamState streamState = mStreamStates[AudioSystem.STREAM_MUSIC];
-        boolean lastAudible = (streamState.muteCount() != 0);
-        int devices = mSafeMediaVolumeDevices;
-        int i = 0;
-
-        while (devices != 0) {
-            int device = 1 << i++;
-            if ((device & devices) == 0) {
-                continue;
-            }
-            int index = streamState.getIndex(device, lastAudible);
-            if (index > mSafeMediaVolumeIndex) {
-                if (lastAudible) {
-                    streamState.setLastAudibleIndex(mSafeMediaVolumeIndex, device);
-                    sendMsg(mAudioHandler,
-                            MSG_PERSIST_VOLUME,
-                            SENDMSG_QUEUE,
-                            PERSIST_LAST_AUDIBLE,
-                            device,
-                            streamState,
-                            PERSIST_DELAY);
-                } else {
-                    streamState.setIndex(mSafeMediaVolumeIndex, device, true);
-                    sendMsg(mAudioHandler,
-                            MSG_SET_DEVICE_VOLUME,
-                            SENDMSG_QUEUE,
-                            device,
-                            0,
-                            streamState,
-                            0);
-                }
-            }
-            devices &= ~device;
-        }
-    }
-
-    private boolean checkSafeMediaVolume(int streamType, int index, int device) {
-        synchronized (mSafeMediaVolumeState) {
-            if (mSafeVolumeEnabled &&
-                    (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE) &&
-                    (mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) &&
-                    ((device & mSafeMediaVolumeDevices) != 0) &&
-                    (index > mSafeMediaVolumeIndex)) {
-                displaySafeVolumeWarning();
-                return false;
-            }
-            return true;
-        }
-    }
-
-    public void disableSafeMediaVolume() {
-        synchronized (mSafeMediaVolumeState) {
-            setSafeMediaVolumeEnabled(false);
-        }
-    }
-
-
-    //==========================================================================================
-    // Camera shutter sound policy.
-    // config_camera_sound_forced configuration option in config.xml defines if the camera shutter
-    // sound is forced (sound even if the device is in silent mode) or not. This option is false by
-    // default and can be overridden by country specific overlay in values-mccXXX/config.xml.
-    //==========================================================================================
-
-    // cached value of com.android.internal.R.bool.config_camera_sound_forced
-    private Boolean mCameraSoundForced;
-
-    // called by android.hardware.Camera to populate CameraInfo.canDisableShutterSound
-    public boolean isCameraSoundForced() {
-        synchronized (mCameraSoundForced) {
-            return mCameraSoundForced;
-        }
-    }
-
-    private static final String[] RINGER_MODE_NAMES = new String[] {
-            "SILENT",
-            "VIBRATE",
-            "NORMAL"
-    };
-
-    private void dumpRingerMode(PrintWriter pw) {
-        pw.println("\nRinger mode: ");
-        pw.println("- mode: "+RINGER_MODE_NAMES[mRingerMode]);
-        pw.print("- ringer mode affected streams = 0x");
-        pw.println(Integer.toHexString(mRingerModeAffectedStreams));
-        pw.print("- ringer mode muted streams = 0x");
-        pw.println(Integer.toHexString(mRingerModeMutedStreams));
-    }
-
-    @Override
-    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
-
-        dumpFocusStack(pw);
-        dumpRCStack(pw);
-        dumpRCCStack(pw);
-        dumpStreamStates(pw);
-        dumpRingerMode(pw);
-        pw.println("\nAudio routes:");
-        pw.print("  mMainType=0x"); pw.println(Integer.toHexString(mCurAudioRoutes.mMainType));
-        pw.print("  mBluetoothName="); pw.println(mCurAudioRoutes.mBluetoothName);
-    }
-}
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.media;
+
+import static android.Manifest.permission.REMOTE_AUDIO_PLAYBACK;
+import static android.media.AudioManager.RINGER_MODE_NORMAL;
+import static android.media.AudioManager.RINGER_MODE_SILENT;
+import static android.media.AudioManager.RINGER_MODE_VIBRATE;
+
+import android.app.Activity;
+import android.app.ActivityManagerNative;
+import android.app.KeyguardManager;
+import android.app.PendingIntent;
+import android.app.PendingIntent.CanceledException;
+import android.app.PendingIntent.OnFinished;
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothProfile;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.media.MediaPlayer.OnCompletionListener;
+import android.media.MediaPlayer.OnErrorListener;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.PowerManager;
+import android.os.RemoteCallbackList;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.os.Vibrator;
+import android.provider.Settings;
+import android.provider.Settings.System;
+import android.provider.Settings.SettingNotFoundException;
+import android.speech.RecognizerIntent;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.VolumePanel;
+
+import com.android.internal.app.ThemeUtils;
+import com.android.internal.telephony.ITelephony;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.Stack;
+
+/**
+ * The implementation of the volume manager service.
+ * <p>
+ * This implementation focuses on delivering a responsive UI. Most methods are
+ * asynchronous to external calls. For example, the task of setting a volume
+ * will update our internal state, but in a separate thread will set the system
+ * volume and later persist to the database. Similarly, setting the ringer mode
+ * will update the state and broadcast a change and in a separate thread later
+ * persist the ringer mode.
+ *
+ * @hide
+ */
+public class AudioService extends IAudioService.Stub implements OnFinished {
+
+    private static final String TAG = "AudioService";
+
+    /** Debug remote control client/display feature */
+    protected static final boolean DEBUG_RC = false;
+    /** Debug volumes */
+    protected static final boolean DEBUG_VOL = false;
+
+    /** How long to delay before persisting a change in volume/ringer mode. */
+    private static final int PERSIST_DELAY = 500;
+
+    private Context mContext;
+    private ContentResolver mContentResolver;
+    private boolean mVoiceCapable;
+
+    /** The UI */
+    private VolumePanel mVolumePanel;
+    private Context mUiContext;
+    private Handler mHandler;
+
+    // sendMsg() flags
+    /** If the msg is already queued, replace it with this one. */
+    private static final int SENDMSG_REPLACE = 0;
+    /** If the msg is already queued, ignore this one and leave the old. */
+    private static final int SENDMSG_NOOP = 1;
+    /** If the msg is already queued, queue this one and leave the old. */
+    private static final int SENDMSG_QUEUE = 2;
+
+    // AudioHandler messages
+    private static final int MSG_SET_DEVICE_VOLUME = 0;
+    private static final int MSG_PERSIST_VOLUME = 1;
+    private static final int MSG_PERSIST_MASTER_VOLUME = 2;
+    private static final int MSG_PERSIST_RINGER_MODE = 3;
+    private static final int MSG_MEDIA_SERVER_DIED = 4;
+    private static final int MSG_MEDIA_SERVER_STARTED = 5;
+    private static final int MSG_PLAY_SOUND_EFFECT = 6;
+    private static final int MSG_BTA2DP_DOCK_TIMEOUT = 7;
+    private static final int MSG_LOAD_SOUND_EFFECTS = 8;
+    private static final int MSG_SET_FORCE_USE = 9;
+    private static final int MSG_PERSIST_MEDIABUTTONRECEIVER = 10;
+    private static final int MSG_BT_HEADSET_CNCT_FAILED = 11;
+    private static final int MSG_RCDISPLAY_CLEAR = 12;
+    private static final int MSG_RCDISPLAY_UPDATE = 13;
+    private static final int MSG_SET_ALL_VOLUMES = 14;
+    private static final int MSG_PERSIST_MASTER_VOLUME_MUTE = 15;
+    private static final int MSG_REPORT_NEW_ROUTES = 16;
+    private static final int MSG_REEVALUATE_REMOTE = 17;
+    private static final int MSG_RCC_NEW_PLAYBACK_INFO = 18;
+    private static final int MSG_RCC_NEW_VOLUME_OBS = 19;
+    private static final int MSG_SET_FORCE_BT_A2DP_USE = 20;
+    // start of messages handled under wakelock
+    //   these messages can only be queued, i.e. sent with queueMsgUnderWakeLock(),
+    //   and not with sendMsg(..., ..., SENDMSG_QUEUE, ...)
+    private static final int MSG_SET_WIRED_DEVICE_CONNECTION_STATE = 21;
+    private static final int MSG_SET_A2DP_CONNECTION_STATE = 22;
+    // end of messages handled under wakelock
+    private static final int MSG_SET_RSX_CONNECTION_STATE = 23; // change remote submix connection
+    private static final int MSG_CHECK_MUSIC_ACTIVE = 24;
+    private static final int MSG_BROADCAST_AUDIO_BECOMING_NOISY = 25;
+    private static final int MSG_CONFIGURE_SAFE_MEDIA_VOLUME = 26;
+    private static final int MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED = 27;
+    private static final int MSG_PERSIST_SAFE_VOLUME_STATE = 28;
+
+    // flags for MSG_PERSIST_VOLUME indicating if current and/or last audible volume should be
+    // persisted
+    private static final int PERSIST_CURRENT = 0x1;
+    private static final int PERSIST_LAST_AUDIBLE = 0x2;
+
+    private static final int BTA2DP_DOCK_TIMEOUT_MILLIS = 8000;
+    // Timeout for connection to bluetooth headset service
+    private static final int BT_HEADSET_CNCT_TIMEOUT_MS = 3000;
+
+    /** @see AudioSystemThread */
+    private AudioSystemThread mAudioSystemThread;
+    /** @see AudioHandler */
+    private AudioHandler mAudioHandler;
+    /** @see VolumeStreamState */
+    private VolumeStreamState[] mStreamStates;
+    private SettingsObserver mSettingsObserver;
+    private boolean noDelayInATwoDP =
+            Resources.getSystem().getBoolean(com.android.internal.R.bool.config_noDelayInATwoDP);
+
+    private int mMode;
+    // protects mRingerMode
+    private final Object mSettingsLock = new Object();
+
+    private boolean mMediaServerOk;
+
+    private SoundPool mSoundPool;
+    private final Object mSoundEffectsLock = new Object();
+    private static final int NUM_SOUNDPOOL_CHANNELS = 4;
+
+    // Internally master volume is a float in the 0.0 - 1.0 range,
+    // but to support integer based AudioManager API we translate it to 0 - 100
+    private static final int MAX_MASTER_VOLUME = 100;
+
+    // Maximum volume adjust steps allowed in a single batch call.
+    private static final int MAX_BATCH_VOLUME_ADJUST_STEPS = 4;
+
+    /* Sound effect file names  */
+    private static final String SOUND_EFFECTS_PATH = "/media/audio/ui/";
+    private static final String[] SOUND_EFFECT_FILES = new String[] {
+        "Effect_Tick.ogg",
+        "KeypressStandard.ogg",
+        "KeypressSpacebar.ogg",
+        "KeypressDelete.ogg",
+        "KeypressReturn.ogg"
+    };
+
+    /* Sound effect file name mapping sound effect id (AudioManager.FX_xxx) to
+     * file index in SOUND_EFFECT_FILES[] (first column) and indicating if effect
+     * uses soundpool (second column) */
+    private final int[][] SOUND_EFFECT_FILES_MAP = new int[][] {
+        {0, -1},  // FX_KEY_CLICK
+        {0, -1},  // FX_FOCUS_NAVIGATION_UP
+        {0, -1},  // FX_FOCUS_NAVIGATION_DOWN
+        {0, -1},  // FX_FOCUS_NAVIGATION_LEFT
+        {0, -1},  // FX_FOCUS_NAVIGATION_RIGHT
+        {1, -1},  // FX_KEYPRESS_STANDARD
+        {2, -1},  // FX_KEYPRESS_SPACEBAR
+        {3, -1},  // FX_FOCUS_DELETE
+        {4, -1}   // FX_FOCUS_RETURN
+    };
+
+   /** @hide Maximum volume index values for audio streams */
+    private final int[] MAX_STREAM_VOLUME = new int[] {
+        5,  // STREAM_VOICE_CALL
+        7,  // STREAM_SYSTEM
+        7,  // STREAM_RING
+        15, // STREAM_MUSIC
+        7,  // STREAM_ALARM
+        7,  // STREAM_NOTIFICATION
+        15, // STREAM_BLUETOOTH_SCO
+        7,  // STREAM_SYSTEM_ENFORCED
+        15, // STREAM_DTMF
+        15, // STREAM_TTS
+        15  // STREAM_FM
+    };
+    /* mStreamVolumeAlias[] indicates for each stream if it uses the volume settings
+     * of another stream: This avoids multiplying the volume settings for hidden
+     * stream types that follow other stream behavior for volume settings
+     * NOTE: do not create loops in aliases!
+     * Some streams alias to different streams according to device category (phone or tablet) or
+     * use case (in call s off call...).See updateStreamVolumeAlias() for more details
+     *  STREAM_VOLUME_ALIAS contains the default aliases for a voice capable device (phone) and
+     *  STREAM_VOLUME_ALIAS_NON_VOICE for a non voice capable device (tablet).*/
+    private final int[] STREAM_VOLUME_ALIAS = new int[] {
+        AudioSystem.STREAM_VOICE_CALL,      // STREAM_VOICE_CALL
+        AudioSystem.STREAM_RING,            // STREAM_SYSTEM
+        AudioSystem.STREAM_RING,            // STREAM_RING
+        AudioSystem.STREAM_MUSIC,           // STREAM_MUSIC
+        AudioSystem.STREAM_ALARM,           // STREAM_ALARM
+        AudioSystem.STREAM_RING,            // STREAM_NOTIFICATION
+        AudioSystem.STREAM_BLUETOOTH_SCO,   // STREAM_BLUETOOTH_SCO
+        AudioSystem.STREAM_RING,            // STREAM_SYSTEM_ENFORCED
+        AudioSystem.STREAM_RING,            // STREAM_DTMF
+        AudioSystem.STREAM_MUSIC,           // STREAM_TTS
+        AudioSystem.STREAM_FM               
+    };
+    private final int[] STREAM_VOLUME_ALIAS_NON_VOICE = new int[] {
+        AudioSystem.STREAM_VOICE_CALL,      // STREAM_VOICE_CALL
+        AudioSystem.STREAM_MUSIC,           // STREAM_SYSTEM
+        AudioSystem.STREAM_RING,            // STREAM_RING
+        AudioSystem.STREAM_MUSIC,           // STREAM_MUSIC
+        AudioSystem.STREAM_ALARM,           // STREAM_ALARM
+        AudioSystem.STREAM_RING,            // STREAM_NOTIFICATION
+        AudioSystem.STREAM_BLUETOOTH_SCO,   // STREAM_BLUETOOTH_SCO
+        AudioSystem.STREAM_MUSIC,           // STREAM_SYSTEM_ENFORCED
+        AudioSystem.STREAM_MUSIC,           // STREAM_DTMF
+        AudioSystem.STREAM_MUSIC,           // STREAM_TTS
+        AudioSystem.STREAM_FM
+    };
+    private int[] mStreamVolumeAlias;
+
+    // stream names used by dumpStreamStates()
+    private final String[] STREAM_NAMES = new String[] {
+            "STREAM_VOICE_CALL",
+            "STREAM_SYSTEM",
+            "STREAM_RING",
+            "STREAM_MUSIC",
+            "STREAM_ALARM",
+            "STREAM_NOTIFICATION",
+            "STREAM_BLUETOOTH_SCO",
+            "STREAM_SYSTEM_ENFORCED",
+            "STREAM_DTMF",
+            "STREAM_TTS",
+            "STREAM_FM"
+    };
+
+    private boolean mLinkNotificationWithVolume;
+
+    private final AudioSystem.ErrorCallback mAudioSystemCallback = new AudioSystem.ErrorCallback() {
+        public void onError(int error) {
+            switch (error) {
+            case AudioSystem.AUDIO_STATUS_SERVER_DIED:
+                if (mMediaServerOk) {
+                    sendMsg(mAudioHandler, MSG_MEDIA_SERVER_DIED, SENDMSG_NOOP, 0, 0,
+                            null, 1500);
+                    mMediaServerOk = false;
+                }
+                break;
+            case AudioSystem.AUDIO_STATUS_OK:
+                if (!mMediaServerOk) {
+                    sendMsg(mAudioHandler, MSG_MEDIA_SERVER_STARTED, SENDMSG_NOOP, 0, 0,
+                            null, 0);
+                    mMediaServerOk = true;
+                }
+                break;
+            default:
+                break;
+            }
+       }
+    };
+
+    /**
+     * Current ringer mode from one of {@link AudioManager#RINGER_MODE_NORMAL},
+     * {@link AudioManager#RINGER_MODE_SILENT}, or
+     * {@link AudioManager#RINGER_MODE_VIBRATE}.
+     */
+    // protected by mSettingsLock
+    private int mRingerMode;
+    // last non-normal ringer mode
+    private int mLastSilentRingerMode = -1;
+
+    /** @see System#MODE_RINGER_STREAMS_AFFECTED */
+    private int mRingerModeAffectedStreams;
+
+    // Streams currently muted by ringer mode
+    private int mRingerModeMutedStreams;
+
+    /** @see System#MUTE_STREAMS_AFFECTED */
+    private int mMuteAffectedStreams;
+
+    /**
+     * NOTE: setVibrateSetting(), getVibrateSetting(), shouldVibrate() are deprecated.
+     * mVibrateSetting is just maintained during deprecation period but vibration policy is
+     * now only controlled by mHasVibrator and mRingerMode
+     */
+    private int mVibrateSetting;
+
+    // Is there a vibrator
+    private final boolean mHasVibrator;
+
+    // Broadcast receiver for device connections intent broadcasts
+    private final BroadcastReceiver mReceiver = new AudioServiceBroadcastReceiver();
+
+    // Used to alter media button redirection when the phone is ringing.
+    private boolean mIsRinging = false;
+
+    // Devices currently connected
+    private final HashMap <Integer, String> mConnectedDevices = new HashMap <Integer, String>();
+
+    // Forced device usage for communications
+    private int mForcedUseForComm;
+
+    // True if we have master volume support
+    private final boolean mUseMasterVolume;
+
+    private final int[] mMasterVolumeRamp;
+
+    // List of binder death handlers for setMode() client processes.
+    // The last process to have called setMode() is at the top of the list.
+    private final ArrayList <SetModeDeathHandler> mSetModeDeathHandlers = new ArrayList <SetModeDeathHandler>();
+
+    // List of clients having issued a SCO start request
+    private final ArrayList <ScoClient> mScoClients = new ArrayList <ScoClient>();
+
+    // BluetoothHeadset API to control SCO connection
+    private BluetoothHeadset mBluetoothHeadset;
+
+    // Bluetooth headset device
+    private BluetoothDevice mBluetoothHeadsetDevice;
+
+    // Indicate if SCO audio connection is currently active and if the initiator is
+    // audio service (internal) or bluetooth headset (external)
+    private int mScoAudioState;
+    // SCO audio state is not active
+    private static final int SCO_STATE_INACTIVE = 0;
+    // SCO audio activation request waiting for headset service to connect
+    private static final int SCO_STATE_ACTIVATE_REQ = 1;
+    // SCO audio state is active or starting due to a local request to start a virtual call
+    private static final int SCO_STATE_ACTIVE_INTERNAL = 3;
+    // SCO audio deactivation request waiting for headset service to connect
+    private static final int SCO_STATE_DEACTIVATE_REQ = 5;
+
+    // SCO audio state is active due to an action in BT handsfree (either voice recognition or
+    // in call audio)
+    private static final int SCO_STATE_ACTIVE_EXTERNAL = 2;
+    // Deactivation request for all SCO connections (initiated by audio mode change)
+    // waiting for headset service to connect
+    private static final int SCO_STATE_DEACTIVATE_EXT_REQ = 4;
+
+    // Current connection state indicated by bluetooth headset
+    private int mScoConnectionState;
+
+    // true if boot sequence has been completed
+    private boolean mBootCompleted;
+    // listener for SoundPool sample load completion indication
+    private SoundPoolCallback mSoundPoolCallBack;
+    // thread for SoundPool listener
+    private SoundPoolListenerThread mSoundPoolListenerThread;
+    // message looper for SoundPool listener
+    private Looper mSoundPoolLooper = null;
+    // volume applied to sound played with playSoundEffect()
+    private static int sSoundEffectVolumeDb;
+    // getActiveStreamType() will return:
+    // - STREAM_NOTIFICATION on tablets during this period after a notification stopped
+    // - STREAM_MUSIC on phones during this period after music or talkback/voice search prompt
+    // stopped
+    private static final int DEFAULT_STREAM_TYPE_OVERRIDE_DELAY_MS = 5000;
+    // previous volume adjustment direction received by checkForRingerModeChange()
+    private int mPrevVolDirection = AudioManager.ADJUST_SAME;
+    // Keyguard manager proxy
+    private KeyguardManager mKeyguardManager;
+    // mVolumeControlStream is set by VolumePanel to temporarily force the stream type which volume
+    // is controlled by Vol keys.
+    private int  mVolumeControlStream = -1;
+    private final Object mForceControlStreamLock = new Object();
+    // VolumePanel is currently the only client of forceVolumeControlStream() and runs in system
+    // server process so in theory it is not necessary to monitor the client death.
+    // However it is good to be ready for future evolutions.
+    private ForceControlStreamClient mForceControlStreamClient = null;
+    // Used to play ringtones outside system_server
+    private volatile IRingtonePlayer mRingtonePlayer;
+
+    private int mDeviceOrientation = Configuration.ORIENTATION_UNDEFINED;
+
+    // Request to override default use of A2DP for media.
+    private boolean mBluetoothA2dpEnabled;
+    private final Object mBluetoothA2dpEnabledLock = new Object();
+
+    // Monitoring of audio routes.  Protected by mCurAudioRoutes.
+    final AudioRoutesInfo mCurAudioRoutes = new AudioRoutesInfo();
+    final RemoteCallbackList<IAudioRoutesObserver> mRoutesObservers
+            = new RemoteCallbackList<IAudioRoutesObserver>();
+
+    /**
+     * A fake stream type to match the notion of remote media playback
+     */
+    public final static int STREAM_REMOTE_MUSIC = -200;
+
+    // Devices for which the volume is fixed and VolumePanel slider should be disabled
+    final int mFixedVolumeDevices = AudioSystem.DEVICE_OUT_AUX_DIGITAL |
+            AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
+            AudioSystem.DEVICE_OUT_ALL_USB;
+
+    private final boolean mMonitorOrientation;
+
+    private boolean mDockAudioMediaEnabled = true;
+
+    private boolean mForceAnalogDeskDock;
+    private boolean mForceAnalogCarDock;
+
+    private int mDockState = Intent.EXTRA_DOCK_STATE_UNDOCKED;
+
+    private boolean mVolumeKeysControlRingStream;
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Construction
+    ///////////////////////////////////////////////////////////////////////////
+
+    /** @hide */
+    public AudioService(Context context) {
+        mContext = context;
+        mContentResolver = context.getContentResolver();
+        mHandler = new Handler();
+        mVoiceCapable = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_voice_capable);
+
+        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        mMediaEventWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "handleMediaEvent");
+
+        Vibrator vibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
+        mHasVibrator = vibrator == null ? false : vibrator.hasVibrator();
+
+       // Intialized volume
+        MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL] = SystemProperties.getInt(
+            "ro.config.vc_call_vol_steps",
+           MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
+
+        sSoundEffectVolumeDb = context.getResources().getInteger(
+                com.android.internal.R.integer.config_soundEffectVolumeDb);
+
+        mMode = AudioSystem.MODE_NORMAL;
+        mForcedUseForComm = AudioSystem.FORCE_NONE;
+
+        createAudioSystemThread();
+
+        boolean cameraSoundForced = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_camera_sound_forced);
+        mCameraSoundForced = new Boolean(cameraSoundForced);
+        sendMsg(mAudioHandler,
+                MSG_SET_FORCE_USE,
+                SENDMSG_QUEUE,
+                AudioSystem.FOR_SYSTEM,
+                cameraSoundForced ?
+                        AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE,
+                null,
+                0);
+
+        mSafeMediaVolumeState = new Integer(Settings.Global.getInt(mContentResolver,
+                                                        Settings.Global.AUDIO_SAFE_VOLUME_STATE,
+                                                        SAFE_MEDIA_VOLUME_NOT_CONFIGURED));
+        // The default safe volume index read here will be replaced by the actual value when
+        // the mcc is read by onConfigureSafeVolume()
+        mSafeMediaVolumeIndex = mContext.getResources().getInteger(
+                com.android.internal.R.integer.config_safe_media_volume_index) * 10;
+
+        readPersistedSettings();
+        mSettingsObserver = new SettingsObserver();
+        updateStreamVolumeAlias(false /*updateVolumes*/);
+        createStreamStates();
+
+        mMediaServerOk = true;
+
+        // Call setRingerModeInt() to apply correct mute
+        // state on streams affected by ringer mode.
+        mRingerModeMutedStreams = 0;
+        setRingerModeInt(getRingerMode(), false);
+
+        AudioSystem.setErrorCallback(mAudioSystemCallback);
+
+        // Register for device connection intent broadcasts.
+        IntentFilter intentFilter =
+                new IntentFilter(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
+        if (noDelayInATwoDP) {
+            intentFilter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+        }
+        intentFilter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+        intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
+        intentFilter.addAction(Intent.ACTION_FM);
+        intentFilter.addAction(Intent.ACTION_FM_TX);		
+        intentFilter.addAction(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG);
+        intentFilter.addAction(Intent.ACTION_USB_AUDIO_DEVICE_PLUG);
+        intentFilter.addAction(Intent.ACTION_BOOT_COMPLETED);
+        intentFilter.addAction(Intent.ACTION_SCREEN_ON);
+        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
+        intentFilter.addAction(Intent.ACTION_USER_BACKGROUND);
+        intentFilter.addAction(Intent.ACTION_USER_SWITCHED);
+        intentFilter.addAction(Intent.ACTION_WIFI_DISPLAY_AUDIO);
+        intentFilter.addAction(Intent.ACTION_HEADSET_PLUG);
+
+        intentFilter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
+        // Register a configuration change listener only if requested by system properties
+        // to monitor orientation changes (off by default)
+        mMonitorOrientation = SystemProperties.getBoolean("ro.audio.monitorOrientation", false);
+        if (mMonitorOrientation) {
+            Log.v(TAG, "monitoring device orientation");
+            // initialize orientation in AudioSystem
+            setOrientationForAudioSystem();
+        }
+
+        context.registerReceiver(mReceiver, intentFilter);
+
+        // Register for package removal intent broadcasts for media button receiver persistence
+        IntentFilter pkgFilter = new IntentFilter();
+        pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
+        pkgFilter.addDataScheme("package");
+        context.registerReceiver(mReceiver, pkgFilter);
+
+        ThemeUtils.registerThemeChangeReceiver(context, new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                mUiContext = null;
+            }
+        });
+
+        // Register for phone state monitoring
+        TelephonyManager tmgr = (TelephonyManager)
+                context.getSystemService(Context.TELEPHONY_SERVICE);
+        tmgr.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);
+
+        mUseMasterVolume = context.getResources().getBoolean(
+                com.android.internal.R.bool.config_useMasterVolume);
+        restoreMasterVolume();
+
+        mMasterVolumeRamp = context.getResources().getIntArray(
+                com.android.internal.R.array.config_masterVolumeRamp);
+
+        mForceAnalogDeskDock = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_forceAnalogDeskDock);
+
+        mForceAnalogCarDock = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_forceAnalogCarDock);
+
+        mMainRemote = new RemotePlaybackState(-1, MAX_STREAM_VOLUME[AudioManager.STREAM_MUSIC],
+                MAX_STREAM_VOLUME[AudioManager.STREAM_MUSIC]);
+        mHasRemotePlayback = false;
+        mMainRemoteIsActive = false;
+        postReevaluateRemote();
+    }
+
+    private void createAudioSystemThread() {
+        mAudioSystemThread = new AudioSystemThread();
+        mAudioSystemThread.start();
+        waitForAudioHandlerCreation();
+    }
+
+    /** Waits for the volume handler to be created by the other thread. */
+    private void waitForAudioHandlerCreation() {
+        synchronized(this) {
+            while (mAudioHandler == null) {
+                try {
+                    // Wait for mAudioHandler to be set by the other thread
+                    wait();
+                } catch (InterruptedException e) {
+                    Log.e(TAG, "Interrupted while waiting on volume handler.");
+                }
+            }
+        }
+    }
+
+    private void checkAllAliasStreamVolumes() {
+        int numStreamTypes = AudioSystem.getNumStreamTypes();
+        for (int streamType = 0; streamType < numStreamTypes; streamType++) {
+            if (streamType != mStreamVolumeAlias[streamType]) {
+                mStreamStates[streamType].
+                                    setAllIndexes(mStreamStates[mStreamVolumeAlias[streamType]],
+                                                  false /*lastAudible*/);
+                mStreamStates[streamType].
+                                    setAllIndexes(mStreamStates[mStreamVolumeAlias[streamType]],
+                                                  true /*lastAudible*/);
+            }
+            // apply stream volume
+            if (mStreamStates[streamType].muteCount() == 0) {
+                mStreamStates[streamType].applyAllVolumes();
+            }
+        }
+    }
+
+    private void createStreamStates() {
+        int numStreamTypes = AudioSystem.getNumStreamTypes();
+        VolumeStreamState[] streams = mStreamStates = new VolumeStreamState[numStreamTypes];
+
+        for (int i = 0; i < numStreamTypes; i++) {
+            streams[i] = new VolumeStreamState(System.VOLUME_SETTINGS[mStreamVolumeAlias[i]], i);
+        }
+
+        checkAllAliasStreamVolumes();
+    }
+
+    private void dumpStreamStates(PrintWriter pw) {
+        pw.println("\nStream volumes (device: index)");
+        int numStreamTypes = AudioSystem.getNumStreamTypes();
+        for (int i = 0; i < numStreamTypes; i++) {
+            pw.println("- "+STREAM_NAMES[i]+":");
+            mStreamStates[i].dump(pw);
+            pw.println("");
+        }
+        pw.print("\n- mute affected streams = 0x");
+        pw.println(Integer.toHexString(mMuteAffectedStreams));
+    }
+
+
+    private void updateStreamVolumeAlias(boolean updateVolumes) {
+        int dtmfStreamAlias;
+        if (mVoiceCapable) {
+            mStreamVolumeAlias = STREAM_VOLUME_ALIAS;
+            dtmfStreamAlias = AudioSystem.STREAM_RING;
+        } else {
+            mStreamVolumeAlias = STREAM_VOLUME_ALIAS_NON_VOICE;
+            dtmfStreamAlias = AudioSystem.STREAM_MUSIC;
+        }
+        if (isInCommunication()) {
+            dtmfStreamAlias = AudioSystem.STREAM_VOICE_CALL;
+        }
+        mStreamVolumeAlias[AudioSystem.STREAM_DTMF] = dtmfStreamAlias;
+
+        if (mLinkNotificationWithVolume) {
+            mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_RING;
+        } else {
+            mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_NOTIFICATION;
+        }
+
+        if (updateVolumes) {
+            mStreamStates[AudioSystem.STREAM_DTMF].setAllIndexes(mStreamStates[dtmfStreamAlias],
+                                                                 false /*lastAudible*/);
+            mStreamStates[AudioSystem.STREAM_DTMF].setAllIndexes(mStreamStates[dtmfStreamAlias],
+                                                                 true /*lastAudible*/);
+            sendMsg(mAudioHandler,
+                    MSG_SET_ALL_VOLUMES,
+                    SENDMSG_QUEUE,
+                    0,
+                    0,
+                    mStreamStates[AudioSystem.STREAM_DTMF], 0);
+        }
+    }
+
+    private void readDockAudioSettings(ContentResolver cr)
+    {
+        mDockAudioMediaEnabled = Settings.Global.getInt(
+                                        cr, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED, 0) == 1;
+
+        if (mDockAudioMediaEnabled) {
+            mBecomingNoisyIntentDevices |= AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET;
+        } else {
+            mBecomingNoisyIntentDevices &= ~AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET;
+        }
+
+        sendMsg(mAudioHandler,
+                MSG_SET_FORCE_USE,
+                SENDMSG_QUEUE,
+                AudioSystem.FOR_DOCK,
+                mDockAudioMediaEnabled ?
+                        AudioSystem.FORCE_ANALOG_DOCK : AudioSystem.FORCE_NONE,
+                null,
+                0);
+    }
+
+    private boolean safeVolumeEnabled(ContentResolver cr) {
+        boolean safeMediaVolumeEnabled = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_safe_media_volume_enabled);
+        boolean safeHeadsetVolumeEnabled = Settings.System.getIntForUser(cr,
+                Settings.System.SAFE_HEADSET_VOLUME, safeMediaVolumeEnabled ? 1 : 0,
+                UserHandle.USER_CURRENT_OR_SELF) != 0;
+        return safeHeadsetVolumeEnabled;
+    }
+
+    private void readPersistedSettings() {
+        final ContentResolver cr = mContentResolver;
+
+        int ringerModeFromSettings =
+                Settings.Global.getInt(
+                        cr, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
+        int ringerMode = ringerModeFromSettings;
+        // sanity check in case the settings are restored from a device with incompatible
+        // ringer modes
+        if (!AudioManager.isValidRingerMode(ringerMode)) {
+            ringerMode = AudioManager.RINGER_MODE_NORMAL;
+        }
+        if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
+            ringerMode = AudioManager.RINGER_MODE_SILENT;
+        }
+        if (ringerMode != ringerModeFromSettings) {
+            Settings.Global.putInt(cr, Settings.Global.MODE_RINGER, ringerMode);
+        }
+        synchronized(mSettingsLock) {
+            mRingerMode = ringerMode;
+
+            // System.VIBRATE_ON is not used any more but defaults for mVibrateSetting
+            // are still needed while setVibrateSetting() and getVibrateSetting() are being
+            // deprecated.
+            mVibrateSetting = getValueForVibrateSetting(0,
+                                            AudioManager.VIBRATE_TYPE_NOTIFICATION,
+                                            mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT
+                                                            : AudioManager.VIBRATE_SETTING_OFF);
+            mVibrateSetting = getValueForVibrateSetting(mVibrateSetting,
+                                            AudioManager.VIBRATE_TYPE_RINGER,
+                                            mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT
+                                                            : AudioManager.VIBRATE_SETTING_OFF);
+
+            // make sure settings for ringer mode are consistent with device type: non voice capable
+            // devices (tablets) include media stream in silent mode whereas phones don't.
+            mRingerModeAffectedStreams = Settings.System.getIntForUser(cr,
+                    Settings.System.MODE_RINGER_STREAMS_AFFECTED,
+                    ((1 << AudioSystem.STREAM_RING)|(1 << AudioSystem.STREAM_NOTIFICATION)|
+                     (1 << AudioSystem.STREAM_SYSTEM)|(1 << AudioSystem.STREAM_SYSTEM_ENFORCED)),
+                     UserHandle.USER_CURRENT);
+
+            // ringtone and system streams are always affected by ringer mode
+            mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_RING)|
+                                            (1 << AudioSystem.STREAM_SYSTEM);
+
+            if (mVoiceCapable) {
+                mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_MUSIC);
+            } else {
+                mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_MUSIC);
+            }
+            synchronized (mCameraSoundForced) {
+                if (mCameraSoundForced) {
+                    mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
+                } else {
+                    mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
+                }
+            }
+
+            Settings.System.putIntForUser(cr,
+                    Settings.System.MODE_RINGER_STREAMS_AFFECTED,
+                    mRingerModeAffectedStreams,
+                    UserHandle.USER_CURRENT);
+
+            readDockAudioSettings(cr);
+
+            mSafeVolumeEnabled = new Boolean(safeVolumeEnabled(cr));
+
+            mVolumeKeysControlRingStream = Settings.System.getIntForUser(cr,
+                    Settings.System.VOLUME_KEYS_CONTROL_RING_STREAM, 1, UserHandle.USER_CURRENT) == 1;
+        }
+
+        mLinkNotificationWithVolume = Settings.System.getIntForUser(cr,
+                Settings.System.VOLUME_LINK_NOTIFICATION, 1, UserHandle.USER_CURRENT) == 1;
+
+        mMuteAffectedStreams = System.getIntForUser(cr,
+                System.MUTE_STREAMS_AFFECTED,
+                ((1 << AudioSystem.STREAM_MUSIC)|
+                 (1 << AudioSystem.STREAM_RING)|
+                 (1 << AudioSystem.STREAM_SYSTEM)),
+                 UserHandle.USER_CURRENT);
+        //Add STREAM_FM in mMuteAffectedStreams
+        mMuteAffectedStreams |= (1 << AudioSystem.STREAM_FM);
+ 				 
+
+        boolean masterMute = System.getIntForUser(cr, System.VOLUME_MASTER_MUTE,
+                                                  0, UserHandle.USER_CURRENT) == 1;
+        AudioSystem.setMasterMute(masterMute);
+        broadcastMasterMuteStatus(masterMute);
+
+        // Each stream will read its own persisted settings
+
+        // Broadcast the sticky intent
+        broadcastRingerMode(ringerMode);
+
+        // Broadcast vibrate settings
+        broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
+        broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
+
+        // Restore the default media button receiver from the system settings
+        restoreMediaButtonReceiver();
+    }
+
+    private int rescaleIndex(int index, int srcStream, int dstStream) {
+        return (index * mStreamStates[dstStream].getMaxIndex() + mStreamStates[srcStream].getMaxIndex() / 2) / mStreamStates[srcStream].getMaxIndex();
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // IPC methods
+    ///////////////////////////////////////////////////////////////////////////
+
+    /** @see AudioManager#adjustVolume(int, int) */
+    public void adjustVolume(int direction, int flags) {
+        adjustSuggestedStreamVolume(direction, AudioManager.USE_DEFAULT_STREAM_TYPE, flags);
+    }
+
+    /** @see AudioManager#adjustLocalOrRemoteStreamVolume(int, int) with current assumption
+     *  on streamType: fixed to STREAM_MUSIC */
+    public void adjustLocalOrRemoteStreamVolume(int streamType, int direction) {
+        if (DEBUG_VOL) Log.d(TAG, "adjustLocalOrRemoteStreamVolume(dir="+direction+")");
+        if (checkUpdateRemoteStateIfActive(AudioSystem.STREAM_MUSIC)) {
+            adjustRemoteVolume(AudioSystem.STREAM_MUSIC, direction, 0);
+        } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0)) {
+            adjustStreamVolume(AudioSystem.STREAM_MUSIC, direction, 0);
+        } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_FM, 0)) {
+            adjustStreamVolume(AudioSystem.STREAM_FM, direction, 0);			
+        }
+    }
+
+    /** @see AudioManager#adjustVolume(int, int, int) */
+    public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags) {
+        if (DEBUG_VOL) Log.d(TAG, "adjustSuggestedStreamVolume() stream="+suggestedStreamType);
+        int streamType;
+        if (mVolumeControlStream != -1) {
+            streamType = mVolumeControlStream;
+        } else {
+            streamType = getActiveStreamType(suggestedStreamType);
+        }
+
+        // Play sounds on STREAM_RING only and if lock screen is not on.
+        if ((streamType != STREAM_REMOTE_MUSIC) &&
+                (flags & AudioManager.FLAG_PLAY_SOUND) != 0 &&
+                ((mStreamVolumeAlias[streamType] != AudioSystem.STREAM_RING)
+                 || (mKeyguardManager != null && mKeyguardManager.isKeyguardLocked()))) {
+            flags &= ~AudioManager.FLAG_PLAY_SOUND;
+        }
+
+        if (streamType == STREAM_REMOTE_MUSIC) {
+            // don't play sounds for remote
+            flags &= ~(AudioManager.FLAG_PLAY_SOUND|AudioManager.FLAG_FIXED_VOLUME);
+            //if (DEBUG_VOL) Log.i(TAG, "Need to adjust remote volume: calling adjustRemoteVolume()");
+            adjustRemoteVolume(AudioSystem.STREAM_MUSIC, direction, flags);
+        } else {
+            adjustStreamVolume(streamType, direction, flags);
+        }
+    }
+
+    /** @see AudioManager#adjustStreamVolume(int, int, int) */
+    public void adjustStreamVolume(int streamType, int direction, int flags) {
+        if (DEBUG_VOL) Log.d(TAG, "adjustStreamVolume() stream="+streamType+", dir="+direction);
+
+        ensureValidDirection(direction);
+        ensureValidStreamType(streamType);
+
+        // use stream type alias here so that streams with same alias have the same behavior,
+        // including with regard to silent mode control (e.g the use of STREAM_RING below and in
+        // checkForRingerModeChange() in place of STREAM_RING or STREAM_NOTIFICATION)
+        int streamTypeAlias = mStreamVolumeAlias[streamType];
+        VolumeStreamState streamState = mStreamStates[streamTypeAlias];
+
+        final int device = getDeviceForStream(streamTypeAlias);
+        // get last audible index if stream is muted, current index otherwise
+        final int aliasIndex = streamState.getIndex(device,
+                                                  (streamState.muteCount() != 0) /* lastAudible */);
+        boolean adjustVolume = true;
+
+        // convert one UI step (+/-1) into a number of internal units on the stream alias
+        int step = rescaleIndex(10, streamType, streamTypeAlias);
+
+        int index;
+        int oldIndex;
+
+        if ((direction == AudioManager.ADJUST_RAISE) &&
+                !checkSafeMediaVolume(streamTypeAlias, aliasIndex + step, device)) {
+            index = mStreamStates[streamType].getIndex(device,
+                                                 (streamState.muteCount() != 0)  /* lastAudible */);
+            oldIndex = index;
+        } else {
+            flags &= ~AudioManager.FLAG_FIXED_VOLUME;
+            if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) &&
+                   ((device & mFixedVolumeDevices) != 0)) {
+                flags |= AudioManager.FLAG_FIXED_VOLUME;
+                index = mStreamStates[streamType].getMaxIndex();
+                oldIndex = index;
+            } else {
+                // If either the client forces allowing ringer modes for this adjustment,
+                // or the stream type is one that is affected by ringer modes
+                if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) ||
+                        (streamTypeAlias == getMasterStreamType())) {
+                    int ringerMode = getRingerMode();
+                    // do not vibrate if already in vibrate mode
+                    if (ringerMode == AudioManager.RINGER_MODE_VIBRATE) {
+                        flags &= ~AudioManager.FLAG_VIBRATE;
+                    }
+                    // Check if the ringer mode changes with this volume adjustment. If
+                    // it does, it will handle adjusting the volume, so we won't below
+                    adjustVolume = checkForRingerModeChange(aliasIndex, direction, step);
+                    if ((streamTypeAlias == getMasterStreamType()) &&
+                            (mRingerMode == AudioManager.RINGER_MODE_SILENT)) {
+                        streamState.setLastAudibleIndex(0, device);
+                    }
+                }
+
+                // If stream is muted, adjust last audible index only
+                oldIndex = mStreamStates[streamType].getIndex(device,
+                        (mStreamStates[streamType].muteCount() != 0) /* lastAudible */);
+
+                if (streamState.muteCount() != 0) {
+                    if (adjustVolume) {
+                        // Post a persist volume msg
+                        // no need to persist volume on all streams sharing the same alias
+                        streamState.adjustLastAudibleIndex(direction * step, device);
+                        sendMsg(mAudioHandler,
+                                MSG_PERSIST_VOLUME,
+                                SENDMSG_QUEUE,
+                                PERSIST_LAST_AUDIBLE,
+                                device,
+                                streamState,
+                                PERSIST_DELAY);
+                    }
+                    index = mStreamStates[streamType].getIndex(device, true  /* lastAudible */);
+                } else {
+                    if (adjustVolume && streamState.adjustIndex(direction * step, device)) {
+                        // Post message to set system volume (it in turn will post a message
+                        // to persist). Do not change volume if stream is muted.
+                        sendMsg(mAudioHandler,
+                                MSG_SET_DEVICE_VOLUME,
+                                SENDMSG_QUEUE,
+                                device,
+                                0,
+                                streamState,
+                                0);
+                    }
+                    index = mStreamStates[streamType].getIndex(device, false  /* lastAudible */);
+                }
+            }
+        }
+        sendVolumeUpdate(streamType, oldIndex, index, flags);
+    }
+
+    /** @see AudioManager#adjustMasterVolume(int) */
+    public void adjustMasterVolume(int steps, int flags) {
+        ensureValidSteps(steps);
+        int volume = Math.round(AudioSystem.getMasterVolume() * MAX_MASTER_VOLUME);
+        int delta = 0;
+        int numSteps = Math.abs(steps);
+        int direction = steps > 0 ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER;
+        for (int i = 0; i < numSteps; ++i) {
+            delta = findVolumeDelta(direction, volume);
+            volume += delta;
+        }
+
+        //Log.d(TAG, "adjustMasterVolume volume: " + volume + " steps: " + steps);
+        setMasterVolume(volume, flags);
+    }
+
+    /** @see AudioManager#setStreamVolume(int, int, int) */
+    public void setStreamVolume(int streamType, int index, int flags) {
+        ensureValidStreamType(streamType);
+        VolumeStreamState streamState = mStreamStates[mStreamVolumeAlias[streamType]];
+
+        final int device = getDeviceForStream(streamType);
+        int oldIndex;
+
+        flags &= ~AudioManager.FLAG_FIXED_VOLUME;
+        if ((mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) &&
+                ((device & mFixedVolumeDevices) != 0)) {
+            flags |= AudioManager.FLAG_FIXED_VOLUME;
+            index = mStreamStates[streamType].getMaxIndex();
+            oldIndex = index;
+        } else {
+            // get last audible index if stream is muted, current index otherwise
+            oldIndex = streamState.getIndex(device,
+                                            (streamState.muteCount() != 0) /* lastAudible */);
+
+            index = rescaleIndex(index * 10, streamType, mStreamVolumeAlias[streamType]);
+
+            if (!checkSafeMediaVolume(mStreamVolumeAlias[streamType], index, device)) {
+                return;
+            }
+
+            // setting volume on master stream type also controls silent mode
+            if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) ||
+                    (mStreamVolumeAlias[streamType] == getMasterStreamType())) {
+                int newRingerMode;
+                if (index == 0) {
+                    synchronized (mSettingsLock) {
+                        if (mLastSilentRingerMode != -1) {
+                            newRingerMode = mLastSilentRingerMode;
+                        } else {
+                            newRingerMode = mHasVibrator ? AudioManager.RINGER_MODE_VIBRATE
+                                                         : AudioManager.RINGER_MODE_SILENT;
+                        }
+                    }
+                    setStreamVolumeInt(mStreamVolumeAlias[streamType],
+                                       index,
+                                       device,
+                                       false,
+                                       true);
+                } else {
+                    newRingerMode = AudioManager.RINGER_MODE_NORMAL;
+                }
+                setRingerMode(newRingerMode);
+            }
+
+            setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, false, true);
+            // get last audible index if stream is muted, current index otherwise
+            index = mStreamStates[streamType].getIndex(device,
+                                    (mStreamStates[streamType].muteCount() != 0) /* lastAudible */);
+        }
+        sendVolumeUpdate(streamType, oldIndex, index, flags);
+    }
+
+    /** @see AudioManager#forceVolumeControlStream(int) */
+    public void forceVolumeControlStream(int streamType, IBinder cb) {
+        synchronized(mForceControlStreamLock) {
+            mVolumeControlStream = streamType;
+            if (mVolumeControlStream == -1) {
+                if (mForceControlStreamClient != null) {
+                    mForceControlStreamClient.release();
+                    mForceControlStreamClient = null;
+                }
+            } else {
+                mForceControlStreamClient = new ForceControlStreamClient(cb);
+            }
+        }
+    }
+
+    private class ForceControlStreamClient implements IBinder.DeathRecipient {
+        private IBinder mCb; // To be notified of client's death
+
+        ForceControlStreamClient(IBinder cb) {
+            if (cb != null) {
+                try {
+                    cb.linkToDeath(this, 0);
+                } catch (RemoteException e) {
+                    // Client has died!
+                    Log.w(TAG, "ForceControlStreamClient() could not link to "+cb+" binder death");
+                    cb = null;
+                }
+            }
+            mCb = cb;
+        }
+
+        public void binderDied() {
+            synchronized(mForceControlStreamLock) {
+                Log.w(TAG, "SCO client died");
+                if (mForceControlStreamClient != this) {
+                    Log.w(TAG, "unregistered control stream client died");
+                } else {
+                    mForceControlStreamClient = null;
+                    mVolumeControlStream = -1;
+                }
+            }
+        }
+
+        public void release() {
+            if (mCb != null) {
+                mCb.unlinkToDeath(this, 0);
+                mCb = null;
+            }
+        }
+    }
+
+    private int findVolumeDelta(int direction, int volume) {
+        int delta = 0;
+        if (direction == AudioManager.ADJUST_RAISE) {
+            if (volume == MAX_MASTER_VOLUME) {
+                return 0;
+            }
+            // This is the default value if we make it to the end
+            delta = mMasterVolumeRamp[1];
+            // If we're raising the volume move down the ramp array until we
+            // find the volume we're above and use that groups delta.
+            for (int i = mMasterVolumeRamp.length - 1; i > 1; i -= 2) {
+                if (volume >= mMasterVolumeRamp[i - 1]) {
+                    delta = mMasterVolumeRamp[i];
+                    break;
+                }
+            }
+        } else if (direction == AudioManager.ADJUST_LOWER){
+            if (volume == 0) {
+                return 0;
+            }
+            int length = mMasterVolumeRamp.length;
+            // This is the default value if we make it to the end
+            delta = -mMasterVolumeRamp[length - 1];
+            // If we're lowering the volume move up the ramp array until we
+            // find the volume we're below and use the group below it's delta
+            for (int i = 2; i < length; i += 2) {
+                if (volume <= mMasterVolumeRamp[i]) {
+                    delta = -mMasterVolumeRamp[i - 1];
+                    break;
+                }
+            }
+        }
+        return delta;
+    }
+
+    private void sendBroadcastToAll(Intent intent) {
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    private void sendStickyBroadcastToAll(Intent intent) {
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    // UI update and Broadcast Intent
+    private void sendVolumeUpdate(int streamType, int oldIndex, int index, int flags) {
+        if (!mVoiceCapable && (streamType == AudioSystem.STREAM_RING)) {
+            streamType = AudioSystem.STREAM_NOTIFICATION;
+        }
+
+        showVolumeChangeUi(streamType, flags);
+
+        if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
+            oldIndex = (oldIndex + 5) / 10;
+            index = (index + 5) / 10;
+            Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
+            intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
+            intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
+            intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
+            sendBroadcastToAll(intent);
+        }
+    }
+
+    // UI update and Broadcast Intent
+    private void sendMasterVolumeUpdate(int flags, int oldVolume, int newVolume) {
+        masterVolumeChanged(flags);
+
+        Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
+        intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
+        intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
+        sendBroadcastToAll(intent);
+    }
+
+    // UI update and Broadcast Intent
+    private void sendMasterMuteUpdate(boolean muted, int flags) {
+        masterMuteChanged(flags);
+        broadcastMasterMuteStatus(muted);
+    }
+
+    private void broadcastMasterMuteStatus(boolean muted) {
+        Intent intent = new Intent(AudioManager.MASTER_MUTE_CHANGED_ACTION);
+        intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_MUTED, muted);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        sendStickyBroadcastToAll(intent);
+    }
+
+    /**
+     * Sets the stream state's index, and posts a message to set system volume.
+     * This will not call out to the UI. Assumes a valid stream type.
+     *
+     * @param streamType Type of the stream
+     * @param index Desired volume index of the stream
+     * @param device the device whose volume must be changed
+     * @param force If true, set the volume even if the desired volume is same
+     * as the current volume.
+     * @param lastAudible If true, stores new index as last audible one
+     */
+    private void setStreamVolumeInt(int streamType,
+                                    int index,
+                                    int device,
+                                    boolean force,
+                                    boolean lastAudible) {
+        VolumeStreamState streamState = mStreamStates[streamType];
+
+        // If stream is muted, set last audible index only
+        if (streamState.muteCount() != 0) {
+            // Do not allow last audible index to be 0
+            if (index != 0) {
+                streamState.setLastAudibleIndex(index, device);
+                // Post a persist volume msg
+                sendMsg(mAudioHandler,
+                        MSG_PERSIST_VOLUME,
+                        SENDMSG_QUEUE,
+                        PERSIST_LAST_AUDIBLE,
+                        device,
+                        streamState,
+                        PERSIST_DELAY);
+            }
+        } else {
+            if (streamState.setIndex(index, device, lastAudible) || force) {
+                // Post message to set system volume (it in turn will post a message
+                // to persist).
+                sendMsg(mAudioHandler,
+                        MSG_SET_DEVICE_VOLUME,
+                        SENDMSG_QUEUE,
+                        device,
+                        0,
+                        streamState,
+                        0);
+            }
+        }
+    }
+
+    /** @see AudioManager#setStreamSolo(int, boolean) */
+    public void setStreamSolo(int streamType, boolean state, IBinder cb) {
+        for (int stream = 0; stream < mStreamStates.length; stream++) {
+            if (!isStreamAffectedByMute(stream) || stream == streamType) continue;
+            // Bring back last audible volume
+            mStreamStates[stream].mute(cb, state);
+         }
+    }
+
+    /** @see AudioManager#setStreamMute(int, boolean) */
+    public void setStreamMute(int streamType, boolean state, IBinder cb) {
+        if (isStreamAffectedByMute(streamType)) {
+            mStreamStates[streamType].mute(cb, state);
+        }
+    }
+
+    /** get stream mute state. */
+    public boolean isStreamMute(int streamType) {
+        return (mStreamStates[streamType].muteCount() != 0);
+    }
+
+    /** @see AudioManager#setMasterMute(boolean, IBinder) */
+    public void setMasterMute(boolean state, int flags, IBinder cb) {
+        if (state != AudioSystem.getMasterMute()) {
+            AudioSystem.setMasterMute(state);
+            // Post a persist master volume msg
+            sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1
+                    : 0, 0, null, PERSIST_DELAY);
+            sendMasterMuteUpdate(state, flags);
+        }
+    }
+
+    /** get master mute state. */
+    public boolean isMasterMute() {
+        return AudioSystem.getMasterMute();
+    }
+
+    /** @see AudioManager#getStreamVolume(int) */
+    public int getStreamVolume(int streamType) {
+        ensureValidStreamType(streamType);
+        int device = getDeviceForStream(streamType);
+        int index;
+
+        if ((mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) &&
+                (device & mFixedVolumeDevices) != 0) {
+            index = mStreamStates[streamType].getMaxIndex();
+        } else {
+            index = mStreamStates[streamType].getIndex(device, false  /* lastAudible */);
+        }
+        return (index + 5) / 10;
+    }
+
+    public int getMasterVolume() {
+        if (isMasterMute()) return 0;
+        return getLastAudibleMasterVolume();
+    }
+
+    public void setMasterVolume(int volume, int flags) {
+        if (volume < 0) {
+            volume = 0;
+        } else if (volume > MAX_MASTER_VOLUME) {
+            volume = MAX_MASTER_VOLUME;
+        }
+        doSetMasterVolume((float)volume / MAX_MASTER_VOLUME, flags);
+    }
+
+    private void doSetMasterVolume(float volume, int flags) {
+        // don't allow changing master volume when muted
+        if (!AudioSystem.getMasterMute()) {
+            int oldVolume = getMasterVolume();
+            AudioSystem.setMasterVolume(volume);
+
+            int newVolume = getMasterVolume();
+            if (newVolume != oldVolume) {
+                // Post a persist master volume msg
+                sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME, SENDMSG_REPLACE,
+                        Math.round(volume * (float)1000.0), 0, null, PERSIST_DELAY);
+            }
+            // Send the volume update regardless whether there was a change.
+            sendMasterVolumeUpdate(flags, oldVolume, newVolume);
+        }
+    }
+
+    /** @see AudioManager#getStreamMaxVolume(int) */
+    public int getStreamMaxVolume(int streamType) {
+        ensureValidStreamType(streamType);
+        return (mStreamStates[streamType].getMaxIndex() + 5) / 10;
+    }
+
+    public int getMasterMaxVolume() {
+        return MAX_MASTER_VOLUME;
+    }
+
+    /** Get last audible volume before stream was muted. */
+    public int getLastAudibleStreamVolume(int streamType) {
+        ensureValidStreamType(streamType);
+        int device = getDeviceForStream(streamType);
+        return (mStreamStates[streamType].getIndex(device, true  /* lastAudible */) + 5) / 10;
+    }
+
+    /** Get last audible master volume before it was muted. */
+    public int getLastAudibleMasterVolume() {
+        return Math.round(AudioSystem.getMasterVolume() * MAX_MASTER_VOLUME);
+    }
+
+    /** @see AudioManager#getMasterStreamType(int) */
+    public int getMasterStreamType() {
+        if (mVoiceCapable) {
+            return AudioSystem.STREAM_RING;
+        } else {
+            return AudioSystem.STREAM_MUSIC;
+        }
+    }
+
+    /** @see AudioManager#getRingerMode() */
+    public int getRingerMode() {
+        synchronized(mSettingsLock) {
+            return mRingerMode;
+        }
+    }
+
+    private void ensureValidRingerMode(int ringerMode) {
+        if (!AudioManager.isValidRingerMode(ringerMode)) {
+            throw new IllegalArgumentException("Bad ringer mode " + ringerMode);
+        }
+    }
+
+    /** @see AudioManager#setRingerMode(int) */
+    public void setRingerMode(int ringerMode) {
+        if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
+            ringerMode = AudioManager.RINGER_MODE_SILENT;
+        }
+        if (ringerMode != getRingerMode()) {
+            setRingerModeInt(ringerMode, true);
+            // Send sticky broadcast
+            broadcastRingerMode(ringerMode);
+        }
+    }
+
+    private void setRingerModeInt(int ringerMode, boolean persist) {
+        synchronized(mSettingsLock) {
+            mRingerMode = ringerMode;
+            if (ringerMode != AudioManager.RINGER_MODE_NORMAL) {
+                mLastSilentRingerMode = ringerMode;
+            }
+        }
+
+        // Mute stream if not previously muted by ringer mode and ringer mode
+        // is not RINGER_MODE_NORMAL and stream is affected by ringer mode.
+        // Unmute stream if previously muted by ringer mode and ringer mode
+        // is RINGER_MODE_NORMAL or stream is not affected by ringer mode.
+        int numStreamTypes = AudioSystem.getNumStreamTypes();
+        for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
+            if (isStreamMutedByRingerMode(streamType)) {
+                if (!isStreamAffectedByRingerMode(streamType) ||
+                    ringerMode == AudioManager.RINGER_MODE_NORMAL) {
+                    // ring and notifications volume should never be 0 when not silenced
+                    // on voice capable devices
+                    if (mVoiceCapable &&
+                            mStreamVolumeAlias[streamType] == AudioSystem.STREAM_RING) {
+                        synchronized (mStreamStates[streamType]) {
+                            Set set = mStreamStates[streamType].mLastAudibleIndex.entrySet();
+                            Iterator i = set.iterator();
+                            while (i.hasNext()) {
+                                Map.Entry entry = (Map.Entry)i.next();
+                                if ((Integer)entry.getValue() == 0) {
+                                    entry.setValue(10);
+                                }
+                            }
+                        }
+                    }
+                    mStreamStates[streamType].mute(null, false);
+                    mRingerModeMutedStreams &= ~(1 << streamType);
+                }
+            } else {
+                if (isStreamAffectedByRingerMode(streamType) &&
+                    ringerMode != AudioManager.RINGER_MODE_NORMAL) {
+                   mStreamStates[streamType].mute(null, true);
+                   mRingerModeMutedStreams |= (1 << streamType);
+               }
+            }
+        }
+
+        // Post a persist ringer mode msg
+        if (persist) {
+            sendMsg(mAudioHandler, MSG_PERSIST_RINGER_MODE,
+                    SENDMSG_REPLACE, 0, 0, null, PERSIST_DELAY);
+        }
+    }
+
+    private void restoreMasterVolume() {
+        if (mUseMasterVolume) {
+            float volume = Settings.System.getFloatForUser(mContentResolver,
+                    Settings.System.VOLUME_MASTER, -1.0f, UserHandle.USER_CURRENT);
+            if (volume >= 0.0f) {
+                AudioSystem.setMasterVolume(volume);
+            }
+        }
+    }
+
+    /** @see AudioManager#shouldVibrate(int) */
+    public boolean shouldVibrate(int vibrateType) {
+        if (!mHasVibrator) return false;
+
+        switch (getVibrateSetting(vibrateType)) {
+
+            case AudioManager.VIBRATE_SETTING_ON:
+                return getRingerMode() != AudioManager.RINGER_MODE_SILENT;
+
+            case AudioManager.VIBRATE_SETTING_ONLY_SILENT:
+                return getRingerMode() == AudioManager.RINGER_MODE_VIBRATE;
+
+            case AudioManager.VIBRATE_SETTING_OFF:
+                // return false, even for incoming calls
+                return false;
+
+            default:
+                return false;
+        }
+    }
+
+    /** @see AudioManager#getVibrateSetting(int) */
+    public int getVibrateSetting(int vibrateType) {
+        if (!mHasVibrator) return AudioManager.VIBRATE_SETTING_OFF;
+        return (mVibrateSetting >> (vibrateType * 2)) & 3;
+    }
+
+    /** @see AudioManager#setVibrateSetting(int, int) */
+    public void setVibrateSetting(int vibrateType, int vibrateSetting) {
+
+        if (!mHasVibrator) return;
+
+        mVibrateSetting = getValueForVibrateSetting(mVibrateSetting, vibrateType, vibrateSetting);
+
+        // Broadcast change
+        broadcastVibrateSetting(vibrateType);
+
+    }
+
+    /**
+     * @see #setVibrateSetting(int, int)
+     */
+    public static int getValueForVibrateSetting(int existingValue, int vibrateType,
+            int vibrateSetting) {
+
+        // First clear the existing setting. Each vibrate type has two bits in
+        // the value. Note '3' is '11' in binary.
+        existingValue &= ~(3 << (vibrateType * 2));
+
+        // Set into the old value
+        existingValue |= (vibrateSetting & 3) << (vibrateType * 2);
+
+        return existingValue;
+    }
+
+    private class SetModeDeathHandler implements IBinder.DeathRecipient {
+        private IBinder mCb; // To be notified of client's death
+        private int mPid;
+        private int mMode = AudioSystem.MODE_NORMAL; // Current mode set by this client
+
+        SetModeDeathHandler(IBinder cb, int pid) {
+            mCb = cb;
+            mPid = pid;
+        }
+
+        public void binderDied() {
+            int newModeOwnerPid = 0;
+            synchronized(mSetModeDeathHandlers) {
+                Log.w(TAG, "setMode() client died");
+                int index = mSetModeDeathHandlers.indexOf(this);
+                if (index < 0) {
+                    Log.w(TAG, "unregistered setMode() client died");
+                } else {
+                    newModeOwnerPid = setModeInt(AudioSystem.MODE_NORMAL, mCb, mPid);
+                }
+            }
+            // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
+            // SCO connections not started by the application changing the mode
+            if (newModeOwnerPid != 0) {
+                 disconnectBluetoothSco(newModeOwnerPid);
+            }
+        }
+
+        public int getPid() {
+            return mPid;
+        }
+
+        public void setMode(int mode) {
+            mMode = mode;
+        }
+
+        public int getMode() {
+            return mMode;
+        }
+
+        public IBinder getBinder() {
+            return mCb;
+        }
+    }
+
+    /** @see AudioManager#setMode(int) */
+    public void setMode(int mode, IBinder cb) {
+        if (!checkAudioSettingsPermission("setMode()")) {
+            return;
+        }
+
+        if (mode < AudioSystem.MODE_CURRENT || mode >= AudioSystem.NUM_MODES) {
+            return;
+        }
+
+        int newModeOwnerPid = 0;
+        synchronized(mSetModeDeathHandlers) {
+            if (mode == AudioSystem.MODE_CURRENT) {
+                mode = mMode;
+            }
+            newModeOwnerPid = setModeInt(mode, cb, Binder.getCallingPid());
+        }
+        // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
+        // SCO connections not started by the application changing the mode
+        if (newModeOwnerPid != 0) {
+             disconnectBluetoothSco(newModeOwnerPid);
+        }
+    }
+
+    // must be called synchronized on mSetModeDeathHandlers
+    // setModeInt() returns a valid PID if the audio mode was successfully set to
+    // any mode other than NORMAL.
+    int setModeInt(int mode, IBinder cb, int pid) {
+        int newModeOwnerPid = 0;
+        if (cb == null) {
+            Log.e(TAG, "setModeInt() called with null binder");
+            return newModeOwnerPid;
+        }
+
+        SetModeDeathHandler hdlr = null;
+        Iterator iter = mSetModeDeathHandlers.iterator();
+        while (iter.hasNext()) {
+            SetModeDeathHandler h = (SetModeDeathHandler)iter.next();
+            if (h.getPid() == pid) {
+                hdlr = h;
+                // Remove from client list so that it is re-inserted at top of list
+                iter.remove();
+                hdlr.getBinder().unlinkToDeath(hdlr, 0);
+                break;
+            }
+        }
+        int status = AudioSystem.AUDIO_STATUS_OK;
+        do {
+            if (mode == AudioSystem.MODE_NORMAL) {
+                // get new mode from client at top the list if any
+                if (!mSetModeDeathHandlers.isEmpty()) {
+                    hdlr = mSetModeDeathHandlers.get(0);
+                    cb = hdlr.getBinder();
+                    mode = hdlr.getMode();
+                }
+            } else {
+                if (hdlr == null) {
+                    hdlr = new SetModeDeathHandler(cb, pid);
+                }
+                // Register for client death notification
+                try {
+                    cb.linkToDeath(hdlr, 0);
+                } catch (RemoteException e) {
+                    // Client has died!
+                    Log.w(TAG, "setMode() could not link to "+cb+" binder death");
+                }
+
+                // Last client to call setMode() is always at top of client list
+                // as required by SetModeDeathHandler.binderDied()
+                mSetModeDeathHandlers.add(0, hdlr);
+                hdlr.setMode(mode);
+            }
+
+            if (mode != mMode) {
+                status = AudioSystem.setPhoneState(mode);
+                if (status == AudioSystem.AUDIO_STATUS_OK) {
+                    mMode = mode;
+                } else {
+                    if (hdlr != null) {
+                        mSetModeDeathHandlers.remove(hdlr);
+                        cb.unlinkToDeath(hdlr, 0);
+                    }
+                    // force reading new top of mSetModeDeathHandlers stack
+                    mode = AudioSystem.MODE_NORMAL;
+                }
+            } else {
+                status = AudioSystem.AUDIO_STATUS_OK;
+            }
+        } while (status != AudioSystem.AUDIO_STATUS_OK && !mSetModeDeathHandlers.isEmpty());
+
+        if (status == AudioSystem.AUDIO_STATUS_OK) {
+            if (mode != AudioSystem.MODE_NORMAL) {
+                if (mSetModeDeathHandlers.isEmpty()) {
+                    Log.e(TAG, "setMode() different from MODE_NORMAL with empty mode client stack");
+                } else {
+                    newModeOwnerPid = mSetModeDeathHandlers.get(0).getPid();
+                }
+            }
+            int streamType = getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
+            if (streamType == STREAM_REMOTE_MUSIC) {
+                // here handle remote media playback the same way as local playback
+                streamType = AudioManager.STREAM_MUSIC;
+            }
+            int device = getDeviceForStream(streamType);
+            int index = mStreamStates[mStreamVolumeAlias[streamType]].getIndex(device, false);
+            setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, true, false);
+
+            updateStreamVolumeAlias(true /*updateVolumes*/);
+        }
+        return newModeOwnerPid;
+    }
+
+    /** @see AudioManager#getMode() */
+    public int getMode() {
+        return mMode;
+    }
+
+    /** @see AudioManager#playSoundEffect(int) */
+    public void playSoundEffect(int effectType) {
+        sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_NOOP,
+                effectType, -1, null, 0);
+    }
+
+    /** @see AudioManager#playSoundEffect(int, float) */
+    public void playSoundEffectVolume(int effectType, float volume) {
+        loadSoundEffects();
+        sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_NOOP,
+                effectType, (int) (volume * 1000), null, 0);
+    }
+
+    /**
+     * Loads samples into the soundpool.
+     * This method must be called at first when sound effects are enabled
+     */
+    public boolean loadSoundEffects() {
+        int status;
+
+        synchronized (mSoundEffectsLock) {
+            if (!mBootCompleted) {
+                Log.w(TAG, "loadSoundEffects() called before boot complete");
+                return false;
+            }
+
+            if (mSoundPool != null) {
+                return true;
+            }
+            mSoundPool = new SoundPool(NUM_SOUNDPOOL_CHANNELS, AudioSystem.STREAM_SYSTEM, 0);
+
+            try {
+                mSoundPoolCallBack = null;
+                mSoundPoolListenerThread = new SoundPoolListenerThread();
+                mSoundPoolListenerThread.start();
+                // Wait for mSoundPoolCallBack to be set by the other thread
+                mSoundEffectsLock.wait();
+            } catch (InterruptedException e) {
+                Log.w(TAG, "Interrupted while waiting sound pool listener thread.");
+            }
+
+            if (mSoundPoolCallBack == null) {
+                Log.w(TAG, "loadSoundEffects() could not create SoundPool listener or thread");
+                if (mSoundPoolLooper != null) {
+                    mSoundPoolLooper.quit();
+                    mSoundPoolLooper = null;
+                }
+                mSoundPoolListenerThread = null;
+                mSoundPool.release();
+                mSoundPool = null;
+                return false;
+            }
+            /*
+             * poolId table: The value -1 in this table indicates that corresponding
+             * file (same index in SOUND_EFFECT_FILES[] has not been loaded.
+             * Once loaded, the value in poolId is the sample ID and the same
+             * sample can be reused for another effect using the same file.
+             */
+            int[] poolId = new int[SOUND_EFFECT_FILES.length];
+            for (int fileIdx = 0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
+                poolId[fileIdx] = -1;
+            }
+            /*
+             * Effects whose value in SOUND_EFFECT_FILES_MAP[effect][1] is -1 must be loaded.
+             * If load succeeds, value in SOUND_EFFECT_FILES_MAP[effect][1] is > 0:
+             * this indicates we have a valid sample loaded for this effect.
+             */
+
+            int lastSample = 0;
+            for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
+                // Do not load sample if this effect uses the MediaPlayer
+                if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
+                    continue;
+                }
+                if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
+                    String filePath = Environment.getRootDirectory()
+                            + SOUND_EFFECTS_PATH
+                            + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effect][0]];
+                    int sampleId = mSoundPool.load(filePath, 0);
+                    if (sampleId <= 0) {
+                        Log.w(TAG, "Soundpool could not load file: "+filePath);
+                    } else {
+                        SOUND_EFFECT_FILES_MAP[effect][1] = sampleId;
+                        poolId[SOUND_EFFECT_FILES_MAP[effect][0]] = sampleId;
+                        lastSample = sampleId;
+                    }
+                } else {
+                    SOUND_EFFECT_FILES_MAP[effect][1] = poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
+                }
+            }
+            // wait for all samples to be loaded
+            if (lastSample != 0) {
+                mSoundPoolCallBack.setLastSample(lastSample);
+
+                try {
+                    mSoundEffectsLock.wait();
+                    status = mSoundPoolCallBack.status();
+                } catch (java.lang.InterruptedException e) {
+                    Log.w(TAG, "Interrupted while waiting sound pool callback.");
+                    status = -1;
+                }
+            } else {
+                status = -1;
+            }
+
+            if (mSoundPoolLooper != null) {
+                mSoundPoolLooper.quit();
+                mSoundPoolLooper = null;
+            }
+            mSoundPoolListenerThread = null;
+            if (status != 0) {
+                Log.w(TAG,
+                        "loadSoundEffects(), Error "
+                                + ((lastSample != 0) ? mSoundPoolCallBack.status() : -1)
+                                + " while loading samples");
+                for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
+                    if (SOUND_EFFECT_FILES_MAP[effect][1] > 0) {
+                        SOUND_EFFECT_FILES_MAP[effect][1] = -1;
+                    }
+                }
+
+                mSoundPool.release();
+                mSoundPool = null;
+            }
+        }
+        return (status == 0);
+    }
+
+    /**
+     *  Unloads samples from the sound pool.
+     *  This method can be called to free some memory when
+     *  sound effects are disabled.
+     */
+    public void unloadSoundEffects() {
+        synchronized (mSoundEffectsLock) {
+            if (mSoundPool == null) {
+                return;
+            }
+
+            mAudioHandler.removeMessages(MSG_LOAD_SOUND_EFFECTS);
+            mAudioHandler.removeMessages(MSG_PLAY_SOUND_EFFECT);
+
+            int[] poolId = new int[SOUND_EFFECT_FILES.length];
+            for (int fileIdx = 0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
+                poolId[fileIdx] = 0;
+            }
+
+            for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
+                if (SOUND_EFFECT_FILES_MAP[effect][1] <= 0) {
+                    continue;
+                }
+                if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == 0) {
+                    mSoundPool.unload(SOUND_EFFECT_FILES_MAP[effect][1]);
+                    SOUND_EFFECT_FILES_MAP[effect][1] = -1;
+                    poolId[SOUND_EFFECT_FILES_MAP[effect][0]] = -1;
+                }
+            }
+            mSoundPool.release();
+            mSoundPool = null;
+        }
+    }
+
+    class SoundPoolListenerThread extends Thread {
+        public SoundPoolListenerThread() {
+            super("SoundPoolListenerThread");
+        }
+
+        @Override
+        public void run() {
+
+            Looper.prepare();
+            mSoundPoolLooper = Looper.myLooper();
+
+            synchronized (mSoundEffectsLock) {
+                if (mSoundPool != null) {
+                    mSoundPoolCallBack = new SoundPoolCallback();
+                    mSoundPool.setOnLoadCompleteListener(mSoundPoolCallBack);
+                }
+                mSoundEffectsLock.notify();
+            }
+            Looper.loop();
+        }
+    }
+
+    private final class SoundPoolCallback implements
+            android.media.SoundPool.OnLoadCompleteListener {
+
+        int mStatus;
+        int mLastSample;
+
+        public int status() {
+            return mStatus;
+        }
+
+        public void setLastSample(int sample) {
+            mLastSample = sample;
+        }
+
+        public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
+            synchronized (mSoundEffectsLock) {
+                if (status != 0) {
+                    mStatus = status;
+                }
+                if (sampleId == mLastSample) {
+                    mSoundEffectsLock.notify();
+                }
+            }
+        }
+    }
+
+    /** @see AudioManager#reloadAudioSettings() */
+    public void reloadAudioSettings() {
+        readAudioSettings(false /*userSwitch*/);
+    }
+
+    private void readAudioSettings(boolean userSwitch) {
+        // restore ringer mode, ringer mode affected streams, mute affected streams and vibrate settings
+        readPersistedSettings();
+
+        // restore volume settings
+        int numStreamTypes = AudioSystem.getNumStreamTypes();
+        for (int streamType = 0; streamType < numStreamTypes; streamType++) {
+            VolumeStreamState streamState = mStreamStates[streamType];
+
+            if (userSwitch && mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) {
+                continue;
+            }
+
+            synchronized (streamState) {
+                streamState.readSettings();
+
+                // unmute stream that was muted but is not affect by mute anymore
+                if (streamState.muteCount() != 0 && !isStreamAffectedByMute(streamType) &&
+                        !isStreamMutedByRingerMode(streamType)) {
+                    int size = streamState.mDeathHandlers.size();
+                    for (int i = 0; i < size; i++) {
+                        streamState.mDeathHandlers.get(i).mMuteCount = 1;
+                        streamState.mDeathHandlers.get(i).mute(false);
+                    }
+                }
+            }
+        }
+
+        // apply new ringer mode before checking volume for alias streams so that streams
+        // muted by ringer mode have the correct volume
+        setRingerModeInt(getRingerMode(), false);
+
+        checkAllAliasStreamVolumes();
+
+        synchronized (mSafeMediaVolumeState) {
+            if (mSafeVolumeEnabled &&
+                    mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE) {
+                enforceSafeMediaVolume();
+            }
+        }
+    }
+
+    /** @see AudioManager#setSpeakerphoneOn() */
+    public void setSpeakerphoneOn(boolean on){
+        if (!checkAudioSettingsPermission("setSpeakerphoneOn()")) {
+            return;
+        }
+        mForcedUseForComm = on ? AudioSystem.FORCE_SPEAKER : AudioSystem.FORCE_NONE;
+
+        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
+                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, null, 0);
+    }
+
+    /** @see AudioManager#isSpeakerphoneOn() */
+    public boolean isSpeakerphoneOn() {
+        return (mForcedUseForComm == AudioSystem.FORCE_SPEAKER);
+    }
+
+    /** @see AudioManager#setBluetoothScoOn() */
+    public void setBluetoothScoOn(boolean on){
+        if (!checkAudioSettingsPermission("setBluetoothScoOn()")) {
+            return;
+        }
+        mForcedUseForComm = on ? AudioSystem.FORCE_BT_SCO : AudioSystem.FORCE_NONE;
+
+        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
+                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, null, 0);
+        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
+                AudioSystem.FOR_RECORD, mForcedUseForComm, null, 0);
+    }
+
+    /** @see AudioManager#isBluetoothScoOn() */
+    public boolean isBluetoothScoOn() {
+        return (mForcedUseForComm == AudioSystem.FORCE_BT_SCO);
+    }
+
+    /** @see AudioManager#setBluetoothA2dpOn() */
+    public void setBluetoothA2dpOn(boolean on) {
+        if (!checkAudioSettingsPermission("setBluetoothA2dpOn()") && noDelayInATwoDP) {
+            return;
+        }
+        synchronized (mBluetoothA2dpEnabledLock) {
+            mBluetoothA2dpEnabled = on;
+            sendMsg(mAudioHandler, MSG_SET_FORCE_BT_A2DP_USE, SENDMSG_QUEUE,
+                    AudioSystem.FOR_MEDIA,
+                    mBluetoothA2dpEnabled ? AudioSystem.FORCE_NONE : AudioSystem.FORCE_NO_BT_A2DP,
+                    null, 0);
+        }
+    }
+
+    /** @see AudioManager#isBluetoothA2dpOn() */
+    public boolean isBluetoothA2dpOn() {
+        synchronized (mBluetoothA2dpEnabledLock) {
+            return mBluetoothA2dpEnabled;
+        }
+    }
+
+    /** @see AudioManager#startBluetoothSco() */
+    public void startBluetoothSco(IBinder cb){
+        if (!checkAudioSettingsPermission("startBluetoothSco()") ||
+                !mBootCompleted) {
+            return;
+        }
+        ScoClient client = getScoClient(cb, true);
+        client.incCount();
+    }
+
+    /** @see AudioManager#stopBluetoothSco() */
+    public void stopBluetoothSco(IBinder cb){
+        if (!checkAudioSettingsPermission("stopBluetoothSco()") ||
+                !mBootCompleted) {
+            return;
+        }
+        ScoClient client = getScoClient(cb, false);
+        if (client != null) {
+            client.decCount();
+        }
+    }
+
+
+    private class ScoClient implements IBinder.DeathRecipient {
+        private IBinder mCb; // To be notified of client's death
+        private int mCreatorPid;
+        private int mStartcount; // number of SCO connections started by this client
+
+        ScoClient(IBinder cb) {
+            mCb = cb;
+            mCreatorPid = Binder.getCallingPid();
+            mStartcount = 0;
+        }
+
+        public void binderDied() {
+            synchronized(mScoClients) {
+                Log.w(TAG, "SCO client died");
+                int index = mScoClients.indexOf(this);
+                if (index < 0) {
+                    Log.w(TAG, "unregistered SCO client died");
+                } else {
+                    clearCount(true);
+                    mScoClients.remove(this);
+                }
+            }
+        }
+
+        public void incCount() {
+            synchronized(mScoClients) {
+                requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED);
+                if (mStartcount == 0) {
+                    try {
+                        mCb.linkToDeath(this, 0);
+                    } catch (RemoteException e) {
+                        // client has already died!
+                        Log.w(TAG, "ScoClient  incCount() could not link to "+mCb+" binder death");
+                    }
+                }
+                mStartcount++;
+            }
+        }
+
+        public void decCount() {
+            synchronized(mScoClients) {
+                if (mStartcount == 0) {
+                    Log.w(TAG, "ScoClient.decCount() already 0");
+                } else {
+                    mStartcount--;
+                    if (mStartcount == 0) {
+                        try {
+                            mCb.unlinkToDeath(this, 0);
+                        } catch (NoSuchElementException e) {
+                            Log.w(TAG, "decCount() going to 0 but not registered to binder");
+                        }
+                    }
+                    requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
+                }
+            }
+        }
+
+        public void clearCount(boolean stopSco) {
+            synchronized(mScoClients) {
+                if (mStartcount != 0) {
+                    try {
+                        mCb.unlinkToDeath(this, 0);
+                    } catch (NoSuchElementException e) {
+                        Log.w(TAG, "clearCount() mStartcount: "+mStartcount+" != 0 but not registered to binder");
+                    }
+                }
+                mStartcount = 0;
+                if (stopSco) {
+                    requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
+                }
+            }
+        }
+
+        public int getCount() {
+            return mStartcount;
+        }
+
+        public IBinder getBinder() {
+            return mCb;
+        }
+
+        public int getPid() {
+            return mCreatorPid;
+        }
+
+        public int totalCount() {
+            synchronized(mScoClients) {
+                int count = 0;
+                int size = mScoClients.size();
+                for (int i = 0; i < size; i++) {
+                    count += mScoClients.get(i).getCount();
+                }
+                return count;
+            }
+        }
+
+        private void requestScoState(int state) {
+            checkScoAudioState();
+            if (totalCount() == 0) {
+                if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
+                    // Make sure that the state transitions to CONNECTING even if we cannot initiate
+                    // the connection.
+                    broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTING);
+                    // Accept SCO audio activation only in NORMAL audio mode or if the mode is
+                    // currently controlled by the same client process.
+                    synchronized(mSetModeDeathHandlers) {
+                        if ((mSetModeDeathHandlers.isEmpty() ||
+                                mSetModeDeathHandlers.get(0).getPid() == mCreatorPid) &&
+                                (mScoAudioState == SCO_STATE_INACTIVE ||
+                                 mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
+                            if (mScoAudioState == SCO_STATE_INACTIVE) {
+                                if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null) {
+                                    if (mBluetoothHeadset.startScoUsingVirtualVoiceCall(
+                                            mBluetoothHeadsetDevice)) {
+                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
+                                    } else {
+                                        broadcastScoConnectionState(
+                                                AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
+                                    }
+                                } else if (getBluetoothHeadset()) {
+                                    mScoAudioState = SCO_STATE_ACTIVATE_REQ;
+                                }
+                            } else {
+                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
+                                broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTED);
+                            }
+                        } else {
+                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
+                        }
+                    }
+                } else if (state == BluetoothHeadset.STATE_AUDIO_DISCONNECTED &&
+                              (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL ||
+                               mScoAudioState == SCO_STATE_ACTIVATE_REQ)) {
+                    if (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL) {
+                        if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null) {
+                            if (!mBluetoothHeadset.stopScoUsingVirtualVoiceCall(
+                                    mBluetoothHeadsetDevice)) {
+                                mScoAudioState = SCO_STATE_INACTIVE;
+                                broadcastScoConnectionState(
+                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
+                            }
+                        } else if (getBluetoothHeadset()) {
+                            mScoAudioState = SCO_STATE_DEACTIVATE_REQ;
+                        }
+                    } else {
+                        mScoAudioState = SCO_STATE_INACTIVE;
+                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
+                    }
+                }
+            }
+        }
+    }
+
+    private void checkScoAudioState() {
+        if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null &&
+                mScoAudioState == SCO_STATE_INACTIVE &&
+                mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
+                != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
+            mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
+        }
+    }
+
+    private ScoClient getScoClient(IBinder cb, boolean create) {
+        synchronized(mScoClients) {
+            ScoClient client = null;
+            int size = mScoClients.size();
+            for (int i = 0; i < size; i++) {
+                client = mScoClients.get(i);
+                if (client.getBinder() == cb)
+                    return client;
+            }
+            if (create) {
+                client = new ScoClient(cb);
+                mScoClients.add(client);
+            }
+            return client;
+        }
+    }
+
+    public void clearAllScoClients(int exceptPid, boolean stopSco) {
+        synchronized(mScoClients) {
+            ScoClient savedClient = null;
+            int size = mScoClients.size();
+            for (int i = 0; i < size; i++) {
+                ScoClient cl = mScoClients.get(i);
+                if (cl.getPid() != exceptPid) {
+                    cl.clearCount(stopSco);
+                } else {
+                    savedClient = cl;
+                }
+            }
+            mScoClients.clear();
+            if (savedClient != null) {
+                mScoClients.add(savedClient);
+            }
+        }
+    }
+
+    private boolean getBluetoothHeadset() {
+        boolean result = false;
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        if (adapter != null) {
+            result = adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
+                                    BluetoothProfile.HEADSET);
+        }
+        // If we could not get a bluetooth headset proxy, send a failure message
+        // without delay to reset the SCO audio state and clear SCO clients.
+        // If we could get a proxy, send a delayed failure message that will reset our state
+        // in case we don't receive onServiceConnected().
+        sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
+                SENDMSG_REPLACE, 0, 0, null, result ? BT_HEADSET_CNCT_TIMEOUT_MS : 0);
+        return result;
+    }
+
+    private void disconnectBluetoothSco(int exceptPid) {
+        synchronized(mScoClients) {
+            checkScoAudioState();
+            if (mScoAudioState == SCO_STATE_ACTIVE_EXTERNAL ||
+                    mScoAudioState == SCO_STATE_DEACTIVATE_EXT_REQ) {
+                if (mBluetoothHeadsetDevice != null) {
+                    if (mBluetoothHeadset != null) {
+                        if (!mBluetoothHeadset.stopVoiceRecognition(
+                                mBluetoothHeadsetDevice)) {
+                            sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
+                                    SENDMSG_REPLACE, 0, 0, null, 0);
+                        }
+                    } else if (mScoAudioState == SCO_STATE_ACTIVE_EXTERNAL &&
+                            getBluetoothHeadset()) {
+                        mScoAudioState = SCO_STATE_DEACTIVATE_EXT_REQ;
+                    }
+                }
+            } else {
+                clearAllScoClients(exceptPid, true);
+            }
+        }
+    }
+
+    private void resetBluetoothSco() {
+        synchronized(mScoClients) {
+            clearAllScoClients(0, false);
+            mScoAudioState = SCO_STATE_INACTIVE;
+            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
+        }
+    }
+
+    private void broadcastScoConnectionState(int state) {
+        if (state != mScoConnectionState) {
+            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_UPDATED);
+            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, state);
+            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_PREVIOUS_STATE,
+                    mScoConnectionState);
+            sendStickyBroadcastToAll(newIntent);
+            mScoConnectionState = state;
+        }
+    }
+
+    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
+        new BluetoothProfile.ServiceListener() {
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            BluetoothDevice btDevice;
+            List<BluetoothDevice> deviceList;
+            switch(profile) {
+            case BluetoothProfile.A2DP:
+                BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
+                deviceList = a2dp.getConnectedDevices();
+                if (deviceList.size() > 0) {
+                    btDevice = deviceList.get(0);
+                    if (!noDelayInATwoDP) {
+                        synchronized (mConnectedDevices) {
+                            int state = a2dp.getConnectionState(btDevice);
+                            int delay = checkSendBecomingNoisyIntent(
+                                                AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
+                                                (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0);
+                            queueMsgUnderWakeLock(mAudioHandler,
+                                    MSG_SET_A2DP_CONNECTION_STATE,
+                                    state,
+                                    0,
+                                    btDevice,
+                                    delay);
+                        }
+                    } else {
+                        onSetA2dpConnectionState(btDevice, a2dp.getConnectionState(btDevice));
+                    }
+                }
+                break;
+
+            case BluetoothProfile.HEADSET:
+                synchronized (mScoClients) {
+                    // Discard timeout message
+                    mAudioHandler.removeMessages(MSG_BT_HEADSET_CNCT_FAILED);
+                    mBluetoothHeadset = (BluetoothHeadset) proxy;
+                    deviceList = mBluetoothHeadset.getConnectedDevices();
+                    if (deviceList.size() > 0) {
+                        mBluetoothHeadsetDevice = deviceList.get(0);
+                    } else {
+                        mBluetoothHeadsetDevice = null;
+                    }
+                    // Refresh SCO audio state
+                    checkScoAudioState();
+                    // Continue pending action if any
+                    if (mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
+                            mScoAudioState == SCO_STATE_DEACTIVATE_REQ ||
+                            mScoAudioState == SCO_STATE_DEACTIVATE_EXT_REQ) {
+                        boolean status = false;
+                        if (mBluetoothHeadsetDevice != null) {
+                            switch (mScoAudioState) {
+                            case SCO_STATE_ACTIVATE_REQ:
+                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
+                                status = mBluetoothHeadset.startScoUsingVirtualVoiceCall(
+                                        mBluetoothHeadsetDevice);
+                                break;
+                            case SCO_STATE_DEACTIVATE_REQ:
+                                status = mBluetoothHeadset.stopScoUsingVirtualVoiceCall(
+                                        mBluetoothHeadsetDevice);
+                                break;
+                            case SCO_STATE_DEACTIVATE_EXT_REQ:
+                                status = mBluetoothHeadset.stopVoiceRecognition(
+                                        mBluetoothHeadsetDevice);
+                            }
+                        }
+                        if (!status) {
+                            sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
+                                    SENDMSG_REPLACE, 0, 0, null, 0);
+                        }
+                    }
+                }
+                break;
+
+            default:
+                break;
+            }
+        }
+        public void onServiceDisconnected(int profile) {
+            switch(profile) {
+            case BluetoothProfile.A2DP:
+                synchronized (mConnectedDevices) {
+                    if (mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)) {
+                        makeA2dpDeviceUnavailableNow(
+                                mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP));
+                    }
+                }
+                break;
+
+            case BluetoothProfile.HEADSET:
+                synchronized (mScoClients) {
+                    mBluetoothHeadset = null;
+                }
+                break;
+
+            default:
+                break;
+            }
+        }
+    };
+
+    /** see AudioManager.setRemoteSubmixOn(boolean on) */
+    public void setRemoteSubmixOn(boolean on, int address) {
+        sendMsg(mAudioHandler, MSG_SET_RSX_CONNECTION_STATE,
+                SENDMSG_REPLACE /* replace with QUEUE when multiple addresses are supported */,
+                on ? 1 : 0 /*arg1*/,
+                address /*arg2*/,
+                null/*obj*/, 0/*delay*/);
+    }
+
+    private void onSetRsxConnectionState(int available, int address) {
+        AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_REMOTE_SUBMIX,
+                available == 1 ?
+                        AudioSystem.DEVICE_STATE_AVAILABLE : AudioSystem.DEVICE_STATE_UNAVAILABLE,
+                String.valueOf(address) /*device_address*/);
+        AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_REMOTE_SUBMIX,
+                available == 1 ?
+                        AudioSystem.DEVICE_STATE_AVAILABLE : AudioSystem.DEVICE_STATE_UNAVAILABLE,
+                String.valueOf(address) /*device_address*/);
+    }
+
+    private void onCheckMusicActive() {
+        synchronized (mSafeMediaVolumeState) {
+            if (mSafeVolumeEnabled &&
+                    mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_INACTIVE) {
+                int device = getDeviceForStream(AudioSystem.STREAM_MUSIC);
+
+                if ((device & mSafeMediaVolumeDevices) != 0) {
+                    sendMsg(mAudioHandler,
+                            MSG_CHECK_MUSIC_ACTIVE,
+                            SENDMSG_REPLACE,
+                            0,
+                            0,
+                            null,
+                            MUSIC_ACTIVE_POLL_PERIOD_MS);
+                    int index = mStreamStates[AudioSystem.STREAM_MUSIC].getIndex(device,
+                                                                            false /*lastAudible*/);
+                    if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0) &&
+                            (index > mSafeMediaVolumeIndex)) {
+                        // Approximate cumulative active music time
+                        mMusicActiveMs += MUSIC_ACTIVE_POLL_PERIOD_MS;
+                        if (mMusicActiveMs > UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX) {
+                            setSafeMediaVolumeEnabled(true);
+                            mMusicActiveMs = 0;
+                            displaySafeVolumeWarning();
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void onConfigureSafeVolume(boolean force) {
+        synchronized (mSafeMediaVolumeState) {
+            int mcc = mContext.getResources().getConfiguration().mcc;
+            if ((mMcc != mcc) || ((mMcc == 0) && force)) {
+                mSafeMediaVolumeIndex = mContext.getResources().getInteger(
+                        com.android.internal.R.integer.config_safe_media_volume_index) * 10;
+                boolean safeMediaVolumeEnabled = mContext.getResources().getBoolean(
+                        com.android.internal.R.bool.config_safe_media_volume_enabled);
+
+                // The persisted state is either "disabled" or "active": this is the state applied
+                // next time we boot and cannot be "inactive"
+                int persistedState;
+                if (safeMediaVolumeEnabled) {
+                    persistedState = SAFE_MEDIA_VOLUME_ACTIVE;
+                    // The state can already be "inactive" here if the user has forced it before
+                    // the 30 seconds timeout for forced configuration. In this case we don't reset
+                    // it to "active".
+                    if (mSafeMediaVolumeState != SAFE_MEDIA_VOLUME_INACTIVE) {
+                        mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_ACTIVE;
+                        enforceSafeMediaVolume();
+                    }
+                } else {
+                    persistedState = SAFE_MEDIA_VOLUME_DISABLED;
+                    mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_DISABLED;
+                }
+                mMcc = mcc;
+                sendMsg(mAudioHandler,
+                        MSG_PERSIST_SAFE_VOLUME_STATE,
+                        SENDMSG_QUEUE,
+                        persistedState,
+                        0,
+                        null,
+                        0);
+            }
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Internal methods
+    ///////////////////////////////////////////////////////////////////////////
+
+    /**
+     * Checks if the adjustment should change ringer mode instead of just
+     * adjusting volume. If so, this will set the proper ringer mode and volume
+     * indices on the stream states.
+     */
+    private boolean checkForRingerModeChange(int oldIndex, int direction,  int step) {
+        boolean adjustVolumeIndex = true;
+        int ringerMode = getRingerMode();
+
+        switch (ringerMode) {
+        case RINGER_MODE_NORMAL:
+            if (direction == AudioManager.ADJUST_LOWER) {
+                if (mHasVibrator) {
+                    // "step" is the delta in internal index units corresponding to a
+                    // change of 1 in UI index units.
+                    // Because of rounding when rescaling from one stream index range to its alias
+                    // index range, we cannot simply test oldIndex == step:
+                    //   (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
+                    if (step <= oldIndex && oldIndex < 2 * step) {
+                        ringerMode = RINGER_MODE_VIBRATE;
+                        if (mVoiceCapable)
+                            adjustVolumeIndex = false;
+                    }
+                } else {
+                    // (oldIndex < step) is equivalent to (old UI index == 0)
+                    if ((oldIndex < step) && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
+                        ringerMode = RINGER_MODE_SILENT;
+                        if (mVoiceCapable)
+                            adjustVolumeIndex = false;
+                    }
+                }
+            }
+            break;
+        case RINGER_MODE_VIBRATE:
+            if (!mHasVibrator) {
+                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" +
+                        "but no vibrator is present");
+                break;
+            }
+            if ((direction == AudioManager.ADJUST_LOWER)) {
+                if (mPrevVolDirection != AudioManager.ADJUST_LOWER) {
+                    ringerMode = RINGER_MODE_SILENT;
+                }
+            } else if (direction == AudioManager.ADJUST_RAISE) {
+                ringerMode = RINGER_MODE_NORMAL;
+            }
+            adjustVolumeIndex = false;
+            break;
+        case RINGER_MODE_SILENT:
+            if (direction == AudioManager.ADJUST_RAISE) {
+                if (mHasVibrator) {
+                    ringerMode = RINGER_MODE_VIBRATE;
+                } else {
+                    ringerMode = RINGER_MODE_NORMAL;
+                }
+            }
+            adjustVolumeIndex = false;
+            break;
+        default:
+            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: "+ringerMode);
+            break;
+        }
+
+        setRingerMode(ringerMode);
+
+        mPrevVolDirection = direction;
+
+        return adjustVolumeIndex;
+    }
+
+    public boolean isStreamAffectedByRingerMode(int streamType) {
+        return (mRingerModeAffectedStreams & (1 << streamType)) != 0;
+    }
+
+    private boolean isStreamMutedByRingerMode(int streamType) {
+        return (mRingerModeMutedStreams & (1 << streamType)) != 0;
+    }
+
+    public boolean isStreamAffectedByMute(int streamType) {
+        return (mMuteAffectedStreams & (1 << streamType)) != 0;
+    }
+
+    private void ensureValidDirection(int direction) {
+        if (direction < AudioManager.ADJUST_LOWER || direction > AudioManager.ADJUST_RAISE) {
+            throw new IllegalArgumentException("Bad direction " + direction);
+        }
+    }
+
+    private void ensureValidSteps(int steps) {
+        if (Math.abs(steps) > MAX_BATCH_VOLUME_ADJUST_STEPS) {
+            throw new IllegalArgumentException("Bad volume adjust steps " + steps);
+        }
+    }
+
+    private void ensureValidStreamType(int streamType) {
+        if (streamType < 0 || streamType >= mStreamStates.length) {
+            throw new IllegalArgumentException("Bad stream type " + streamType);
+        }
+    }
+
+    private boolean isInCommunication() {
+        boolean isOffhook = false;
+
+        if (mVoiceCapable) {
+            try {
+                ITelephony phone = ITelephony.Stub.asInterface(ServiceManager.checkService("phone"));
+                if (phone != null) isOffhook = phone.isOffhook();
+            } catch (RemoteException e) {
+                Log.w(TAG, "Couldn't connect to phone service", e);
+            }
+        }
+        return (isOffhook || getMode() == AudioManager.MODE_IN_COMMUNICATION);
+    }
+
+    private int getActiveStreamType(int suggestedStreamType) {
+        if (mVoiceCapable) {
+            if (isInCommunication()) {
+                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION)
+                        == AudioSystem.FORCE_BT_SCO) {
+                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO...");
+                    return AudioSystem.STREAM_BLUETOOTH_SCO;
+                } else {
+                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL...");
+                    return AudioSystem.STREAM_VOICE_CALL;
+                }
+            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
+                // Having the suggested stream be USE_DEFAULT_STREAM_TYPE is how remote control
+                // volume can have priority over STREAM_MUSIC
+                if (checkUpdateRemoteStateIfActive(AudioSystem.STREAM_MUSIC)) {
+                    if (DEBUG_VOL)
+                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_REMOTE_MUSIC");
+                    return STREAM_REMOTE_MUSIC;
+                } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC,
+                            DEFAULT_STREAM_TYPE_OVERRIDE_DELAY_MS)) {
+                    if (DEBUG_VOL)
+                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
+                    return AudioSystem.STREAM_MUSIC;
+                } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_FM, 0)) {
+                    if (DEBUG_VOL)
+                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_FM...");
+                    return AudioSystem.STREAM_FM;					
+                } else {
+                    if (mVolumeKeysControlRingStream) {
+                        if (DEBUG_VOL)
+                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_RING b/c default");
+                        return AudioSystem.STREAM_RING;
+                    } else {
+                        if (DEBUG_VOL)
+                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC b/c default setting");
+                        return AudioSystem.STREAM_MUSIC;
+                    }
+                }
+            } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0)) {
+                if (DEBUG_VOL)
+                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
+                return AudioSystem.STREAM_MUSIC;
+            } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_FM, 0)) {
+                if (DEBUG_VOL)
+                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_FM...");
+                return AudioSystem.STREAM_FM;				
+            } else {
+                if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Returning suggested type "
+                        + suggestedStreamType);
+                return suggestedStreamType;
+            }
+        } else {
+            if (isInCommunication()) {
+                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION)
+                        == AudioSystem.FORCE_BT_SCO) {
+                    if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO");
+                    return AudioSystem.STREAM_BLUETOOTH_SCO;
+                } else {
+                    if (DEBUG_VOL)  Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL");
+                    return AudioSystem.STREAM_VOICE_CALL;
+                }
+            } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_NOTIFICATION,
+                    DEFAULT_STREAM_TYPE_OVERRIDE_DELAY_MS) ||
+                    AudioSystem.isStreamActive(AudioSystem.STREAM_RING,
+                            DEFAULT_STREAM_TYPE_OVERRIDE_DELAY_MS)) {
+                if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Forcing STREAM_NOTIFICATION");
+                return AudioSystem.STREAM_NOTIFICATION;
+            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
+                if (checkUpdateRemoteStateIfActive(AudioSystem.STREAM_MUSIC)) {
+                    // Having the suggested stream be USE_DEFAULT_STREAM_TYPE is how remote control
+                    // volume can have priority over STREAM_MUSIC
+                    if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Forcing STREAM_REMOTE_MUSIC");
+                    return STREAM_REMOTE_MUSIC;
+                } else {
+                    if (DEBUG_VOL)
+                        Log.v(TAG, "getActiveStreamType: using STREAM_MUSIC as default");
+                    return AudioSystem.STREAM_MUSIC;
+                }
+            } else {
+                if (DEBUG_VOL) Log.v(TAG, "getActiveStreamType: Returning suggested type "
+                        + suggestedStreamType);
+                return suggestedStreamType;
+            }
+        }
+    }
+
+    private void broadcastRingerMode(int ringerMode) {
+        // Send sticky broadcast
+        Intent broadcast = new Intent(AudioManager.RINGER_MODE_CHANGED_ACTION);
+        broadcast.putExtra(AudioManager.EXTRA_RINGER_MODE, ringerMode);
+        broadcast.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        sendStickyBroadcastToAll(broadcast);
+    }
+
+    private void broadcastVibrateSetting(int vibrateType) {
+        // Send broadcast
+        if (ActivityManagerNative.isSystemReady()) {
+            Intent broadcast = new Intent(AudioManager.VIBRATE_SETTING_CHANGED_ACTION);
+            broadcast.putExtra(AudioManager.EXTRA_VIBRATE_TYPE, vibrateType);
+            broadcast.putExtra(AudioManager.EXTRA_VIBRATE_SETTING, getVibrateSetting(vibrateType));
+            sendBroadcastToAll(broadcast);
+        }
+    }
+
+    // Message helper methods
+    /**
+     * Queue a message on the given handler's message queue, after acquiring the service wake lock.
+     * Note that the wake lock needs to be released after the message has been handled.
+     */
+    private void queueMsgUnderWakeLock(Handler handler, int msg,
+            int arg1, int arg2, Object obj, int delay) {
+        mMediaEventWakeLock.acquire();
+        sendMsg(handler, msg, SENDMSG_QUEUE, arg1, arg2, obj, delay);
+    }
+
+    private static void sendMsg(Handler handler, int msg,
+            int existingMsgPolicy, int arg1, int arg2, Object obj, int delay) {
+
+        if (existingMsgPolicy == SENDMSG_REPLACE) {
+            handler.removeMessages(msg);
+        } else if (existingMsgPolicy == SENDMSG_NOOP && handler.hasMessages(msg)) {
+            return;
+        }
+
+        handler.sendMessageDelayed(handler.obtainMessage(msg, arg1, arg2, obj), delay);
+    }
+
+    boolean checkAudioSettingsPermission(String method) {
+        if (mContext.checkCallingOrSelfPermission("android.permission.MODIFY_AUDIO_SETTINGS")
+                == PackageManager.PERMISSION_GRANTED) {
+            return true;
+        }
+        String msg = "Audio Settings Permission Denial: " + method + " from pid="
+                + Binder.getCallingPid()
+                + ", uid=" + Binder.getCallingUid();
+        Log.w(TAG, msg);
+        return false;
+    }
+
+    private int getDeviceForStream(int stream) {
+        int device = AudioSystem.getDevicesForStream(stream);
+        if ((device & (device - 1)) != 0) {
+            // Multiple device selection is either:
+            //  - speaker + one other device: give priority to speaker in this case.
+            //  - one A2DP device + another device: happens with duplicated output. In this case
+            // retain the device on the A2DP output as the other must not correspond to an active
+            // selection if not the speaker.
+            if ((device & AudioSystem.DEVICE_OUT_SPEAKER) != 0) {
+                device = AudioSystem.DEVICE_OUT_SPEAKER;
+            } else if ((device & AudioSystem.DEVICE_OUT_WIRED_HEADSET) != 0) {
+                device = AudioSystem.DEVICE_OUT_WIRED_HEADSET;
+            } else if ((device & AudioSystem.DEVICE_OUT_WIRED_HEADPHONE) != 0) {
+                device = AudioSystem.DEVICE_OUT_WIRED_HEADPHONE;				
+            } else {
+                device &= AudioSystem.DEVICE_OUT_ALL_A2DP;
+            }
+        }
+        return device;
+    }
+
+    public void setWiredDeviceConnectionState(int device, int state, String name) {
+        synchronized (mConnectedDevices) {
+            int delay = checkSendBecomingNoisyIntent(device, state);
+            queueMsgUnderWakeLock(mAudioHandler,
+                    MSG_SET_WIRED_DEVICE_CONNECTION_STATE,
+                    device,
+                    state,
+                    name,
+                    delay);
+        }
+    }
+
+    public int setBluetoothA2dpDeviceConnectionState(BluetoothDevice device, int state) {
+        int delay;
+        if (!noDelayInATwoDP) {
+            synchronized (mConnectedDevices) {
+                delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
+                                                (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0);
+                queueMsgUnderWakeLock(mAudioHandler,
+                        MSG_SET_A2DP_CONNECTION_STATE,
+                        state,
+                        0,
+                        device,
+                        delay);
+            }
+        } else {
+            delay = 0;
+        }
+        return delay;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Inner classes
+    ///////////////////////////////////////////////////////////////////////////
+
+    public class VolumeStreamState {
+        private final int mStreamType;
+
+        private String mVolumeIndexSettingName;
+        private String mLastAudibleVolumeIndexSettingName;
+        private int mIndexMax;
+        private final ConcurrentHashMap<Integer, Integer> mIndex =
+                                            new ConcurrentHashMap<Integer, Integer>(8, 0.75f, 4);
+        private final ConcurrentHashMap<Integer, Integer> mLastAudibleIndex =
+                                            new ConcurrentHashMap<Integer, Integer>(8, 0.75f, 4);
+        private ArrayList<VolumeDeathHandler> mDeathHandlers; //handles mute/solo clients death
+
+        private VolumeStreamState(String settingName, int streamType) {
+
+            mVolumeIndexSettingName = settingName;
+            mLastAudibleVolumeIndexSettingName = settingName + System.APPEND_FOR_LAST_AUDIBLE;
+
+            mStreamType = streamType;
+            mIndexMax = MAX_STREAM_VOLUME[streamType];
+            AudioSystem.initStreamVolume(streamType, 0, mIndexMax);
+            mIndexMax *= 10;
+
+            // mDeathHandlers must be created before calling readSettings()
+            mDeathHandlers = new ArrayList<VolumeDeathHandler>();
+
+            readSettings();
+        }
+
+        public String getSettingNameForDevice(boolean lastAudible, int device) {
+            String name = lastAudible ?
+                            mLastAudibleVolumeIndexSettingName :
+                            mVolumeIndexSettingName;
+            String suffix = AudioSystem.getDeviceName(device);
+            if (suffix.isEmpty()) {
+                return name;
+            }
+            return name + "_" + suffix;
+        }
+
+        public synchronized void readSettings() {
+            int remainingDevices = AudioSystem.DEVICE_OUT_ALL;
+
+            // do not read system stream volume from settings: this stream is always aliased
+            // to another stream type and its volume is never persisted. Values in settings can
+            // only be stale values
+            // on first call to readSettings() at init time, muteCount() is always 0 so we will
+            // always create entries for default device
+            if ((mStreamType == AudioSystem.STREAM_SYSTEM) ||
+                    (mStreamType == AudioSystem.STREAM_SYSTEM_ENFORCED)) {
+                int index = 10 * AudioManager.DEFAULT_STREAM_VOLUME[mStreamType];
+                synchronized (mCameraSoundForced) {
+                    if (mCameraSoundForced) {
+                        index = mIndexMax;
+                    }
+                }
+                if (muteCount() == 0) {
+                    mIndex.put(AudioSystem.DEVICE_OUT_DEFAULT, index);
+                }
+                mLastAudibleIndex.put(AudioSystem.DEVICE_OUT_DEFAULT, index);
+                return;
+            }
+
+            for (int i = 0; remainingDevices != 0; i++) {
+                int device = (1 << i);
+                if ((device & remainingDevices) == 0) {
+                    continue;
+                }
+                remainingDevices &= ~device;
+
+                // ignore settings for fixed volume devices: volume should always be at max
+                if ((mStreamVolumeAlias[mStreamType] == AudioSystem.STREAM_MUSIC) &&
+                        ((device & mFixedVolumeDevices) != 0)) {
+                    if (muteCount() == 0) {
+                        mIndex.put(device, mIndexMax);
+                    }
+                    mLastAudibleIndex.put(device, mIndexMax);
+                    continue;
+                }
+                // retrieve current volume for device
+                String name = getSettingNameForDevice(false /* lastAudible */, device);
+                // if no volume stored for current stream and device, use default volume if default
+                // device, continue otherwise
+                int defaultIndex = (device == AudioSystem.DEVICE_OUT_DEFAULT) ?
+                                        AudioManager.DEFAULT_STREAM_VOLUME[mStreamType] : -1;
+                int index = Settings.System.getIntForUser(
+                        mContentResolver, name, defaultIndex, UserHandle.USER_CURRENT);
+                if (index == -1) {
+                    continue;
+                }
+
+                // retrieve last audible volume for device
+                name = getSettingNameForDevice(true  /* lastAudible */, device);
+                // use stored last audible index if present, otherwise use current index if not 0
+                // or default index
+                defaultIndex = (index > 0) ?
+                                    index : AudioManager.DEFAULT_STREAM_VOLUME[mStreamType];
+                int lastAudibleIndex = Settings.System.getIntForUser(
+                        mContentResolver, name, defaultIndex, UserHandle.USER_CURRENT);
+
+                // a last audible index of 0 should never be stored for ring and notification
+                // streams on phones (voice capable devices).
+                if ((lastAudibleIndex == 0) && mVoiceCapable &&
+                                (mStreamVolumeAlias[mStreamType] == AudioSystem.STREAM_RING)) {
+                    lastAudibleIndex = AudioManager.DEFAULT_STREAM_VOLUME[mStreamType];
+                    // Correct the data base
+                    sendMsg(mAudioHandler,
+                            MSG_PERSIST_VOLUME,
+                            SENDMSG_QUEUE,
+                            PERSIST_LAST_AUDIBLE,
+                            device,
+                            this,
+                            PERSIST_DELAY);
+                }
+                mLastAudibleIndex.put(device, getValidIndex(10 * lastAudibleIndex));
+                // the initial index should never be 0 for ring and notification streams on phones
+                // (voice capable devices) if not in silent or vibrate mode.
+                if ((index == 0) && (mRingerMode == AudioManager.RINGER_MODE_NORMAL) &&
+                        mVoiceCapable &&
+                        (mStreamVolumeAlias[mStreamType] == AudioSystem.STREAM_RING)) {
+                    index = lastAudibleIndex;
+                    // Correct the data base
+                    sendMsg(mAudioHandler,
+                            MSG_PERSIST_VOLUME,
+                            SENDMSG_QUEUE,
+                            PERSIST_CURRENT,
+                            device,
+                            this,
+                            PERSIST_DELAY);
+                }
+                if (muteCount() == 0) {
+                    mIndex.put(device, getValidIndex(10 * index));
+                }
+            }
+        }
+
+        public void applyDeviceVolume(int device) {
+            AudioSystem.setStreamVolumeIndex(mStreamType,
+                                             (getIndex(device, false  /* lastAudible */) + 5)/10,
+                                             device);
+        }
+
+        public synchronized void applyAllVolumes() {
+            // apply default volume first: by convention this will reset all
+            // devices volumes in audio policy manager to the supplied value
+            AudioSystem.setStreamVolumeIndex(mStreamType,
+                    (getIndex(AudioSystem.DEVICE_OUT_DEFAULT, false /* lastAudible */) + 5)/10,
+                    AudioSystem.DEVICE_OUT_DEFAULT);
+            // then apply device specific volumes
+            Set set = mIndex.entrySet();
+            Iterator i = set.iterator();
+            while (i.hasNext()) {
+                Map.Entry entry = (Map.Entry)i.next();
+                int device = ((Integer)entry.getKey()).intValue();
+                if (device != AudioSystem.DEVICE_OUT_DEFAULT) {
+                    AudioSystem.setStreamVolumeIndex(mStreamType,
+                                                     ((Integer)entry.getValue() + 5)/10,
+                                                     device);
+                }
+            }
+        }
+
+        public boolean adjustIndex(int deltaIndex, int device) {
+            return setIndex(getIndex(device,
+                                     false  /* lastAudible */) + deltaIndex,
+                            device,
+                            true  /* lastAudible */);
+        }
+
+        public synchronized boolean setIndex(int index, int device, boolean lastAudible) {
+            int oldIndex = getIndex(device, false  /* lastAudible */);
+            index = getValidIndex(index);
+            synchronized (mCameraSoundForced) {
+                if ((mStreamType == AudioSystem.STREAM_SYSTEM_ENFORCED) && mCameraSoundForced) {
+                    index = mIndexMax;
+                }
+            }
+            mIndex.put(device, getValidIndex(index));
+
+            if (oldIndex != index) {
+                if (lastAudible) {
+                    mLastAudibleIndex.put(device, index);
+                }
+                // Apply change to all streams using this one as alias
+                // if changing volume of current device, also change volume of current
+                // device on aliased stream
+                boolean currentDevice = (device == getDeviceForStream(mStreamType));
+                int numStreamTypes = AudioSystem.getNumStreamTypes();
+                for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
+                    if (streamType != mStreamType &&
+                            mStreamVolumeAlias[streamType] == mStreamType) {
+                        int scaledIndex = rescaleIndex(index, mStreamType, streamType);
+                        mStreamStates[streamType].setIndex(scaledIndex,
+                                                           device,
+                                                           lastAudible);
+                        if (currentDevice) {
+                            mStreamStates[streamType].setIndex(scaledIndex,
+                                                               getDeviceForStream(streamType),
+                                                               lastAudible);
+                        }
+                    }
+                }
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        public synchronized int getIndex(int device, boolean lastAudible) {
+            ConcurrentHashMap <Integer, Integer> indexes;
+            if (lastAudible) {
+                indexes = mLastAudibleIndex;
+            } else {
+                indexes = mIndex;
+            }
+            Integer index = indexes.get(device);
+            if (index == null) {
+                // there is always an entry for AudioSystem.DEVICE_OUT_DEFAULT
+                index = indexes.get(AudioSystem.DEVICE_OUT_DEFAULT);
+            }
+            return index.intValue();
+        }
+
+        public synchronized void setLastAudibleIndex(int index, int device) {
+            // Apply change to all streams using this one as alias
+            // if changing volume of current device, also change volume of current
+            // device on aliased stream
+            boolean currentDevice = (device == getDeviceForStream(mStreamType));
+            int numStreamTypes = AudioSystem.getNumStreamTypes();
+            for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
+                if (streamType != mStreamType &&
+                        mStreamVolumeAlias[streamType] == mStreamType) {
+                    int scaledIndex = rescaleIndex(index, mStreamType, streamType);
+                    mStreamStates[streamType].setLastAudibleIndex(scaledIndex, device);
+                    if (currentDevice) {
+                        mStreamStates[streamType].setLastAudibleIndex(scaledIndex,
+                                                                   getDeviceForStream(streamType));
+                    }
+                }
+            }
+            mLastAudibleIndex.put(device, getValidIndex(index));
+        }
+
+        public synchronized void adjustLastAudibleIndex(int deltaIndex, int device) {
+            setLastAudibleIndex(getIndex(device,
+                                         true  /* lastAudible */) + deltaIndex,
+                                device);
+        }
+
+        public int getMaxIndex() {
+            return mIndexMax;
+        }
+
+        // only called by setAllIndexes() which is already synchronized
+        public ConcurrentHashMap <Integer, Integer> getAllIndexes(boolean lastAudible) {
+            if (lastAudible) {
+                return mLastAudibleIndex;
+            } else {
+                return mIndex;
+            }
+        }
+
+        public synchronized void setAllIndexes(VolumeStreamState srcStream, boolean lastAudible) {
+            ConcurrentHashMap <Integer, Integer> indexes = srcStream.getAllIndexes(lastAudible);
+            Set set = indexes.entrySet();
+            Iterator i = set.iterator();
+            while (i.hasNext()) {
+                Map.Entry entry = (Map.Entry)i.next();
+                int device = ((Integer)entry.getKey()).intValue();
+                int index = ((Integer)entry.getValue()).intValue();
+                index = rescaleIndex(index, srcStream.getStreamType(), mStreamType);
+
+                if (lastAudible) {
+                    setLastAudibleIndex(index, device);
+                } else {
+                    setIndex(index, device, false /* lastAudible */);
+                }
+            }
+        }
+
+        public synchronized void setAllIndexesToMax() {
+            Set set = mIndex.entrySet();
+            Iterator i = set.iterator();
+            while (i.hasNext()) {
+                Map.Entry entry = (Map.Entry)i.next();
+                entry.setValue(mIndexMax);
+            }
+            set = mLastAudibleIndex.entrySet();
+            i = set.iterator();
+            while (i.hasNext()) {
+                Map.Entry entry = (Map.Entry)i.next();
+                entry.setValue(mIndexMax);
+            }
+        }
+
+        public synchronized void mute(IBinder cb, boolean state) {
+            VolumeDeathHandler handler = getDeathHandler(cb, state);
+            if (handler == null) {
+                Log.e(TAG, "Could not get client death handler for stream: "+mStreamType);
+                return;
+            }
+            handler.mute(state);
+        }
+
+        public int getStreamType() {
+            return mStreamType;
+        }
+
+        private int getValidIndex(int index) {
+            if (index < 0) {
+                return 0;
+            } else if (index > mIndexMax) {
+                return mIndexMax;
+            }
+
+            return index;
+        }
+
+        private class VolumeDeathHandler implements IBinder.DeathRecipient {
+            private IBinder mICallback; // To be notified of client's death
+            private int mMuteCount; // Number of active mutes for this client
+
+            VolumeDeathHandler(IBinder cb) {
+                mICallback = cb;
+            }
+
+            // must be called while synchronized on parent VolumeStreamState
+            public void mute(boolean state) {
+                if (state) {
+                    if (mMuteCount == 0) {
+                        // Register for client death notification
+                        try {
+                            // mICallback can be 0 if muted by AudioService
+                            if (mICallback != null) {
+                                mICallback.linkToDeath(this, 0);
+                            }
+                            mDeathHandlers.add(this);
+                            // If the stream is not yet muted by any client, set level to 0
+                            if (muteCount() == 0) {
+                                Set set = mIndex.entrySet();
+                                Iterator i = set.iterator();
+                                while (i.hasNext()) {
+                                    Map.Entry entry = (Map.Entry)i.next();
+                                    int streamTypeAlias = mStreamVolumeAlias[mStreamType];
+                                    int device = getDeviceForStream(streamTypeAlias);
+                                    setIndex(0, device, false /* lastAudible */);
+                                    device = ((Integer)entry.getKey()).intValue();
+                                    setIndex(0, device, false /* lastAudible */);
+                                }
+                                sendMsg(mAudioHandler,
+                                        MSG_SET_ALL_VOLUMES,
+                                        SENDMSG_QUEUE,
+                                        0,
+                                        0,
+                                        VolumeStreamState.this, 0);
+                            }
+                        } catch (RemoteException e) {
+                            // Client has died!
+                            binderDied();
+                            return;
+                        }
+                    } else {
+                        Log.w(TAG, "stream: "+mStreamType+" was already muted by this client");
+                    }
+                    mMuteCount++;
+                } else {
+                    if (mMuteCount == 0) {
+                        Log.e(TAG, "unexpected unmute for stream: "+mStreamType);
+                    } else {
+                        mMuteCount--;
+                        if (mMuteCount == 0) {
+                            // Unregister from client death notification
+                            mDeathHandlers.remove(this);
+                            // mICallback can be 0 if muted by AudioService
+                            if (mICallback != null) {
+                                mICallback.unlinkToDeath(this, 0);
+                            }
+                            if (muteCount() == 0) {
+                                // If the stream is not muted any more, restore its volume if
+                                // ringer mode allows it
+                                if (!isStreamAffectedByRingerMode(mStreamType) ||
+                                        mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
+                                    Set set = mIndex.entrySet();
+                                    Iterator i = set.iterator();
+                                    while (i.hasNext()) {
+                                        Map.Entry entry = (Map.Entry)i.next();
+                                        int device = ((Integer)entry.getKey()).intValue();
+                                        setIndex(getIndex(device,
+                                                          true  /* lastAudible */),
+                                                 device,
+                                                 false  /* lastAudible */);
+                                    }
+                                    sendMsg(mAudioHandler,
+                                            MSG_SET_ALL_VOLUMES,
+                                            SENDMSG_QUEUE,
+                                            0,
+                                            0,
+                                            VolumeStreamState.this, 0);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            public void binderDied() {
+                Log.w(TAG, "Volume service client died for stream: "+mStreamType);
+                if (mMuteCount != 0) {
+                    // Reset all active mute requests from this client.
+                    mMuteCount = 1;
+                    mute(false);
+                }
+            }
+        }
+
+        private synchronized int muteCount() {
+            int count = 0;
+            int size = mDeathHandlers.size();
+            for (int i = 0; i < size; i++) {
+                count += mDeathHandlers.get(i).mMuteCount;
+            }
+            return count;
+        }
+
+        // only called by mute() which is already synchronized
+        private VolumeDeathHandler getDeathHandler(IBinder cb, boolean state) {
+            VolumeDeathHandler handler;
+            int size = mDeathHandlers.size();
+            for (int i = 0; i < size; i++) {
+                handler = mDeathHandlers.get(i);
+                if (cb == handler.mICallback) {
+                    return handler;
+                }
+            }
+            // If this is the first mute request for this client, create a new
+            // client death handler. Otherwise, it is an out of sequence unmute request.
+            if (state) {
+                handler = new VolumeDeathHandler(cb);
+            } else {
+                Log.w(TAG, "stream was not muted by this client");
+                handler = null;
+            }
+            return handler;
+        }
+
+        private void dump(PrintWriter pw) {
+            pw.print("   Mute count: ");
+            pw.println(muteCount());
+            pw.print("   Current: ");
+            Set set = mIndex.entrySet();
+            Iterator i = set.iterator();
+            while (i.hasNext()) {
+                Map.Entry entry = (Map.Entry)i.next();
+                pw.print(Integer.toHexString(((Integer)entry.getKey()).intValue())
+                             + ": " + ((((Integer)entry.getValue()).intValue() + 5) / 10)+", ");
+            }
+            pw.print("\n   Last audible: ");
+            set = mLastAudibleIndex.entrySet();
+            i = set.iterator();
+            while (i.hasNext()) {
+                Map.Entry entry = (Map.Entry)i.next();
+                pw.print(Integer.toHexString(((Integer)entry.getKey()).intValue())
+                             + ": " + ((((Integer)entry.getValue()).intValue() + 5) / 10)+", ");
+            }
+        }
+    }
+
+    /** Thread that handles native AudioSystem control. */
+    private class AudioSystemThread extends Thread {
+        AudioSystemThread() {
+            super("AudioService");
+        }
+
+        @Override
+        public void run() {
+            // Set this thread up so the handler will work on it
+            Looper.prepare();
+
+            synchronized(AudioService.this) {
+                mAudioHandler = new AudioHandler();
+
+                // Notify that the handler has been created
+                AudioService.this.notify();
+            }
+
+            // Listen for volume change requests that are set by VolumePanel
+            Looper.loop();
+        }
+    }
+
+    /** Handles internal volume messages in separate volume thread. */
+    private class AudioHandler extends Handler {
+
+        private void setDeviceVolume(VolumeStreamState streamState, int device) {
+
+            // Apply volume
+            streamState.applyDeviceVolume(device);
+
+            // Apply change to all streams using this one as alias
+            int numStreamTypes = AudioSystem.getNumStreamTypes();
+            for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
+                if (streamType != streamState.mStreamType &&
+                        mStreamVolumeAlias[streamType] == streamState.mStreamType) {
+                    mStreamStates[streamType].applyDeviceVolume(getDeviceForStream(streamType));
+                }
+            }
+
+            // Post a persist volume msg
+            sendMsg(mAudioHandler,
+                    MSG_PERSIST_VOLUME,
+                    SENDMSG_QUEUE,
+                    PERSIST_CURRENT|PERSIST_LAST_AUDIBLE,
+                    device,
+                    streamState,
+                    PERSIST_DELAY);
+
+        }
+
+        private void setAllVolumes(VolumeStreamState streamState) {
+
+            // Apply volume
+            streamState.applyAllVolumes();
+
+            // Apply change to all streams using this one as alias
+            int numStreamTypes = AudioSystem.getNumStreamTypes();
+            for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
+                if (streamType != streamState.mStreamType &&
+                        mStreamVolumeAlias[streamType] == streamState.mStreamType) {
+                    mStreamStates[streamType].applyAllVolumes();
+                }
+            }
+        }
+
+        private void persistVolume(VolumeStreamState streamState,
+                                   int persistType,
+                                   int device) {
+            if ((persistType & PERSIST_CURRENT) != 0) {
+                System.putIntForUser(mContentResolver,
+                          streamState.getSettingNameForDevice(false /* lastAudible */, device),
+                          (streamState.getIndex(device, false /* lastAudible */) + 5)/ 10,
+                          UserHandle.USER_CURRENT);
+            }
+            if ((persistType & PERSIST_LAST_AUDIBLE) != 0) {
+                System.putIntForUser(mContentResolver,
+                        streamState.getSettingNameForDevice(true /* lastAudible */, device),
+                        (streamState.getIndex(device, true  /* lastAudible */) + 5) / 10,
+                        UserHandle.USER_CURRENT);
+            }
+        }
+
+        private void persistRingerMode(int ringerMode) {
+            Settings.Global.putInt(mContentResolver, Settings.Global.MODE_RINGER, ringerMode);
+        }
+
+        private void playSoundEffect(int effectType, int volume) {
+            synchronized (mSoundEffectsLock) {
+                if (mSoundPool == null) {
+                    return;
+                }
+                float volFloat;
+                // use default if volume is not specified by caller
+                if (volume < 0) {
+                    volFloat = (float)Math.pow(10, (float)sSoundEffectVolumeDb/20);
+                } else {
+                    volFloat = (float) volume / 1000.0f;
+                }
+
+                if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
+                    mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1], volFloat, volFloat, 0, 0, 1.0f);
+                } else {
+                    MediaPlayer mediaPlayer = new MediaPlayer();
+                    try {
+                        String filePath = Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effectType][0]];
+                        mediaPlayer.setDataSource(filePath);
+                        mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
+                        mediaPlayer.prepare();
+                        mediaPlayer.setVolume(volFloat, volFloat);
+                        mediaPlayer.setOnCompletionListener(new OnCompletionListener() {
+                            public void onCompletion(MediaPlayer mp) {
+                                cleanupPlayer(mp);
+                            }
+                        });
+                        mediaPlayer.setOnErrorListener(new OnErrorListener() {
+                            public boolean onError(MediaPlayer mp, int what, int extra) {
+                                cleanupPlayer(mp);
+                                return true;
+                            }
+                        });
+                        mediaPlayer.start();
+                    } catch (IOException ex) {
+                        Log.w(TAG, "MediaPlayer IOException: "+ex);
+                    } catch (IllegalArgumentException ex) {
+                        Log.w(TAG, "MediaPlayer IllegalArgumentException: "+ex);
+                    } catch (IllegalStateException ex) {
+                        Log.w(TAG, "MediaPlayer IllegalStateException: "+ex);
+                    }
+                }
+            }
+        }
+
+        private void onHandlePersistMediaButtonReceiver(ComponentName receiver) {
+            Settings.System.putStringForUser(mContentResolver,
+                                             Settings.System.MEDIA_BUTTON_RECEIVER,
+                                             receiver == null ? "" : receiver.flattenToString(),
+                                             UserHandle.USER_CURRENT);
+        }
+
+        private void cleanupPlayer(MediaPlayer mp) {
+            if (mp != null) {
+                try {
+                    mp.stop();
+                    mp.release();
+                } catch (IllegalStateException ex) {
+                    Log.w(TAG, "MediaPlayer IllegalStateException: "+ex);
+                }
+            }
+        }
+
+        private void setForceUse(int usage, int config) {
+            AudioSystem.setForceUse(usage, config);
+        }
+
+        private void onPersistSafeVolumeState(int state) {
+            Settings.Global.putInt(mContentResolver,
+                    Settings.Global.AUDIO_SAFE_VOLUME_STATE,
+                    state);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+
+            switch (msg.what) {
+
+                case MSG_SET_DEVICE_VOLUME:
+                    setDeviceVolume((VolumeStreamState) msg.obj, msg.arg1);
+                    break;
+
+                case MSG_SET_ALL_VOLUMES:
+                    setAllVolumes((VolumeStreamState) msg.obj);
+                    break;
+
+                case MSG_PERSIST_VOLUME:
+                    persistVolume((VolumeStreamState) msg.obj, msg.arg1, msg.arg2);
+                    break;
+
+                case MSG_PERSIST_MASTER_VOLUME:
+                    Settings.System.putFloatForUser(mContentResolver,
+                                                    Settings.System.VOLUME_MASTER,
+                                                    (float)msg.arg1 / (float)1000.0,
+                                                    UserHandle.USER_CURRENT);
+                    break;
+
+                case MSG_PERSIST_MASTER_VOLUME_MUTE:
+                    Settings.System.putIntForUser(mContentResolver,
+                                                 Settings.System.VOLUME_MASTER_MUTE,
+                                                 msg.arg1,
+                                                 UserHandle.USER_CURRENT);
+                    break;
+
+                case MSG_PERSIST_RINGER_MODE:
+                    // note that the value persisted is the current ringer mode, not the
+                    // value of ringer mode as of the time the request was made to persist
+                    persistRingerMode(getRingerMode());
+                    break;
+
+                case MSG_MEDIA_SERVER_DIED:
+                    if (!mMediaServerOk) {
+                        Log.e(TAG, "Media server died.");
+                        // Force creation of new IAudioFlinger interface so that we are notified
+                        // when new media_server process is back to life.
+                        AudioSystem.setErrorCallback(mAudioSystemCallback);
+                        sendMsg(mAudioHandler, MSG_MEDIA_SERVER_DIED, SENDMSG_NOOP, 0, 0,
+                                null, 500);
+                    }
+                    break;
+
+                case MSG_MEDIA_SERVER_STARTED:
+                    Log.e(TAG, "Media server started.");
+                    // indicate to audio HAL that we start the reconfiguration phase after a media
+                    // server crash
+                    // Note that MSG_MEDIA_SERVER_STARTED message is only received when the media server
+                    // process restarts after a crash, not the first time it is started.
+                    AudioSystem.setParameters("restarting=true");
+
+                    // Restore device connection states
+                    synchronized (mConnectedDevices) {
+                        Set set = mConnectedDevices.entrySet();
+                        Iterator i = set.iterator();
+                        while (i.hasNext()) {
+                            Map.Entry device = (Map.Entry)i.next();
+                            AudioSystem.setDeviceConnectionState(
+                                                            ((Integer)device.getKey()).intValue(),
+                                                            AudioSystem.DEVICE_STATE_AVAILABLE,
+                                                            (String)device.getValue());
+                        }
+                    }
+                    // Restore call state
+                    AudioSystem.setPhoneState(mMode);
+
+                    // Restore forced usage for communcations and record
+                    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION, mForcedUseForComm);
+                    AudioSystem.setForceUse(AudioSystem.FOR_RECORD, mForcedUseForComm);
+                    AudioSystem.setForceUse(AudioSystem.FOR_SYSTEM, mCameraSoundForced ?
+                                    AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE);
+
+                    // Restore stream volumes
+                    int numStreamTypes = AudioSystem.getNumStreamTypes();
+                    for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
+                        VolumeStreamState streamState = mStreamStates[streamType];
+                        AudioSystem.initStreamVolume(streamType, 0, (streamState.mIndexMax + 5) / 10);
+
+                        streamState.applyAllVolumes();
+                    }
+
+                    // Restore ringer mode
+                    setRingerModeInt(getRingerMode(), false);
+
+                    // Restore master volume
+                    restoreMasterVolume();
+
+                    // Reset device orientation (if monitored for this device)
+                    if (mMonitorOrientation) {
+                        setOrientationForAudioSystem();
+                    }
+
+                    synchronized (mBluetoothA2dpEnabledLock) {
+                        AudioSystem.setForceUse(AudioSystem.FOR_MEDIA,
+                                mBluetoothA2dpEnabled ?
+                                        AudioSystem.FORCE_NONE : AudioSystem.FORCE_NO_BT_A2DP);
+                    }
+
+                    synchronized (mSettingsLock) {
+                        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,
+                                mDockAudioMediaEnabled ?
+                                        AudioSystem.FORCE_ANALOG_DOCK : AudioSystem.FORCE_NONE);
+                    }
+
+                    // indicate the end of reconfiguration phase to audio HAL
+                    AudioSystem.setParameters("restarting=false");
+                    break;
+
+                case MSG_LOAD_SOUND_EFFECTS:
+                    loadSoundEffects();
+                    break;
+
+                case MSG_PLAY_SOUND_EFFECT:
+                    playSoundEffect(msg.arg1, msg.arg2);
+                    break;
+
+                case MSG_BTA2DP_DOCK_TIMEOUT:
+                    // msg.obj  == address of BTA2DP device
+                    synchronized (mConnectedDevices) {
+                        makeA2dpDeviceUnavailableNow( (String) msg.obj );
+                    }
+                    break;
+
+                case MSG_SET_FORCE_USE:
+                case MSG_SET_FORCE_BT_A2DP_USE:
+                    setForceUse(msg.arg1, msg.arg2);
+                    break;
+
+                case MSG_PERSIST_MEDIABUTTONRECEIVER:
+                    onHandlePersistMediaButtonReceiver( (ComponentName) msg.obj );
+                    break;
+
+                case MSG_RCDISPLAY_CLEAR:
+                    onRcDisplayClear();
+                    break;
+
+                case MSG_RCDISPLAY_UPDATE:
+                    // msg.obj is guaranteed to be non null
+                    onRcDisplayUpdate( (RemoteControlStackEntry) msg.obj, msg.arg1);
+                    break;
+
+                case MSG_BT_HEADSET_CNCT_FAILED:
+                    resetBluetoothSco();
+                    break;
+
+                case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
+                    onSetWiredDeviceConnectionState(msg.arg1, msg.arg2, (String)msg.obj);
+                    mMediaEventWakeLock.release();
+                    break;
+
+                case MSG_SET_A2DP_CONNECTION_STATE:
+                    onSetA2dpConnectionState((BluetoothDevice)msg.obj, msg.arg1);
+                    mMediaEventWakeLock.release();
+                    break;
+
+                case MSG_REPORT_NEW_ROUTES: {
+                    int N = mRoutesObservers.beginBroadcast();
+                    if (N > 0) {
+                        AudioRoutesInfo routes;
+                        synchronized (mCurAudioRoutes) {
+                            routes = new AudioRoutesInfo(mCurAudioRoutes);
+                        }
+                        while (N > 0) {
+                            N--;
+                            IAudioRoutesObserver obs = mRoutesObservers.getBroadcastItem(N);
+                            try {
+                                obs.dispatchAudioRoutesChanged(routes);
+                            } catch (RemoteException e) {
+                            }
+                        }
+                    }
+                    mRoutesObservers.finishBroadcast();
+                    break;
+                }
+
+                case MSG_REEVALUATE_REMOTE:
+                    onReevaluateRemote();
+                    break;
+
+                case MSG_RCC_NEW_PLAYBACK_INFO:
+                    onNewPlaybackInfoForRcc(msg.arg1 /* rccId */, msg.arg2 /* key */,
+                            ((Integer)msg.obj).intValue() /* value */);
+                    break;
+                case MSG_RCC_NEW_VOLUME_OBS:
+                    onRegisterVolumeObserverForRcc(msg.arg1 /* rccId */,
+                            (IRemoteVolumeObserver)msg.obj /* rvo */);
+                    break;
+
+                case MSG_SET_RSX_CONNECTION_STATE:
+                    onSetRsxConnectionState(msg.arg1/*available*/, msg.arg2/*address*/);
+                    break;
+
+                case MSG_CHECK_MUSIC_ACTIVE:
+                    onCheckMusicActive();
+                    break;
+
+                case MSG_BROADCAST_AUDIO_BECOMING_NOISY:
+                    onSendBecomingNoisyIntent();
+                    break;
+
+                case MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED:
+                case MSG_CONFIGURE_SAFE_MEDIA_VOLUME:
+                    onConfigureSafeVolume((msg.what == MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED));
+                    break;
+                case MSG_PERSIST_SAFE_VOLUME_STATE:
+                    onPersistSafeVolumeState(msg.arg1);
+                    break;
+            }
+        }
+    }
+
+    private class SettingsObserver extends ContentObserver {
+
+        SettingsObserver() {
+            super(new Handler());
+            mContentResolver.registerContentObserver(Settings.System.getUriFor(
+                Settings.System.MODE_RINGER_STREAMS_AFFECTED), false, this);
+            mContentResolver.registerContentObserver(Settings.Global.getUriFor(
+                Settings.Global.DOCK_AUDIO_MEDIA_ENABLED), false, this);
+            mContentResolver.registerContentObserver(Settings.System.getUriFor(
+                Settings.System.VOLUME_LINK_NOTIFICATION), false, this);
+            mContentResolver.registerContentObserver(Settings.System.getUriFor(
+                Settings.System.SAFE_HEADSET_VOLUME), false, this);
+            mContentResolver.registerContentObserver(Settings.System.getUriFor(
+                Settings.System.VOLUME_KEYS_CONTROL_RING_STREAM), false, this);
+        }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            super.onChange(selfChange, uri);
+            // FIXME This synchronized is not necessary if mSettingsLock only protects mRingerMode.
+            //       However there appear to be some missing locks around mRingerModeMutedStreams
+            //       and mRingerModeAffectedStreams, so will leave this synchronized for now.
+            //       mRingerModeMutedStreams and mMuteAffectedStreams are safe (only accessed once).
+            synchronized (mSettingsLock) {
+                if (uri.equals(Settings.System.getUriFor(Settings.System.MODE_RINGER_STREAMS_AFFECTED))) {
+                    int ringerModeAffectedStreams = Settings.System.getIntForUser(mContentResolver,
+                           Settings.System.MODE_RINGER_STREAMS_AFFECTED,
+                           ((1 << AudioSystem.STREAM_RING)|(1 << AudioSystem.STREAM_NOTIFICATION)|
+                           (1 << AudioSystem.STREAM_SYSTEM)|(1 << AudioSystem.STREAM_SYSTEM_ENFORCED)),
+                           UserHandle.USER_CURRENT);
+                    if (mVoiceCapable) {
+                        ringerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_MUSIC);
+                    } else {
+                        ringerModeAffectedStreams |= (1 << AudioSystem.STREAM_MUSIC);
+                    }
+                    synchronized (mCameraSoundForced) {
+                        if (mCameraSoundForced) {
+                            ringerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
+                        } else {
+                            ringerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
+                        }
+                    }
+                    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
+                        /*
+                         * Ensure all stream types that should be affected by ringer mode
+                         * are in the proper state.
+                         */
+                        mRingerModeAffectedStreams = ringerModeAffectedStreams;
+                        setRingerModeInt(getRingerMode(), false);
+                    }
+
+                } else if (uri.equals(Settings.Global.getUriFor(Settings.Global.DOCK_AUDIO_MEDIA_ENABLED))) {
+                    readDockAudioSettings(mContentResolver);
+
+                } else if (uri.equals(Settings.System.getUriFor(Settings.System.VOLUME_LINK_NOTIFICATION))) {
+                    mLinkNotificationWithVolume = Settings.System.getInt(mContentResolver,
+                            Settings.System.VOLUME_LINK_NOTIFICATION, 1) == 1;
+                    if (mLinkNotificationWithVolume) {
+                        mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_RING;
+                    } else {
+                        mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_NOTIFICATION;
+                    }
+
+                } else if (uri.equals(Settings.System.getUriFor(Settings.System.SAFE_HEADSET_VOLUME))) {
+                    mSafeVolumeEnabled = safeVolumeEnabled(mContentResolver);
+                } else if (uri.equals(Settings.System.getUriFor(Settings.System.VOLUME_KEYS_CONTROL_RING_STREAM))) {
+                    mVolumeKeysControlRingStream = Settings.System.getIntForUser(mContentResolver,
+                            Settings.System.VOLUME_KEYS_CONTROL_RING_STREAM, 1, UserHandle.USER_CURRENT) == 1;
+                }
+            }
+        }
+    }
+
+    // must be called synchronized on mConnectedDevices
+    private void makeA2dpDeviceAvailable(String address) {
+        // enable A2DP before notifying A2DP connection to avoid unecessary processing in
+        // audio policy manager
+        setBluetoothA2dpOnInt(true);
+        AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
+                AudioSystem.DEVICE_STATE_AVAILABLE,
+                address);
+        // Reset A2DP suspend state each time a new sink is connected
+        AudioSystem.setParameters("A2dpSuspended=false");
+        mConnectedDevices.put( new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),
+                address);
+    }
+
+    private void onSendBecomingNoisyIntent() {
+        sendBroadcastToAll(new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY));
+    }
+
+    // must be called synchronized on mConnectedDevices
+    private void makeA2dpDeviceUnavailableNow(String address) {
+        if (noDelayInATwoDP) {
+            onSendBecomingNoisyIntent();
+        }
+        AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
+                AudioSystem.DEVICE_STATE_UNAVAILABLE,
+                address);
+        mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
+    }
+
+    // must be called synchronized on mConnectedDevices
+    private void makeA2dpDeviceUnavailableLater(String address) {
+        // prevent any activity on the A2DP audio output to avoid unwanted
+        // reconnection of the sink.
+        AudioSystem.setParameters("A2dpSuspended=true");
+        // the device will be made unavailable later, so consider it disconnected right away
+        mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
+        // send the delayed message to make the device unavailable later
+        Message msg = mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT, address);
+        mAudioHandler.sendMessageDelayed(msg, BTA2DP_DOCK_TIMEOUT_MILLIS);
+
+    }
+
+    // must be called synchronized on mConnectedDevices
+    private void cancelA2dpDeviceTimeout() {
+        mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
+    }
+
+    // must be called synchronized on mConnectedDevices
+    private boolean hasScheduledA2dpDockTimeout() {
+        return mAudioHandler.hasMessages(MSG_BTA2DP_DOCK_TIMEOUT);
+    }
+
+    private void onSetA2dpConnectionState(BluetoothDevice btDevice, int state)
+    {
+        if (btDevice == null) {
+            return;
+        }
+        String address = btDevice.getAddress();
+        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+            address = "";
+        }
+        synchronized (mConnectedDevices) {
+            boolean isConnected =
+                (mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) &&
+                 mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP).equals(address));
+
+            if (isConnected && state != BluetoothProfile.STATE_CONNECTED) {
+                if (btDevice.isBluetoothDock()) {
+                    if (state == BluetoothProfile.STATE_DISCONNECTED) {
+                        // introduction of a delay for transient disconnections of docks when
+                        // power is rapidly turned off/on, this message will be canceled if
+                        // we reconnect the dock under a preset delay
+                        makeA2dpDeviceUnavailableLater(address);
+                        // the next time isConnected is evaluated, it will be false for the dock
+                    }
+                } else {
+                    makeA2dpDeviceUnavailableNow(address);
+                }
+                synchronized (mCurAudioRoutes) {
+                    if (mCurAudioRoutes.mBluetoothName != null) {
+                        mCurAudioRoutes.mBluetoothName = null;
+                        sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES,
+                                SENDMSG_NOOP, 0, 0, null, 0);
+                    }
+                }
+            } else if (!isConnected && state == BluetoothProfile.STATE_CONNECTED) {
+                if (btDevice.isBluetoothDock()) {
+                    // this could be a reconnection after a transient disconnection
+                    cancelA2dpDeviceTimeout();
+                    mDockAddress = address;
+                } else {
+                    // this could be a connection of another A2DP device before the timeout of
+                    // a dock: cancel the dock timeout, and make the dock unavailable now
+                    if(hasScheduledA2dpDockTimeout()) {
+                        cancelA2dpDeviceTimeout();
+                        makeA2dpDeviceUnavailableNow(mDockAddress);
+                    }
+                }
+                makeA2dpDeviceAvailable(address);
+                synchronized (mCurAudioRoutes) {
+                    String name = btDevice.getAliasName();
+                    if (!TextUtils.equals(mCurAudioRoutes.mBluetoothName, name)) {
+                        mCurAudioRoutes.mBluetoothName = name;
+                        sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES,
+                                SENDMSG_NOOP, 0, 0, null, 0);
+                    }
+                }
+            }
+        }
+    }
+
+    private boolean handleDeviceConnection(boolean connected, int device, String params) {
+        synchronized (mConnectedDevices) {
+            boolean isConnected = (mConnectedDevices.containsKey(device) &&
+                    (params.isEmpty() || mConnectedDevices.get(device).equals(params)));
+
+            if (isConnected && !connected) {
+                AudioSystem.setDeviceConnectionState(device,
+                                              AudioSystem.DEVICE_STATE_UNAVAILABLE,
+                                              mConnectedDevices.get(device));
+                 mConnectedDevices.remove(device);
+                 return true;
+            } else if (!isConnected && connected) {
+                 AudioSystem.setDeviceConnectionState(device,
+                                                      AudioSystem.DEVICE_STATE_AVAILABLE,
+                                                      params);
+                 mConnectedDevices.put(new Integer(device), params);
+                 return true;
+            }
+        }
+        return false;
+    }
+
+    // Devices which removal triggers intent ACTION_AUDIO_BECOMING_NOISY. The intent is only
+    // sent if none of these devices is connected.
+    int mBecomingNoisyIntentDevices =
+            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
+            AudioSystem.DEVICE_OUT_ALL_A2DP | AudioSystem.DEVICE_OUT_AUX_DIGITAL |
+            AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET | AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
+            AudioSystem.DEVICE_OUT_ALL_USB;
+
+    // must be called before removing the device from mConnectedDevices
+    private int checkSendBecomingNoisyIntent(int device, int state) {
+        int delay = 0;
+        if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
+            int devices = 0;
+            for (int dev : mConnectedDevices.keySet()) {
+                if ((dev & mBecomingNoisyIntentDevices) != 0) {
+                   devices |= dev;
+                }
+            }
+            if (devices == device) {
+                sendMsg(mAudioHandler,
+                        MSG_BROADCAST_AUDIO_BECOMING_NOISY,
+                        SENDMSG_REPLACE,
+                        0,
+                        0,
+                        null,
+                        0);
+                delay = 1000;
+            }
+        }
+
+        if (mAudioHandler.hasMessages(MSG_SET_A2DP_CONNECTION_STATE) ||
+                mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
+            delay = 1000;
+        }
+        return delay;
+    }
+
+    private void sendDeviceConnectionIntent(int device, int state, String name)
+    {
+        Intent intent = new Intent();
+
+        intent.putExtra("state", state);
+        intent.putExtra("name", name);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
+
+        int connType = 0;
+
+        if (device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) {
+            connType = AudioRoutesInfo.MAIN_HEADSET;
+            intent.setAction(Intent.ACTION_HEADSET_PLUG);
+            intent.putExtra("microphone", 1);
+        } else if (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE) {
+            connType = AudioRoutesInfo.MAIN_HEADPHONES;
+            intent.setAction(Intent.ACTION_HEADSET_PLUG);
+            intent.putExtra("microphone", 0);
+        } else if (device == AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET) {
+            connType = AudioRoutesInfo.MAIN_DOCK_SPEAKERS;
+            intent.setAction(Intent.ACTION_ANALOG_AUDIO_DOCK_PLUG);
+        } else if (device == AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET) {
+            connType = AudioRoutesInfo.MAIN_DOCK_SPEAKERS;
+            intent.setAction(Intent.ACTION_DIGITAL_AUDIO_DOCK_PLUG);
+        } else if (device == AudioSystem.DEVICE_OUT_AUX_DIGITAL) {
+            connType = AudioRoutesInfo.MAIN_HDMI;
+            intent.setAction(Intent.ACTION_HDMI_AUDIO_PLUG);
+        }
+
+        synchronized (mCurAudioRoutes) {
+            if (connType != 0) {
+                int newConn = mCurAudioRoutes.mMainType;
+                if (state != 0) {
+                    newConn |= connType;
+                } else {
+                    newConn &= ~connType;
+                }
+                if (newConn != mCurAudioRoutes.mMainType) {
+                    mCurAudioRoutes.mMainType = newConn;
+                    sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES,
+                            SENDMSG_NOOP, 0, 0, null, 0);
+                }
+            }
+        }
+
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            ActivityManagerNative.broadcastStickyIntent(intent, null, UserHandle.USER_ALL);
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    private void onSetWiredDeviceConnectionState(int device, int state, String name)
+    {
+        synchronized (mConnectedDevices) {
+            if ((state == 0) && ((device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) ||
+                    (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE))) {
+                setBluetoothA2dpOnInt(true);
+            }
+            boolean isUsb = ((device & AudioSystem.DEVICE_OUT_ALL_USB) != 0);
+            handleDeviceConnection((state == 1), device, (isUsb ? name : ""));
+            if (state != 0) {
+                if ((device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) ||
+                    (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE)) {
+                    setBluetoothA2dpOnInt(false);
+                }
+                if ((device & mSafeMediaVolumeDevices) != 0) {
+                    sendMsg(mAudioHandler,
+                            MSG_CHECK_MUSIC_ACTIVE,
+                            SENDMSG_REPLACE,
+                            0,
+                            0,
+                            null,
+                            MUSIC_ACTIVE_POLL_PERIOD_MS);
+                }
+            }
+            if (!isUsb) {
+                sendDeviceConnectionIntent(device, state, name);
+            }
+        }
+    }
+
+    /* cache of the address of the last dock the device was connected to */
+    private String mDockAddress;
+
+    /**
+     * Receiver for misc intent broadcasts the Phone app cares about.
+     */
+    private class AudioServiceBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            int device;
+            int state;
+
+            if (action.equals(Intent.ACTION_DOCK_EVENT)) {
+                int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
+                        Intent.EXTRA_DOCK_STATE_UNDOCKED);
+                int config;
+                switch (dockState) {
+                    case Intent.EXTRA_DOCK_STATE_DESK:
+                        config = mForceAnalogDeskDock ? AudioSystem.FORCE_ANALOG_DOCK : AudioSystem.FORCE_BT_DESK_DOCK;
+                        break;
+                    case Intent.EXTRA_DOCK_STATE_CAR:
+                        config = mForceAnalogCarDock ? AudioSystem.FORCE_ANALOG_DOCK : AudioSystem.FORCE_BT_CAR_DOCK;
+                        break;
+                    case Intent.EXTRA_DOCK_STATE_LE_DESK:
+                        config = AudioSystem.FORCE_ANALOG_DOCK;
+                        break;
+                    case Intent.EXTRA_DOCK_STATE_HE_DESK:
+                        config = AudioSystem.FORCE_DIGITAL_DOCK;
+                        break;
+                    case Intent.EXTRA_DOCK_STATE_UNDOCKED:
+                    default:
+                        config = AudioSystem.FORCE_NONE;
+                }
+
+                // Low end docks have a menu to enable or disable audio
+                // (see mDockAudioMediaEnabled)
+                if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) ||
+                      ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) &&
+                       (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
+                    AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
+                }
+                mDockState = dockState;
+            } else if (action.equals(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED) && noDelayInATwoDP) {
+                state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                                           BluetoothProfile.STATE_DISCONNECTED);
+                BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+                onSetA2dpConnectionState(btDevice, state);
+            } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
+                state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                                               BluetoothProfile.STATE_DISCONNECTED);
+                device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
+                String address = null;
+
+                BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+                if (btDevice == null) {
+                    return;
+                }
+
+                address = btDevice.getAddress();
+                BluetoothClass btClass = btDevice.getBluetoothClass();
+                if (btClass != null) {
+                    switch (btClass.getDeviceClass()) {
+                    case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
+                    case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
+                        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
+                        break;
+                    case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
+                        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
+                        break;
+                    }
+                }
+
+                if (!BluetoothAdapter.checkBluetoothAddress(address)) {
+                    address = "";
+                }
+
+                boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
+                if (handleDeviceConnection(connected, device, address)) {
+                    synchronized (mScoClients) {
+                        if (connected) {
+                            mBluetoothHeadsetDevice = btDevice;
+                        } else {
+                            mBluetoothHeadsetDevice = null;
+                            resetBluetoothSco();
+                        }
+                    }
+                }
+            } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
+                state = intent.getIntExtra("state", 0);
+                if (state == 1) {
+                    // Headset plugged in
+                    adjustCurrentStreamVolume();
+                    // TODO: Cap volume at safe levels
+                } else {
+                    // Headset disconnected
+                    adjustCurrentStreamVolume();
+                }
+            } else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ||
+                           action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
+                state = intent.getIntExtra("state", 0);
+                int alsaCard = intent.getIntExtra("card", -1);
+                int alsaDevice = intent.getIntExtra("device", -1);
+                String params = (alsaCard == -1 && alsaDevice == -1 ? ""
+                                    : "card=" + alsaCard + ";device=" + alsaDevice);
+                device = action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ?
+                        AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
+                Log.v(TAG, "Broadcast Receiver: Got "
+                        + (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ?
+                              "ACTION_USB_AUDIO_ACCESSORY_PLUG" : "ACTION_USB_AUDIO_DEVICE_PLUG")
+                        + ", state = " + state + ", card: " + alsaCard + ", device: " + alsaDevice);
+                setWiredDeviceConnectionState(device, state, params);
+            } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
+                boolean broadcast = false;
+                int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
+                synchronized (mScoClients) {
+                    int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
+                    // broadcast intent if the connection was initated by AudioService
+                    if (!mScoClients.isEmpty() &&
+                            (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL ||
+                             mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
+                             mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
+                        broadcast = true;
+                    }
+                    switch (btState) {
+                    case BluetoothHeadset.STATE_AUDIO_CONNECTED:
+                        scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
+                        if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
+                            mScoAudioState != SCO_STATE_DEACTIVATE_REQ &&
+                            mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
+                            mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
+                        }
+                        break;
+                    case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
+                        scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
+                        mScoAudioState = SCO_STATE_INACTIVE;
+                        clearAllScoClients(0, false);
+                        break;
+                    case BluetoothHeadset.STATE_AUDIO_CONNECTING:
+                        if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
+                            mScoAudioState != SCO_STATE_DEACTIVATE_REQ &&
+                            mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
+                            mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
+                        }
+                    default:
+                        // do not broadcast CONNECTING or invalid state
+                        broadcast = false;
+                        break;
+                    }
+                }
+                if (broadcast) {
+                    broadcastScoConnectionState(scoAudioState);
+                    //FIXME: this is to maintain compatibility with deprecated intent
+                    // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
+                    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
+                    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
+                    sendStickyBroadcastToAll(newIntent);
+                }
+            } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
+                mBootCompleted = true;
+                sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_NOOP,
+                        0, 0, null, 0);
+
+                mKeyguardManager =
+                        (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
+                mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
+                resetBluetoothSco();
+                getBluetoothHeadset();
+                //FIXME: this is to maintain compatibility with deprecated intent
+                // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
+                Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
+                newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,
+                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
+                sendStickyBroadcastToAll(newIntent);
+
+                BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+                if (adapter != null) {
+                    adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
+                                            BluetoothProfile.A2DP);
+                }
+
+                sendMsg(mAudioHandler,
+                        MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED,
+                        SENDMSG_REPLACE,
+                        0,
+                        0,
+                        null,
+                        SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
+
+                adjustCurrentStreamVolume();
+            } else if (action.equals(Intent.ACTION_PACKAGE_REMOVED)) {
+                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {
+                    // a package is being removed, not replaced
+                    String packageName = intent.getData().getSchemeSpecificPart();
+                    if (packageName != null) {
+                        removeMediaButtonReceiverForPackage(packageName);
+                    }
+                }
+            } else if (action.equals(Intent.ACTION_FM)){
+               Log.v(TAG, "FM Intent received");
+               state = intent.getIntExtra("state", 0);
+               if(state == 1){
+                   AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM,
+                            AudioSystem.DEVICE_STATE_AVAILABLE,
+                            "");
+                    mConnectedDevices.put( new Integer(AudioSystem.DEVICE_OUT_FM), "");
+                }else if(state == 0){
+                    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM,
+                            AudioSystem.DEVICE_STATE_UNAVAILABLE,
+                            "");
+                    mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM);
+                }
+            }else if (action.equals(Intent.ACTION_FM_TX)){
+               state = intent.getIntExtra("state", 0);
+               Log.v(TAG, "FM Tx Intent received "+state);
+               boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_FM_TX);
+               if(state == 1 && !isConnected){
+                    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_TX,
+                            AudioSystem.DEVICE_STATE_AVAILABLE,
+                            "");
+                    mConnectedDevices.put( new Integer(AudioSystem.DEVICE_OUT_FM_TX), "");
+                }else if(state == 0 && isConnected){
+                    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_TX,
+                            AudioSystem.DEVICE_STATE_UNAVAILABLE,
+                            "");
+                    mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM_TX);
+                }				
+            } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                AudioSystem.setParameters("screen_state=on");
+            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                AudioSystem.setParameters("screen_state=off");
+            } else if (action.equalsIgnoreCase(Intent.ACTION_CONFIGURATION_CHANGED)) {
+                handleConfigurationChanged(context);
+            } else if (action.equals(Intent.ACTION_USER_BACKGROUND)) {
+                // attempt to stop music playback for background user
+                sendMsg(mAudioHandler,
+                        MSG_BROADCAST_AUDIO_BECOMING_NOISY,
+                        SENDMSG_REPLACE,
+                        0,
+                        0,
+                        null,
+                        0);
+            } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
+                // the current audio focus owner is no longer valid
+                discardAudioFocusOwner();
+
+                // load volume settings for new user
+                readAudioSettings(true /*userSwitch*/);
+                // preserve STREAM_MUSIC volume from one user to the next.
+                sendMsg(mAudioHandler,
+                        MSG_SET_ALL_VOLUMES,
+                        SENDMSG_QUEUE,
+                        0,
+                        0,
+                        mStreamStates[AudioSystem.STREAM_MUSIC], 0);
+            } else if (action.equals(Intent.ACTION_WIFI_DISPLAY_AUDIO)) {
+                state = intent.getIntExtra("state", 0);
+                Log.v(TAG, "WiFi Display device state "+state);
+                boolean isConnected = mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_PROXY);
+                if(state == 1 && !isConnected){
+                    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_PROXY,
+                            AudioSystem.DEVICE_STATE_AVAILABLE,
+                            "");
+                    mConnectedDevices.put( new Integer(AudioSystem.DEVICE_OUT_PROXY), "");
+                }else if(state == 0 && isConnected){
+                    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_PROXY,
+                            AudioSystem.DEVICE_STATE_UNAVAILABLE,
+                            "");
+                    mConnectedDevices.remove(AudioSystem.DEVICE_OUT_PROXY);
+                }
+            }
+        }
+
+        private void adjustCurrentStreamVolume() {
+            VolumeStreamState streamState;
+            int device;
+
+            for (int stream = 0; stream < AudioSystem.getNumStreamTypes(); stream++) {
+                if (stream == mStreamVolumeAlias[stream]) {
+                    streamState = mStreamStates[mStreamVolumeAlias[stream]];
+                    device = getDeviceForStream(stream);
+                    // apply stored value for device
+                    streamState.applyDeviceVolume(device);
+                }
+            }
+        }
+    }
+
+    private void masterVolumeChanged(final int flags) {
+        if (mUiContext != null && mVolumePanel != null) {
+            mVolumePanel.postMasterVolumeChanged(flags);
+        } else {
+            mHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (mUiContext == null) {
+                        mUiContext = ThemeUtils.createUiContext(mContext);
+                    }
+
+                    final Context context = mUiContext != null ? mUiContext : mContext;
+                    mVolumePanel = new VolumePanel(context, AudioService.this);
+                    mVolumePanel.postMasterVolumeChanged(flags);
+                }
+            });
+        }
+    }
+
+    private void masterMuteChanged(final int flags) {
+        if (mUiContext != null && mVolumePanel != null) {
+            mVolumePanel.postMasterMuteChanged(flags);
+        } else {
+            mHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (mUiContext == null) {
+                        mUiContext = ThemeUtils.createUiContext(mContext);
+                    }
+
+                    final Context context = mUiContext != null ? mUiContext : mContext;
+                    mVolumePanel = new VolumePanel(context, AudioService.this);
+                    mVolumePanel.postMasterMuteChanged(flags);
+                }
+            });
+        }
+    }
+
+    private void remoteSliderVisibility(final boolean hasRemotePlayback) {
+        if (mUiContext != null && mVolumePanel != null) {
+            mVolumePanel.postRemoteSliderVisibility(hasRemotePlayback);
+        } else {
+            mHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (mUiContext == null) {
+                        mUiContext = ThemeUtils.createUiContext(mContext);
+                    }
+
+                    final Context context = mUiContext != null ? mUiContext : mContext;
+                    mVolumePanel = new VolumePanel(context, AudioService.this);
+                    mVolumePanel.postRemoteSliderVisibility(hasRemotePlayback);
+                }
+            });
+        }
+    }
+
+    private void showVolumeChangeUi(final int streamType, final int flags) {
+        if (mUiContext != null && mVolumePanel != null) {
+            mVolumePanel.postVolumeChanged(streamType, flags);
+        } else {
+            mHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (mUiContext == null) {
+                        mUiContext = ThemeUtils.createUiContext(mContext);
+                    }
+
+                    final Context context = mUiContext != null ? mUiContext : mContext;
+                    mVolumePanel = new VolumePanel(context, AudioService.this);
+                    mVolumePanel.postVolumeChanged(streamType, flags);
+                }
+            });
+        }
+    }
+
+    private void remoteVolumeChanged(final int streamType, final int flags) {
+        if (mUiContext != null && mVolumePanel != null) {
+            mVolumePanel.postRemoteVolumeChanged(streamType, flags);
+        } else {
+            mHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (mUiContext == null) {
+                        mUiContext = ThemeUtils.createUiContext(mContext);
+                    }
+
+                    final Context context = mUiContext != null ? mUiContext : mContext;
+                    mVolumePanel = new VolumePanel(context, AudioService.this);
+                    mVolumePanel.postRemoteVolumeChanged(streamType, flags);
+                }
+            });
+        }
+    }
+
+    private void displaySafeVolumeWarning() {
+        if (mUiContext != null && mVolumePanel != null) {
+            mVolumePanel.postDisplaySafeVolumeWarning();
+        } else {
+            mHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (mUiContext == null) {
+                        mUiContext = ThemeUtils.createUiContext(mContext);
+                    }
+
+                    final Context context = mUiContext != null ? mUiContext : mContext;
+                    mVolumePanel = new VolumePanel(context, AudioService.this);
+                    mVolumePanel.postDisplaySafeVolumeWarning();
+                }
+            });
+        }
+    }
+
+    private void hasNewRemotePlaybackInfo() {
+        if (mUiContext != null && mVolumePanel != null) {
+            mVolumePanel.postHasNewRemotePlaybackInfo();
+        } else {
+            mHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (mUiContext == null) {
+                        mUiContext = ThemeUtils.createUiContext(mContext);
+                    }
+
+                    final Context context = mUiContext != null ? mUiContext : mContext;
+                    mVolumePanel = new VolumePanel(context, AudioService.this);
+                    mVolumePanel.postHasNewRemotePlaybackInfo();
+                }
+            });
+        }
+    }
+
+    //==========================================================================================
+    // AudioFocus
+    //==========================================================================================
+
+    /* constant to identify focus stack entry that is used to hold the focus while the phone
+     * is ringing or during a call. Used by com.android.internal.telephony.CallManager when
+     * entering and exiting calls.
+     */
+    public final static String IN_VOICE_COMM_FOCUS_ID = "AudioFocus_For_Phone_Ring_And_Calls";
+
+    private final static Object mAudioFocusLock = new Object();
+
+    private final static Object mRingingLock = new Object();
+
+    private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
+        @Override
+        public void onCallStateChanged(int state, String incomingNumber) {
+            if (state == TelephonyManager.CALL_STATE_RINGING) {
+                //Log.v(TAG, " CALL_STATE_RINGING");
+                synchronized(mRingingLock) {
+                    mIsRinging = true;
+                }
+            } else if ((state == TelephonyManager.CALL_STATE_OFFHOOK)
+                    || (state == TelephonyManager.CALL_STATE_IDLE)) {
+                synchronized(mRingingLock) {
+                    mIsRinging = false;
+                }
+            }
+        }
+    };
+
+    /**
+     * Discard the current audio focus owner.
+     * Notify top of audio focus stack that it lost focus (regardless of possibility to reassign
+     * focus), remove it from the stack, and clear the remote control display.
+     */
+    private void discardAudioFocusOwner() {
+        synchronized(mAudioFocusLock) {
+            if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
+                // notify the current focus owner it lost focus after removing it from stack
+                FocusStackEntry focusOwner = mFocusStack.pop();
+                try {
+                    focusOwner.mFocusDispatcher.dispatchAudioFocusChange(
+                            AudioManager.AUDIOFOCUS_LOSS, focusOwner.mClientId);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Failure to signal loss of audio focus due to "+ e);
+                    e.printStackTrace();
+                }
+                focusOwner.unlinkToDeath();
+                // clear RCD
+                synchronized(mRCStack) {
+                    clearRemoteControlDisplay_syncAfRcs();
+                }
+            }
+        }
+    }
+
+    private void notifyTopOfAudioFocusStack() {
+        // notify the top of the stack it gained focus
+        if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
+            String clientId = mFocusStack.peek().mClientId;
+            if (canReassignAudioFocusTo(clientId)) {
+                try {
+                    mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(
+                            AudioManager.AUDIOFOCUS_GAIN, clientId);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Failure to signal gain of audio control focus due to "+ e);
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    private static class FocusStackEntry {
+        public int mStreamType = -1;// no stream type
+        public IAudioFocusDispatcher mFocusDispatcher = null;
+        public IBinder mSourceRef = null;
+        public String mClientId;
+        public int mFocusChangeType;
+        public AudioFocusDeathHandler mHandler;
+        public String mPackageName;
+        public int mCallingUid;
+
+        public FocusStackEntry() {
+        }
+
+        public FocusStackEntry(int streamType, int duration,
+                IAudioFocusDispatcher afl, IBinder source, String id, AudioFocusDeathHandler hdlr,
+                String pn, int uid) {
+            mStreamType = streamType;
+            mFocusDispatcher = afl;
+            mSourceRef = source;
+            mClientId = id;
+            mFocusChangeType = duration;
+            mHandler = hdlr;
+            mPackageName = pn;
+            mCallingUid = uid;
+        }
+
+        public void unlinkToDeath() {
+            try {
+                if (mSourceRef != null && mHandler != null) {
+                    mSourceRef.unlinkToDeath(mHandler, 0);
+                    mHandler = null;
+                }
+            } catch (java.util.NoSuchElementException e) {
+                Log.e(TAG, "Encountered " + e + " in FocusStackEntry.unlinkToDeath()");
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            unlinkToDeath(); // unlink exception handled inside method
+            super.finalize();
+        }
+    }
+
+    private final Stack<FocusStackEntry> mFocusStack = new Stack<FocusStackEntry>();
+
+    /**
+     * Helper function:
+     * Display in the log the current entries in the audio focus stack
+     */
+    private void dumpFocusStack(PrintWriter pw) {
+        pw.println("\nAudio Focus stack entries:");
+        synchronized(mAudioFocusLock) {
+            Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
+            while(stackIterator.hasNext()) {
+                FocusStackEntry fse = stackIterator.next();
+                pw.println("  source:" + fse.mSourceRef
+                        + " -- pack: " + fse.mPackageName
+                        + " -- client: " + fse.mClientId
+                        + " -- duration: " + fse.mFocusChangeType
+                        + " -- uid: " + fse.mCallingUid
+                        + " -- stream: " + fse.mStreamType);
+            }
+        }
+    }
+
+    /**
+     * Helper function:
+     * Called synchronized on mAudioFocusLock
+     * Remove a focus listener from the focus stack.
+     * @param focusListenerToRemove the focus listener
+     * @param signal if true and the listener was at the top of the focus stack, i.e. it was holding
+     *   focus, notify the next item in the stack it gained focus.
+     */
+    private void removeFocusStackEntry(String clientToRemove, boolean signal) {
+        // is the current top of the focus stack abandoning focus? (because of request, not death)
+        if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove))
+        {
+            //Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
+            FocusStackEntry fse = mFocusStack.pop();
+            fse.unlinkToDeath();
+            if (signal) {
+                // notify the new top of the stack it gained focus
+                notifyTopOfAudioFocusStack();
+                // there's a new top of the stack, let the remote control know
+                synchronized(mRCStack) {
+                    checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
+                }
+            }
+        } else {
+            // focus is abandoned by a client that's not at the top of the stack,
+            // no need to update focus.
+            Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
+            while(stackIterator.hasNext()) {
+                FocusStackEntry fse = (FocusStackEntry)stackIterator.next();
+                if(fse.mClientId.equals(clientToRemove)) {
+                    Log.i(TAG, " AudioFocus  abandonAudioFocus(): removing entry for "
+                            + fse.mClientId);
+                    stackIterator.remove();
+                    fse.unlinkToDeath();
+                }
+            }
+        }
+    }
+
+    /**
+     * Helper function:
+     * Called synchronized on mAudioFocusLock
+     * Remove focus listeners from the focus stack for a particular client when it has died.
+     */
+    private void removeFocusStackEntryForClient(IBinder cb) {
+        // is the owner of the audio focus part of the client to remove?
+        boolean isTopOfStackForClientToRemove = !mFocusStack.isEmpty() &&
+                mFocusStack.peek().mSourceRef.equals(cb);
+        Iterator<FocusStackEntry> stackIterator = mFocusStack.iterator();
+        while(stackIterator.hasNext()) {
+            FocusStackEntry fse = (FocusStackEntry)stackIterator.next();
+            if(fse.mSourceRef.equals(cb)) {
+                Log.i(TAG, " AudioFocus  abandonAudioFocus(): removing entry for "
+                        + fse.mClientId);
+                stackIterator.remove();
+                // the client just died, no need to unlink to its death
+            }
+        }
+        if (isTopOfStackForClientToRemove) {
+            // we removed an entry at the top of the stack:
+            //  notify the new top of the stack it gained focus.
+            notifyTopOfAudioFocusStack();
+            // there's a new top of the stack, let the remote control know
+            synchronized(mRCStack) {
+                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
+            }
+        }
+    }
+
+    /**
+     * Helper function:
+     * Returns true if the system is in a state where the focus can be reevaluated, false otherwise.
+     */
+    private boolean canReassignAudioFocusTo(String clientId) {
+        // focus requests are rejected during a phone call or when the phone is ringing
+        // this is equivalent to IN_VOICE_COMM_FOCUS_ID having the focus
+        if (IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
+            return true;
+        }
+        if (!mFocusStack.isEmpty() && IN_VOICE_COMM_FOCUS_ID.equals(mFocusStack.peek().mClientId)) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Inner class to monitor audio focus client deaths, and remove them from the audio focus
+     * stack if necessary.
+     */
+    private class AudioFocusDeathHandler implements IBinder.DeathRecipient {
+        private IBinder mCb; // To be notified of client's death
+
+        AudioFocusDeathHandler(IBinder cb) {
+            mCb = cb;
+        }
+
+        public void binderDied() {
+            synchronized(mAudioFocusLock) {
+                Log.w(TAG, "  AudioFocus   audio focus client died");
+                removeFocusStackEntryForClient(mCb);
+            }
+        }
+
+        public IBinder getBinder() {
+            return mCb;
+        }
+    }
+
+
+    /** @see AudioManager#requestAudioFocus(IAudioFocusDispatcher, int, int) */
+    public int requestAudioFocus(int mainStreamType, int focusChangeHint, IBinder cb,
+            IAudioFocusDispatcher fd, String clientId, String callingPackageName) {
+        Log.i(TAG, " AudioFocus  requestAudioFocus() from " + clientId);
+        // the main stream type for the audio focus request is currently not used. It may
+        // potentially be used to handle multiple stream type-dependent audio focuses.
+
+        // we need a valid binder callback for clients
+        if (!cb.pingBinder()) {
+            Log.e(TAG, " AudioFocus DOA client for requestAudioFocus(), aborting.");
+            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
+        }
+
+        synchronized(mAudioFocusLock) {
+            if (!canReassignAudioFocusTo(clientId)) {
+                return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
+            }
+
+            // handle the potential premature death of the new holder of the focus
+            // (premature death == death before abandoning focus)
+            // Register for client death notification
+            AudioFocusDeathHandler afdh = new AudioFocusDeathHandler(cb);
+            try {
+                cb.linkToDeath(afdh, 0);
+            } catch (RemoteException e) {
+                // client has already died!
+                Log.w(TAG, "AudioFocus  requestAudioFocus() could not link to "+cb+" binder death");
+                return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
+            }
+
+            if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
+                // if focus is already owned by this client and the reason for acquiring the focus
+                // hasn't changed, don't do anything
+                if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
+                    // unlink death handler so it can be gc'ed.
+                    // linkToDeath() creates a JNI global reference preventing collection.
+                    cb.unlinkToDeath(afdh, 0);
+                    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
+                }
+                // the reason for the audio focus request has changed: remove the current top of
+                // stack and respond as if we had a new focus owner
+                FocusStackEntry fse = mFocusStack.pop();
+                fse.unlinkToDeath();
+            }
+
+            // notify current top of stack it is losing focus
+            if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
+                try {
+                    mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(
+                            -1 * focusChangeHint, // loss and gain codes are inverse of each other
+                            mFocusStack.peek().mClientId);
+                } catch (RemoteException e) {
+                    Log.e(TAG, " Failure to signal loss of focus due to "+ e);
+                    e.printStackTrace();
+                }
+            }
+
+            // focus requester might already be somewhere below in the stack, remove it
+            removeFocusStackEntry(clientId, false /* signal */);
+
+            // push focus requester at the top of the audio focus stack
+            mFocusStack.push(new FocusStackEntry(mainStreamType, focusChangeHint, fd, cb,
+                    clientId, afdh, callingPackageName, Binder.getCallingUid()));
+
+            // there's a new top of the stack, let the remote control know
+            synchronized(mRCStack) {
+                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
+            }
+        }//synchronized(mAudioFocusLock)
+
+        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
+    }
+
+    /** @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) */
+    public int abandonAudioFocus(IAudioFocusDispatcher fl, String clientId) {
+        Log.i(TAG, " AudioFocus  abandonAudioFocus() from " + clientId);
+        try {
+            // this will take care of notifying the new focus owner if needed
+            synchronized(mAudioFocusLock) {
+                removeFocusStackEntry(clientId, true);
+            }
+        } catch (java.util.ConcurrentModificationException cme) {
+            // Catching this exception here is temporary. It is here just to prevent
+            // a crash seen when the "Silent" notification is played. This is believed to be fixed
+            // but this try catch block is left just to be safe.
+            Log.e(TAG, "FATAL EXCEPTION AudioFocus  abandonAudioFocus() caused " + cme);
+            cme.printStackTrace();
+        }
+
+        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
+    }
+
+
+    public void unregisterAudioFocusClient(String clientId) {
+        synchronized(mAudioFocusLock) {
+            removeFocusStackEntry(clientId, false);
+        }
+    }
+
+
+    //==========================================================================================
+    // RemoteControl
+    //==========================================================================================
+    public void dispatchMediaKeyEvent(KeyEvent keyEvent) {
+        filterMediaKeyEvent(keyEvent, false /*needWakeLock*/);
+    }
+
+    public void dispatchMediaKeyEventUnderWakelock(KeyEvent keyEvent) {
+        filterMediaKeyEvent(keyEvent, true /*needWakeLock*/);
+    }
+
+    private void filterMediaKeyEvent(KeyEvent keyEvent, boolean needWakeLock) {
+        // sanity check on the incoming key event
+        if (!isValidMediaKeyEvent(keyEvent)) {
+            Log.e(TAG, "not dispatching invalid media key event " + keyEvent);
+            return;
+        }
+        // event filtering for telephony
+        synchronized(mRingingLock) {
+            synchronized(mRCStack) {
+                if ((mMediaReceiverForCalls != null) &&
+                        (mIsRinging || (getMode() == AudioSystem.MODE_IN_CALL))) {
+                    dispatchMediaKeyEventForCalls(keyEvent, needWakeLock);
+                    return;
+                }
+            }
+        }
+        // event filtering based on voice-based interactions
+        if (isValidVoiceInputKeyCode(keyEvent.getKeyCode())) {
+            filterVoiceInputKeyEvent(keyEvent, needWakeLock);
+        } else {
+            dispatchMediaKeyEvent(keyEvent, needWakeLock);
+        }
+    }
+
+    /**
+     * Handles the dispatching of the media button events to the telephony package.
+     * Precondition: mMediaReceiverForCalls != null
+     * @param keyEvent a non-null KeyEvent whose key code is one of the supported media buttons
+     * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held while this key event
+     *     is dispatched.
+     */
+    private void dispatchMediaKeyEventForCalls(KeyEvent keyEvent, boolean needWakeLock) {
+        Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
+        keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
+        keyIntent.setPackage(mMediaReceiverForCalls.getPackageName());
+        if (needWakeLock) {
+            mMediaEventWakeLock.acquire();
+            keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
+        }
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            mContext.sendOrderedBroadcastAsUser(keyIntent, UserHandle.ALL,
+                    null, mKeyEventDone, mAudioHandler, Activity.RESULT_OK, null, null);
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    /**
+     * Handles the dispatching of the media button events to one of the registered listeners,
+     * or if there was none, broadcast an ACTION_MEDIA_BUTTON intent to the rest of the system.
+     * @param keyEvent a non-null KeyEvent whose key code is one of the supported media buttons
+     * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held while this key event
+     *     is dispatched.
+     */
+    private void dispatchMediaKeyEvent(KeyEvent keyEvent, boolean needWakeLock) {
+        if (needWakeLock) {
+            mMediaEventWakeLock.acquire();
+        }
+        Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
+        keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
+        synchronized(mRCStack) {
+            if (!mRCStack.empty()) {
+                // send the intent that was registered by the client
+                try {
+                    mRCStack.peek().mMediaIntent.send(mContext,
+                            needWakeLock ? WAKELOCK_RELEASE_ON_FINISHED : 0 /*code*/,
+                            keyIntent, AudioService.this, mAudioHandler);
+                } catch (CanceledException e) {
+                    Log.e(TAG, "Error sending pending intent " + mRCStack.peek());
+                    e.printStackTrace();
+                }
+            } else {
+                // legacy behavior when nobody registered their media button event receiver
+                //    through AudioManager
+                if (needWakeLock) {
+                    keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
+                }
+                final long ident = Binder.clearCallingIdentity();
+                try {
+                    mContext.sendOrderedBroadcastAsUser(keyIntent, UserHandle.ALL,
+                            null, mKeyEventDone,
+                            mAudioHandler, Activity.RESULT_OK, null, null);
+                } finally {
+                    Binder.restoreCallingIdentity(ident);
+                }
+            }
+        }
+    }
+
+    /**
+     * The different actions performed in response to a voice button key event.
+     */
+    private final static int VOICEBUTTON_ACTION_DISCARD_CURRENT_KEY_PRESS = 1;
+    private final static int VOICEBUTTON_ACTION_START_VOICE_INPUT = 2;
+    private final static int VOICEBUTTON_ACTION_SIMULATE_KEY_PRESS = 3;
+
+    private final Object mVoiceEventLock = new Object();
+    private boolean mVoiceButtonDown;
+    private boolean mVoiceButtonHandled;
+
+    /**
+     * Filter key events that may be used for voice-based interactions
+     * @param keyEvent a non-null KeyEvent whose key code is that of one of the supported
+     *    media buttons that can be used to trigger voice-based interactions.
+     * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held while this key event
+     *     is dispatched.
+     */
+    private void filterVoiceInputKeyEvent(KeyEvent keyEvent, boolean needWakeLock) {
+        if (DEBUG_RC) {
+            Log.v(TAG, "voice input key event: " + keyEvent + ", needWakeLock=" + needWakeLock);
+        }
+
+        int voiceButtonAction = VOICEBUTTON_ACTION_DISCARD_CURRENT_KEY_PRESS;
+        int keyAction = keyEvent.getAction();
+        synchronized (mVoiceEventLock) {
+            if (keyAction == KeyEvent.ACTION_DOWN) {
+                if (keyEvent.getRepeatCount() == 0) {
+                    // initial down
+                    mVoiceButtonDown = true;
+                    mVoiceButtonHandled = false;
+                } else if (mVoiceButtonDown && !mVoiceButtonHandled
+                        && (keyEvent.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
+                    // long-press, start voice-based interactions
+                    mVoiceButtonHandled = true;
+                    voiceButtonAction = VOICEBUTTON_ACTION_START_VOICE_INPUT;
+                }
+            } else if (keyAction == KeyEvent.ACTION_UP) {
+                if (mVoiceButtonDown) {
+                    // voice button up
+                    mVoiceButtonDown = false;
+                    if (!mVoiceButtonHandled && !keyEvent.isCanceled()) {
+                        voiceButtonAction = VOICEBUTTON_ACTION_SIMULATE_KEY_PRESS;
+                    }
+                }
+            }
+        }//synchronized (mVoiceEventLock)
+
+        // take action after media button event filtering for voice-based interactions
+        switch (voiceButtonAction) {
+            case VOICEBUTTON_ACTION_DISCARD_CURRENT_KEY_PRESS:
+                if (DEBUG_RC) Log.v(TAG, "   ignore key event");
+                break;
+            case VOICEBUTTON_ACTION_START_VOICE_INPUT:
+                if (DEBUG_RC) Log.v(TAG, "   start voice-based interactions");
+                // then start the voice-based interactions
+                startVoiceBasedInteractions(needWakeLock);
+                break;
+            case VOICEBUTTON_ACTION_SIMULATE_KEY_PRESS:
+                if (DEBUG_RC) Log.v(TAG, "   send simulated key event, wakelock=" + needWakeLock);
+                sendSimulatedMediaButtonEvent(keyEvent, needWakeLock);
+                break;
+        }
+    }
+
+    private void sendSimulatedMediaButtonEvent(KeyEvent originalKeyEvent, boolean needWakeLock) {
+        // send DOWN event
+        KeyEvent keyEvent = KeyEvent.changeAction(originalKeyEvent, KeyEvent.ACTION_DOWN);
+        dispatchMediaKeyEvent(keyEvent, needWakeLock);
+        // send UP event
+        keyEvent = KeyEvent.changeAction(originalKeyEvent, KeyEvent.ACTION_UP);
+        dispatchMediaKeyEvent(keyEvent, needWakeLock);
+
+    }
+
+
+    private static boolean isValidMediaKeyEvent(KeyEvent keyEvent) {
+        if (keyEvent == null) {
+            return false;
+        }
+        final int keyCode = keyEvent.getKeyCode();
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_MUTE:
+            case KeyEvent.KEYCODE_HEADSETHOOK:
+            case KeyEvent.KEYCODE_MEDIA_PLAY:
+            case KeyEvent.KEYCODE_MEDIA_PAUSE:
+            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+            case KeyEvent.KEYCODE_MEDIA_STOP:
+            case KeyEvent.KEYCODE_MEDIA_NEXT:
+            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+            case KeyEvent.KEYCODE_MEDIA_REWIND:
+            case KeyEvent.KEYCODE_MEDIA_RECORD:
+            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
+            case KeyEvent.KEYCODE_MEDIA_CLOSE:
+            case KeyEvent.KEYCODE_MEDIA_EJECT:
+                break;
+            default:
+                return false;
+        }
+        return true;
+    }
+
+    /**
+     * Checks whether the given key code is one that can trigger the launch of voice-based
+     *   interactions.
+     * @param keyCode the key code associated with the key event
+     * @return true if the key is one of the supported voice-based interaction triggers
+     */
+    private static boolean isValidVoiceInputKeyCode(int keyCode) {
+        if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Tell the system to start voice-based interactions / voice commands
+     */
+    private void startVoiceBasedInteractions(boolean needWakeLock) {
+        Intent voiceIntent = null;
+        // select which type of search to launch:
+        // - screen on and device unlocked: action is ACTION_WEB_SEARCH
+        // - device locked or screen off: action is ACTION_VOICE_SEARCH_HANDS_FREE
+        //    with EXTRA_SECURE set to true if the device is securely locked
+        PowerManager pm = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
+        boolean isLocked = mKeyguardManager != null && mKeyguardManager.isKeyguardLocked();
+        if (!isLocked && pm.isScreenOn()) {
+            voiceIntent = new Intent(android.speech.RecognizerIntent.ACTION_WEB_SEARCH);
+        } else {
+            voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
+            voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE,
+                    isLocked && mKeyguardManager.isKeyguardSecure());
+        }
+        // start the search activity
+        if (needWakeLock) {
+            mMediaEventWakeLock.acquire();
+        }
+        try {
+            if (voiceIntent != null) {
+                voiceIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                        | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
+                mContext.startActivity(voiceIntent);
+            }
+        } catch (ActivityNotFoundException e) {
+            Log.w(TAG, "No activity for search: " + e);
+        } finally {
+            if (needWakeLock) {
+                mMediaEventWakeLock.release();
+            }
+        }
+    }
+
+    private PowerManager.WakeLock mMediaEventWakeLock;
+
+    private static final int WAKELOCK_RELEASE_ON_FINISHED = 1980; //magic number
+
+    // only set when wakelock was acquired, no need to check value when received
+    private static final String EXTRA_WAKELOCK_ACQUIRED =
+            "android.media.AudioService.WAKELOCK_ACQUIRED";
+
+    public void onSendFinished(PendingIntent pendingIntent, Intent intent,
+            int resultCode, String resultData, Bundle resultExtras) {
+        if (resultCode == WAKELOCK_RELEASE_ON_FINISHED) {
+            mMediaEventWakeLock.release();
+        }
+    }
+
+    BroadcastReceiver mKeyEventDone = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            if (intent == null) {
+                return;
+            }
+            Bundle extras = intent.getExtras();
+            if (extras == null) {
+                return;
+            }
+            if (extras.containsKey(EXTRA_WAKELOCK_ACQUIRED)) {
+                mMediaEventWakeLock.release();
+            }
+        }
+    };
+
+    private final Object mCurrentRcLock = new Object();
+    /**
+     * The one remote control client which will receive a request for display information.
+     * This object may be null.
+     * Access protected by mCurrentRcLock.
+     */
+    private IRemoteControlClient mCurrentRcClient = null;
+
+    private final static int RC_INFO_NONE = 0;
+    private final static int RC_INFO_ALL =
+        RemoteControlClient.FLAG_INFORMATION_REQUEST_ALBUM_ART |
+        RemoteControlClient.FLAG_INFORMATION_REQUEST_KEY_MEDIA |
+        RemoteControlClient.FLAG_INFORMATION_REQUEST_METADATA |
+        RemoteControlClient.FLAG_INFORMATION_REQUEST_PLAYSTATE;
+
+    /**
+     * A monotonically increasing generation counter for mCurrentRcClient.
+     * Only accessed with a lock on mCurrentRcLock.
+     * No value wrap-around issues as we only act on equal values.
+     */
+    private int mCurrentRcClientGen = 0;
+
+    /**
+     * Inner class to monitor remote control client deaths, and remove the client for the
+     * remote control stack if necessary.
+     */
+    private class RcClientDeathHandler implements IBinder.DeathRecipient {
+        private IBinder mCb; // To be notified of client's death
+        private PendingIntent mMediaIntent;
+
+        RcClientDeathHandler(IBinder cb, PendingIntent pi) {
+            mCb = cb;
+            mMediaIntent = pi;
+        }
+
+        public void binderDied() {
+            Log.w(TAG, "  RemoteControlClient died");
+            // remote control client died, make sure the displays don't use it anymore
+            //  by setting its remote control client to null
+            registerRemoteControlClient(mMediaIntent, null/*rcClient*/, null/*ignored*/);
+            // the dead client was maybe handling remote playback, reevaluate
+            postReevaluateRemote();
+        }
+
+        public IBinder getBinder() {
+            return mCb;
+        }
+    }
+
+    /**
+     * A global counter for RemoteControlClient identifiers
+     */
+    private static int sLastRccId = 0;
+
+    private class RemotePlaybackState {
+        int mRccId;
+        int mVolume;
+        int mVolumeMax;
+        int mVolumeHandling;
+
+        private RemotePlaybackState(int id, int vol, int volMax) {
+            mRccId = id;
+            mVolume = vol;
+            mVolumeMax = volMax;
+            mVolumeHandling = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME_HANDLING;
+        }
+    }
+
+    /**
+     * Internal cache for the playback information of the RemoteControlClient whose volume gets to
+     * be controlled by the volume keys ("main"), so we don't have to iterate over the RC stack
+     * every time we need this info.
+     */
+    private RemotePlaybackState mMainRemote;
+    /**
+     * Indicates whether the "main" RemoteControlClient is considered active.
+     * Use synchronized on mMainRemote.
+     */
+    private boolean mMainRemoteIsActive;
+    /**
+     * Indicates whether there is remote playback going on. True even if there is no "active"
+     * remote playback (mMainRemoteIsActive is false), but a RemoteControlClient has declared it
+     * handles remote playback.
+     * Use synchronized on mMainRemote.
+     */
+    private boolean mHasRemotePlayback;
+
+    private static class RemoteControlStackEntry {
+        public int mRccId = RemoteControlClient.RCSE_ID_UNREGISTERED;
+        /**
+         * The target for the ACTION_MEDIA_BUTTON events.
+         * Always non null.
+         */
+        public PendingIntent mMediaIntent;
+        /**
+         * The registered media button event receiver.
+         * Always non null.
+         */
+        public ComponentName mReceiverComponent;
+        public String mCallingPackageName;
+        public int mCallingUid;
+        /**
+         * Provides access to the information to display on the remote control.
+         * May be null (when a media button event receiver is registered,
+         *     but no remote control client has been registered) */
+        public IRemoteControlClient mRcClient;
+        public RcClientDeathHandler mRcClientDeathHandler;
+        /**
+         * Information only used for non-local playback
+         */
+        public int mPlaybackType;
+        public int mPlaybackVolume;
+        public int mPlaybackVolumeMax;
+        public int mPlaybackVolumeHandling;
+        public int mPlaybackStream;
+        public int mPlaybackState;
+        public IRemoteVolumeObserver mRemoteVolumeObs;
+
+        public void resetPlaybackInfo() {
+            mPlaybackType = RemoteControlClient.PLAYBACK_TYPE_LOCAL;
+            mPlaybackVolume = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME;
+            mPlaybackVolumeMax = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME;
+            mPlaybackVolumeHandling = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME_HANDLING;
+            mPlaybackStream = AudioManager.STREAM_MUSIC;
+            mPlaybackState = RemoteControlClient.PLAYSTATE_STOPPED;
+            mRemoteVolumeObs = null;
+        }
+
+        /** precondition: mediaIntent != null, eventReceiver != null */
+        public RemoteControlStackEntry(PendingIntent mediaIntent, ComponentName eventReceiver) {
+            mMediaIntent = mediaIntent;
+            mReceiverComponent = eventReceiver;
+            mCallingUid = -1;
+            mRcClient = null;
+            mRccId = ++sLastRccId;
+
+            resetPlaybackInfo();
+        }
+
+        public void unlinkToRcClientDeath() {
+            if ((mRcClientDeathHandler != null) && (mRcClientDeathHandler.mCb != null)) {
+                try {
+                    mRcClientDeathHandler.mCb.unlinkToDeath(mRcClientDeathHandler, 0);
+                    mRcClientDeathHandler = null;
+                } catch (java.util.NoSuchElementException e) {
+                    // not much we can do here
+                    Log.e(TAG, "Encountered " + e + " in unlinkToRcClientDeath()");
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            unlinkToRcClientDeath();// unlink exception handled inside method
+            super.finalize();
+        }
+    }
+
+    /**
+     *  The stack of remote control event receivers.
+     *  Code sections and methods that modify the remote control event receiver stack are
+     *  synchronized on mRCStack, but also BEFORE on mFocusLock as any change in either
+     *  stack, audio focus or RC, can lead to a change in the remote control display
+     */
+    private final Stack<RemoteControlStackEntry> mRCStack = new Stack<RemoteControlStackEntry>();
+
+    /**
+     * The component the telephony package can register so telephony calls have priority to
+     * handle media button events
+     */
+    private ComponentName mMediaReceiverForCalls = null;
+
+    /**
+     * Helper function:
+     * Display in the log the current entries in the remote control focus stack
+     */
+    private void dumpRCStack(PrintWriter pw) {
+        pw.println("\nRemote Control stack entries:");
+        synchronized(mRCStack) {
+            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            while(stackIterator.hasNext()) {
+                RemoteControlStackEntry rcse = stackIterator.next();
+                pw.println("  pi: " + rcse.mMediaIntent +
+                        " -- pack: " + rcse.mCallingPackageName +
+                        "  -- ercvr: " + rcse.mReceiverComponent +
+                        "  -- client: " + rcse.mRcClient +
+                        "  -- uid: " + rcse.mCallingUid +
+                        "  -- type: " + rcse.mPlaybackType +
+                        "  state: " + rcse.mPlaybackState);
+            }
+        }
+    }
+
+    /**
+     * Helper function:
+     * Display in the log the current entries in the remote control stack, focusing
+     * on RemoteControlClient data
+     */
+    private void dumpRCCStack(PrintWriter pw) {
+        pw.println("\nRemote Control Client stack entries:");
+        synchronized(mRCStack) {
+            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            while(stackIterator.hasNext()) {
+                RemoteControlStackEntry rcse = stackIterator.next();
+                pw.println("  uid: " + rcse.mCallingUid +
+                        "  -- id: " + rcse.mRccId +
+                        "  -- type: " + rcse.mPlaybackType +
+                        "  -- state: " + rcse.mPlaybackState +
+                        "  -- vol handling: " + rcse.mPlaybackVolumeHandling +
+                        "  -- vol: " + rcse.mPlaybackVolume +
+                        "  -- volMax: " + rcse.mPlaybackVolumeMax +
+                        "  -- volObs: " + rcse.mRemoteVolumeObs);
+
+            }
+        }
+        synchronized (mMainRemote) {
+            pw.println("\nRemote Volume State:");
+            pw.println("  has remote: " + mHasRemotePlayback);
+            pw.println("  is remote active: " + mMainRemoteIsActive);
+            pw.println("  rccId: " + mMainRemote.mRccId);
+            pw.println("  volume handling: "
+                    + ((mMainRemote.mVolumeHandling == RemoteControlClient.PLAYBACK_VOLUME_FIXED) ?
+                            "PLAYBACK_VOLUME_FIXED(0)" : "PLAYBACK_VOLUME_VARIABLE(1)"));
+            pw.println("  volume: " + mMainRemote.mVolume);
+            pw.println("  volume steps: " + mMainRemote.mVolumeMax);
+        }
+    }
+
+    /**
+     * Helper function:
+     * Remove any entry in the remote control stack that has the same package name as packageName
+     * Pre-condition: packageName != null
+     */
+    private void removeMediaButtonReceiverForPackage(String packageName) {
+        synchronized(mRCStack) {
+            if (mRCStack.empty()) {
+                return;
+            } else {
+                RemoteControlStackEntry oldTop = mRCStack.peek();
+                Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+                // iterate over the stack entries
+                while(stackIterator.hasNext()) {
+                    RemoteControlStackEntry rcse = (RemoteControlStackEntry)stackIterator.next();
+                    if (packageName.equalsIgnoreCase(rcse.mReceiverComponent.getPackageName())) {
+                        // a stack entry is from the package being removed, remove it from the stack
+                        stackIterator.remove();
+                        rcse.unlinkToRcClientDeath();
+                    }
+                }
+                if (mRCStack.empty()) {
+                    // no saved media button receiver
+                    mAudioHandler.sendMessage(
+                            mAudioHandler.obtainMessage(MSG_PERSIST_MEDIABUTTONRECEIVER, 0, 0,
+                                    null));
+                } else if (oldTop != mRCStack.peek()) {
+                    // the top of the stack has changed, save it in the system settings
+                    // by posting a message to persist it
+                    mAudioHandler.sendMessage(
+                            mAudioHandler.obtainMessage(MSG_PERSIST_MEDIABUTTONRECEIVER, 0, 0,
+                                    mRCStack.peek().mReceiverComponent));
+                }
+            }
+        }
+    }
+
+    /**
+     * Helper function:
+     * Restore remote control receiver from the system settings.
+     */
+    private void restoreMediaButtonReceiver() {
+        String receiverName = Settings.System.getStringForUser(mContentResolver,
+                Settings.System.MEDIA_BUTTON_RECEIVER, UserHandle.USER_CURRENT);
+        if ((null != receiverName) && !receiverName.isEmpty()) {
+            ComponentName eventReceiver = ComponentName.unflattenFromString(receiverName);
+            // construct a PendingIntent targeted to the restored component name
+            // for the media button and register it
+            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
+            //     the associated intent will be handled by the component being registered
+            mediaButtonIntent.setComponent(eventReceiver);
+            PendingIntent pi = PendingIntent.getBroadcast(mContext,
+                    0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);
+            registerMediaButtonIntent(pi, eventReceiver);
+        }
+    }
+
+    /**
+     * Helper function:
+     * Set the new remote control receiver at the top of the RC focus stack.
+     * precondition: mediaIntent != null, target != null
+     */
+    private void pushMediaButtonReceiver(PendingIntent mediaIntent, ComponentName target) {
+        // already at top of stack?
+        if (!mRCStack.empty() && mRCStack.peek().mMediaIntent.equals(mediaIntent)) {
+            return;
+        }
+        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+        RemoteControlStackEntry rcse = null;
+        boolean wasInsideStack = false;
+        while(stackIterator.hasNext()) {
+            rcse = (RemoteControlStackEntry)stackIterator.next();
+            if(rcse.mMediaIntent.equals(mediaIntent)) {
+                wasInsideStack = true;
+                stackIterator.remove();
+                break;
+            }
+        }
+        if (!wasInsideStack) {
+            rcse = new RemoteControlStackEntry(mediaIntent, target);
+        }
+        mRCStack.push(rcse);
+
+        // post message to persist the default media button receiver
+        mAudioHandler.sendMessage( mAudioHandler.obtainMessage(
+                MSG_PERSIST_MEDIABUTTONRECEIVER, 0, 0, target/*obj*/) );
+    }
+
+    /**
+     * Helper function:
+     * Remove the remote control receiver from the RC focus stack.
+     * precondition: pi != null
+     */
+    private void removeMediaButtonReceiver(PendingIntent pi) {
+        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+        while(stackIterator.hasNext()) {
+            RemoteControlStackEntry rcse = (RemoteControlStackEntry)stackIterator.next();
+            if(rcse.mMediaIntent.equals(pi)) {
+                stackIterator.remove();
+                rcse.unlinkToRcClientDeath();
+                break;
+            }
+        }
+    }
+
+    /**
+     * Helper function:
+     * Called synchronized on mRCStack
+     */
+    private boolean isCurrentRcController(PendingIntent pi) {
+        if (!mRCStack.empty() && mRCStack.peek().mMediaIntent.equals(pi)) {
+            return true;
+        }
+        return false;
+    }
+
+    //==========================================================================================
+    // Remote control display / client
+    //==========================================================================================
+    /**
+     * Update the remote control displays with the new "focused" client generation
+     */
+    private void setNewRcClientOnDisplays_syncRcsCurrc(int newClientGeneration,
+            PendingIntent newMediaIntent, boolean clearing) {
+        // NOTE: Only one IRemoteControlDisplay supported in this implementation
+        if (mRcDisplay != null) {
+            try {
+                mRcDisplay.setCurrentClientId(
+                        newClientGeneration, newMediaIntent, clearing);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Dead display in setNewRcClientOnDisplays_syncRcsCurrc() "+e);
+                // if we had a display before, stop monitoring its death
+                rcDisplay_stopDeathMonitor_syncRcStack();
+                mRcDisplay = null;
+            }
+        }
+    }
+
+    /**
+     * Update the remote control clients with the new "focused" client generation
+     */
+    private void setNewRcClientGenerationOnClients_syncRcsCurrc(int newClientGeneration) {
+        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+        while(stackIterator.hasNext()) {
+            RemoteControlStackEntry se = stackIterator.next();
+            if ((se != null) && (se.mRcClient != null)) {
+                try {
+                    se.mRcClient.setCurrentClientGenerationId(newClientGeneration);
+                } catch (RemoteException e) {
+                    Log.w(TAG, "Dead client in setNewRcClientGenerationOnClients_syncRcsCurrc()"+e);
+                    stackIterator.remove();
+                    se.unlinkToRcClientDeath();
+                }
+            }
+        }
+    }
+
+    /**
+     * Update the displays and clients with the new "focused" client generation and name
+     * @param newClientGeneration the new generation value matching a client update
+     * @param newClientEventReceiver the media button event receiver associated with the client.
+     *    May be null, which implies there is no registered media button event receiver.
+     * @param clearing true if the new client generation value maps to a remote control update
+     *    where the display should be cleared.
+     */
+    private void setNewRcClient_syncRcsCurrc(int newClientGeneration,
+            PendingIntent newMediaIntent, boolean clearing) {
+        // send the new valid client generation ID to all displays
+        setNewRcClientOnDisplays_syncRcsCurrc(newClientGeneration, newMediaIntent, clearing);
+        // send the new valid client generation ID to all clients
+        setNewRcClientGenerationOnClients_syncRcsCurrc(newClientGeneration);
+    }
+
+    /**
+     * Called when processing MSG_RCDISPLAY_CLEAR event
+     */
+    private void onRcDisplayClear() {
+        if (DEBUG_RC) Log.i(TAG, "Clear remote control display");
+
+        synchronized(mRCStack) {
+            synchronized(mCurrentRcLock) {
+                mCurrentRcClientGen++;
+                // synchronously update the displays and clients with the new client generation
+                setNewRcClient_syncRcsCurrc(mCurrentRcClientGen,
+                        null /*newMediaIntent*/, true /*clearing*/);
+            }
+        }
+    }
+
+    /**
+     * Called when processing MSG_RCDISPLAY_UPDATE event
+     */
+    private void onRcDisplayUpdate(RemoteControlStackEntry rcse, int flags /* USED ?*/) {
+        synchronized(mRCStack) {
+            synchronized(mCurrentRcLock) {
+                if ((mCurrentRcClient != null) && (mCurrentRcClient.equals(rcse.mRcClient))) {
+                    if (DEBUG_RC) Log.i(TAG, "Display/update remote control ");
+
+                    mCurrentRcClientGen++;
+                    // synchronously update the displays and clients with
+                    //      the new client generation
+                    setNewRcClient_syncRcsCurrc(mCurrentRcClientGen,
+                            rcse.mMediaIntent /*newMediaIntent*/,
+                            false /*clearing*/);
+
+                    // tell the current client that it needs to send info
+                    try {
+                        mCurrentRcClient.onInformationRequested(mCurrentRcClientGen,
+                                flags, mArtworkExpectedWidth, mArtworkExpectedHeight);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "Current valid remote client is dead: "+e);
+                        mCurrentRcClient = null;
+                    }
+                } else {
+                    // the remote control display owner has changed between the
+                    // the message to update the display was sent, and the time it
+                    // gets to be processed (now)
+                }
+            }
+        }
+    }
+
+
+    /**
+     * Helper function:
+     * Called synchronized on mRCStack
+     */
+    private void clearRemoteControlDisplay_syncAfRcs() {
+        synchronized(mCurrentRcLock) {
+            mCurrentRcClient = null;
+        }
+        // will cause onRcDisplayClear() to be called in AudioService's handler thread
+        mAudioHandler.sendMessage( mAudioHandler.obtainMessage(MSG_RCDISPLAY_CLEAR) );
+    }
+
+    /**
+     * Helper function for code readability: only to be called from
+     *    checkUpdateRemoteControlDisplay_syncAfRcs() which checks the preconditions for
+     *    this method.
+     * Preconditions:
+     *    - called synchronized mAudioFocusLock then on mRCStack
+     *    - mRCStack.isEmpty() is false
+     */
+    private void updateRemoteControlDisplay_syncAfRcs(int infoChangedFlags) {
+        RemoteControlStackEntry rcse = mRCStack.peek();
+        int infoFlagsAboutToBeUsed = infoChangedFlags;
+        // this is where we enforce opt-in for information display on the remote controls
+        //   with the new AudioManager.registerRemoteControlClient() API
+        if (rcse.mRcClient == null) {
+            //Log.w(TAG, "Can't update remote control display with null remote control client");
+            clearRemoteControlDisplay_syncAfRcs();
+            return;
+        }
+        synchronized(mCurrentRcLock) {
+            if (!rcse.mRcClient.equals(mCurrentRcClient)) {
+                // new RC client, assume every type of information shall be queried
+                infoFlagsAboutToBeUsed = RC_INFO_ALL;
+            }
+            mCurrentRcClient = rcse.mRcClient;
+        }
+        // will cause onRcDisplayUpdate() to be called in AudioService's handler thread
+        mAudioHandler.sendMessage( mAudioHandler.obtainMessage(MSG_RCDISPLAY_UPDATE,
+                infoFlagsAboutToBeUsed /* arg1 */, 0, rcse /* obj, != null */) );
+    }
+
+    /**
+     * Helper function:
+     * Called synchronized on mAudioFocusLock, then mRCStack
+     * Check whether the remote control display should be updated, triggers the update if required
+     * @param infoChangedFlags the flags corresponding to the remote control client information
+     *     that has changed, if applicable (checking for the update conditions might trigger a
+     *     clear, rather than an update event).
+     */
+    private void checkUpdateRemoteControlDisplay_syncAfRcs(int infoChangedFlags) {
+        // determine whether the remote control display should be refreshed
+        // if either stack is empty, there is a mismatch, so clear the RC display
+        if (mRCStack.isEmpty() || mFocusStack.isEmpty()) {
+            clearRemoteControlDisplay_syncAfRcs();
+            return;
+        }
+
+        // determine which entry in the AudioFocus stack to consider, and compare against the
+        // top of the stack for the media button event receivers : simply using the top of the
+        // stack would make the entry disappear from the RemoteControlDisplay in conditions such as
+        // notifications playing during music playback.
+        // Crawl the AudioFocus stack from the top until an entry is found with the following
+        // characteristics:
+        // - focus gain on STREAM_MUSIC stream
+        // - non-transient focus gain on a stream other than music
+        FocusStackEntry af = null;
+        try {
+            for (int index = mFocusStack.size()-1; index >= 0; index--) {
+                FocusStackEntry fse = mFocusStack.elementAt(index);
+                if ((fse.mStreamType == AudioManager.STREAM_MUSIC)
+                        || (fse.mFocusChangeType == AudioManager.AUDIOFOCUS_GAIN)) {
+                    af = fse;
+                    break;
+                }
+            }
+        } catch (ArrayIndexOutOfBoundsException e) {
+            Log.e(TAG, "Wrong index accessing audio focus stack when updating RCD: " + e);
+            af = null;
+        }
+        if (af == null) {
+            clearRemoteControlDisplay_syncAfRcs();
+            return;
+        }
+
+        // if the audio focus and RC owners belong to different packages, there is a mismatch, clear
+        if ((mRCStack.peek().mCallingPackageName != null)
+                && (af.mPackageName != null)
+                && !(mRCStack.peek().mCallingPackageName.compareTo(
+                        af.mPackageName) == 0)) {
+            clearRemoteControlDisplay_syncAfRcs();
+            return;
+        }
+        // if the audio focus didn't originate from the same Uid as the one in which the remote
+        //   control information will be retrieved, clear
+        if (mRCStack.peek().mCallingUid != af.mCallingUid) {
+            clearRemoteControlDisplay_syncAfRcs();
+            return;
+        }
+
+        // refresh conditions were verified: update the remote controls
+        // ok to call: synchronized mAudioFocusLock then on mRCStack, mRCStack is not empty
+        updateRemoteControlDisplay_syncAfRcs(infoChangedFlags);
+    }
+
+    /**
+     * see AudioManager.registerMediaButtonIntent(PendingIntent pi, ComponentName c)
+     * precondition: mediaIntent != null, target != null
+     */
+    public void registerMediaButtonIntent(PendingIntent mediaIntent, ComponentName eventReceiver) {
+        Log.i(TAG, "  Remote Control   registerMediaButtonIntent() for " + mediaIntent);
+
+        synchronized(mAudioFocusLock) {
+            synchronized(mRCStack) {
+                pushMediaButtonReceiver(mediaIntent, eventReceiver);
+                // new RC client, assume every type of information shall be queried
+                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
+            }
+        }
+    }
+
+    /**
+     * see AudioManager.unregisterMediaButtonIntent(PendingIntent mediaIntent)
+     * precondition: mediaIntent != null, eventReceiver != null
+     */
+    public void unregisterMediaButtonIntent(PendingIntent mediaIntent, ComponentName eventReceiver)
+    {
+        Log.i(TAG, "  Remote Control   unregisterMediaButtonIntent() for " + mediaIntent);
+
+        synchronized(mAudioFocusLock) {
+            synchronized(mRCStack) {
+                boolean topOfStackWillChange = isCurrentRcController(mediaIntent);
+                removeMediaButtonReceiver(mediaIntent);
+                if (topOfStackWillChange) {
+                    // current RC client will change, assume every type of info needs to be queried
+                    checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
+                }
+            }
+        }
+    }
+
+    /**
+     * see AudioManager.registerMediaButtonEventReceiverForCalls(ComponentName c)
+     * precondition: c != null
+     */
+    public void registerMediaButtonEventReceiverForCalls(ComponentName c) {
+        if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE")
+                != PackageManager.PERMISSION_GRANTED) {
+            Log.e(TAG, "Invalid permissions to register media button receiver for calls");
+            return;
+        }
+        synchronized(mRCStack) {
+            mMediaReceiverForCalls = c;
+        }
+    }
+
+    /**
+     * see AudioManager.unregisterMediaButtonEventReceiverForCalls()
+     */
+    public void unregisterMediaButtonEventReceiverForCalls() {
+        if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE")
+                != PackageManager.PERMISSION_GRANTED) {
+            Log.e(TAG, "Invalid permissions to unregister media button receiver for calls");
+            return;
+        }
+        synchronized(mRCStack) {
+            mMediaReceiverForCalls = null;
+        }
+    }
+
+    /**
+     * see AudioManager.registerRemoteControlClient(ComponentName eventReceiver, ...)
+     * @return the unique ID of the RemoteControlStackEntry associated with the RemoteControlClient
+     * Note: using this method with rcClient == null is a way to "disable" the IRemoteControlClient
+     *     without modifying the RC stack, but while still causing the display to refresh (will
+     *     become blank as a result of this)
+     */
+    public int registerRemoteControlClient(PendingIntent mediaIntent,
+            IRemoteControlClient rcClient, String callingPackageName) {
+        if (DEBUG_RC) Log.i(TAG, "Register remote control client rcClient="+rcClient);
+        int rccId = RemoteControlClient.RCSE_ID_UNREGISTERED;
+        synchronized(mAudioFocusLock) {
+            synchronized(mRCStack) {
+                // store the new display information
+                Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+                while(stackIterator.hasNext()) {
+                    RemoteControlStackEntry rcse = stackIterator.next();
+                    if(rcse.mMediaIntent.equals(mediaIntent)) {
+                        // already had a remote control client?
+                        if (rcse.mRcClientDeathHandler != null) {
+                            // stop monitoring the old client's death
+                            rcse.unlinkToRcClientDeath();
+                        }
+                        // save the new remote control client
+                        rcse.mRcClient = rcClient;
+                        rcse.mCallingPackageName = callingPackageName;
+                        rcse.mCallingUid = Binder.getCallingUid();
+                        if (rcClient == null) {
+                            // here rcse.mRcClientDeathHandler is null;
+                            rcse.resetPlaybackInfo();
+                            break;
+                        }
+                        rccId = rcse.mRccId;
+
+                        // there is a new (non-null) client:
+                        // 1/ give the new client the current display (if any)
+                        if (mRcDisplay != null) {
+                            try {
+                                rcse.mRcClient.plugRemoteControlDisplay(mRcDisplay);
+                            } catch (RemoteException e) {
+                                Log.e(TAG, "Error connecting remote control display to client: "+e);
+                                e.printStackTrace();
+                            }
+                        }
+                        // 2/ monitor the new client's death
+                        IBinder b = rcse.mRcClient.asBinder();
+                        RcClientDeathHandler rcdh =
+                                new RcClientDeathHandler(b, rcse.mMediaIntent);
+                        try {
+                            b.linkToDeath(rcdh, 0);
+                        } catch (RemoteException e) {
+                            // remote control client is DOA, disqualify it
+                            Log.w(TAG, "registerRemoteControlClient() has a dead client " + b);
+                            rcse.mRcClient = null;
+                        }
+                        rcse.mRcClientDeathHandler = rcdh;
+                        break;
+                    }
+                }
+                // if the eventReceiver is at the top of the stack
+                // then check for potential refresh of the remote controls
+                if (isCurrentRcController(mediaIntent)) {
+                    checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
+                }
+            }
+        }
+        return rccId;
+    }
+
+    /**
+     * see AudioManager.unregisterRemoteControlClient(PendingIntent pi, ...)
+     * rcClient is guaranteed non-null
+     */
+    public void unregisterRemoteControlClient(PendingIntent mediaIntent,
+            IRemoteControlClient rcClient) {
+        synchronized(mAudioFocusLock) {
+            synchronized(mRCStack) {
+                Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+                while(stackIterator.hasNext()) {
+                    RemoteControlStackEntry rcse = stackIterator.next();
+                    if ((rcse.mMediaIntent.equals(mediaIntent))
+                            && rcClient.equals(rcse.mRcClient)) {
+                        // we found the IRemoteControlClient to unregister
+                        // stop monitoring its death
+                        rcse.unlinkToRcClientDeath();
+                        // reset the client-related fields
+                        rcse.mRcClient = null;
+                        rcse.mCallingPackageName = null;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * The remote control displays.
+     * Access synchronized on mRCStack
+     * NOTE: Only one IRemoteControlDisplay supported in this implementation
+     */
+    private IRemoteControlDisplay mRcDisplay;
+    private RcDisplayDeathHandler mRcDisplayDeathHandler;
+    private int mArtworkExpectedWidth = -1;
+    private int mArtworkExpectedHeight = -1;
+    /**
+     * Inner class to monitor remote control display deaths, and unregister them from the list
+     * of displays if necessary.
+     */
+    private class RcDisplayDeathHandler implements IBinder.DeathRecipient {
+        private IBinder mCb; // To be notified of client's death
+
+        public RcDisplayDeathHandler(IBinder b) {
+            if (DEBUG_RC) Log.i(TAG, "new RcDisplayDeathHandler for "+b);
+            mCb = b;
+        }
+
+        public void binderDied() {
+            synchronized(mRCStack) {
+                Log.w(TAG, "RemoteControl: display died");
+                mRcDisplay = null;
+            }
+        }
+
+        public void unlinkToRcDisplayDeath() {
+            if (DEBUG_RC) Log.i(TAG, "unlinkToRcDisplayDeath for "+mCb);
+            try {
+                mCb.unlinkToDeath(this, 0);
+            } catch (java.util.NoSuchElementException e) {
+                // not much we can do here, the display was being unregistered anyway
+                Log.e(TAG, "Encountered " + e + " in unlinkToRcDisplayDeath()");
+                e.printStackTrace();
+            }
+        }
+
+    }
+
+    private void rcDisplay_stopDeathMonitor_syncRcStack() {
+        if (mRcDisplay != null) { // implies (mRcDisplayDeathHandler != null)
+            // we had a display before, stop monitoring its death
+            mRcDisplayDeathHandler.unlinkToRcDisplayDeath();
+        }
+    }
+
+    private void rcDisplay_startDeathMonitor_syncRcStack() {
+        if (mRcDisplay != null) {
+            // new non-null display, monitor its death
+            IBinder b = mRcDisplay.asBinder();
+            mRcDisplayDeathHandler = new RcDisplayDeathHandler(b);
+            try {
+                b.linkToDeath(mRcDisplayDeathHandler, 0);
+            } catch (RemoteException e) {
+                // remote control display is DOA, disqualify it
+                Log.w(TAG, "registerRemoteControlDisplay() has a dead client " + b);
+                mRcDisplay = null;
+            }
+        }
+    }
+
+    /**
+     * Register an IRemoteControlDisplay.
+     * Notify all IRemoteControlClient of the new display and cause the RemoteControlClient
+     * at the top of the stack to update the new display with its information.
+     * Since only one IRemoteControlDisplay is supported, this will unregister the previous display.
+     * @param rcd the IRemoteControlDisplay to register. No effect if null.
+     */
+    public void registerRemoteControlDisplay(IRemoteControlDisplay rcd) {
+        if (DEBUG_RC) Log.d(TAG, ">>> registerRemoteControlDisplay("+rcd+")");
+        synchronized(mAudioFocusLock) {
+            synchronized(mRCStack) {
+                if ((mRcDisplay == rcd) || (rcd == null)) {
+                    return;
+                }
+                // if we had a display before, stop monitoring its death
+                rcDisplay_stopDeathMonitor_syncRcStack();
+                mRcDisplay = rcd;
+                // new display, start monitoring its death
+                rcDisplay_startDeathMonitor_syncRcStack();
+
+                // let all the remote control clients there is a new display
+                // no need to unplug the previous because we only support one display
+                // and the clients don't track the death of the display
+                Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+                while(stackIterator.hasNext()) {
+                    RemoteControlStackEntry rcse = stackIterator.next();
+                    if(rcse.mRcClient != null) {
+                        try {
+                            rcse.mRcClient.plugRemoteControlDisplay(mRcDisplay);
+                        } catch (RemoteException e) {
+                            Log.e(TAG, "Error connecting remote control display to client: " + e);
+                            e.printStackTrace();
+                        }
+                    }
+                }
+
+                // we have a new display, of which all the clients are now aware: have it be updated
+                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
+            }
+        }
+    }
+
+    /**
+     * Unregister an IRemoteControlDisplay.
+     * Since only one IRemoteControlDisplay is supported, this has no effect if the one to
+     *    unregister is not the current one.
+     * @param rcd the IRemoteControlDisplay to unregister. No effect if null.
+     */
+    public void unregisterRemoteControlDisplay(IRemoteControlDisplay rcd) {
+        if (DEBUG_RC) Log.d(TAG, "<<< unregisterRemoteControlDisplay("+rcd+")");
+        synchronized(mRCStack) {
+            // only one display here, so you can only unregister the current display
+            if ((rcd == null) || (rcd != mRcDisplay)) {
+                if (DEBUG_RC) Log.w(TAG, "    trying to unregister unregistered RCD");
+                return;
+            }
+            // if we had a display before, stop monitoring its death
+            rcDisplay_stopDeathMonitor_syncRcStack();
+            mRcDisplay = null;
+
+            // disconnect this remote control display from all the clients
+            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            while(stackIterator.hasNext()) {
+                RemoteControlStackEntry rcse = stackIterator.next();
+                if(rcse.mRcClient != null) {
+                    try {
+                        rcse.mRcClient.unplugRemoteControlDisplay(rcd);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "Error disconnecting remote control display to client: " + e);
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+    }
+
+    public void remoteControlDisplayUsesBitmapSize(IRemoteControlDisplay rcd, int w, int h) {
+        synchronized(mRCStack) {
+            // NOTE: Only one IRemoteControlDisplay supported in this implementation
+            mArtworkExpectedWidth = w;
+            mArtworkExpectedHeight = h;
+        }
+    }
+
+    public void setPlaybackInfoForRcc(int rccId, int what, int value) {
+        sendMsg(mAudioHandler, MSG_RCC_NEW_PLAYBACK_INFO, SENDMSG_QUEUE,
+                rccId /* arg1 */, what /* arg2 */, Integer.valueOf(value) /* obj */, 0 /* delay */);
+    }
+
+    // handler for MSG_RCC_NEW_PLAYBACK_INFO
+    private void onNewPlaybackInfoForRcc(int rccId, int key, int value) {
+        if(DEBUG_RC) Log.d(TAG, "onNewPlaybackInfoForRcc(id=" + rccId +
+                ", what=" + key + ",val=" + value + ")");
+        synchronized(mRCStack) {
+            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            while(stackIterator.hasNext()) {
+                RemoteControlStackEntry rcse = stackIterator.next();
+                if (rcse.mRccId == rccId) {
+                    switch (key) {
+                        case RemoteControlClient.PLAYBACKINFO_PLAYBACK_TYPE:
+                            rcse.mPlaybackType = value;
+                            postReevaluateRemote();
+                            break;
+                        case RemoteControlClient.PLAYBACKINFO_VOLUME:
+                            rcse.mPlaybackVolume = value;
+                            synchronized (mMainRemote) {
+                                if (rccId == mMainRemote.mRccId) {
+                                    mMainRemote.mVolume = value;
+                                    hasNewRemotePlaybackInfo();
+                                }
+                            }
+                            break;
+                        case RemoteControlClient.PLAYBACKINFO_VOLUME_MAX:
+                            rcse.mPlaybackVolumeMax = value;
+                            synchronized (mMainRemote) {
+                                if (rccId == mMainRemote.mRccId) {
+                                    mMainRemote.mVolumeMax = value;
+                                    hasNewRemotePlaybackInfo();
+                                }
+                            }
+                            break;
+                        case RemoteControlClient.PLAYBACKINFO_VOLUME_HANDLING:
+                            rcse.mPlaybackVolumeHandling = value;
+                            synchronized (mMainRemote) {
+                                if (rccId == mMainRemote.mRccId) {
+                                    mMainRemote.mVolumeHandling = value;
+                                    hasNewRemotePlaybackInfo();
+                                }
+                            }
+                            break;
+                        case RemoteControlClient.PLAYBACKINFO_USES_STREAM:
+                            rcse.mPlaybackStream = value;
+                            break;
+                        case RemoteControlClient.PLAYBACKINFO_PLAYSTATE:
+                            rcse.mPlaybackState = value;
+                            synchronized (mMainRemote) {
+                                if (rccId == mMainRemote.mRccId) {
+                                    mMainRemoteIsActive = isPlaystateActive(value);
+                                    postReevaluateRemote();
+                                }
+                            }
+                            break;
+                        default:
+                            Log.e(TAG, "unhandled key " + key + " for RCC " + rccId);
+                            break;
+                    }
+                    return;
+                }
+            }
+        }
+    }
+
+    public void registerRemoteVolumeObserverForRcc(int rccId, IRemoteVolumeObserver rvo) {
+        sendMsg(mAudioHandler, MSG_RCC_NEW_VOLUME_OBS, SENDMSG_QUEUE,
+                rccId /* arg1 */, 0, rvo /* obj */, 0 /* delay */);
+    }
+
+    // handler for MSG_RCC_NEW_VOLUME_OBS
+    private void onRegisterVolumeObserverForRcc(int rccId, IRemoteVolumeObserver rvo) {
+        synchronized(mRCStack) {
+            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            while(stackIterator.hasNext()) {
+                RemoteControlStackEntry rcse = stackIterator.next();
+                if (rcse.mRccId == rccId) {
+                    rcse.mRemoteVolumeObs = rvo;
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks if a remote client is active on the supplied stream type. Update the remote stream
+     * volume state if found and playing
+     * @param streamType
+     * @return false if no remote playing is currently playing
+     */
+    private boolean checkUpdateRemoteStateIfActive(int streamType) {
+        synchronized(mRCStack) {
+            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            while(stackIterator.hasNext()) {
+                RemoteControlStackEntry rcse = stackIterator.next();
+                if ((rcse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE)
+                        && isPlaystateActive(rcse.mPlaybackState)
+                        && (rcse.mPlaybackStream == streamType)) {
+                    if (DEBUG_RC) Log.d(TAG, "remote playback active on stream " + streamType
+                            + ", vol =" + rcse.mPlaybackVolume);
+                    synchronized (mMainRemote) {
+                        mMainRemote.mRccId = rcse.mRccId;
+                        mMainRemote.mVolume = rcse.mPlaybackVolume;
+                        mMainRemote.mVolumeMax = rcse.mPlaybackVolumeMax;
+                        mMainRemote.mVolumeHandling = rcse.mPlaybackVolumeHandling;
+                        mMainRemoteIsActive = true;
+                    }
+                    return true;
+                }
+            }
+        }
+        synchronized (mMainRemote) {
+            mMainRemoteIsActive = false;
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if the given playback state is considered "active", i.e. it describes a state
+     * where playback is happening, or about to
+     * @param playState the playback state to evaluate
+     * @return true if active, false otherwise (inactive or unknown)
+     */
+    private static boolean isPlaystateActive(int playState) {
+        switch (playState) {
+            case RemoteControlClient.PLAYSTATE_PLAYING:
+            case RemoteControlClient.PLAYSTATE_BUFFERING:
+            case RemoteControlClient.PLAYSTATE_FAST_FORWARDING:
+            case RemoteControlClient.PLAYSTATE_REWINDING:
+            case RemoteControlClient.PLAYSTATE_SKIPPING_BACKWARDS:
+            case RemoteControlClient.PLAYSTATE_SKIPPING_FORWARDS:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    private void adjustRemoteVolume(int streamType, int direction, int flags) {
+        int rccId = RemoteControlClient.RCSE_ID_UNREGISTERED;
+        boolean volFixed = false;
+        synchronized (mMainRemote) {
+            if (!mMainRemoteIsActive) {
+                if (DEBUG_VOL) Log.w(TAG, "adjustRemoteVolume didn't find an active client");
+                return;
+            }
+            rccId = mMainRemote.mRccId;
+            volFixed = (mMainRemote.mVolumeHandling ==
+                    RemoteControlClient.PLAYBACK_VOLUME_FIXED);
+        }
+        // unlike "local" stream volumes, we can't compute the new volume based on the direction,
+        // we can only notify the remote that volume needs to be updated, and we'll get an async'
+        // update through setPlaybackInfoForRcc()
+        if (!volFixed) {
+            sendVolumeUpdateToRemote(rccId, direction);
+        }
+
+        // fire up the UI
+        remoteVolumeChanged(streamType, flags);
+    }
+
+    private void sendVolumeUpdateToRemote(int rccId, int direction) {
+        if (DEBUG_VOL) { Log.d(TAG, "sendVolumeUpdateToRemote(rccId="+rccId+" , dir="+direction); }
+        if (direction == 0) {
+            // only handling discrete events
+            return;
+        }
+        IRemoteVolumeObserver rvo = null;
+        synchronized (mRCStack) {
+            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            while(stackIterator.hasNext()) {
+                RemoteControlStackEntry rcse = stackIterator.next();
+                //FIXME OPTIMIZE store this info in mMainRemote so we don't have to iterate?
+                if (rcse.mRccId == rccId) {
+                    rvo = rcse.mRemoteVolumeObs;
+                    break;
+                }
+            }
+        }
+        if (rvo != null) {
+            try {
+                rvo.dispatchRemoteVolumeUpdate(direction, -1);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error dispatching relative volume update", e);
+            }
+        }
+    }
+
+    public int getRemoteStreamMaxVolume() {
+        synchronized (mMainRemote) {
+            if (mMainRemote.mRccId == RemoteControlClient.RCSE_ID_UNREGISTERED) {
+                return 0;
+            }
+            return mMainRemote.mVolumeMax;
+        }
+    }
+
+    public int getRemoteStreamVolume() {
+        synchronized (mMainRemote) {
+            if (mMainRemote.mRccId == RemoteControlClient.RCSE_ID_UNREGISTERED) {
+                return 0;
+            }
+            return mMainRemote.mVolume;
+        }
+    }
+
+    public void setRemoteStreamVolume(int vol) {
+        if (DEBUG_VOL) { Log.d(TAG, "setRemoteStreamVolume(vol="+vol+")"); }
+        int rccId = RemoteControlClient.RCSE_ID_UNREGISTERED;
+        synchronized (mMainRemote) {
+            if (mMainRemote.mRccId == RemoteControlClient.RCSE_ID_UNREGISTERED) {
+                return;
+            }
+            rccId = mMainRemote.mRccId;
+        }
+        IRemoteVolumeObserver rvo = null;
+        synchronized (mRCStack) {
+            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            while(stackIterator.hasNext()) {
+                RemoteControlStackEntry rcse = stackIterator.next();
+                if (rcse.mRccId == rccId) {
+                    //FIXME OPTIMIZE store this info in mMainRemote so we don't have to iterate?
+                    rvo = rcse.mRemoteVolumeObs;
+                    break;
+                }
+            }
+        }
+        if (rvo != null) {
+            try {
+                rvo.dispatchRemoteVolumeUpdate(0, vol);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error dispatching absolute volume update", e);
+            }
+        }
+    }
+
+    /**
+     * Call to make AudioService reevaluate whether it's in a mode where remote players should
+     * have their volume controlled. In this implementation this is only to reset whether
+     * VolumePanel should display remote volumes
+     */
+    private void postReevaluateRemote() {
+        sendMsg(mAudioHandler, MSG_REEVALUATE_REMOTE, SENDMSG_QUEUE, 0, 0, null, 0);
+    }
+
+    private void onReevaluateRemote() {
+        if (DEBUG_VOL) { Log.w(TAG, "onReevaluateRemote()"); }
+        // is there a registered RemoteControlClient that is handling remote playback
+        boolean hasRemotePlayback = false;
+        synchronized (mRCStack) {
+            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            while(stackIterator.hasNext()) {
+                RemoteControlStackEntry rcse = stackIterator.next();
+                if (rcse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE) {
+                    hasRemotePlayback = true;
+                    break;
+                }
+            }
+        }
+        synchronized (mMainRemote) {
+            if (mHasRemotePlayback != hasRemotePlayback) {
+                mHasRemotePlayback = hasRemotePlayback;
+                remoteSliderVisibility(hasRemotePlayback);
+            }
+        }
+    }
+
+    //==========================================================================================
+    // Device orientation
+    //==========================================================================================
+    /**
+     * Handles device configuration changes that may map to a change in the orientation.
+     * This feature is optional, and is defined by the definition and value of the
+     * "ro.audio.monitorOrientation" system property.
+     */
+    private void handleConfigurationChanged(Context context) {
+        try {
+            // reading new orientation "safely" (i.e. under try catch) in case anything
+            // goes wrong when obtaining resources and configuration
+            Configuration config = context.getResources().getConfiguration();
+            if (mMonitorOrientation) {
+                int newOrientation = config.orientation;
+                if (newOrientation != mDeviceOrientation) {
+                    mDeviceOrientation = newOrientation;
+                    setOrientationForAudioSystem();
+                }
+            }
+            sendMsg(mAudioHandler,
+                    MSG_CONFIGURE_SAFE_MEDIA_VOLUME,
+                    SENDMSG_REPLACE,
+                    0,
+                    0,
+                    null,
+                    0);
+
+            boolean cameraSoundForced = mContext.getResources().getBoolean(
+                    com.android.internal.R.bool.config_camera_sound_forced);
+            synchronized (mSettingsLock) {
+                synchronized (mCameraSoundForced) {
+                    if (cameraSoundForced != mCameraSoundForced) {
+                        mCameraSoundForced = cameraSoundForced;
+
+                        VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
+                        if (cameraSoundForced) {
+                            s.setAllIndexesToMax();
+                            mRingerModeAffectedStreams &=
+                                    ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
+                        } else {
+                            s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM],
+                                            false /*lastAudible*/);
+                            s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM],
+                                            true /*lastAudible*/);
+                            mRingerModeAffectedStreams |=
+                                    (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
+                        }
+                        // take new state into account for streams muted by ringer mode
+                        setRingerModeInt(getRingerMode(), false);
+
+                        sendMsg(mAudioHandler,
+                                MSG_SET_FORCE_USE,
+                                SENDMSG_QUEUE,
+                                AudioSystem.FOR_SYSTEM,
+                                cameraSoundForced ?
+                                        AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE,
+                                null,
+                                0);
+
+                        sendMsg(mAudioHandler,
+                                MSG_SET_ALL_VOLUMES,
+                                SENDMSG_QUEUE,
+                                0,
+                                0,
+                                mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Error retrieving device orientation: " + e);
+        }
+    }
+
+    private void setOrientationForAudioSystem() {
+        switch (mDeviceOrientation) {
+            case Configuration.ORIENTATION_LANDSCAPE:
+                //Log.i(TAG, "orientation is landscape");
+                AudioSystem.setParameters("orientation=landscape");
+                break;
+            case Configuration.ORIENTATION_PORTRAIT:
+                //Log.i(TAG, "orientation is portrait");
+                AudioSystem.setParameters("orientation=portrait");
+                break;
+            case Configuration.ORIENTATION_SQUARE:
+                //Log.i(TAG, "orientation is square");
+                AudioSystem.setParameters("orientation=square");
+                break;
+            case Configuration.ORIENTATION_UNDEFINED:
+                //Log.i(TAG, "orientation is undefined");
+                AudioSystem.setParameters("orientation=undefined");
+                break;
+            default:
+                Log.e(TAG, "Unknown orientation");
+        }
+    }
+
+
+    // Handles request to override default use of A2DP for media.
+    public void setBluetoothA2dpOnInt(boolean on) {
+        synchronized (mBluetoothA2dpEnabledLock) {
+            mBluetoothA2dpEnabled = on;
+            mAudioHandler.removeMessages(MSG_SET_FORCE_BT_A2DP_USE);
+            AudioSystem.setForceUse(AudioSystem.FOR_MEDIA,
+                    mBluetoothA2dpEnabled ? AudioSystem.FORCE_NONE : AudioSystem.FORCE_NO_BT_A2DP);
+        }
+    }
+
+    @Override
+    public void setRingtonePlayer(IRingtonePlayer player) {
+        mContext.enforceCallingOrSelfPermission(REMOTE_AUDIO_PLAYBACK, null);
+        mRingtonePlayer = player;
+    }
+
+    @Override
+    public IRingtonePlayer getRingtonePlayer() {
+        return mRingtonePlayer;
+    }
+
+    @Override
+    public AudioRoutesInfo startWatchingRoutes(IAudioRoutesObserver observer) {
+        synchronized (mCurAudioRoutes) {
+            AudioRoutesInfo routes = new AudioRoutesInfo(mCurAudioRoutes);
+            mRoutesObservers.register(observer);
+            return routes;
+        }
+    }
+
+
+    //==========================================================================================
+    // Safe media volume management.
+    // MUSIC stream volume level is limited when headphones are connected according to safety
+    // regulation. When the user attempts to raise the volume above the limit, a warning is
+    // displayed and the user has to acknowlegde before the volume is actually changed.
+    // The volume index corresponding to the limit is stored in config_safe_media_volume_index
+    // property. Platforms with a different limit must set this property accordingly in their
+    // overlay.
+    //==========================================================================================
+
+    // mSafeMediaVolumeState indicates whether the media volume is limited over headphones.
+    // It is SAFE_MEDIA_VOLUME_NOT_CONFIGURED at boot time until a network service is connected
+    // or the configure time is elapsed. It is then set to SAFE_MEDIA_VOLUME_ACTIVE or
+    // SAFE_MEDIA_VOLUME_DISABLED according to country option. If not SAFE_MEDIA_VOLUME_DISABLED, it
+    // can be set to SAFE_MEDIA_VOLUME_INACTIVE by calling AudioService.disableSafeMediaVolume()
+    // (when user opts out).
+    private final int SAFE_MEDIA_VOLUME_NOT_CONFIGURED = 0;
+    private final int SAFE_MEDIA_VOLUME_DISABLED = 1;
+    private final int SAFE_MEDIA_VOLUME_INACTIVE = 2;
+    private final int SAFE_MEDIA_VOLUME_ACTIVE = 3;
+    private Integer mSafeMediaVolumeState;
+
+    private int mMcc = 0;
+    // mSafeVolumeEnabled indicates whether to check the volume of media play via headset
+    private boolean mSafeVolumeEnabled;
+    // mSafeMediaVolumeIndex is the cached value of config_safe_media_volume_index property
+    private int mSafeMediaVolumeIndex;
+    // mSafeMediaVolumeDevices lists the devices for which safe media volume is enforced,
+    private final int mSafeMediaVolumeDevices = AudioSystem.DEVICE_OUT_WIRED_HEADSET |
+                                                AudioSystem.DEVICE_OUT_WIRED_HEADPHONE;
+    // mMusicActiveMs is the cumulative time of music activity since safe volume was disabled.
+    // When this time reaches UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX, the safe media volume is re-enabled
+    // automatically. mMusicActiveMs is rounded to a multiple of MUSIC_ACTIVE_POLL_PERIOD_MS.
+    private int mMusicActiveMs;
+    private static final int UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX = (20 * 3600 * 1000); // 20 hours
+    private static final int MUSIC_ACTIVE_POLL_PERIOD_MS = 60000;  // 1 minute polling interval
+    private static final int SAFE_VOLUME_CONFIGURE_TIMEOUT_MS = 30000;  // 30s after boot completed
+
+    private void setSafeMediaVolumeEnabled(boolean on) {
+        synchronized (mSafeMediaVolumeState) {
+            if (mSafeVolumeEnabled &&
+                    (mSafeMediaVolumeState != SAFE_MEDIA_VOLUME_NOT_CONFIGURED) &&
+                    (mSafeMediaVolumeState != SAFE_MEDIA_VOLUME_DISABLED)) {
+                if (on && (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_INACTIVE)) {
+                    mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_ACTIVE;
+                    enforceSafeMediaVolume();
+                } else if (!on && (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE)) {
+                    mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_INACTIVE;
+                    mMusicActiveMs = 0;
+                    sendMsg(mAudioHandler,
+                            MSG_CHECK_MUSIC_ACTIVE,
+                            SENDMSG_REPLACE,
+                            0,
+                            0,
+                            null,
+                            MUSIC_ACTIVE_POLL_PERIOD_MS);
+                }
+            }
+        }
+    }
+
+    private void enforceSafeMediaVolume() {
+        VolumeStreamState streamState = mStreamStates[AudioSystem.STREAM_MUSIC];
+        boolean lastAudible = (streamState.muteCount() != 0);
+        int devices = mSafeMediaVolumeDevices;
+        int i = 0;
+
+        while (devices != 0) {
+            int device = 1 << i++;
+            if ((device & devices) == 0) {
+                continue;
+            }
+            int index = streamState.getIndex(device, lastAudible);
+            if (index > mSafeMediaVolumeIndex) {
+                if (lastAudible) {
+                    streamState.setLastAudibleIndex(mSafeMediaVolumeIndex, device);
+                    sendMsg(mAudioHandler,
+                            MSG_PERSIST_VOLUME,
+                            SENDMSG_QUEUE,
+                            PERSIST_LAST_AUDIBLE,
+                            device,
+                            streamState,
+                            PERSIST_DELAY);
+                } else {
+                    streamState.setIndex(mSafeMediaVolumeIndex, device, true);
+                    sendMsg(mAudioHandler,
+                            MSG_SET_DEVICE_VOLUME,
+                            SENDMSG_QUEUE,
+                            device,
+                            0,
+                            streamState,
+                            0);
+                }
+            }
+            devices &= ~device;
+        }
+    }
+
+    private boolean checkSafeMediaVolume(int streamType, int index, int device) {
+        synchronized (mSafeMediaVolumeState) {
+            if (mSafeVolumeEnabled &&
+                    (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE) &&
+                    (mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) &&
+                    ((device & mSafeMediaVolumeDevices) != 0) &&
+                    (index > mSafeMediaVolumeIndex)) {
+                displaySafeVolumeWarning();
+                return false;
+            }
+            return true;
+        }
+    }
+
+    public void disableSafeMediaVolume() {
+        synchronized (mSafeMediaVolumeState) {
+            setSafeMediaVolumeEnabled(false);
+        }
+    }
+
+
+    //==========================================================================================
+    // Camera shutter sound policy.
+    // config_camera_sound_forced configuration option in config.xml defines if the camera shutter
+    // sound is forced (sound even if the device is in silent mode) or not. This option is false by
+    // default and can be overridden by country specific overlay in values-mccXXX/config.xml.
+    //==========================================================================================
+
+    // cached value of com.android.internal.R.bool.config_camera_sound_forced
+    private Boolean mCameraSoundForced;
+
+    // called by android.hardware.Camera to populate CameraInfo.canDisableShutterSound
+    public boolean isCameraSoundForced() {
+        synchronized (mCameraSoundForced) {
+            return mCameraSoundForced;
+        }
+    }
+
+    private static final String[] RINGER_MODE_NAMES = new String[] {
+            "SILENT",
+            "VIBRATE",
+            "NORMAL"
+    };
+
+    private void dumpRingerMode(PrintWriter pw) {
+        pw.println("\nRinger mode: ");
+        pw.println("- mode: "+RINGER_MODE_NAMES[mRingerMode]);
+        pw.print("- ringer mode affected streams = 0x");
+        pw.println(Integer.toHexString(mRingerModeAffectedStreams));
+        pw.print("- ringer mode muted streams = 0x");
+        pw.println(Integer.toHexString(mRingerModeMutedStreams));
+    }
+
+    @Override
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
+
+        dumpFocusStack(pw);
+        dumpRCStack(pw);
+        dumpRCCStack(pw);
+        dumpStreamStates(pw);
+        dumpRingerMode(pw);
+        pw.println("\nAudio routes:");
+        pw.print("  mMainType=0x"); pw.println(Integer.toHexString(mCurAudioRoutes.mMainType));
+        pw.print("  mBluetoothName="); pw.println(mCurAudioRoutes.mBluetoothName);
+    }
+}
diff --git a/media/java/android/media/AudioSystem.java b/media/java/android/media/AudioSystem.java
index 01e79e7..5191d84 100644
--- a/media/java/android/media/AudioSystem.java
+++ b/media/java/android/media/AudioSystem.java
@@ -1,415 +1,432 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.media;
-
-
-/* IF YOU CHANGE ANY OF THE CONSTANTS IN THIS FILE, DO NOT FORGET
- * TO UPDATE THE CORRESPONDING NATIVE GLUE AND AudioManager.java.
- * THANK YOU FOR YOUR COOPERATION.
- */
-
-/**
- * @hide
- */
-public class AudioSystem
-{
-    /* These values must be kept in sync with AudioSystem.h */
-    /*
-     * If these are modified, please also update Settings.System.VOLUME_SETTINGS
-     * and attrs.xml and AudioManager.java.
-     */
-    /* The audio stream for phone calls */
-    public static final int STREAM_VOICE_CALL = 0;
-    /* The audio stream for system sounds */
-    public static final int STREAM_SYSTEM = 1;
-    /* The audio stream for the phone ring and message alerts */
-    public static final int STREAM_RING = 2;
-    /* The audio stream for music playback */
-    public static final int STREAM_MUSIC = 3;
-    /* The audio stream for alarms */
-    public static final int STREAM_ALARM = 4;
-    /* The audio stream for notifications */
-    public static final int STREAM_NOTIFICATION = 5;
-    /* @hide The audio stream for phone calls when connected on bluetooth */
-    public static final int STREAM_BLUETOOTH_SCO = 6;
-    /* @hide The audio stream for enforced system sounds in certain countries (e.g camera in Japan) */
-    public static final int STREAM_SYSTEM_ENFORCED = 7;
-    /* @hide The audio stream for DTMF tones */
-    public static final int STREAM_DTMF = 8;
-    /* @hide The audio stream for text to speech (TTS) */
-    public static final int STREAM_TTS = 9;
-    /**
-     * @deprecated Use {@link #numStreamTypes() instead}
-     */
-    public static final int NUM_STREAMS = 5;
-
-    // Expose only the getter method publicly so we can change it in the future
-    private static final int NUM_STREAM_TYPES = 10;
-    public static final int getNumStreamTypes() { return NUM_STREAM_TYPES; }
-
-    /*
-     * Sets the microphone mute on or off.
-     *
-     * @param on set <var>true</var> to mute the microphone;
-     *           <var>false</var> to turn mute off
-     * @return command completion status see AUDIO_STATUS_OK, see AUDIO_STATUS_ERROR
-     */
-    public static native int muteMicrophone(boolean on);
-
-    /*
-     * Checks whether the microphone mute is on or off.
-     *
-     * @return true if microphone is muted, false if it's not
-     */
-    public static native boolean isMicrophoneMuted();
-
-    /* modes for setPhoneState, must match AudioSystem.h audio_mode */
-    public static final int MODE_INVALID            = -2;
-    public static final int MODE_CURRENT            = -1;
-    public static final int MODE_NORMAL             = 0;
-    public static final int MODE_RINGTONE           = 1;
-    public static final int MODE_IN_CALL            = 2;
-    public static final int MODE_IN_COMMUNICATION   = 3;
-    public static final int NUM_MODES               = 4;
-
-
-    /* Routing bits for the former setRouting/getRouting API */
-    /** @deprecated */
-    @Deprecated public static final int ROUTE_EARPIECE          = (1 << 0);
-    /** @deprecated */
-    @Deprecated public static final int ROUTE_SPEAKER           = (1 << 1);
-    /** @deprecated use {@link #ROUTE_BLUETOOTH_SCO} */
-    @Deprecated public static final int ROUTE_BLUETOOTH = (1 << 2);
-    /** @deprecated */
-    @Deprecated public static final int ROUTE_BLUETOOTH_SCO     = (1 << 2);
-    /** @deprecated */
-    @Deprecated public static final int ROUTE_HEADSET           = (1 << 3);
-    /** @deprecated */
-    @Deprecated public static final int ROUTE_BLUETOOTH_A2DP    = (1 << 4);
-    /** @deprecated */
-    @Deprecated public static final int ROUTE_ALL               = 0xFFFFFFFF;
-
-    /*
-     * Checks whether the specified stream type is active.
-     *
-     * return true if any track playing on this stream is active.
-     */
-    public static native boolean isStreamActive(int stream, int inPastMs);
-
-    /*
-     * Checks whether the specified audio source is active.
-     *
-     * return true if any recorder using this source is currently recording
-     */
-    public static native boolean isSourceActive(int source);
-
-    /*
-     * Sets a group generic audio configuration parameters. The use of these parameters
-     * are platform dependent, see libaudio
-     *
-     * param keyValuePairs  list of parameters key value pairs in the form:
-     *    key1=value1;key2=value2;...
-     */
-    public static native int setParameters(String keyValuePairs);
-
-    /*
-     * Gets a group generic audio configuration parameters. The use of these parameters
-     * are platform dependent, see libaudio
-     *
-     * param keys  list of parameters
-     * return value: list of parameters key value pairs in the form:
-     *    key1=value1;key2=value2;...
-     */
-    public static native String getParameters(String keys);
-
-    // These match the enum AudioError in frameworks/base/core/jni/android_media_AudioSystem.cpp
-    /* Command sucessful or Media server restarted. see ErrorCallback */
-    public static final int AUDIO_STATUS_OK = 0;
-    /* Command failed or unspecified audio error.  see ErrorCallback */
-    public static final int AUDIO_STATUS_ERROR = 1;
-    /* Media server died. see ErrorCallback */
-    public static final int AUDIO_STATUS_SERVER_DIED = 100;
-
-    private static ErrorCallback mErrorCallback;
-
-    /*
-     * Handles the audio error callback.
-     */
-    public interface ErrorCallback
-    {
-        /*
-         * Callback for audio server errors.
-         * param error   error code:
-         * - AUDIO_STATUS_OK
-         * - AUDIO_STATUS_SERVER_DIED
-         * - AUDIO_STATUS_ERROR
-         */
-        void onError(int error);
-    };
-
-    /*
-     * Registers a callback to be invoked when an error occurs.
-     * @param cb the callback to run
-     */
-    public static void setErrorCallback(ErrorCallback cb)
-    {
-        synchronized (AudioSystem.class) {
-            mErrorCallback = cb;
-        }
-        // Calling a method on AudioFlinger here makes sure that we bind to IAudioFlinger
-        // binder interface death. Not doing that would result in not being notified of
-        // media_server process death if no other method is called on AudioSystem that reaches
-        // to AudioFlinger.
-        isMicrophoneMuted();
-    }
-
-    private static void errorCallbackFromNative(int error)
-    {
-        ErrorCallback errorCallback = null;
-        synchronized (AudioSystem.class) {
-            if (mErrorCallback != null) {
-                errorCallback = mErrorCallback;
-            }
-        }
-        if (errorCallback != null) {
-            errorCallback.onError(error);
-        }
-    }
-
-
-    /*
-     * AudioPolicyService methods
-     */
-
-    //
-    // audio device definitions: must be kept in sync with values in system/core/audio.h
-    //
-
-    // reserved bits
-    public static final int DEVICE_BIT_IN = 0x80000000;
-    public static final int DEVICE_BIT_DEFAULT = 0x40000000;
-    // output devices, be sure to update AudioManager.java also
-    public static final int DEVICE_OUT_EARPIECE = 0x1;
-    public static final int DEVICE_OUT_SPEAKER = 0x2;
-    public static final int DEVICE_OUT_WIRED_HEADSET = 0x4;
-    public static final int DEVICE_OUT_WIRED_HEADPHONE = 0x8;
-    public static final int DEVICE_OUT_BLUETOOTH_SCO = 0x10;
-    public static final int DEVICE_OUT_BLUETOOTH_SCO_HEADSET = 0x20;
-    public static final int DEVICE_OUT_BLUETOOTH_SCO_CARKIT = 0x40;
-    public static final int DEVICE_OUT_BLUETOOTH_A2DP = 0x80;
-    public static final int DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES = 0x100;
-    public static final int DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER = 0x200;
-    public static final int DEVICE_OUT_AUX_DIGITAL = 0x400;
-    public static final int DEVICE_OUT_ANLG_DOCK_HEADSET = 0x800;
-    public static final int DEVICE_OUT_DGTL_DOCK_HEADSET = 0x1000;
-    public static final int DEVICE_OUT_USB_ACCESSORY = 0x2000;
-    public static final int DEVICE_OUT_USB_DEVICE = 0x4000;
-    public static final int DEVICE_OUT_REMOTE_SUBMIX = 0x8000;
-    public static final int DEVICE_OUT_ANC_HEADSET = 0x10000;
-    public static final int DEVICE_OUT_ANC_HEADPHONE = 0x20000;
-    public static final int DEVICE_OUT_PROXY = 0x40000;
-    public static final int DEVICE_OUT_DEFAULT = DEVICE_BIT_DEFAULT;
-
-    public static final int DEVICE_OUT_ALL = (DEVICE_OUT_EARPIECE |
-                                              DEVICE_OUT_SPEAKER |
-                                              DEVICE_OUT_WIRED_HEADSET |
-                                              DEVICE_OUT_WIRED_HEADPHONE |
-                                              DEVICE_OUT_BLUETOOTH_SCO |
-                                              DEVICE_OUT_BLUETOOTH_SCO_HEADSET |
-                                              DEVICE_OUT_BLUETOOTH_SCO_CARKIT |
-                                              DEVICE_OUT_BLUETOOTH_A2DP |
-                                              DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
-                                              DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER |
-                                              DEVICE_OUT_AUX_DIGITAL |
-                                              DEVICE_OUT_ANLG_DOCK_HEADSET |
-                                              DEVICE_OUT_DGTL_DOCK_HEADSET |
-                                              DEVICE_OUT_USB_ACCESSORY |
-                                              DEVICE_OUT_USB_DEVICE |
-                                              DEVICE_OUT_REMOTE_SUBMIX |
-                                              DEVICE_OUT_ANC_HEADSET |
-                                              DEVICE_OUT_ANC_HEADPHONE |
-                                              DEVICE_OUT_PROXY |
-                                              DEVICE_OUT_DEFAULT);
-    public static final int DEVICE_OUT_ALL_A2DP = (DEVICE_OUT_BLUETOOTH_A2DP |
-                                                   DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
-                                                   DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER);
-    public static final int DEVICE_OUT_ALL_SCO = (DEVICE_OUT_BLUETOOTH_SCO |
-                                                  DEVICE_OUT_BLUETOOTH_SCO_HEADSET |
-                                                  DEVICE_OUT_BLUETOOTH_SCO_CARKIT);
-    public static final int DEVICE_OUT_ALL_USB = (DEVICE_OUT_USB_ACCESSORY |
-                                                  DEVICE_OUT_USB_DEVICE);
-
-    // input devices
-    public static final int DEVICE_IN_COMMUNICATION = DEVICE_BIT_IN | 0x1;
-    public static final int DEVICE_IN_AMBIENT = DEVICE_BIT_IN | 0x2;
-    public static final int DEVICE_IN_BUILTIN_MIC = DEVICE_BIT_IN | 0x4;
-    public static final int DEVICE_IN_BLUETOOTH_SCO_HEADSET = DEVICE_BIT_IN | 0x8;
-    public static final int DEVICE_IN_WIRED_HEADSET = DEVICE_BIT_IN | 0x10;
-    public static final int DEVICE_IN_AUX_DIGITAL = DEVICE_BIT_IN | 0x20;
-    public static final int DEVICE_IN_VOICE_CALL = DEVICE_BIT_IN | 0x40;
-    public static final int DEVICE_IN_BACK_MIC = DEVICE_BIT_IN | 0x80;
-    public static final int DEVICE_IN_REMOTE_SUBMIX = DEVICE_BIT_IN | 0x100;
-    public static final int DEVICE_IN_ANLG_DOCK_HEADSET = DEVICE_BIT_IN | 0x200;
-    public static final int DEVICE_IN_DGTL_DOCK_HEADSET = DEVICE_BIT_IN | 0x400;
-    public static final int DEVICE_IN_USB_ACCESSORY = DEVICE_BIT_IN | 0x800;
-    public static final int DEVICE_IN_USB_DEVICE = DEVICE_BIT_IN | 0x1000;
-    public static final int DEVICE_IN_ANC_HEADSET = DEVICE_BIT_IN | 0x2000;
-    public static final int DEVICE_IN_PROXY = DEVICE_BIT_IN | 0x4000;
-    public static final int DEVICE_IN_DEFAULT = DEVICE_BIT_IN | DEVICE_BIT_DEFAULT;
-
-    public static final int DEVICE_IN_ALL = (DEVICE_IN_COMMUNICATION |
-                                             DEVICE_IN_AMBIENT |
-                                             DEVICE_IN_BUILTIN_MIC |
-                                             DEVICE_IN_BLUETOOTH_SCO_HEADSET |
-                                             DEVICE_IN_WIRED_HEADSET |
-                                             DEVICE_IN_AUX_DIGITAL |
-                                             DEVICE_IN_VOICE_CALL |
-                                             DEVICE_IN_BACK_MIC |
-                                             DEVICE_IN_REMOTE_SUBMIX |
-                                             DEVICE_IN_ANLG_DOCK_HEADSET |
-                                             DEVICE_IN_DGTL_DOCK_HEADSET |
-                                             DEVICE_IN_USB_ACCESSORY |
-                                             DEVICE_IN_USB_DEVICE |
-                                             DEVICE_IN_ANC_HEADSET |
-                                             DEVICE_IN_PROXY |
-                                             DEVICE_IN_DEFAULT);
-    public static final int DEVICE_IN_ALL_SCO = DEVICE_IN_BLUETOOTH_SCO_HEADSET;
-
-    // device states, must match AudioSystem::device_connection_state
-    public static final int DEVICE_STATE_UNAVAILABLE = 0;
-    public static final int DEVICE_STATE_AVAILABLE = 1;
-    private static final int NUM_DEVICE_STATES = 1;
-
-    public static final String DEVICE_OUT_EARPIECE_NAME = "earpiece";
-    public static final String DEVICE_OUT_SPEAKER_NAME = "speaker";
-    public static final String DEVICE_OUT_WIRED_HEADSET_NAME = "headset";
-    public static final String DEVICE_OUT_WIRED_HEADPHONE_NAME = "headphone";
-    public static final String DEVICE_OUT_BLUETOOTH_SCO_NAME = "bt_sco";
-    public static final String DEVICE_OUT_BLUETOOTH_SCO_HEADSET_NAME = "bt_sco_hs";
-    public static final String DEVICE_OUT_BLUETOOTH_SCO_CARKIT_NAME = "bt_sco_carkit";
-    public static final String DEVICE_OUT_BLUETOOTH_A2DP_NAME = "bt_a2dp";
-    public static final String DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES_NAME = "bt_a2dp_hp";
-    public static final String DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER_NAME = "bt_a2dp_spk";
-    public static final String DEVICE_OUT_AUX_DIGITAL_NAME = "aux_digital";
-    public static final String DEVICE_OUT_ANLG_DOCK_HEADSET_NAME = "analog_dock";
-    public static final String DEVICE_OUT_DGTL_DOCK_HEADSET_NAME = "digital_dock";
-    public static final String DEVICE_OUT_USB_ACCESSORY_NAME = "usb_accessory";
-    public static final String DEVICE_OUT_USB_DEVICE_NAME = "usb_device";
-    public static final String DEVICE_OUT_REMOTE_SUBMIX_NAME = "remote_submix";
-    public static final String DEVICE_OUT_ANC_HEADSET_NAME = "anc_headset";
-    public static final String DEVICE_OUT_ANC_HEADPHONE_NAME = "anc_headphone";
-    public static final String DEVICE_OUT_PROXY_NAME = "proxy";
-
-    public static String getDeviceName(int device)
-    {
-        switch(device) {
-        case DEVICE_OUT_EARPIECE:
-            return DEVICE_OUT_EARPIECE_NAME;
-        case DEVICE_OUT_SPEAKER:
-            return DEVICE_OUT_SPEAKER_NAME;
-        case DEVICE_OUT_WIRED_HEADSET:
-            return DEVICE_OUT_WIRED_HEADSET_NAME;
-        case DEVICE_OUT_WIRED_HEADPHONE:
-            return DEVICE_OUT_WIRED_HEADPHONE_NAME;
-        case DEVICE_OUT_BLUETOOTH_SCO:
-            return DEVICE_OUT_BLUETOOTH_SCO_NAME;
-        case DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
-            return DEVICE_OUT_BLUETOOTH_SCO_HEADSET_NAME;
-        case DEVICE_OUT_BLUETOOTH_SCO_CARKIT:
-            return DEVICE_OUT_BLUETOOTH_SCO_CARKIT_NAME;
-        case DEVICE_OUT_BLUETOOTH_A2DP:
-            return DEVICE_OUT_BLUETOOTH_A2DP_NAME;
-        case DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:
-            return DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES_NAME;
-        case DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER:
-            return DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER_NAME;
-        case DEVICE_OUT_AUX_DIGITAL:
-            return DEVICE_OUT_AUX_DIGITAL_NAME;
-        case DEVICE_OUT_ANLG_DOCK_HEADSET:
-            return DEVICE_OUT_ANLG_DOCK_HEADSET_NAME;
-        case DEVICE_OUT_DGTL_DOCK_HEADSET:
-            return DEVICE_OUT_DGTL_DOCK_HEADSET_NAME;
-        case DEVICE_OUT_USB_ACCESSORY:
-            return DEVICE_OUT_USB_ACCESSORY_NAME;
-        case DEVICE_OUT_USB_DEVICE:
-            return DEVICE_OUT_USB_DEVICE_NAME;
-        case DEVICE_OUT_REMOTE_SUBMIX:
-            return DEVICE_OUT_REMOTE_SUBMIX_NAME;
-        case DEVICE_OUT_ANC_HEADSET:
-            return DEVICE_OUT_ANC_HEADSET_NAME;
-        case DEVICE_OUT_ANC_HEADPHONE:
-            return DEVICE_OUT_ANC_HEADPHONE_NAME;
-        case DEVICE_OUT_PROXY:
-            return DEVICE_OUT_PROXY_NAME;
-        case DEVICE_OUT_DEFAULT:
-        default:
-            return "";
-        }
-    }
-
-    // phone state, match audio_mode???
-    public static final int PHONE_STATE_OFFCALL = 0;
-    public static final int PHONE_STATE_RINGING = 1;
-    public static final int PHONE_STATE_INCALL = 2;
-
-    // device categories config for setForceUse, must match AudioSystem::forced_config
-    public static final int FORCE_NONE = 0;
-    public static final int FORCE_SPEAKER = 1;
-    public static final int FORCE_HEADPHONES = 2;
-    public static final int FORCE_BT_SCO = 3;
-    public static final int FORCE_BT_A2DP = 4;
-    public static final int FORCE_WIRED_ACCESSORY = 5;
-    public static final int FORCE_BT_CAR_DOCK = 6;
-    public static final int FORCE_BT_DESK_DOCK = 7;
-    public static final int FORCE_ANALOG_DOCK = 8;
-    public static final int FORCE_DIGITAL_DOCK = 9;
-    public static final int FORCE_NO_BT_A2DP = 10;
-    public static final int FORCE_SYSTEM_ENFORCED = 11;
-    private static final int NUM_FORCE_CONFIG = 12;
-    public static final int FORCE_DEFAULT = FORCE_NONE;
-
-    // usage for setForceUse, must match AudioSystem::force_use
-    public static final int FOR_COMMUNICATION = 0;
-    public static final int FOR_MEDIA = 1;
-    public static final int FOR_RECORD = 2;
-    public static final int FOR_DOCK = 3;
-    public static final int FOR_SYSTEM = 4;
-    private static final int NUM_FORCE_USE = 5;
-
-    // usage for AudioRecord.startRecordingSync(), must match AudioSystem::sync_event_t
-    public static final int SYNC_EVENT_NONE = 0;
-    public static final int SYNC_EVENT_PRESENTATION_COMPLETE = 1;
-
-    public static native int setDeviceConnectionState(int device, int state, String device_address);
-    public static native int getDeviceConnectionState(int device, String device_address);
-    public static native int setPhoneState(int state);
-    public static native int setForceUse(int usage, int config);
-    public static native int getForceUse(int usage);
-    public static native int initStreamVolume(int stream, int indexMin, int indexMax);
-    public static native int setStreamVolumeIndex(int stream, int index, int device);
-    public static native int getStreamVolumeIndex(int stream, int device);
-    public static native int setMasterVolume(float value);
-    public static native float getMasterVolume();
-    public static native int setMasterMute(boolean mute);
-    public static native boolean getMasterMute();
-    public static native int getDevicesForStream(int stream);
-
-    // helpers for android.media.AudioManager.getProperty(), see description there for meaning
-    public static native int getPrimaryOutputSamplingRate();
-    public static native int getPrimaryOutputFrameCount();
-
-}
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.media;
+
+
+/* IF YOU CHANGE ANY OF THE CONSTANTS IN THIS FILE, DO NOT FORGET
+ * TO UPDATE THE CORRESPONDING NATIVE GLUE AND AudioManager.java.
+ * THANK YOU FOR YOUR COOPERATION.
+ */
+
+/**
+ * @hide
+ */
+public class AudioSystem
+{
+    /* These values must be kept in sync with AudioSystem.h */
+    /*
+     * If these are modified, please also update Settings.System.VOLUME_SETTINGS
+     * and attrs.xml and AudioManager.java.
+     */
+    /* The audio stream for phone calls */
+    public static final int STREAM_VOICE_CALL = 0;
+    /* The audio stream for system sounds */
+    public static final int STREAM_SYSTEM = 1;
+    /* The audio stream for the phone ring and message alerts */
+    public static final int STREAM_RING = 2;
+    /* The audio stream for music playback */
+    public static final int STREAM_MUSIC = 3;
+    /* The audio stream for alarms */
+    public static final int STREAM_ALARM = 4;
+    /* The audio stream for notifications */
+    public static final int STREAM_NOTIFICATION = 5;
+    /* @hide The audio stream for phone calls when connected on bluetooth */
+    public static final int STREAM_BLUETOOTH_SCO = 6;
+    /* @hide The audio stream for enforced system sounds in certain countries (e.g camera in Japan) */
+    public static final int STREAM_SYSTEM_ENFORCED = 7;
+    /* @hide The audio stream for DTMF tones */
+    public static final int STREAM_DTMF = 8;
+    /* @hide The audio stream for text to speech (TTS) */
+    public static final int STREAM_TTS = 9;
+    /* @hide The audio stream for FM */
+    public static final int STREAM_FM = 10;	
+    /**
+     * @deprecated Use {@link #numStreamTypes() instead}
+     */
+    public static final int NUM_STREAMS = 5;
+
+    // Expose only the getter method publicly so we can change it in the future
+    private static final int NUM_STREAM_TYPES = 11;
+    public static final int getNumStreamTypes() { return NUM_STREAM_TYPES; }
+
+    /*
+     * Sets the microphone mute on or off.
+     *
+     * @param on set <var>true</var> to mute the microphone;
+     *           <var>false</var> to turn mute off
+     * @return command completion status see AUDIO_STATUS_OK, see AUDIO_STATUS_ERROR
+     */
+    public static native int muteMicrophone(boolean on);
+
+    /*
+     * Checks whether the microphone mute is on or off.
+     *
+     * @return true if microphone is muted, false if it's not
+     */
+    public static native boolean isMicrophoneMuted();
+
+    /* modes for setPhoneState, must match AudioSystem.h audio_mode */
+    public static final int MODE_INVALID            = -2;
+    public static final int MODE_CURRENT            = -1;
+    public static final int MODE_NORMAL             = 0;
+    public static final int MODE_RINGTONE           = 1;
+    public static final int MODE_IN_CALL            = 2;
+    public static final int MODE_IN_COMMUNICATION   = 3;
+    public static final int NUM_MODES               = 4;
+
+
+    /* Routing bits for the former setRouting/getRouting API */
+    /** @deprecated */
+    @Deprecated public static final int ROUTE_EARPIECE          = (1 << 0);
+    /** @deprecated */
+    @Deprecated public static final int ROUTE_SPEAKER           = (1 << 1);
+    /** @deprecated use {@link #ROUTE_BLUETOOTH_SCO} */
+    @Deprecated public static final int ROUTE_BLUETOOTH = (1 << 2);
+    /** @deprecated */
+    @Deprecated public static final int ROUTE_BLUETOOTH_SCO     = (1 << 2);
+    /** @deprecated */
+    @Deprecated public static final int ROUTE_HEADSET           = (1 << 3);
+    /** @deprecated */
+    @Deprecated public static final int ROUTE_BLUETOOTH_A2DP    = (1 << 4);
+    /** @deprecated */
+    @Deprecated public static final int ROUTE_ALL               = 0xFFFFFFFF;
+
+    /*
+     * Checks whether the specified stream type is active.
+     *
+     * return true if any track playing on this stream is active.
+     */
+    public static native boolean isStreamActive(int stream, int inPastMs);
+
+    /*
+     * Checks whether the specified audio source is active.
+     *
+     * return true if any recorder using this source is currently recording
+     */
+    public static native boolean isSourceActive(int source);
+
+    /*
+     * Sets a group generic audio configuration parameters. The use of these parameters
+     * are platform dependent, see libaudio
+     *
+     * param keyValuePairs  list of parameters key value pairs in the form:
+     *    key1=value1;key2=value2;...
+     */
+    public static native int setParameters(String keyValuePairs);
+
+    /*
+     * Gets a group generic audio configuration parameters. The use of these parameters
+     * are platform dependent, see libaudio
+     *
+     * param keys  list of parameters
+     * return value: list of parameters key value pairs in the form:
+     *    key1=value1;key2=value2;...
+     */
+    public static native String getParameters(String keys);
+
+    // These match the enum AudioError in frameworks/base/core/jni/android_media_AudioSystem.cpp
+    /* Command sucessful or Media server restarted. see ErrorCallback */
+    public static final int AUDIO_STATUS_OK = 0;
+    /* Command failed or unspecified audio error.  see ErrorCallback */
+    public static final int AUDIO_STATUS_ERROR = 1;
+    /* Media server died. see ErrorCallback */
+    public static final int AUDIO_STATUS_SERVER_DIED = 100;
+
+    private static ErrorCallback mErrorCallback;
+
+    /*
+     * Handles the audio error callback.
+     */
+    public interface ErrorCallback
+    {
+        /*
+         * Callback for audio server errors.
+         * param error   error code:
+         * - AUDIO_STATUS_OK
+         * - AUDIO_STATUS_SERVER_DIED
+         * - AUDIO_STATUS_ERROR
+         */
+        void onError(int error);
+    };
+
+    /*
+     * Registers a callback to be invoked when an error occurs.
+     * @param cb the callback to run
+     */
+    public static void setErrorCallback(ErrorCallback cb)
+    {
+        synchronized (AudioSystem.class) {
+            mErrorCallback = cb;
+        }
+        // Calling a method on AudioFlinger here makes sure that we bind to IAudioFlinger
+        // binder interface death. Not doing that would result in not being notified of
+        // media_server process death if no other method is called on AudioSystem that reaches
+        // to AudioFlinger.
+        isMicrophoneMuted();
+    }
+
+    private static void errorCallbackFromNative(int error)
+    {
+        ErrorCallback errorCallback = null;
+        synchronized (AudioSystem.class) {
+            if (mErrorCallback != null) {
+                errorCallback = mErrorCallback;
+            }
+        }
+        if (errorCallback != null) {
+            errorCallback.onError(error);
+        }
+    }
+
+
+    /*
+     * AudioPolicyService methods
+     */
+
+    //
+    // audio device definitions: must be kept in sync with values in system/core/audio.h
+    //
+
+    // reserved bits
+    public static final int DEVICE_BIT_IN = 0x80000000;
+    public static final int DEVICE_BIT_DEFAULT = 0x40000000;
+    // output devices, be sure to update AudioManager.java also
+    public static final int DEVICE_OUT_EARPIECE = 0x1;
+    public static final int DEVICE_OUT_SPEAKER = 0x2;
+    public static final int DEVICE_OUT_WIRED_HEADSET = 0x4;
+    public static final int DEVICE_OUT_WIRED_HEADPHONE = 0x8;
+    public static final int DEVICE_OUT_BLUETOOTH_SCO = 0x10;
+    public static final int DEVICE_OUT_BLUETOOTH_SCO_HEADSET = 0x20;
+    public static final int DEVICE_OUT_BLUETOOTH_SCO_CARKIT = 0x40;
+    public static final int DEVICE_OUT_BLUETOOTH_A2DP = 0x80;
+    public static final int DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES = 0x100;
+    public static final int DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER = 0x200;
+    public static final int DEVICE_OUT_AUX_DIGITAL = 0x400;
+    public static final int DEVICE_OUT_ANLG_DOCK_HEADSET = 0x800;
+    public static final int DEVICE_OUT_DGTL_DOCK_HEADSET = 0x1000;
+    public static final int DEVICE_OUT_USB_ACCESSORY = 0x2000;
+    public static final int DEVICE_OUT_USB_DEVICE = 0x4000;
+    public static final int DEVICE_OUT_REMOTE_SUBMIX = 0x8000;
+    public static final int DEVICE_OUT_ANC_HEADSET = 0x10000;
+    public static final int DEVICE_OUT_ANC_HEADPHONE = 0x20000;
+    public static final int DEVICE_OUT_PROXY = 0x40000;
+    public static final int DEVICE_OUT_FM = 0x80000;
+    public static final int DEVICE_OUT_FM_TX = 0x100000;	
+    public static final int DEVICE_OUT_DEFAULT = DEVICE_BIT_DEFAULT;
+
+    public static final int DEVICE_OUT_ALL = (DEVICE_OUT_EARPIECE |
+                                              DEVICE_OUT_SPEAKER |
+                                              DEVICE_OUT_WIRED_HEADSET |
+                                              DEVICE_OUT_WIRED_HEADPHONE |
+                                              DEVICE_OUT_BLUETOOTH_SCO |
+                                              DEVICE_OUT_BLUETOOTH_SCO_HEADSET |
+                                              DEVICE_OUT_BLUETOOTH_SCO_CARKIT |
+                                              DEVICE_OUT_BLUETOOTH_A2DP |
+                                              DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
+                                              DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER |
+                                              DEVICE_OUT_AUX_DIGITAL |
+                                              DEVICE_OUT_ANLG_DOCK_HEADSET |
+                                              DEVICE_OUT_DGTL_DOCK_HEADSET |
+                                              DEVICE_OUT_USB_ACCESSORY |
+                                              DEVICE_OUT_USB_DEVICE |
+                                              DEVICE_OUT_REMOTE_SUBMIX |
+                                              DEVICE_OUT_ANC_HEADSET |
+                                              DEVICE_OUT_ANC_HEADPHONE |
+                                              DEVICE_OUT_PROXY |
+                                              DEVICE_OUT_FM |
+                                              DEVICE_OUT_FM_TX |											  
+                                              DEVICE_OUT_DEFAULT);
+    public static final int DEVICE_OUT_ALL_A2DP = (DEVICE_OUT_BLUETOOTH_A2DP |
+                                                   DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
+                                                   DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER);
+    public static final int DEVICE_OUT_ALL_SCO = (DEVICE_OUT_BLUETOOTH_SCO |
+                                                  DEVICE_OUT_BLUETOOTH_SCO_HEADSET |
+                                                  DEVICE_OUT_BLUETOOTH_SCO_CARKIT);
+    public static final int DEVICE_OUT_ALL_USB = (DEVICE_OUT_USB_ACCESSORY |
+                                                  DEVICE_OUT_USB_DEVICE);
+
+    // input devices
+    public static final int DEVICE_IN_COMMUNICATION = DEVICE_BIT_IN | 0x1;
+    public static final int DEVICE_IN_AMBIENT = DEVICE_BIT_IN | 0x2;
+    public static final int DEVICE_IN_BUILTIN_MIC = DEVICE_BIT_IN | 0x4;
+    public static final int DEVICE_IN_BLUETOOTH_SCO_HEADSET = DEVICE_BIT_IN | 0x8;
+    public static final int DEVICE_IN_WIRED_HEADSET = DEVICE_BIT_IN | 0x10;
+    public static final int DEVICE_IN_AUX_DIGITAL = DEVICE_BIT_IN | 0x20;
+    public static final int DEVICE_IN_VOICE_CALL = DEVICE_BIT_IN | 0x40;
+    public static final int DEVICE_IN_BACK_MIC = DEVICE_BIT_IN | 0x80;
+    public static final int DEVICE_IN_REMOTE_SUBMIX = DEVICE_BIT_IN | 0x100;
+    public static final int DEVICE_IN_ANLG_DOCK_HEADSET = DEVICE_BIT_IN | 0x200;
+    public static final int DEVICE_IN_DGTL_DOCK_HEADSET = DEVICE_BIT_IN | 0x400;
+    public static final int DEVICE_IN_USB_ACCESSORY = DEVICE_BIT_IN | 0x800;
+    public static final int DEVICE_IN_USB_DEVICE = DEVICE_BIT_IN | 0x1000;
+    public static final int DEVICE_IN_ANC_HEADSET = DEVICE_BIT_IN | 0x2000;
+    public static final int DEVICE_IN_PROXY = DEVICE_BIT_IN | 0x4000;
+    public static final int DEVICE_IN_FM_RX = DEVICE_BIT_IN | 0x8000;
+    public static final int DEVICE_IN_FM_RX_A2DP = DEVICE_BIT_IN | 0x10000;	
+    public static final int DEVICE_IN_DEFAULT = DEVICE_BIT_IN | DEVICE_BIT_DEFAULT;
+
+    public static final int DEVICE_IN_ALL = (DEVICE_IN_COMMUNICATION |
+                                             DEVICE_IN_AMBIENT |
+                                             DEVICE_IN_BUILTIN_MIC |
+                                             DEVICE_IN_BLUETOOTH_SCO_HEADSET |
+                                             DEVICE_IN_WIRED_HEADSET |
+                                             DEVICE_IN_AUX_DIGITAL |
+                                             DEVICE_IN_VOICE_CALL |
+                                             DEVICE_IN_BACK_MIC |
+                                             DEVICE_IN_REMOTE_SUBMIX |
+                                             DEVICE_IN_ANLG_DOCK_HEADSET |
+                                             DEVICE_IN_DGTL_DOCK_HEADSET |
+                                             DEVICE_IN_USB_ACCESSORY |
+                                             DEVICE_IN_USB_DEVICE |
+                                             DEVICE_IN_ANC_HEADSET |
+                                             DEVICE_IN_PROXY |
+                                             DEVICE_IN_FM_RX |
+                                             DEVICE_IN_FM_RX_A2DP |											 
+                                             DEVICE_IN_DEFAULT);
+    public static final int DEVICE_IN_ALL_SCO = DEVICE_IN_BLUETOOTH_SCO_HEADSET;
+
+    // device states, must match AudioSystem::device_connection_state
+    public static final int DEVICE_STATE_UNAVAILABLE = 0;
+    public static final int DEVICE_STATE_AVAILABLE = 1;
+    private static final int NUM_DEVICE_STATES = 1;
+
+    public static final String DEVICE_OUT_EARPIECE_NAME = "earpiece";
+    public static final String DEVICE_OUT_SPEAKER_NAME = "speaker";
+    public static final String DEVICE_OUT_WIRED_HEADSET_NAME = "headset";
+    public static final String DEVICE_OUT_WIRED_HEADPHONE_NAME = "headphone";
+    public static final String DEVICE_OUT_BLUETOOTH_SCO_NAME = "bt_sco";
+    public static final String DEVICE_OUT_BLUETOOTH_SCO_HEADSET_NAME = "bt_sco_hs";
+    public static final String DEVICE_OUT_BLUETOOTH_SCO_CARKIT_NAME = "bt_sco_carkit";
+    public static final String DEVICE_OUT_BLUETOOTH_A2DP_NAME = "bt_a2dp";
+    public static final String DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES_NAME = "bt_a2dp_hp";
+    public static final String DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER_NAME = "bt_a2dp_spk";
+    public static final String DEVICE_OUT_AUX_DIGITAL_NAME = "aux_digital";
+    public static final String DEVICE_OUT_ANLG_DOCK_HEADSET_NAME = "analog_dock";
+    public static final String DEVICE_OUT_DGTL_DOCK_HEADSET_NAME = "digital_dock";
+    public static final String DEVICE_OUT_USB_ACCESSORY_NAME = "usb_accessory";
+    public static final String DEVICE_OUT_USB_DEVICE_NAME = "usb_device";
+    public static final String DEVICE_OUT_REMOTE_SUBMIX_NAME = "remote_submix";
+    public static final String DEVICE_OUT_ANC_HEADSET_NAME = "anc_headset";
+    public static final String DEVICE_OUT_ANC_HEADPHONE_NAME = "anc_headphone";
+    public static final String DEVICE_OUT_PROXY_NAME = "proxy";
+    public static final String DEVICE_OUT_FM_NAME = "fm";
+    public static final String DEVICE_OUT_FM_TX_NAME = "fm_tx";	
+
+    public static String getDeviceName(int device)
+    {
+        switch(device) {
+        case DEVICE_OUT_EARPIECE:
+            return DEVICE_OUT_EARPIECE_NAME;
+        case DEVICE_OUT_SPEAKER:
+            return DEVICE_OUT_SPEAKER_NAME;
+        case DEVICE_OUT_WIRED_HEADSET:
+            return DEVICE_OUT_WIRED_HEADSET_NAME;
+        case DEVICE_OUT_WIRED_HEADPHONE:
+            return DEVICE_OUT_WIRED_HEADPHONE_NAME;
+        case DEVICE_OUT_BLUETOOTH_SCO:
+            return DEVICE_OUT_BLUETOOTH_SCO_NAME;
+        case DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
+            return DEVICE_OUT_BLUETOOTH_SCO_HEADSET_NAME;
+        case DEVICE_OUT_BLUETOOTH_SCO_CARKIT:
+            return DEVICE_OUT_BLUETOOTH_SCO_CARKIT_NAME;
+        case DEVICE_OUT_BLUETOOTH_A2DP:
+            return DEVICE_OUT_BLUETOOTH_A2DP_NAME;
+        case DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:
+            return DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES_NAME;
+        case DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER:
+            return DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER_NAME;
+        case DEVICE_OUT_AUX_DIGITAL:
+            return DEVICE_OUT_AUX_DIGITAL_NAME;
+        case DEVICE_OUT_ANLG_DOCK_HEADSET:
+            return DEVICE_OUT_ANLG_DOCK_HEADSET_NAME;
+        case DEVICE_OUT_DGTL_DOCK_HEADSET:
+            return DEVICE_OUT_DGTL_DOCK_HEADSET_NAME;
+        case DEVICE_OUT_USB_ACCESSORY:
+            return DEVICE_OUT_USB_ACCESSORY_NAME;
+        case DEVICE_OUT_USB_DEVICE:
+            return DEVICE_OUT_USB_DEVICE_NAME;
+        case DEVICE_OUT_REMOTE_SUBMIX:
+            return DEVICE_OUT_REMOTE_SUBMIX_NAME;
+        case DEVICE_OUT_ANC_HEADSET:
+            return DEVICE_OUT_ANC_HEADSET_NAME;
+        case DEVICE_OUT_ANC_HEADPHONE:
+            return DEVICE_OUT_ANC_HEADPHONE_NAME;
+        case DEVICE_OUT_PROXY:
+            return DEVICE_OUT_PROXY_NAME;
+        case DEVICE_OUT_FM:
+            return DEVICE_OUT_FM_NAME;
+        case DEVICE_OUT_FM_TX:
+            return DEVICE_OUT_FM_TX_NAME;			
+        case DEVICE_OUT_DEFAULT:
+        default:
+            return "";
+        }
+    }

+
+    // phone state, match audio_mode???
+    public static final int PHONE_STATE_OFFCALL = 0;
+    public static final int PHONE_STATE_RINGING = 1;
+    public static final int PHONE_STATE_INCALL = 2;
+
+    // device categories config for setForceUse, must match AudioSystem::forced_config
+    public static final int FORCE_NONE = 0;
+    public static final int FORCE_SPEAKER = 1;
+    public static final int FORCE_HEADPHONES = 2;
+    public static final int FORCE_BT_SCO = 3;
+    public static final int FORCE_BT_A2DP = 4;
+    public static final int FORCE_WIRED_ACCESSORY = 5;
+    public static final int FORCE_BT_CAR_DOCK = 6;
+    public static final int FORCE_BT_DESK_DOCK = 7;
+    public static final int FORCE_ANALOG_DOCK = 8;
+    public static final int FORCE_DIGITAL_DOCK = 9;
+    public static final int FORCE_NO_BT_A2DP = 10;
+    public static final int FORCE_SYSTEM_ENFORCED = 11;
+    private static final int NUM_FORCE_CONFIG = 12;
+    public static final int FORCE_DEFAULT = FORCE_NONE;
+
+    // usage for setForceUse, must match AudioSystem::force_use
+    public static final int FOR_COMMUNICATION = 0;
+    public static final int FOR_MEDIA = 1;
+    public static final int FOR_RECORD = 2;
+    public static final int FOR_DOCK = 3;
+    public static final int FOR_SYSTEM = 4;
+    private static final int NUM_FORCE_USE = 5;
+
+    // usage for AudioRecord.startRecordingSync(), must match AudioSystem::sync_event_t
+    public static final int SYNC_EVENT_NONE = 0;
+    public static final int SYNC_EVENT_PRESENTATION_COMPLETE = 1;
+
+    public static native int setDeviceConnectionState(int device, int state, String device_address);
+    public static native int getDeviceConnectionState(int device, String device_address);
+    public static native int setPhoneState(int state);
+    public static native int setForceUse(int usage, int config);
+    public static native int getForceUse(int usage);
+    public static native int initStreamVolume(int stream, int indexMin, int indexMax);
+    public static native int setStreamVolumeIndex(int stream, int index, int device);
+    public static native int getStreamVolumeIndex(int stream, int device);
+    public static native int setMasterVolume(float value);
+    public static native float getMasterVolume();
+    public static native int setMasterMute(boolean mute);
+    public static native boolean getMasterMute();
+    public static native int getDevicesForStream(int stream);
+
+    // helpers for android.media.AudioManager.getProperty(), see description there for meaning
+    public static native int getPrimaryOutputSamplingRate();
+    public static native int getPrimaryOutputFrameCount();
+
+}
diff --git a/media/java/android/media/MediaRecorder.java b/media/java/android/media/MediaRecorder.java
index 544410f..8a6a828 100644
--- a/media/java/android/media/MediaRecorder.java
+++ b/media/java/android/media/MediaRecorder.java
@@ -1,1010 +1,1017 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.media;
-
-import android.hardware.Camera;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.util.Log;
-import android.view.Surface;
-
-import java.io.FileDescriptor;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.lang.ref.WeakReference;
-
-/**
- * Used to record audio and video. The recording control is based on a
- * simple state machine (see below).
- *
- * <p><img src="{@docRoot}images/mediarecorder_state_diagram.gif" border="0" />
- * </p>
- *
- * <p>A common case of using MediaRecorder to record audio works as follows:
- *
- * <pre>MediaRecorder recorder = new MediaRecorder();
- * recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
- * recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
- * recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
- * recorder.setOutputFile(PATH_NAME);
- * recorder.prepare();
- * recorder.start();   // Recording is now started
- * ...
- * recorder.stop();
- * recorder.reset();   // You can reuse the object by going back to setAudioSource() step
- * recorder.release(); // Now the object cannot be reused
- * </pre>
- *
- * <p>Applications may want to register for informational and error
- * events in order to be informed of some internal update and possible
- * runtime errors during recording. Registration for such events is
- * done by setting the appropriate listeners (via calls
- * (to {@link #setOnInfoListener(OnInfoListener)}setOnInfoListener and/or
- * {@link #setOnErrorListener(OnErrorListener)}setOnErrorListener).
- * In order to receive the respective callback associated with these listeners,
- * applications are required to create MediaRecorder objects on threads with a
- * Looper running (the main UI thread by default already has a Looper running).
- *
- * <p><strong>Note:</strong> Currently, MediaRecorder does not work on the emulator.
- *
- * <div class="special reference">
- * <h3>Developer Guides</h3>
- * <p>For more information about how to use MediaRecorder for recording video, read the
- * <a href="{@docRoot}guide/topics/media/camera.html#capture-video">Camera</a> developer guide.
- * For more information about how to use MediaRecorder for recording sound, read the
- * <a href="{@docRoot}guide/topics/media/audio-capture.html">Audio Capture</a> developer guide.</p>
- * </div>
- */
-public class MediaRecorder
-{
-    static {
-        System.loadLibrary("media_jni");
-        native_init();
-    }
-    private final static String TAG = "MediaRecorder";
-
-    // The two fields below are accessed by native methods
-    @SuppressWarnings("unused")
-    private int mNativeContext;
-
-    @SuppressWarnings("unused")
-    private Surface mSurface;
-
-    private String mPath;
-    private FileDescriptor mFd;
-    private EventHandler mEventHandler;
-    private OnErrorListener mOnErrorListener;
-    private OnInfoListener mOnInfoListener;
-
-    /**
-     * Default constructor.
-     */
-    public MediaRecorder() {
-
-        Looper looper;
-        if ((looper = Looper.myLooper()) != null) {
-            mEventHandler = new EventHandler(this, looper);
-        } else if ((looper = Looper.getMainLooper()) != null) {
-            mEventHandler = new EventHandler(this, looper);
-        } else {
-            mEventHandler = null;
-        }
-
-        /* Native setup requires a weak reference to our object.
-         * It's easier to create it here than in C++.
-         */
-        native_setup(new WeakReference<MediaRecorder>(this));
-    }
-
-    /**
-     * Sets a Camera to use for recording. Use this function to switch
-     * quickly between preview and capture mode without a teardown of
-     * the camera object. {@link android.hardware.Camera#unlock()} should be
-     * called before this. Must call before prepare().
-     *
-     * @param c the Camera to use for recording
-     */
-    public native void setCamera(Camera c);
-
-    /**
-     * Sets a Surface to show a preview of recorded media (video). Calls this
-     * before prepare() to make sure that the desirable preview display is
-     * set. If {@link #setCamera(Camera)} is used and the surface has been
-     * already set to the camera, application do not need to call this. If
-     * this is called with non-null surface, the preview surface of the camera
-     * will be replaced by the new surface. If this method is called with null
-     * surface or not called at all, media recorder will not change the preview
-     * surface of the camera.
-     *
-     * @param sv the Surface to use for the preview
-     * @see android.hardware.Camera#setPreviewDisplay(android.view.SurfaceHolder)
-     */
-    public void setPreviewDisplay(Surface sv) {
-        mSurface = sv;
-    }
-
-    /**
-     * Defines the audio source. These constants are used with
-     * {@link MediaRecorder#setAudioSource(int)}.
-     */
-    public final class AudioSource {
-      /* Do not change these values without updating their counterparts
-       * in system/core/include/system/audio.h!
-       */
-        private AudioSource() {}
-
-        /** Default audio source **/
-        public static final int DEFAULT = 0;
-
-        /** Microphone audio source */
-        public static final int MIC = 1;
-
-        /** Voice call uplink (Tx) audio source */
-        public static final int VOICE_UPLINK = 2;
-
-        /** Voice call downlink (Rx) audio source */
-        public static final int VOICE_DOWNLINK = 3;
-
-        /** Voice call uplink + downlink audio source */
-        public static final int VOICE_CALL = 4;
-
-        /** Microphone audio source with same orientation as camera if available, the main
-         *  device microphone otherwise */
-        public static final int CAMCORDER = 5;
-
-        /** Microphone audio source tuned for voice recognition if available, behaves like
-         *  {@link #DEFAULT} otherwise. */
-        public static final int VOICE_RECOGNITION = 6;
-
-        /** Microphone audio source tuned for voice communications such as VoIP. It
-         *  will for instance take advantage of echo cancellation or automatic gain control
-         *  if available. It otherwise behaves like {@link #DEFAULT} if no voice processing
-         *  is applied.
-         */
-        public static final int VOICE_COMMUNICATION = 7;
-
-        /**
-         * @hide
-         * Audio source for remote submix.
-         */
-        public static final int REMOTE_SUBMIX_SOURCE = 8;
-    }
-
-    /**
-     * Defines the video source. These constants are used with
-     * {@link MediaRecorder#setVideoSource(int)}.
-     */
-    public final class VideoSource {
-      /* Do not change these values without updating their counterparts
-       * in include/media/mediarecorder.h!
-       */
-        private VideoSource() {}
-        public static final int DEFAULT = 0;
-        /** Camera video source */
-        public static final int CAMERA = 1;
-        /** @hide */
-        public static final int GRALLOC_BUFFER = 2;
-    }
-
-    /**
-     * Defines the output format. These constants are used with
-     * {@link MediaRecorder#setOutputFormat(int)}.
-     */
-    public final class OutputFormat {
-      /* Do not change these values without updating their counterparts
-       * in include/media/mediarecorder.h!
-       */
-        private OutputFormat() {}
-        public static final int DEFAULT = 0;
-        /** 3GPP media file format*/
-        public static final int THREE_GPP = 1;
-        /** MPEG4 media file format*/
-        public static final int MPEG_4 = 2;
-
-        /** The following formats are audio only .aac or .amr formats */
-
-        /**
-         * AMR NB file format
-         * @deprecated  Deprecated in favor of MediaRecorder.OutputFormat.AMR_NB
-         */
-        public static final int RAW_AMR = 3;
-
-        /** AMR NB file format */
-        public static final int AMR_NB = 3;
-
-        /** AMR WB file format */
-        public static final int AMR_WB = 4;
-
-        /** @hide AAC ADIF file format */
-        public static final int AAC_ADIF = 5;
-
-        /** AAC ADTS file format */
-        public static final int AAC_ADTS = 6;
-
-        /** @hide Stream over a socket, limited to a single stream */
-        public static final int OUTPUT_FORMAT_RTP_AVP = 7;
-
-        /** @hide H.264/AAC data encapsulated in MPEG2/TS */
-        public static final int OUTPUT_FORMAT_MPEG2TS = 8;
-
-        /** @hide QCP file format */
-        public static final int QCP = 9;
-        /** @hide 3GPP2 media file format*/
-        public static final int THREE_GPP2 = 10;
-        /** @hide WAVE media file format*/
-        public static final int WAVE = 11;
-    };
-
-    /**
-     * Defines the audio encoding. These constants are used with
-     * {@link MediaRecorder#setAudioEncoder(int)}.
-     */
-    public final class AudioEncoder {
-      /* Do not change these values without updating their counterparts
-       * in include/media/mediarecorder.h!
-       */
-        private AudioEncoder() {}
-        public static final int DEFAULT = 0;
-        /** AMR (Narrowband) audio codec */
-        public static final int AMR_NB = 1;
-        /** AMR (Wideband) audio codec */
-        public static final int AMR_WB = 2;
-        /** AAC Low Complexity (AAC-LC) audio codec */
-        public static final int AAC = 3;
-        /** High Efficiency AAC (HE-AAC) audio codec */
-        public static final int HE_AAC = 4;
-        /** Enhanced Low Delay AAC (AAC-ELD) audio codec */
-        public static final int AAC_ELD = 5;
-        /** @hide EVRC audio codec */
-        public static final int EVRC = 6;
-        /** @hide QCELP audio codec */
-        public static final int QCELP =7;
-        /** @hide Linear PCM audio codec */
-        public static final int LPCM =8;
-    }
-
-    /**
-     * Defines the video encoding. These constants are used with
-     * {@link MediaRecorder#setVideoEncoder(int)}.
-     */
-    public final class VideoEncoder {
-      /* Do not change these values without updating their counterparts
-       * in include/media/mediarecorder.h!
-       */
-        private VideoEncoder() {}
-        public static final int DEFAULT = 0;
-        public static final int H263 = 1;
-        public static final int H264 = 2;
-        public static final int MPEG_4_SP = 3;
-    }
-
-    /**
-     * Sets the audio source to be used for recording. If this method is not
-     * called, the output file will not contain an audio track. The source needs
-     * to be specified before setting recording-parameters or encoders. Call
-     * this only before setOutputFormat().
-     *
-     * @param audio_source the audio source to use
-     * @throws IllegalStateException if it is called after setOutputFormat()
-     * @see android.media.MediaRecorder.AudioSource
-     */
-    public native void setAudioSource(int audio_source)
-            throws IllegalStateException;
-
-    /**
-     * Gets the maximum value for audio sources.
-     * @see android.media.MediaRecorder.AudioSource
-     */
-    public static final int getAudioSourceMax() {
-        // FIXME disable selection of the remote submxi source selection once test code
-        //       doesn't rely on it
-        return AudioSource.REMOTE_SUBMIX_SOURCE;
-        //return AudioSource.VOICE_COMMUNICATION;
-    }
-
-    /**
-     * Sets the video source to be used for recording. If this method is not
-     * called, the output file will not contain an video track. The source needs
-     * to be specified before setting recording-parameters or encoders. Call
-     * this only before setOutputFormat().
-     *
-     * @param video_source the video source to use
-     * @throws IllegalStateException if it is called after setOutputFormat()
-     * @see android.media.MediaRecorder.VideoSource
-     */
-    public native void setVideoSource(int video_source)
-            throws IllegalStateException;
-
-    /**
-     * Uses the settings from a CamcorderProfile object for recording. This method should
-     * be called after the video AND audio sources are set, and before setOutputFile().
-     * If a time lapse CamcorderProfile is used, audio related source or recording
-     * parameters are ignored.
-     *
-     * @param profile the CamcorderProfile to use
-     * @see android.media.CamcorderProfile
-     */
-    public void setProfile(CamcorderProfile profile) {
-        setOutputFormat(profile.fileFormat);
-        setVideoFrameRate(profile.videoFrameRate);
-        setVideoSize(profile.videoFrameWidth, profile.videoFrameHeight);
-        setVideoEncodingBitRate(profile.videoBitRate);
-        setVideoEncoder(profile.videoCodec);
-        if (profile.quality >= CamcorderProfile.QUALITY_TIME_LAPSE_LOW &&
-             profile.quality <= CamcorderProfile.QUALITY_TIME_LAPSE_QVGA) {
-            // Nothing needs to be done. Call to setCaptureRate() enables
-            // time lapse video recording.
-        } else {
-            setAudioEncodingBitRate(profile.audioBitRate);
-            setAudioChannels(profile.audioChannels);
-            setAudioSamplingRate(profile.audioSampleRate);
-            setAudioEncoder(profile.audioCodec);
-        }
-    }
-
-    /**
-     * Set video frame capture rate. This can be used to set a different video frame capture
-     * rate than the recorded video's playback rate. This method also sets the recording mode
-     * to time lapse. In time lapse video recording, only video is recorded. Audio related
-     * parameters are ignored when a time lapse recording session starts, if an application
-     * sets them.
-     *
-     * @param fps Rate at which frames should be captured in frames per second.
-     * The fps can go as low as desired. However the fastest fps will be limited by the hardware.
-     * For resolutions that can be captured by the video camera, the fastest fps can be computed using
-     * {@link android.hardware.Camera.Parameters#getPreviewFpsRange(int[])}. For higher
-     * resolutions the fastest fps may be more restrictive.
-     * Note that the recorder cannot guarantee that frames will be captured at the
-     * given rate due to camera/encoder limitations. However it tries to be as close as
-     * possible.
-     */
-    public void setCaptureRate(double fps) {
-        // Make sure that time lapse is enabled when this method is called.
-        setParameter("time-lapse-enable=1");
-
-        double timeBetweenFrameCapture = 1 / fps;
-        int timeBetweenFrameCaptureMs = (int) (1000 * timeBetweenFrameCapture);
-        setParameter("time-between-time-lapse-frame-capture=" + timeBetweenFrameCaptureMs);
-    }
-
-    /**
-     * Sets the orientation hint for output video playback.
-     * This method should be called before prepare(). This method will not
-     * trigger the source video frame to rotate during video recording, but to
-     * add a composition matrix containing the rotation angle in the output
-     * video if the output format is OutputFormat.THREE_GPP or
-     * OutputFormat.MPEG_4 so that a video player can choose the proper
-     * orientation for playback. Note that some video players may choose
-     * to ignore the compostion matrix in a video during playback.
-     *
-     * @param degrees the angle to be rotated clockwise in degrees.
-     * The supported angles are 0, 90, 180, and 270 degrees.
-     * @throws IllegalArgumentException if the angle is not supported.
-     *
-     */
-    public void setOrientationHint(int degrees) {
-        if (degrees != 0   &&
-            degrees != 90  &&
-            degrees != 180 &&
-            degrees != 270) {
-            throw new IllegalArgumentException("Unsupported angle: " + degrees);
-        }
-        setParameter("video-param-rotation-angle-degrees=" + degrees);
-    }
-
-    /**
-     * Set and store the geodata (latitude and longitude) in the output file.
-     * This method should be called before prepare(). The geodata is
-     * stored in udta box if the output format is OutputFormat.THREE_GPP
-     * or OutputFormat.MPEG_4, and is ignored for other output formats.
-     * The geodata is stored according to ISO-6709 standard.
-     *
-     * @param latitude latitude in degrees. Its value must be in the
-     * range [-90, 90].
-     * @param longitude longitude in degrees. Its value must be in the
-     * range [-180, 180].
-     *
-     * @throws IllegalArgumentException if the given latitude or
-     * longitude is out of range.
-     *
-     */
-    public void setLocation(float latitude, float longitude) {
-        int latitudex10000  = (int) (latitude * 10000 + 0.5);
-        int longitudex10000 = (int) (longitude * 10000 + 0.5);
-
-        if (latitudex10000 > 900000 || latitudex10000 < -900000) {
-            String msg = "Latitude: " + latitude + " out of range.";
-            throw new IllegalArgumentException(msg);
-        }
-        if (longitudex10000 > 1800000 || longitudex10000 < -1800000) {
-            String msg = "Longitude: " + longitude + " out of range";
-            throw new IllegalArgumentException(msg);
-        }
-
-        setParameter("param-geotag-latitude=" + latitudex10000);
-        setParameter("param-geotag-longitude=" + longitudex10000);
-    }
-
-    /**
-     * Sets the format of the output file produced during recording. Call this
-     * after setAudioSource()/setVideoSource() but before prepare().
-     *
-     * <p>It is recommended to always use 3GP format when using the H.263
-     * video encoder and AMR audio encoder. Using an MPEG-4 container format
-     * may confuse some desktop players.</p>
-     *
-     * @param output_format the output format to use. The output format
-     * needs to be specified before setting recording-parameters or encoders.
-     * @throws IllegalStateException if it is called after prepare() or before
-     * setAudioSource()/setVideoSource().
-     * @see android.media.MediaRecorder.OutputFormat
-     */
-    public native void setOutputFormat(int output_format)
-            throws IllegalStateException;
-
-    /**
-     * Sets the width and height of the video to be captured.  Must be called
-     * after setVideoSource(). Call this after setOutFormat() but before
-     * prepare().
-     *
-     * @param width the width of the video to be captured
-     * @param height the height of the video to be captured
-     * @throws IllegalStateException if it is called after
-     * prepare() or before setOutputFormat()
-     */
-    public native void setVideoSize(int width, int height)
-            throws IllegalStateException;
-
-    /**
-     * Sets the frame rate of the video to be captured.  Must be called
-     * after setVideoSource(). Call this after setOutFormat() but before
-     * prepare().
-     *
-     * @param rate the number of frames per second of video to capture
-     * @throws IllegalStateException if it is called after
-     * prepare() or before setOutputFormat().
-     *
-     * NOTE: On some devices that have auto-frame rate, this sets the
-     * maximum frame rate, not a constant frame rate. Actual frame rate
-     * will vary according to lighting conditions.
-     */
-    public native void setVideoFrameRate(int rate) throws IllegalStateException;
-
-    /**
-     * Sets the maximum duration (in ms) of the recording session.
-     * Call this after setOutFormat() but before prepare().
-     * After recording reaches the specified duration, a notification
-     * will be sent to the {@link android.media.MediaRecorder.OnInfoListener}
-     * with a "what" code of {@link #MEDIA_RECORDER_INFO_MAX_DURATION_REACHED}
-     * and recording will be stopped. Stopping happens asynchronously, there
-     * is no guarantee that the recorder will have stopped by the time the
-     * listener is notified.
-     *
-     * @param max_duration_ms the maximum duration in ms (if zero or negative, disables the duration limit)
-     *
-     */
-    public native void setMaxDuration(int max_duration_ms) throws IllegalArgumentException;
-
-    /**
-     * Sets the maximum filesize (in bytes) of the recording session.
-     * Call this after setOutFormat() but before prepare().
-     * After recording reaches the specified filesize, a notification
-     * will be sent to the {@link android.media.MediaRecorder.OnInfoListener}
-     * with a "what" code of {@link #MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED}
-     * and recording will be stopped. Stopping happens asynchronously, there
-     * is no guarantee that the recorder will have stopped by the time the
-     * listener is notified.
-     *
-     * @param max_filesize_bytes the maximum filesize in bytes (if zero or negative, disables the limit)
-     *
-     */
-    public native void setMaxFileSize(long max_filesize_bytes) throws IllegalArgumentException;
-
-    /**
-     * Sets the audio encoder to be used for recording. If this method is not
-     * called, the output file will not contain an audio track. Call this after
-     * setOutputFormat() but before prepare().
-     *
-     * @param audio_encoder the audio encoder to use.
-     * @throws IllegalStateException if it is called before
-     * setOutputFormat() or after prepare().
-     * @see android.media.MediaRecorder.AudioEncoder
-     */
-    public native void setAudioEncoder(int audio_encoder)
-            throws IllegalStateException;
-
-    /**
-     * Sets the video encoder to be used for recording. If this method is not
-     * called, the output file will not contain an video track. Call this after
-     * setOutputFormat() and before prepare().
-     *
-     * @param video_encoder the video encoder to use.
-     * @throws IllegalStateException if it is called before
-     * setOutputFormat() or after prepare()
-     * @see android.media.MediaRecorder.VideoEncoder
-     */
-    public native void setVideoEncoder(int video_encoder)
-            throws IllegalStateException;
-
-    /**
-     * Sets the audio sampling rate for recording. Call this method before prepare().
-     * Prepare() may perform additional checks on the parameter to make sure whether
-     * the specified audio sampling rate is applicable. The sampling rate really depends
-     * on the format for the audio recording, as well as the capabilities of the platform.
-     * For instance, the sampling rate supported by AAC audio coding standard ranges
-     * from 8 to 96 kHz, the sampling rate supported by AMRNB is 8kHz, and the sampling
-     * rate supported by AMRWB is 16kHz. Please consult with the related audio coding
-     * standard for the supported audio sampling rate.
-     *
-     * @param samplingRate the sampling rate for audio in samples per second.
-     */
-    public void setAudioSamplingRate(int samplingRate) {
-        if (samplingRate <= 0) {
-            throw new IllegalArgumentException("Audio sampling rate is not positive");
-        }
-        setParameter("audio-param-sampling-rate=" + samplingRate);
-    }
-
-    /**
-     * Sets the number of audio channels for recording. Call this method before prepare().
-     * Prepare() may perform additional checks on the parameter to make sure whether the
-     * specified number of audio channels are applicable.
-     *
-     * @param numChannels the number of audio channels. Usually it is either 1 (mono) or 2
-     * (stereo).
-     */
-    public void setAudioChannels(int numChannels) {
-        if (numChannels <= 0) {
-            throw new IllegalArgumentException("Number of channels is not positive");
-        }
-        setParameter("audio-param-number-of-channels=" + numChannels);
-    }
-
-    /**
-     * Sets the audio encoding bit rate for recording. Call this method before prepare().
-     * Prepare() may perform additional checks on the parameter to make sure whether the
-     * specified bit rate is applicable, and sometimes the passed bitRate will be clipped
-     * internally to ensure the audio recording can proceed smoothly based on the
-     * capabilities of the platform.
-     *
-     * @param bitRate the audio encoding bit rate in bits per second.
-     */
-    public void setAudioEncodingBitRate(int bitRate) {
-        if (bitRate <= 0) {
-            throw new IllegalArgumentException("Audio encoding bit rate is not positive");
-        }
-        setParameter("audio-param-encoding-bitrate=" + bitRate);
-    }
-
-    /**
-     * Sets the video encoding bit rate for recording. Call this method before prepare().
-     * Prepare() may perform additional checks on the parameter to make sure whether the
-     * specified bit rate is applicable, and sometimes the passed bitRate will be
-     * clipped internally to ensure the video recording can proceed smoothly based on
-     * the capabilities of the platform.
-     *
-     * @param bitRate the video encoding bit rate in bits per second.
-     */
-    public void setVideoEncodingBitRate(int bitRate) {
-        if (bitRate <= 0) {
-            throw new IllegalArgumentException("Video encoding bit rate is not positive");
-        }
-        setParameter("video-param-encoding-bitrate=" + bitRate);
-    }
-
-    /**
-     * Currently not implemented. It does nothing.
-     * @deprecated Time lapse mode video recording using camera still image capture
-     * is not desirable, and will not be supported.
-     * @hide
-     */
-    public void setAuxiliaryOutputFile(FileDescriptor fd)
-    {
-        Log.w(TAG, "setAuxiliaryOutputFile(FileDescriptor) is no longer supported.");
-    }
-
-    /**
-     * Currently not implemented. It does nothing.
-     * @deprecated Time lapse mode video recording using camera still image capture
-     * is not desirable, and will not be supported.
-     * @hide
-     */
-    public void setAuxiliaryOutputFile(String path)
-    {
-        Log.w(TAG, "setAuxiliaryOutputFile(String) is no longer supported.");
-    }
-
-    /**
-     * Pass in the file descriptor of the file to be written. Call this after
-     * setOutputFormat() but before prepare().
-     *
-     * @param fd an open file descriptor to be written into.
-     * @throws IllegalStateException if it is called before
-     * setOutputFormat() or after prepare()
-     */
-    public void setOutputFile(FileDescriptor fd) throws IllegalStateException
-    {
-        mPath = null;
-        mFd = fd;
-    }
-
-    /**
-     * Sets the path of the output file to be produced. Call this after
-     * setOutputFormat() but before prepare().
-     *
-     * @param path The pathname to use.
-     * @throws IllegalStateException if it is called before
-     * setOutputFormat() or after prepare()
-     */
-    public void setOutputFile(String path) throws IllegalStateException
-    {
-        mFd = null;
-        mPath = path;
-    }
-
-    // native implementation
-    private native void _setOutputFile(FileDescriptor fd, long offset, long length)
-        throws IllegalStateException, IOException;
-    private native void _prepare() throws IllegalStateException, IOException;
-
-    /**
-     * Prepares the recorder to begin capturing and encoding data. This method
-     * must be called after setting up the desired audio and video sources,
-     * encoders, file format, etc., but before start().
-     *
-     * @throws IllegalStateException if it is called after
-     * start() or before setOutputFormat().
-     * @throws IOException if prepare fails otherwise.
-     */
-    public void prepare() throws IllegalStateException, IOException
-    {
-        if (mPath != null) {
-            FileOutputStream fos = new FileOutputStream(mPath);
-            try {
-                _setOutputFile(fos.getFD(), 0, 0);
-            } finally {
-                fos.close();
-            }
-        } else if (mFd != null) {
-            _setOutputFile(mFd, 0, 0);
-        } else {
-            throw new IOException("No valid output file");
-        }
-
-        _prepare();
-    }
-
-    /**
-     * Begins capturing and encoding data to the file specified with
-     * setOutputFile(). Call this after prepare().
-     *
-     * <p>Since API level 13, if applications set a camera via
-     * {@link #setCamera(Camera)}, the apps can use the camera after this method
-     * call. The apps do not need to lock the camera again. However, if this
-     * method fails, the apps should still lock the camera back. The apps should
-     * not start another recording session during recording.
-     *
-     * @throws IllegalStateException if it is called before
-     * prepare().
-     */
-    public native void start() throws IllegalStateException;
-
-    /**
-     * Stops recording. Call this after start(). Once recording is stopped,
-     * you will have to configure it again as if it has just been constructed.
-     * Note that a RuntimeException is intentionally thrown to the
-     * application, if no valid audio/video data has been received when stop()
-     * is called. This happens if stop() is called immediately after
-     * start(). The failure lets the application take action accordingly to
-     * clean up the output file (delete the output file, for instance), since
-     * the output file is not properly constructed when this happens.
-     *
-     * @throws IllegalStateException if it is called before start()
-     */
-    public native void stop() throws IllegalStateException;
-
-    /**
-     * Restarts the MediaRecorder to its idle state. After calling
-     * this method, you will have to configure it again as if it had just been
-     * constructed.
-     */
-    public void reset() {
-        native_reset();
-
-        // make sure none of the listeners get called anymore
-        mEventHandler.removeCallbacksAndMessages(null);
-    }
-
-    private native void native_reset();
-
-    /**
-     * Returns the maximum absolute amplitude that was sampled since the last
-     * call to this method. Call this only after the setAudioSource().
-     *
-     * @return the maximum absolute amplitude measured since the last call, or
-     * 0 when called for the first time
-     * @throws IllegalStateException if it is called before
-     * the audio source has been set.
-     */
-    public native int getMaxAmplitude() throws IllegalStateException;
-
-    /* Do not change this value without updating its counterpart
-     * in include/media/mediarecorder.h or mediaplayer.h!
-     */
-    /** Unspecified media recorder error.
-     * @see android.media.MediaRecorder.OnErrorListener
-     */
-    public static final int MEDIA_RECORDER_ERROR_UNKNOWN = 1;
-    /** Media server died. In this case, the application must release the
-     * MediaRecorder object and instantiate a new one.
-     * @see android.media.MediaRecorder.OnErrorListener
-     */
-    public static final int MEDIA_ERROR_SERVER_DIED = 100;
-
-    /**
-     * Interface definition for a callback to be invoked when an error
-     * occurs while recording.
-     */
-    public interface OnErrorListener
-    {
-        /**
-         * Called when an error occurs while recording.
-         *
-         * @param mr the MediaRecorder that encountered the error
-         * @param what    the type of error that has occurred:
-         * <ul>
-         * <li>{@link #MEDIA_RECORDER_ERROR_UNKNOWN}
-         * <li>{@link #MEDIA_ERROR_SERVER_DIED}
-         * </ul>
-         * @param extra   an extra code, specific to the error type
-         */
-        void onError(MediaRecorder mr, int what, int extra);
-    }
-
-    /**
-     * Register a callback to be invoked when an error occurs while
-     * recording.
-     *
-     * @param l the callback that will be run
-     */
-    public void setOnErrorListener(OnErrorListener l)
-    {
-        mOnErrorListener = l;
-    }
-
-    /* Do not change these values without updating their counterparts
-     * in include/media/mediarecorder.h!
-     */
-    /** Unspecified media recorder error.
-     * @see android.media.MediaRecorder.OnInfoListener
-     */
-    public static final int MEDIA_RECORDER_INFO_UNKNOWN              = 1;
-    /** A maximum duration had been setup and has now been reached.
-     * @see android.media.MediaRecorder.OnInfoListener
-     */
-    public static final int MEDIA_RECORDER_INFO_MAX_DURATION_REACHED = 800;
-    /** A maximum filesize had been setup and has now been reached.
-     * @see android.media.MediaRecorder.OnInfoListener
-     */
-    public static final int MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED = 801;
-
-    /** informational events for individual tracks, for testing purpose.
-     * The track informational event usually contains two parts in the ext1
-     * arg of the onInfo() callback: bit 31-28 contains the track id; and
-     * the rest of the 28 bits contains the informational event defined here.
-     * For example, ext1 = (1 << 28 | MEDIA_RECORDER_TRACK_INFO_TYPE) if the
-     * track id is 1 for informational event MEDIA_RECORDER_TRACK_INFO_TYPE;
-     * while ext1 = (0 << 28 | MEDIA_RECORDER_TRACK_INFO_TYPE) if the track
-     * id is 0 for informational event MEDIA_RECORDER_TRACK_INFO_TYPE. The
-     * application should extract the track id and the type of informational
-     * event from ext1, accordingly.
-     *
-     * FIXME:
-     * Please update the comment for onInfo also when these
-     * events are unhidden so that application knows how to extract the track
-     * id and the informational event type from onInfo callback.
-     *
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_LIST_START        = 1000;
-    /** Signal the completion of the track for the recording session.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_COMPLETION_STATUS = 1000;
-    /** Indicate the recording progress in time (ms) during recording.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_PROGRESS_IN_TIME  = 1001;
-    /** Indicate the track type: 0 for Audio and 1 for Video.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_TYPE              = 1002;
-    /** Provide the track duration information.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_DURATION_MS       = 1003;
-    /** Provide the max chunk duration in time (ms) for the given track.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_MAX_CHUNK_DUR_MS  = 1004;
-    /** Provide the total number of recordd frames.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_ENCODED_FRAMES    = 1005;
-    /** Provide the max spacing between neighboring chunks for the given track.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INTER_CHUNK_TIME_MS    = 1006;
-    /** Provide the elapsed time measuring from the start of the recording
-     * till the first output frame of the given track is received, excluding
-     * any intentional start time offset of a recording session for the
-     * purpose of eliminating the recording sound in the recorded file.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_INITIAL_DELAY_MS  = 1007;
-    /** Provide the start time difference (delay) betweeen this track and
-     * the start of the movie.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_START_OFFSET_MS   = 1008;
-    /** Provide the total number of data (in kilo-bytes) encoded.
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_DATA_KBYTES       = 1009;
-    /**
-     * {@hide}
-     */
-    public static final int MEDIA_RECORDER_TRACK_INFO_LIST_END          = 2000;
-
-
-    /**
-     * Interface definition for a callback to be invoked when an error
-     * occurs while recording.
-     */
-    public interface OnInfoListener
-    {
-        /**
-         * Called when an error occurs while recording.
-         *
-         * @param mr the MediaRecorder that encountered the error
-         * @param what    the type of error that has occurred:
-         * <ul>
-         * <li>{@link #MEDIA_RECORDER_INFO_UNKNOWN}
-         * <li>{@link #MEDIA_RECORDER_INFO_MAX_DURATION_REACHED}
-         * <li>{@link #MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED}
-         * </ul>
-         * @param extra   an extra code, specific to the error type
-         */
-        void onInfo(MediaRecorder mr, int what, int extra);
-    }
-
-    /**
-     * Register a callback to be invoked when an informational event occurs while
-     * recording.
-     *
-     * @param listener the callback that will be run
-     */
-    public void setOnInfoListener(OnInfoListener listener)
-    {
-        mOnInfoListener = listener;
-    }
-
-    private class EventHandler extends Handler
-    {
-        private MediaRecorder mMediaRecorder;
-
-        public EventHandler(MediaRecorder mr, Looper looper) {
-            super(looper);
-            mMediaRecorder = mr;
-        }
-
-        /* Do not change these values without updating their counterparts
-         * in include/media/mediarecorder.h!
-         */
-        private static final int MEDIA_RECORDER_EVENT_LIST_START = 1;
-        private static final int MEDIA_RECORDER_EVENT_ERROR      = 1;
-        private static final int MEDIA_RECORDER_EVENT_INFO       = 2;
-        private static final int MEDIA_RECORDER_EVENT_LIST_END   = 99;
-
-        /* Events related to individual tracks */
-        private static final int MEDIA_RECORDER_TRACK_EVENT_LIST_START = 100;
-        private static final int MEDIA_RECORDER_TRACK_EVENT_ERROR      = 100;
-        private static final int MEDIA_RECORDER_TRACK_EVENT_INFO       = 101;
-        private static final int MEDIA_RECORDER_TRACK_EVENT_LIST_END   = 1000;
-
-
-        @Override
-        public void handleMessage(Message msg) {
-            if (mMediaRecorder.mNativeContext == 0) {
-                Log.w(TAG, "mediarecorder went away with unhandled events");
-                return;
-            }
-            switch(msg.what) {
-            case MEDIA_RECORDER_EVENT_ERROR:
-            case MEDIA_RECORDER_TRACK_EVENT_ERROR:
-                if (mOnErrorListener != null)
-                    mOnErrorListener.onError(mMediaRecorder, msg.arg1, msg.arg2);
-
-                return;
-
-            case MEDIA_RECORDER_EVENT_INFO:
-            case MEDIA_RECORDER_TRACK_EVENT_INFO:
-                if (mOnInfoListener != null)
-                    mOnInfoListener.onInfo(mMediaRecorder, msg.arg1, msg.arg2);
-
-                return;
-
-            default:
-                Log.e(TAG, "Unknown message type " + msg.what);
-                return;
-            }
-        }
-    }
-
-    /**
-     * Called from native code when an interesting event happens.  This method
-     * just uses the EventHandler system to post the event back to the main app thread.
-     * We use a weak reference to the original MediaRecorder object so that the native
-     * code is safe from the object disappearing from underneath it.  (This is
-     * the cookie passed to native_setup().)
-     */
-    private static void postEventFromNative(Object mediarecorder_ref,
-                                            int what, int arg1, int arg2, Object obj)
-    {
-        MediaRecorder mr = (MediaRecorder)((WeakReference)mediarecorder_ref).get();
-        if (mr == null) {
-            return;
-        }
-
-        if (mr.mEventHandler != null) {
-            Message m = mr.mEventHandler.obtainMessage(what, arg1, arg2, obj);
-            mr.mEventHandler.sendMessage(m);
-        }
-    }
-
-    /**
-     * Releases resources associated with this MediaRecorder object.
-     * It is good practice to call this method when you're done
-     * using the MediaRecorder. In particular, whenever an Activity
-     * of an application is paused (its onPause() method is called),
-     * or stopped (its onStop() method is called), this method should be
-     * invoked to release the MediaRecorder object, unless the application
-     * has a special need to keep the object around. In addition to
-     * unnecessary resources (such as memory and instances of codecs)
-     * being held, failure to call this method immediately if a
-     * MediaRecorder object is no longer needed may also lead to
-     * continuous battery consumption for mobile devices, and recording
-     * failure for other applications if no multiple instances of the
-     * same codec are supported on a device. Even if multiple instances
-     * of the same codec are supported, some performance degradation
-     * may be expected when unnecessary multiple instances are used
-     * at the same time.
-     */
-    public native void release();
-
-    private static native final void native_init();
-
-    private native final void native_setup(Object mediarecorder_this) throws IllegalStateException;
-
-    private native final void native_finalize();
-
-    private native void setParameter(String nameValuePair);
-
-    @Override
-    protected void finalize() { native_finalize(); }
-}
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.media;
+
+import android.hardware.Camera;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+import android.view.Surface;
+
+import java.io.FileDescriptor;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+
+/**
+ * Used to record audio and video. The recording control is based on a
+ * simple state machine (see below).
+ *
+ * <p><img src="{@docRoot}images/mediarecorder_state_diagram.gif" border="0" />
+ * </p>
+ *
+ * <p>A common case of using MediaRecorder to record audio works as follows:
+ *
+ * <pre>MediaRecorder recorder = new MediaRecorder();
+ * recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
+ * recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
+ * recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
+ * recorder.setOutputFile(PATH_NAME);
+ * recorder.prepare();
+ * recorder.start();   // Recording is now started
+ * ...
+ * recorder.stop();
+ * recorder.reset();   // You can reuse the object by going back to setAudioSource() step
+ * recorder.release(); // Now the object cannot be reused
+ * </pre>
+ *
+ * <p>Applications may want to register for informational and error
+ * events in order to be informed of some internal update and possible
+ * runtime errors during recording. Registration for such events is
+ * done by setting the appropriate listeners (via calls
+ * (to {@link #setOnInfoListener(OnInfoListener)}setOnInfoListener and/or
+ * {@link #setOnErrorListener(OnErrorListener)}setOnErrorListener).
+ * In order to receive the respective callback associated with these listeners,
+ * applications are required to create MediaRecorder objects on threads with a
+ * Looper running (the main UI thread by default already has a Looper running).
+ *
+ * <p><strong>Note:</strong> Currently, MediaRecorder does not work on the emulator.
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about how to use MediaRecorder for recording video, read the
+ * <a href="{@docRoot}guide/topics/media/camera.html#capture-video">Camera</a> developer guide.
+ * For more information about how to use MediaRecorder for recording sound, read the
+ * <a href="{@docRoot}guide/topics/media/audio-capture.html">Audio Capture</a> developer guide.</p>
+ * </div>
+ */
+public class MediaRecorder
+{
+    static {
+        System.loadLibrary("media_jni");
+        native_init();
+    }
+    private final static String TAG = "MediaRecorder";
+
+    // The two fields below are accessed by native methods
+    @SuppressWarnings("unused")
+    private int mNativeContext;
+
+    @SuppressWarnings("unused")
+    private Surface mSurface;
+
+    private String mPath;
+    private FileDescriptor mFd;
+    private EventHandler mEventHandler;
+    private OnErrorListener mOnErrorListener;
+    private OnInfoListener mOnInfoListener;
+
+    /**
+     * Default constructor.
+     */
+    public MediaRecorder() {
+
+        Looper looper;
+        if ((looper = Looper.myLooper()) != null) {
+            mEventHandler = new EventHandler(this, looper);
+        } else if ((looper = Looper.getMainLooper()) != null) {
+            mEventHandler = new EventHandler(this, looper);
+        } else {
+            mEventHandler = null;
+        }
+
+        /* Native setup requires a weak reference to our object.
+         * It's easier to create it here than in C++.
+         */
+        native_setup(new WeakReference<MediaRecorder>(this));
+    }
+
+    /**
+     * Sets a Camera to use for recording. Use this function to switch
+     * quickly between preview and capture mode without a teardown of
+     * the camera object. {@link android.hardware.Camera#unlock()} should be
+     * called before this. Must call before prepare().
+     *
+     * @param c the Camera to use for recording
+     */
+    public native void setCamera(Camera c);
+
+    /**
+     * Sets a Surface to show a preview of recorded media (video). Calls this
+     * before prepare() to make sure that the desirable preview display is
+     * set. If {@link #setCamera(Camera)} is used and the surface has been
+     * already set to the camera, application do not need to call this. If
+     * this is called with non-null surface, the preview surface of the camera
+     * will be replaced by the new surface. If this method is called with null
+     * surface or not called at all, media recorder will not change the preview
+     * surface of the camera.
+     *
+     * @param sv the Surface to use for the preview
+     * @see android.hardware.Camera#setPreviewDisplay(android.view.SurfaceHolder)
+     */
+    public void setPreviewDisplay(Surface sv) {
+        mSurface = sv;
+    }
+
+    /**
+     * Defines the audio source. These constants are used with
+     * {@link MediaRecorder#setAudioSource(int)}.
+     */
+    public final class AudioSource {
+      /* Do not change these values without updating their counterparts
+       * in system/core/include/system/audio.h!
+       */
+        private AudioSource() {}
+
+        /** Default audio source **/
+        public static final int DEFAULT = 0;
+
+        /** Microphone audio source */
+        public static final int MIC = 1;
+
+        /** Voice call uplink (Tx) audio source */
+        public static final int VOICE_UPLINK = 2;
+
+        /** Voice call downlink (Rx) audio source */
+        public static final int VOICE_DOWNLINK = 3;
+
+        /** Voice call uplink + downlink audio source */
+        public static final int VOICE_CALL = 4;
+
+        /** Microphone audio source with same orientation as camera if available, the main
+         *  device microphone otherwise */
+        public static final int CAMCORDER = 5;
+
+        /** Microphone audio source tuned for voice recognition if available, behaves like
+         *  {@link #DEFAULT} otherwise. */
+        public static final int VOICE_RECOGNITION = 6;
+
+        /** Microphone audio source tuned for voice communications such as VoIP. It
+         *  will for instance take advantage of echo cancellation or automatic gain control
+         *  if available. It otherwise behaves like {@link #DEFAULT} if no voice processing
+         *  is applied.
+         */
+        public static final int VOICE_COMMUNICATION = 7;
+
+        /**
+         * @hide
+         * Audio source for remote submix.
+         */
+        public static final int REMOTE_SUBMIX_SOURCE = 8;
+
+        /** @hide */
+        public static final int FM_RX = 9;
+
+        /** @hide */
+        public static final int FM_RX_A2DP = 10;		
+    }
+
+    /**
+     * Defines the video source. These constants are used with
+     * {@link MediaRecorder#setVideoSource(int)}.
+     */
+    public final class VideoSource {
+      /* Do not change these values without updating their counterparts
+       * in include/media/mediarecorder.h!
+       */
+        private VideoSource() {}
+        public static final int DEFAULT = 0;
+        /** Camera video source */
+        public static final int CAMERA = 1;
+        /** @hide */
+        public static final int GRALLOC_BUFFER = 2;
+    }
+
+    /**
+     * Defines the output format. These constants are used with
+     * {@link MediaRecorder#setOutputFormat(int)}.
+     */
+    public final class OutputFormat {
+      /* Do not change these values without updating their counterparts
+       * in include/media/mediarecorder.h!
+       */
+        private OutputFormat() {}
+        public static final int DEFAULT = 0;
+        /** 3GPP media file format*/
+        public static final int THREE_GPP = 1;
+        /** MPEG4 media file format*/
+        public static final int MPEG_4 = 2;
+
+        /** The following formats are audio only .aac or .amr formats */
+
+        /**
+         * AMR NB file format
+         * @deprecated  Deprecated in favor of MediaRecorder.OutputFormat.AMR_NB
+         */
+        public static final int RAW_AMR = 3;
+
+        /** AMR NB file format */
+        public static final int AMR_NB = 3;
+
+        /** AMR WB file format */
+        public static final int AMR_WB = 4;
+
+        /** @hide AAC ADIF file format */
+        public static final int AAC_ADIF = 5;
+
+        /** AAC ADTS file format */
+        public static final int AAC_ADTS = 6;
+
+        /** @hide Stream over a socket, limited to a single stream */
+        public static final int OUTPUT_FORMAT_RTP_AVP = 7;
+
+        /** @hide H.264/AAC data encapsulated in MPEG2/TS */
+        public static final int OUTPUT_FORMAT_MPEG2TS = 8;
+
+        /** @hide QCP file format */
+        public static final int QCP = 9;
+        /** @hide 3GPP2 media file format*/
+        public static final int THREE_GPP2 = 10;
+        /** @hide WAVE media file format*/
+        public static final int WAVE = 11;
+    };
+
+    /**
+     * Defines the audio encoding. These constants are used with
+     * {@link MediaRecorder#setAudioEncoder(int)}.
+     */
+    public final class AudioEncoder {
+      /* Do not change these values without updating their counterparts
+       * in include/media/mediarecorder.h!
+       */
+        private AudioEncoder() {}
+        public static final int DEFAULT = 0;
+        /** AMR (Narrowband) audio codec */
+        public static final int AMR_NB = 1;
+        /** AMR (Wideband) audio codec */
+        public static final int AMR_WB = 2;
+        /** AAC Low Complexity (AAC-LC) audio codec */
+        public static final int AAC = 3;
+        /** High Efficiency AAC (HE-AAC) audio codec */
+        public static final int HE_AAC = 4;
+        /** Enhanced Low Delay AAC (AAC-ELD) audio codec */
+        public static final int AAC_ELD = 5;
+        /** @hide EVRC audio codec */
+        public static final int EVRC = 6;
+        /** @hide QCELP audio codec */
+        public static final int QCELP =7;
+        /** @hide Linear PCM audio codec */
+        public static final int LPCM =8;
+    }
+
+    /**
+     * Defines the video encoding. These constants are used with
+     * {@link MediaRecorder#setVideoEncoder(int)}.
+     */
+    public final class VideoEncoder {
+      /* Do not change these values without updating their counterparts
+       * in include/media/mediarecorder.h!
+       */
+        private VideoEncoder() {}
+        public static final int DEFAULT = 0;
+        public static final int H263 = 1;
+        public static final int H264 = 2;
+        public static final int MPEG_4_SP = 3;
+    }
+
+    /**
+     * Sets the audio source to be used for recording. If this method is not
+     * called, the output file will not contain an audio track. The source needs
+     * to be specified before setting recording-parameters or encoders. Call
+     * this only before setOutputFormat().
+     *
+     * @param audio_source the audio source to use
+     * @throws IllegalStateException if it is called after setOutputFormat()
+     * @see android.media.MediaRecorder.AudioSource
+     */
+    public native void setAudioSource(int audio_source)
+            throws IllegalStateException;
+
+    /**
+     * Gets the maximum value for audio sources.
+     * @see android.media.MediaRecorder.AudioSource
+     */
+    public static final int getAudioSourceMax() {
+        // FIXME disable selection of the remote submxi source selection once test code
+        //       doesn't rely on it
+        return AudioSource.FM_RX_A2DP;
+        //return AudioSource.VOICE_COMMUNICATION;
+    }
+
+    /**
+     * Sets the video source to be used for recording. If this method is not
+     * called, the output file will not contain an video track. The source needs
+     * to be specified before setting recording-parameters or encoders. Call
+     * this only before setOutputFormat().
+     *
+     * @param video_source the video source to use
+     * @throws IllegalStateException if it is called after setOutputFormat()
+     * @see android.media.MediaRecorder.VideoSource
+     */
+    public native void setVideoSource(int video_source)
+            throws IllegalStateException;
+
+    /**
+     * Uses the settings from a CamcorderProfile object for recording. This method should
+     * be called after the video AND audio sources are set, and before setOutputFile().
+     * If a time lapse CamcorderProfile is used, audio related source or recording
+     * parameters are ignored.
+     *
+     * @param profile the CamcorderProfile to use
+     * @see android.media.CamcorderProfile
+     */
+    public void setProfile(CamcorderProfile profile) {
+        setOutputFormat(profile.fileFormat);
+        setVideoFrameRate(profile.videoFrameRate);
+        setVideoSize(profile.videoFrameWidth, profile.videoFrameHeight);
+        setVideoEncodingBitRate(profile.videoBitRate);
+        setVideoEncoder(profile.videoCodec);
+        if (profile.quality >= CamcorderProfile.QUALITY_TIME_LAPSE_LOW &&
+             profile.quality <= CamcorderProfile.QUALITY_TIME_LAPSE_QVGA) {
+            // Nothing needs to be done. Call to setCaptureRate() enables
+            // time lapse video recording.
+        } else {
+            setAudioEncodingBitRate(profile.audioBitRate);
+            setAudioChannels(profile.audioChannels);
+            setAudioSamplingRate(profile.audioSampleRate);
+            setAudioEncoder(profile.audioCodec);
+        }
+    }
+
+    /**
+     * Set video frame capture rate. This can be used to set a different video frame capture
+     * rate than the recorded video's playback rate. This method also sets the recording mode
+     * to time lapse. In time lapse video recording, only video is recorded. Audio related
+     * parameters are ignored when a time lapse recording session starts, if an application
+     * sets them.
+     *
+     * @param fps Rate at which frames should be captured in frames per second.
+     * The fps can go as low as desired. However the fastest fps will be limited by the hardware.
+     * For resolutions that can be captured by the video camera, the fastest fps can be computed using
+     * {@link android.hardware.Camera.Parameters#getPreviewFpsRange(int[])}. For higher
+     * resolutions the fastest fps may be more restrictive.
+     * Note that the recorder cannot guarantee that frames will be captured at the
+     * given rate due to camera/encoder limitations. However it tries to be as close as
+     * possible.
+     */
+    public void setCaptureRate(double fps) {
+        // Make sure that time lapse is enabled when this method is called.
+        setParameter("time-lapse-enable=1");
+
+        double timeBetweenFrameCapture = 1 / fps;
+        int timeBetweenFrameCaptureMs = (int) (1000 * timeBetweenFrameCapture);
+        setParameter("time-between-time-lapse-frame-capture=" + timeBetweenFrameCaptureMs);
+    }
+
+    /**
+     * Sets the orientation hint for output video playback.
+     * This method should be called before prepare(). This method will not
+     * trigger the source video frame to rotate during video recording, but to
+     * add a composition matrix containing the rotation angle in the output
+     * video if the output format is OutputFormat.THREE_GPP or
+     * OutputFormat.MPEG_4 so that a video player can choose the proper
+     * orientation for playback. Note that some video players may choose
+     * to ignore the compostion matrix in a video during playback.
+     *
+     * @param degrees the angle to be rotated clockwise in degrees.
+     * The supported angles are 0, 90, 180, and 270 degrees.
+     * @throws IllegalArgumentException if the angle is not supported.
+     *
+     */
+    public void setOrientationHint(int degrees) {
+        if (degrees != 0   &&
+            degrees != 90  &&
+            degrees != 180 &&
+            degrees != 270) {
+            throw new IllegalArgumentException("Unsupported angle: " + degrees);
+        }
+        setParameter("video-param-rotation-angle-degrees=" + degrees);
+    }
+
+    /**
+     * Set and store the geodata (latitude and longitude) in the output file.
+     * This method should be called before prepare(). The geodata is
+     * stored in udta box if the output format is OutputFormat.THREE_GPP
+     * or OutputFormat.MPEG_4, and is ignored for other output formats.
+     * The geodata is stored according to ISO-6709 standard.
+     *
+     * @param latitude latitude in degrees. Its value must be in the
+     * range [-90, 90].
+     * @param longitude longitude in degrees. Its value must be in the
+     * range [-180, 180].
+     *
+     * @throws IllegalArgumentException if the given latitude or
+     * longitude is out of range.
+     *
+     */
+    public void setLocation(float latitude, float longitude) {
+        int latitudex10000  = (int) (latitude * 10000 + 0.5);
+        int longitudex10000 = (int) (longitude * 10000 + 0.5);
+
+        if (latitudex10000 > 900000 || latitudex10000 < -900000) {
+            String msg = "Latitude: " + latitude + " out of range.";
+            throw new IllegalArgumentException(msg);
+        }
+        if (longitudex10000 > 1800000 || longitudex10000 < -1800000) {
+            String msg = "Longitude: " + longitude + " out of range";
+            throw new IllegalArgumentException(msg);
+        }
+
+        setParameter("param-geotag-latitude=" + latitudex10000);
+        setParameter("param-geotag-longitude=" + longitudex10000);
+    }
+
+    /**
+     * Sets the format of the output file produced during recording. Call this
+     * after setAudioSource()/setVideoSource() but before prepare().
+     *
+     * <p>It is recommended to always use 3GP format when using the H.263
+     * video encoder and AMR audio encoder. Using an MPEG-4 container format
+     * may confuse some desktop players.</p>
+     *
+     * @param output_format the output format to use. The output format
+     * needs to be specified before setting recording-parameters or encoders.
+     * @throws IllegalStateException if it is called after prepare() or before
+     * setAudioSource()/setVideoSource().
+     * @see android.media.MediaRecorder.OutputFormat
+     */
+    public native void setOutputFormat(int output_format)
+            throws IllegalStateException;
+
+    /**
+     * Sets the width and height of the video to be captured.  Must be called
+     * after setVideoSource(). Call this after setOutFormat() but before
+     * prepare().
+     *
+     * @param width the width of the video to be captured
+     * @param height the height of the video to be captured
+     * @throws IllegalStateException if it is called after
+     * prepare() or before setOutputFormat()
+     */
+    public native void setVideoSize(int width, int height)
+            throws IllegalStateException;
+
+    /**
+     * Sets the frame rate of the video to be captured.  Must be called
+     * after setVideoSource(). Call this after setOutFormat() but before
+     * prepare().
+     *
+     * @param rate the number of frames per second of video to capture
+     * @throws IllegalStateException if it is called after
+     * prepare() or before setOutputFormat().
+     *
+     * NOTE: On some devices that have auto-frame rate, this sets the
+     * maximum frame rate, not a constant frame rate. Actual frame rate
+     * will vary according to lighting conditions.
+     */
+    public native void setVideoFrameRate(int rate) throws IllegalStateException;
+
+    /**
+     * Sets the maximum duration (in ms) of the recording session.

+     * Call this after setOutFormat() but before prepare().
+     * After recording reaches the specified duration, a notification
+     * will be sent to the {@link android.media.MediaRecorder.OnInfoListener}
+     * with a "what" code of {@link #MEDIA_RECORDER_INFO_MAX_DURATION_REACHED}
+     * and recording will be stopped. Stopping happens asynchronously, there
+     * is no guarantee that the recorder will have stopped by the time the
+     * listener is notified.
+     *
+     * @param max_duration_ms the maximum duration in ms (if zero or negative, disables the duration limit)
+     *
+     */
+    public native void setMaxDuration(int max_duration_ms) throws IllegalArgumentException;
+
+    /**
+     * Sets the maximum filesize (in bytes) of the recording session.
+     * Call this after setOutFormat() but before prepare().
+     * After recording reaches the specified filesize, a notification
+     * will be sent to the {@link android.media.MediaRecorder.OnInfoListener}
+     * with a "what" code of {@link #MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED}
+     * and recording will be stopped. Stopping happens asynchronously, there
+     * is no guarantee that the recorder will have stopped by the time the
+     * listener is notified.
+     *
+     * @param max_filesize_bytes the maximum filesize in bytes (if zero or negative, disables the limit)
+     *
+     */
+    public native void setMaxFileSize(long max_filesize_bytes) throws IllegalArgumentException;
+
+    /**
+     * Sets the audio encoder to be used for recording. If this method is not
+     * called, the output file will not contain an audio track. Call this after
+     * setOutputFormat() but before prepare().
+     *
+     * @param audio_encoder the audio encoder to use.
+     * @throws IllegalStateException if it is called before
+     * setOutputFormat() or after prepare().
+     * @see android.media.MediaRecorder.AudioEncoder
+     */
+    public native void setAudioEncoder(int audio_encoder)
+            throws IllegalStateException;
+
+    /**
+     * Sets the video encoder to be used for recording. If this method is not
+     * called, the output file will not contain an video track. Call this after
+     * setOutputFormat() and before prepare().
+     *
+     * @param video_encoder the video encoder to use.
+     * @throws IllegalStateException if it is called before
+     * setOutputFormat() or after prepare()
+     * @see android.media.MediaRecorder.VideoEncoder
+     */
+    public native void setVideoEncoder(int video_encoder)
+            throws IllegalStateException;
+
+    /**
+     * Sets the audio sampling rate for recording. Call this method before prepare().
+     * Prepare() may perform additional checks on the parameter to make sure whether
+     * the specified audio sampling rate is applicable. The sampling rate really depends
+     * on the format for the audio recording, as well as the capabilities of the platform.
+     * For instance, the sampling rate supported by AAC audio coding standard ranges
+     * from 8 to 96 kHz, the sampling rate supported by AMRNB is 8kHz, and the sampling
+     * rate supported by AMRWB is 16kHz. Please consult with the related audio coding
+     * standard for the supported audio sampling rate.
+     *
+     * @param samplingRate the sampling rate for audio in samples per second.
+     */
+    public void setAudioSamplingRate(int samplingRate) {
+        if (samplingRate <= 0) {
+            throw new IllegalArgumentException("Audio sampling rate is not positive");
+        }
+        setParameter("audio-param-sampling-rate=" + samplingRate);
+    }
+
+    /**
+     * Sets the number of audio channels for recording. Call this method before prepare().
+     * Prepare() may perform additional checks on the parameter to make sure whether the
+     * specified number of audio channels are applicable.
+     *
+     * @param numChannels the number of audio channels. Usually it is either 1 (mono) or 2
+     * (stereo).
+     */
+    public void setAudioChannels(int numChannels) {
+        if (numChannels <= 0) {
+            throw new IllegalArgumentException("Number of channels is not positive");
+        }
+        setParameter("audio-param-number-of-channels=" + numChannels);
+    }
+
+    /**
+     * Sets the audio encoding bit rate for recording. Call this method before prepare().
+     * Prepare() may perform additional checks on the parameter to make sure whether the
+     * specified bit rate is applicable, and sometimes the passed bitRate will be clipped
+     * internally to ensure the audio recording can proceed smoothly based on the
+     * capabilities of the platform.
+     *
+     * @param bitRate the audio encoding bit rate in bits per second.
+     */
+    public void setAudioEncodingBitRate(int bitRate) {
+        if (bitRate <= 0) {
+            throw new IllegalArgumentException("Audio encoding bit rate is not positive");
+        }
+        setParameter("audio-param-encoding-bitrate=" + bitRate);
+    }
+
+    /**
+     * Sets the video encoding bit rate for recording. Call this method before prepare().
+     * Prepare() may perform additional checks on the parameter to make sure whether the
+     * specified bit rate is applicable, and sometimes the passed bitRate will be
+     * clipped internally to ensure the video recording can proceed smoothly based on
+     * the capabilities of the platform.
+     *
+     * @param bitRate the video encoding bit rate in bits per second.
+     */
+    public void setVideoEncodingBitRate(int bitRate) {
+        if (bitRate <= 0) {
+            throw new IllegalArgumentException("Video encoding bit rate is not positive");
+        }
+        setParameter("video-param-encoding-bitrate=" + bitRate);
+    }
+
+    /**
+     * Currently not implemented. It does nothing.
+     * @deprecated Time lapse mode video recording using camera still image capture
+     * is not desirable, and will not be supported.
+     * @hide
+     */
+    public void setAuxiliaryOutputFile(FileDescriptor fd)
+    {
+        Log.w(TAG, "setAuxiliaryOutputFile(FileDescriptor) is no longer supported.");
+    }
+
+    /**
+     * Currently not implemented. It does nothing.
+     * @deprecated Time lapse mode video recording using camera still image capture
+     * is not desirable, and will not be supported.
+     * @hide
+     */
+    public void setAuxiliaryOutputFile(String path)
+    {
+        Log.w(TAG, "setAuxiliaryOutputFile(String) is no longer supported.");
+    }
+
+    /**
+     * Pass in the file descriptor of the file to be written. Call this after
+     * setOutputFormat() but before prepare().
+     *
+     * @param fd an open file descriptor to be written into.
+     * @throws IllegalStateException if it is called before
+     * setOutputFormat() or after prepare()
+     */
+    public void setOutputFile(FileDescriptor fd) throws IllegalStateException
+    {
+        mPath = null;
+        mFd = fd;
+    }
+
+    /**
+     * Sets the path of the output file to be produced. Call this after
+     * setOutputFormat() but before prepare().
+     *
+     * @param path The pathname to use.
+     * @throws IllegalStateException if it is called before
+     * setOutputFormat() or after prepare()
+     */
+    public void setOutputFile(String path) throws IllegalStateException
+    {
+        mFd = null;
+        mPath = path;
+    }
+
+    // native implementation
+    private native void _setOutputFile(FileDescriptor fd, long offset, long length)
+        throws IllegalStateException, IOException;
+    private native void _prepare() throws IllegalStateException, IOException;
+
+    /**
+     * Prepares the recorder to begin capturing and encoding data. This method
+     * must be called after setting up the desired audio and video sources,
+     * encoders, file format, etc., but before start().
+     *
+     * @throws IllegalStateException if it is called after
+     * start() or before setOutputFormat().
+     * @throws IOException if prepare fails otherwise.
+     */
+    public void prepare() throws IllegalStateException, IOException
+    {
+        if (mPath != null) {
+            FileOutputStream fos = new FileOutputStream(mPath);
+            try {
+                _setOutputFile(fos.getFD(), 0, 0);
+            } finally {
+                fos.close();
+            }
+        } else if (mFd != null) {
+            _setOutputFile(mFd, 0, 0);
+        } else {
+            throw new IOException("No valid output file");
+        }
+
+        _prepare();
+    }
+
+    /**
+     * Begins capturing and encoding data to the file specified with
+     * setOutputFile(). Call this after prepare().
+     *
+     * <p>Since API level 13, if applications set a camera via
+     * {@link #setCamera(Camera)}, the apps can use the camera after this method
+     * call. The apps do not need to lock the camera again. However, if this
+     * method fails, the apps should still lock the camera back. The apps should
+     * not start another recording session during recording.
+     *
+     * @throws IllegalStateException if it is called before
+     * prepare().
+     */
+    public native void start() throws IllegalStateException;
+
+    /**
+     * Stops recording. Call this after start(). Once recording is stopped,
+     * you will have to configure it again as if it has just been constructed.
+     * Note that a RuntimeException is intentionally thrown to the
+     * application, if no valid audio/video data has been received when stop()
+     * is called. This happens if stop() is called immediately after
+     * start(). The failure lets the application take action accordingly to
+     * clean up the output file (delete the output file, for instance), since
+     * the output file is not properly constructed when this happens.
+     *
+     * @throws IllegalStateException if it is called before start()
+     */
+    public native void stop() throws IllegalStateException;
+
+    /**
+     * Restarts the MediaRecorder to its idle state. After calling
+     * this method, you will have to configure it again as if it had just been
+     * constructed.
+     */
+    public void reset() {
+        native_reset();
+
+        // make sure none of the listeners get called anymore
+        mEventHandler.removeCallbacksAndMessages(null);
+    }
+
+    private native void native_reset();
+
+    /**
+     * Returns the maximum absolute amplitude that was sampled since the last
+     * call to this method. Call this only after the setAudioSource().
+     *
+     * @return the maximum absolute amplitude measured since the last call, or
+     * 0 when called for the first time
+     * @throws IllegalStateException if it is called before
+     * the audio source has been set.
+     */
+    public native int getMaxAmplitude() throws IllegalStateException;
+
+    /* Do not change this value without updating its counterpart
+     * in include/media/mediarecorder.h or mediaplayer.h!
+     */
+    /** Unspecified media recorder error.
+     * @see android.media.MediaRecorder.OnErrorListener
+     */
+    public static final int MEDIA_RECORDER_ERROR_UNKNOWN = 1;
+    /** Media server died. In this case, the application must release the
+     * MediaRecorder object and instantiate a new one.
+     * @see android.media.MediaRecorder.OnErrorListener
+     */
+    public static final int MEDIA_ERROR_SERVER_DIED = 100;
+
+    /**
+     * Interface definition for a callback to be invoked when an error
+     * occurs while recording.
+     */
+    public interface OnErrorListener
+    {
+        /**
+         * Called when an error occurs while recording.
+         *
+         * @param mr the MediaRecorder that encountered the error
+         * @param what    the type of error that has occurred:
+         * <ul>
+         * <li>{@link #MEDIA_RECORDER_ERROR_UNKNOWN}
+         * <li>{@link #MEDIA_ERROR_SERVER_DIED}
+         * </ul>
+         * @param extra   an extra code, specific to the error type
+         */
+        void onError(MediaRecorder mr, int what, int extra);
+    }
+
+    /**
+     * Register a callback to be invoked when an error occurs while
+     * recording.
+     *
+     * @param l the callback that will be run
+     */
+    public void setOnErrorListener(OnErrorListener l)
+    {
+        mOnErrorListener = l;
+    }
+
+    /* Do not change these values without updating their counterparts
+     * in include/media/mediarecorder.h!
+     */
+    /** Unspecified media recorder error.
+     * @see android.media.MediaRecorder.OnInfoListener
+     */
+    public static final int MEDIA_RECORDER_INFO_UNKNOWN              = 1;
+    /** A maximum duration had been setup and has now been reached.
+     * @see android.media.MediaRecorder.OnInfoListener
+     */
+    public static final int MEDIA_RECORDER_INFO_MAX_DURATION_REACHED = 800;
+    /** A maximum filesize had been setup and has now been reached.
+     * @see android.media.MediaRecorder.OnInfoListener
+     */
+    public static final int MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED = 801;
+
+    /** informational events for individual tracks, for testing purpose.
+     * The track informational event usually contains two parts in the ext1
+     * arg of the onInfo() callback: bit 31-28 contains the track id; and
+     * the rest of the 28 bits contains the informational event defined here.
+     * For example, ext1 = (1 << 28 | MEDIA_RECORDER_TRACK_INFO_TYPE) if the
+     * track id is 1 for informational event MEDIA_RECORDER_TRACK_INFO_TYPE;
+     * while ext1 = (0 << 28 | MEDIA_RECORDER_TRACK_INFO_TYPE) if the track
+     * id is 0 for informational event MEDIA_RECORDER_TRACK_INFO_TYPE. The
+     * application should extract the track id and the type of informational
+     * event from ext1, accordingly.
+     *
+     * FIXME:
+     * Please update the comment for onInfo also when these
+     * events are unhidden so that application knows how to extract the track
+     * id and the informational event type from onInfo callback.
+     *
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_LIST_START        = 1000;
+    /** Signal the completion of the track for the recording session.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_COMPLETION_STATUS = 1000;
+    /** Indicate the recording progress in time (ms) during recording.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_PROGRESS_IN_TIME  = 1001;
+    /** Indicate the track type: 0 for Audio and 1 for Video.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_TYPE              = 1002;
+    /** Provide the track duration information.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_DURATION_MS       = 1003;
+    /** Provide the max chunk duration in time (ms) for the given track.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_MAX_CHUNK_DUR_MS  = 1004;
+    /** Provide the total number of recordd frames.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_ENCODED_FRAMES    = 1005;
+    /** Provide the max spacing between neighboring chunks for the given track.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INTER_CHUNK_TIME_MS    = 1006;
+    /** Provide the elapsed time measuring from the start of the recording
+     * till the first output frame of the given track is received, excluding
+     * any intentional start time offset of a recording session for the
+     * purpose of eliminating the recording sound in the recorded file.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_INITIAL_DELAY_MS  = 1007;
+    /** Provide the start time difference (delay) betweeen this track and
+     * the start of the movie.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_START_OFFSET_MS   = 1008;
+    /** Provide the total number of data (in kilo-bytes) encoded.
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_DATA_KBYTES       = 1009;
+    /**
+     * {@hide}
+     */
+    public static final int MEDIA_RECORDER_TRACK_INFO_LIST_END          = 2000;
+
+
+    /**
+     * Interface definition for a callback to be invoked when an error
+     * occurs while recording.
+     */
+    public interface OnInfoListener
+    {
+        /**
+         * Called when an error occurs while recording.
+         *
+         * @param mr the MediaRecorder that encountered the error
+         * @param what    the type of error that has occurred:
+         * <ul>
+         * <li>{@link #MEDIA_RECORDER_INFO_UNKNOWN}
+         * <li>{@link #MEDIA_RECORDER_INFO_MAX_DURATION_REACHED}
+         * <li>{@link #MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED}
+         * </ul>
+         * @param extra   an extra code, specific to the error type
+         */
+        void onInfo(MediaRecorder mr, int what, int extra);
+    }
+
+    /**
+     * Register a callback to be invoked when an informational event occurs while
+     * recording.
+     *
+     * @param listener the callback that will be run
+     */
+    public void setOnInfoListener(OnInfoListener listener)
+    {
+        mOnInfoListener = listener;
+    }
+
+    private class EventHandler extends Handler
+    {
+        private MediaRecorder mMediaRecorder;
+
+        public EventHandler(MediaRecorder mr, Looper looper) {
+            super(looper);
+            mMediaRecorder = mr;
+        }
+
+        /* Do not change these values without updating their counterparts
+         * in include/media/mediarecorder.h!
+         */
+        private static final int MEDIA_RECORDER_EVENT_LIST_START = 1;
+        private static final int MEDIA_RECORDER_EVENT_ERROR      = 1;
+        private static final int MEDIA_RECORDER_EVENT_INFO       = 2;
+        private static final int MEDIA_RECORDER_EVENT_LIST_END   = 99;
+
+        /* Events related to individual tracks */
+        private static final int MEDIA_RECORDER_TRACK_EVENT_LIST_START = 100;
+        private static final int MEDIA_RECORDER_TRACK_EVENT_ERROR      = 100;
+        private static final int MEDIA_RECORDER_TRACK_EVENT_INFO       = 101;
+        private static final int MEDIA_RECORDER_TRACK_EVENT_LIST_END   = 1000;
+
+
+        @Override
+        public void handleMessage(Message msg) {
+            if (mMediaRecorder.mNativeContext == 0) {
+                Log.w(TAG, "mediarecorder went away with unhandled events");
+                return;
+            }
+            switch(msg.what) {
+            case MEDIA_RECORDER_EVENT_ERROR:
+            case MEDIA_RECORDER_TRACK_EVENT_ERROR:
+                if (mOnErrorListener != null)
+                    mOnErrorListener.onError(mMediaRecorder, msg.arg1, msg.arg2);
+
+                return;
+
+            case MEDIA_RECORDER_EVENT_INFO:
+            case MEDIA_RECORDER_TRACK_EVENT_INFO:
+                if (mOnInfoListener != null)
+                    mOnInfoListener.onInfo(mMediaRecorder, msg.arg1, msg.arg2);
+
+                return;
+
+            default:
+                Log.e(TAG, "Unknown message type " + msg.what);
+                return;
+            }
+        }
+    }
+
+    /**
+     * Called from native code when an interesting event happens.  This method
+     * just uses the EventHandler system to post the event back to the main app thread.
+     * We use a weak reference to the original MediaRecorder object so that the native
+     * code is safe from the object disappearing from underneath it.  (This is
+     * the cookie passed to native_setup().)
+     */
+    private static void postEventFromNative(Object mediarecorder_ref,
+                                            int what, int arg1, int arg2, Object obj)
+    {
+        MediaRecorder mr = (MediaRecorder)((WeakReference)mediarecorder_ref).get();
+        if (mr == null) {
+            return;
+        }
+
+        if (mr.mEventHandler != null) {
+            Message m = mr.mEventHandler.obtainMessage(what, arg1, arg2, obj);
+            mr.mEventHandler.sendMessage(m);
+        }
+    }
+
+    /**
+     * Releases resources associated with this MediaRecorder object.
+     * It is good practice to call this method when you're done
+     * using the MediaRecorder. In particular, whenever an Activity
+     * of an application is paused (its onPause() method is called),
+     * or stopped (its onStop() method is called), this method should be
+     * invoked to release the MediaRecorder object, unless the application
+     * has a special need to keep the object around. In addition to
+     * unnecessary resources (such as memory and instances of codecs)
+     * being held, failure to call this method immediately if a
+     * MediaRecorder object is no longer needed may also lead to
+     * continuous battery consumption for mobile devices, and recording
+     * failure for other applications if no multiple instances of the
+     * same codec are supported on a device. Even if multiple instances
+     * of the same codec are supported, some performance degradation
+     * may be expected when unnecessary multiple instances are used
+     * at the same time.
+     */
+    public native void release();
+
+    private static native final void native_init();
+
+    private native final void native_setup(Object mediarecorder_this) throws IllegalStateException;
+
+    private native final void native_finalize();
+
+    private native void setParameter(String nameValuePair);
+
+    @Override
+    protected void finalize() { native_finalize(); }
+}
diff --git a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
index ab3356d..142beba 100644
--- a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+++ b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
@@ -1,2311 +1,2314 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.settings;
-
-import android.content.ComponentName;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.IPackageManager;
-import android.content.pm.PackageManager;
-import android.content.res.XmlResourceParser;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.database.sqlite.SQLiteStatement;
-import android.media.AudioManager;
-import android.media.AudioService;
-import android.net.ConnectivityManager;
-import android.os.Environment;
-import android.os.RemoteException;
-import android.os.ServiceManager;
-import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.provider.Settings;
-import android.provider.Settings.Global;
-import android.provider.Settings.Secure;
-import android.telephony.TelephonyManager;
-import android.text.TextUtils;
-import android.util.Log;
-
-import com.android.internal.content.PackageHelper;
-import com.android.internal.telephony.Phone;
-import com.android.internal.telephony.PhoneConstants;
-import com.android.internal.telephony.RILConstants;
-import com.android.internal.util.XmlUtils;
-import com.android.internal.widget.LockPatternUtils;
-import com.android.internal.widget.LockPatternView;
-
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.HashSet;
-import java.util.List;
-
-/**
- * Database helper class for {@link SettingsProvider}.
- * Mostly just has a bit {@link #onCreate} to initialize the database.
- */
-public class DatabaseHelper extends SQLiteOpenHelper {
-    private static final String TAG = "SettingsProvider";
-    private static final String DATABASE_NAME = "settings.db";
-
-    // Please, please please. If you update the database version, check to make sure the
-    // database gets upgraded properly. At a minimum, please confirm that 'upgradeVersion'
-    // is properly propagated through your change.  Not doing so will result in a loss of user
-    // settings.
-    private static final int DATABASE_VERSION = 95;
-
-    private Context mContext;
-    private int mUserHandle;
-
-    private static final HashSet<String> mValidTables = new HashSet<String>();
-
-    private static final String TABLE_SYSTEM = "system";
-    private static final String TABLE_SECURE = "secure";
-    private static final String TABLE_GLOBAL = "global";
-
-    static {
-        mValidTables.add(TABLE_SYSTEM);
-        mValidTables.add(TABLE_SECURE);
-        mValidTables.add(TABLE_GLOBAL);
-        mValidTables.add("bluetooth_devices");
-        mValidTables.add("bookmarks");
-
-        // These are old.
-        mValidTables.add("favorites");
-        mValidTables.add("gservices");
-        mValidTables.add("old_favorites");
-    }
-
-    static String dbNameForUser(final int userHandle) {
-        // The owner gets the unadorned db name;
-        if (userHandle == UserHandle.USER_OWNER) {
-            return DATABASE_NAME;
-        } else {
-            // Place the database in the user-specific data tree so that it's
-            // cleaned up automatically when the user is deleted.
-            File databaseFile = new File(
-                    Environment.getUserSystemDirectory(userHandle), DATABASE_NAME);
-            return databaseFile.getPath();
-        }
-    }
-
-    public DatabaseHelper(Context context, int userHandle) {
-        super(context, dbNameForUser(userHandle), null, DATABASE_VERSION);
-        mContext = context;
-        mUserHandle = userHandle;
-        setWriteAheadLoggingEnabled(true);
-    }
-
-    public static boolean isValidTable(String name) {
-        return mValidTables.contains(name);
-    }
-
-    private void createSecureTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE secure (" +
-                "_id INTEGER PRIMARY KEY AUTOINCREMENT," +
-                "name TEXT UNIQUE ON CONFLICT REPLACE," +
-                "value TEXT" +
-                ");");
-        db.execSQL("CREATE INDEX secureIndex1 ON secure (name);");
-    }
-
-    private void createGlobalTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE global (" +
-                "_id INTEGER PRIMARY KEY AUTOINCREMENT," +
-                "name TEXT UNIQUE ON CONFLICT REPLACE," +
-                "value TEXT" +
-                ");");
-        db.execSQL("CREATE INDEX globalIndex1 ON global (name);");
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE system (" +
-                    "_id INTEGER PRIMARY KEY AUTOINCREMENT," +
-                    "name TEXT UNIQUE ON CONFLICT REPLACE," +
-                    "value TEXT" +
-                    ");");
-        db.execSQL("CREATE INDEX systemIndex1 ON system (name);");
-
-        createSecureTable(db);
-
-        // Only create the global table for the singleton 'owner' user
-        if (mUserHandle == UserHandle.USER_OWNER) {
-            createGlobalTable(db);
-        }
-
-        db.execSQL("CREATE TABLE bluetooth_devices (" +
-                    "_id INTEGER PRIMARY KEY," +
-                    "name TEXT," +
-                    "addr TEXT," +
-                    "channel INTEGER," +
-                    "type INTEGER" +
-                    ");");
-
-        db.execSQL("CREATE TABLE bookmarks (" +
-                    "_id INTEGER PRIMARY KEY," +
-                    "title TEXT," +
-                    "folder TEXT," +
-                    "intent TEXT," +
-                    "shortcut INTEGER," +
-                    "ordering INTEGER" +
-                    ");");
-
-        db.execSQL("CREATE INDEX bookmarksIndex1 ON bookmarks (folder);");
-        db.execSQL("CREATE INDEX bookmarksIndex2 ON bookmarks (shortcut);");
-
-        // Populate bookmarks table with initial bookmarks
-        boolean onlyCore = false;
-        try {
-            onlyCore = IPackageManager.Stub.asInterface(ServiceManager.getService(
-                    "package")).isOnlyCoreApps();
-        } catch (RemoteException e) {
-        }
-        if (!onlyCore) {
-            loadBookmarks(db);
-        }
-
-        // Load initial volume levels into DB
-        loadVolumeLevels(db);
-
-        // Load inital settings values
-        loadSettings(db);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) {
-        Log.w(TAG, "Upgrading settings database from version " + oldVersion + " to "
-                + currentVersion);
-
-        int upgradeVersion = oldVersion;
-
-        // Pattern for upgrade blocks:
-        //
-        //    if (upgradeVersion == [the DATABASE_VERSION you set] - 1) {
-        //        .. your upgrade logic..
-        //        upgradeVersion = [the DATABASE_VERSION you set]
-        //    }
-
-        if (upgradeVersion == 20) {
-            /*
-             * Version 21 is part of the volume control refresh. There is no
-             * longer a UI-visible for setting notification vibrate on/off (in
-             * our design), but the functionality still exists. Force the
-             * notification vibrate to on.
-             */
-            loadVibrateSetting(db, true);
-
-            upgradeVersion = 21;
-        }
-
-        if (upgradeVersion < 22) {
-            upgradeVersion = 22;
-            // Upgrade the lock gesture storage location and format
-            upgradeLockPatternLocation(db);
-        }
-
-        if (upgradeVersion < 23) {
-            db.execSQL("UPDATE favorites SET iconResource=0 WHERE iconType=0");
-            upgradeVersion = 23;
-        }
-
-        if (upgradeVersion == 23) {
-            db.beginTransaction();
-            try {
-                db.execSQL("ALTER TABLE favorites ADD spanX INTEGER");
-                db.execSQL("ALTER TABLE favorites ADD spanY INTEGER");
-                // Shortcuts, applications, folders
-                db.execSQL("UPDATE favorites SET spanX=1, spanY=1 WHERE itemType<=0");
-                // Photo frames, clocks
-                db.execSQL(
-                    "UPDATE favorites SET spanX=2, spanY=2 WHERE itemType=1000 or itemType=1002");
-                // Search boxes
-                db.execSQL("UPDATE favorites SET spanX=4, spanY=1 WHERE itemType=1001");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 24;
-        }
-
-        if (upgradeVersion == 24) {
-            db.beginTransaction();
-            try {
-                // The value of the constants for preferring wifi or preferring mobile have been
-                // swapped, so reload the default.
-                db.execSQL("DELETE FROM system WHERE name='network_preference'");
-                db.execSQL("INSERT INTO system ('name', 'value') values ('network_preference', '" +
-                        ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + "')");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 25;
-        }
-
-        if (upgradeVersion == 25) {
-            db.beginTransaction();
-            try {
-                db.execSQL("ALTER TABLE favorites ADD uri TEXT");
-                db.execSQL("ALTER TABLE favorites ADD displayMode INTEGER");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 26;
-        }
-
-        if (upgradeVersion == 26) {
-            // This introduces the new secure settings table.
-            db.beginTransaction();
-            try {
-                createSecureTable(db);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 27;
-        }
-
-        if (upgradeVersion == 27) {
-            String[] settingsToMove = {
-                    Settings.Secure.ADB_ENABLED,
-                    Settings.Secure.ANDROID_ID,
-                    Settings.Secure.BLUETOOTH_ON,
-                    Settings.Secure.DATA_ROAMING,
-                    Settings.Secure.DEVICE_PROVISIONED,
-                    Settings.Secure.HTTP_PROXY,
-                    Settings.Secure.INSTALL_NON_MARKET_APPS,
-                    Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
-                    Settings.Secure.LOGGING_ID,
-                    Settings.Secure.NETWORK_PREFERENCE,
-                    Settings.Secure.PARENTAL_CONTROL_ENABLED,
-                    Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,
-                    Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,
-                    Settings.Secure.SETTINGS_CLASSNAME,
-                    Settings.Secure.USB_MASS_STORAGE_ENABLED,
-                    Settings.Secure.USE_GOOGLE_MAIL,
-                    Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
-                    Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
-                    Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,
-                    Settings.Secure.WIFI_ON,
-                    Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,
-                    Settings.Secure.WIFI_WATCHDOG_AP_COUNT,
-                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,
-                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,
-                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,
-                    Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,
-                    Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,
-                    Settings.Secure.WIFI_WATCHDOG_ON,
-                    Settings.Secure.WIFI_WATCHDOG_PING_COUNT,
-                    Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,
-                    Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS,
-                };
-            moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
-            upgradeVersion = 28;
-        }
-
-        if (upgradeVersion == 28 || upgradeVersion == 29) {
-            // Note: The upgrade to 28 was flawed since it didn't delete the old
-            // setting first before inserting. Combining 28 and 29 with the
-            // fixed version.
-
-            // This upgrade adds the STREAM_NOTIFICATION type to the list of
-            // types affected by ringer modes (silent, vibrate, etc.)
-            db.beginTransaction();
-            try {
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
-                int newValue = (1 << AudioManager.STREAM_RING)
-                        | (1 << AudioManager.STREAM_NOTIFICATION)
-                        | (1 << AudioManager.STREAM_SYSTEM);
-                db.execSQL("INSERT INTO system ('name', 'value') values ('"
-                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
-                        + String.valueOf(newValue) + "')");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-
-            upgradeVersion = 30;
-        }
-
-        if (upgradeVersion == 30) {
-            /*
-             * Upgrade 31 clears the title for all quick launch shortcuts so the
-             * activities' titles will be resolved at display time. Also, the
-             * folder is changed to '@quicklaunch'.
-             */
-            db.beginTransaction();
-            try {
-                db.execSQL("UPDATE bookmarks SET folder = '@quicklaunch'");
-                db.execSQL("UPDATE bookmarks SET title = ''");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 31;
-        }
-
-        if (upgradeVersion == 31) {
-            /*
-             * Animations are now managed in preferences, and may be
-             * enabled or disabled based on product resources.
-             */
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
-                stmt = db.compileStatement("INSERT INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadDefaultAnimationSettings(stmt);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 32;
-        }
-
-        if (upgradeVersion == 32) {
-            // The Wi-Fi watchdog SSID list is now seeded with the value of
-            // the property ro.com.android.wifi-watchlist
-            String wifiWatchList = SystemProperties.get("ro.com.android.wifi-watchlist");
-            if (!TextUtils.isEmpty(wifiWatchList)) {
-                db.beginTransaction();
-                try {
-                    db.execSQL("INSERT OR IGNORE INTO secure(name,value) values('" +
-                            Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + "','" +
-                            wifiWatchList + "');");
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                }
-            }
-            upgradeVersion = 33;
-        }
-
-        if (upgradeVersion == 33) {
-            // Set the default zoom controls to: tap-twice to bring up +/-
-            db.beginTransaction();
-            try {
-                db.execSQL("INSERT INTO system(name,value) values('zoom','2');");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 34;
-        }
-
-        if (upgradeVersion == 34) {
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                loadSecure35Settings(stmt);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 35;
-        }
-            // due to a botched merge from donut to eclair, the initialization of ASSISTED_GPS_ENABLED
-            // was accidentally done out of order here.
-            // to fix this, ASSISTED_GPS_ENABLED is now initialized while upgrading from 38 to 39,
-            // and we intentionally do nothing from 35 to 36 now.
-        if (upgradeVersion == 35) {
-            upgradeVersion = 36;
-        }
-
-        if (upgradeVersion == 36) {
-           // This upgrade adds the STREAM_SYSTEM_ENFORCED type to the list of
-            // types affected by ringer modes (silent, vibrate, etc.)
-            db.beginTransaction();
-            try {
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
-                int newValue = (1 << AudioManager.STREAM_RING)
-                        | (1 << AudioManager.STREAM_NOTIFICATION)
-                        | (1 << AudioManager.STREAM_SYSTEM)
-                        | (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
-                db.execSQL("INSERT INTO system ('name', 'value') values ('"
-                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
-                        + String.valueOf(newValue) + "')");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 37;
-        }
-
-        if (upgradeVersion == 37) {
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadStringSetting(stmt, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
-                        R.string.airplane_mode_toggleable_radios);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 38;
-        }
-
-        if (upgradeVersion == 38) {
-            db.beginTransaction();
-            try {
-                String value =
-                        mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? "1" : "0";
-                db.execSQL("INSERT OR IGNORE INTO secure(name,value) values('" +
-                        Settings.Global.ASSISTED_GPS_ENABLED + "','" + value + "');");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-
-            upgradeVersion = 39;
-        }
-
-        if (upgradeVersion == 39) {
-            upgradeAutoBrightness(db);
-            upgradeVersion = 40;
-        }
-
-        if (upgradeVersion == 40) {
-            /*
-             * All animations are now turned on by default!
-             */
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
-                stmt = db.compileStatement("INSERT INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadDefaultAnimationSettings(stmt);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 41;
-        }
-
-        if (upgradeVersion == 41) {
-            /*
-             * Initialize newly public haptic feedback setting
-             */
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.HAPTIC_FEEDBACK_ENABLED + "'");
-                stmt = db.compileStatement("INSERT INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadDefaultHapticSettings(stmt);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 42;
-        }
-
-        if (upgradeVersion == 42) {
-            /*
-             * Initialize new notification pulse setting
-             */
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadBooleanSetting(stmt, Settings.System.NOTIFICATION_LIGHT_PULSE,
-                        R.bool.def_notification_pulse);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 43;
-        }
-
-        if (upgradeVersion == 43) {
-            /*
-             * This upgrade stores bluetooth volume separately from voice volume
-             */
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadSetting(stmt, Settings.System.VOLUME_BLUETOOTH_SCO,
-                        AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 44;
-        }
-
-        if (upgradeVersion == 44) {
-            /*
-             * Gservices was moved into vendor/google.
-             */
-            db.execSQL("DROP TABLE IF EXISTS gservices");
-            db.execSQL("DROP INDEX IF EXISTS gservicesIndex1");
-            upgradeVersion = 45;
-        }
-
-        if (upgradeVersion == 45) {
-             /*
-              * New settings for MountService
-              */
-            db.beginTransaction();
-            try {
-                db.execSQL("INSERT INTO secure(name,value) values('" +
-                        Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + "','1');");
-                db.execSQL("INSERT INTO secure(name,value) values('" +
-                        Settings.Secure.MOUNT_UMS_AUTOSTART + "','0');");
-                db.execSQL("INSERT INTO secure(name,value) values('" +
-                        Settings.Secure.MOUNT_UMS_PROMPT + "','1');");
-                db.execSQL("INSERT INTO secure(name,value) values('" +
-                        Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + "','1');");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 46;
-        }
-
-        if (upgradeVersion == 46) {
-            /*
-             * The password mode constants have changed; reset back to no
-             * password.
-             */
-            db.beginTransaction();
-            try {
-                db.execSQL("DELETE FROM system WHERE name='lockscreen.password_type';");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-           upgradeVersion = 47;
-       }
-
-
-        if (upgradeVersion == 47) {
-            /*
-             * The password mode constants have changed again; reset back to no
-             * password.
-             */
-            db.beginTransaction();
-            try {
-                db.execSQL("DELETE FROM system WHERE name='lockscreen.password_type';");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-           upgradeVersion = 48;
-       }
-
-       if (upgradeVersion == 48) {
-           /*
-            * Default recognition service no longer initialized here,
-            * moved to RecognitionManagerService.
-            */
-           upgradeVersion = 49;
-       }
-
-       if (upgradeVersion == 49) {
-           /*
-            * New settings for new user interface noises.
-            */
-           db.beginTransaction();
-           SQLiteStatement stmt = null;
-           try {
-                stmt = db.compileStatement("INSERT INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadUISoundEffectsSettings(stmt);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-
-           upgradeVersion = 50;
-       }
-
-       if (upgradeVersion == 50) {
-           /*
-            * Install location no longer initiated here.
-            */
-           upgradeVersion = 51;
-       }
-
-       if (upgradeVersion == 51) {
-           /* Move the lockscreen related settings to Secure, including some private ones. */
-           String[] settingsToMove = {
-                   Secure.LOCK_PATTERN_ENABLED,
-                   Secure.LOCK_PATTERN_VISIBLE,
-                   Secure.LOCK_SHOW_ERROR_PATH,
-                   Secure.LOCK_DOTS_VISIBLE,
-                   Secure.LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED,
-                   "lockscreen.password_type",
-                   "lockscreen.lockoutattemptdeadline",
-                   "lockscreen.patterneverchosen",
-                   "lock_pattern_autolock",
-                   "lockscreen.lockedoutpermanently",
-                   "lockscreen.password_salt"
-           };
-           moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
-           upgradeVersion = 52;
-       }
-
-        if (upgradeVersion == 52) {
-            // new vibration/silent mode settings
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadBooleanSetting(stmt, Settings.System.VIBRATE_IN_SILENT,
-                        R.bool.def_vibrate_in_silent);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-
-            upgradeVersion = 53;
-        }
-
-        if (upgradeVersion == 53) {
-            /*
-             * New settings for set install location UI no longer initiated here.
-             */
-            upgradeVersion = 54;
-        }
-
-        if (upgradeVersion == 54) {
-            /*
-             * Update the screen timeout value if set to never
-             */
-            db.beginTransaction();
-            try {
-                upgradeScreenTimeoutFromNever(db);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-
-            upgradeVersion = 55;
-        }
-
-        if (upgradeVersion == 55) {
-            /* Move the install location settings. */
-            String[] settingsToMove = {
-                    Global.SET_INSTALL_LOCATION,
-                    Global.DEFAULT_INSTALL_LOCATION
-            };
-            moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadSetting(stmt, Global.SET_INSTALL_LOCATION, 0);
-                loadSetting(stmt, Global.DEFAULT_INSTALL_LOCATION,
-                        PackageHelper.APP_INSTALL_AUTO);
-                db.setTransactionSuccessful();
-             } finally {
-                 db.endTransaction();
-                 if (stmt != null) stmt.close();
-             }
-            upgradeVersion = 56;
-        }
-
-        if (upgradeVersion == 56) {
-            /*
-             * Add Bluetooth to list of toggleable radios in airplane mode
-             */
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS + "'");
-                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadStringSetting(stmt, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
-                        R.string.airplane_mode_toggleable_radios);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 57;
-        }
-
-        /************* The following are Honeycomb changes ************/
-
-        if (upgradeVersion == 57) {
-            /*
-             * New settings to:
-             *  1. Enable injection of accessibility scripts in WebViews.
-             *  2. Define the key bindings for traversing web content in WebViews.
-             */
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SCRIPT_INJECTION,
-                        R.bool.def_accessibility_script_injection);
-                stmt.close();
-                stmt = db.compileStatement("INSERT INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_WEB_CONTENT_KEY_BINDINGS,
-                        R.string.def_accessibility_web_content_key_bindings);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 58;
-        }
-
-        if (upgradeVersion == 58) {
-            /* Add default for new Auto Time Zone */
-            int autoTimeValue = getIntValueFromSystem(db, Settings.System.AUTO_TIME, 0);
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO system(name,value)" + " VALUES(?,?);");
-                loadSetting(stmt, Settings.System.AUTO_TIME_ZONE,
-                        autoTimeValue); // Sync timezone to NITZ if auto_time was enabled
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 59;
-        }
-
-        if (upgradeVersion == 59) {
-            // Persistence for the rotation lock feature.
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadBooleanSetting(stmt, Settings.System.USER_ROTATION,
-                        R.integer.def_user_rotation); // should be zero degrees
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 60;
-        }
-
-        if (upgradeVersion == 60) {
-            // Don't do this for upgrades from Gingerbread
-            // Were only required for intra-Honeycomb upgrades for testing
-            // upgradeScreenTimeout(db);
-            upgradeVersion = 61;
-        }
-
-        if (upgradeVersion == 61) {
-            // Don't do this for upgrades from Gingerbread
-            // Were only required for intra-Honeycomb upgrades for testing
-            // upgradeScreenTimeout(db);
-            upgradeVersion = 62;
-        }
-
-        // Change the default for screen auto-brightness mode
-        if (upgradeVersion == 62) {
-            // Don't do this for upgrades from Gingerbread
-            // Were only required for intra-Honeycomb upgrades for testing
-            // upgradeAutoBrightness(db);
-            upgradeVersion = 63;
-        }
-
-        if (upgradeVersion == 63) {
-            // This upgrade adds the STREAM_MUSIC type to the list of
-             // types affected by ringer modes (silent, vibrate, etc.)
-             db.beginTransaction();
-             try {
-                 db.execSQL("DELETE FROM system WHERE name='"
-                         + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
-                 int newValue = (1 << AudioManager.STREAM_RING)
-                         | (1 << AudioManager.STREAM_NOTIFICATION)
-                         | (1 << AudioManager.STREAM_SYSTEM)
-                         | (1 << AudioManager.STREAM_SYSTEM_ENFORCED)
-                         | (1 << AudioManager.STREAM_MUSIC);
-                 db.execSQL("INSERT INTO system ('name', 'value') values ('"
-                         + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
-                         + String.valueOf(newValue) + "')");
-                 db.setTransactionSuccessful();
-             } finally {
-                 db.endTransaction();
-             }
-             upgradeVersion = 64;
-         }
-
-        if (upgradeVersion == 64) {
-            // New setting to configure the long press timeout.
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                loadIntegerSetting(stmt, Settings.Secure.LONG_PRESS_TIMEOUT,
-                        R.integer.def_long_press_timeout_millis);
-                stmt.close();
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 65;
-        }
-
-        /************* The following are Ice Cream Sandwich changes ************/
-
-        if (upgradeVersion == 65) {
-            /*
-             * Animations are removed from Settings. Turned on by default
-             */
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
-                stmt = db.compileStatement("INSERT INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadDefaultAnimationSettings(stmt);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 66;
-        }
-
-        if (upgradeVersion == 66) {
-            // This upgrade makes sure that MODE_RINGER_STREAMS_AFFECTED is set
-            // according to device voice capability
-            db.beginTransaction();
-            try {
-                int ringerModeAffectedStreams = (1 << AudioManager.STREAM_RING) |
-                                                (1 << AudioManager.STREAM_NOTIFICATION) |
-                                                (1 << AudioManager.STREAM_SYSTEM) |
-                                                (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
-                if (!mContext.getResources().getBoolean(
-                        com.android.internal.R.bool.config_voice_capable)) {
-                    ringerModeAffectedStreams |= (1 << AudioManager.STREAM_MUSIC);
-                }
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
-                db.execSQL("INSERT INTO system ('name', 'value') values ('"
-                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
-                        + String.valueOf(ringerModeAffectedStreams) + "')");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 67;
-        }
-
-        if (upgradeVersion == 67) {
-            // New setting to enable touch exploration.
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                loadBooleanSetting(stmt, Settings.Secure.TOUCH_EXPLORATION_ENABLED,
-                        R.bool.def_touch_exploration_enabled);
-                stmt.close();
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 68;
-        }
-
-        if (upgradeVersion == 68) {
-            // Enable all system sounds by default
-            db.beginTransaction();
-            try {
-                db.execSQL("DELETE FROM system WHERE name='"
-                        + Settings.System.NOTIFICATIONS_USE_RING_VOLUME + "'");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 69;
-        }
-
-        if (upgradeVersion == 69) {
-            // Add RADIO_NFC to AIRPLANE_MODE_RADIO and AIRPLANE_MODE_TOGGLEABLE_RADIOS
-            String airplaneRadios = mContext.getResources().getString(
-                    R.string.def_airplane_mode_radios);
-            String toggleableRadios = mContext.getResources().getString(
-                    R.string.airplane_mode_toggleable_radios);
-            db.beginTransaction();
-            try {
-                db.execSQL("UPDATE system SET value='" + airplaneRadios + "' " +
-                        "WHERE name='" + Settings.System.AIRPLANE_MODE_RADIOS + "'");
-                db.execSQL("UPDATE system SET value='" + toggleableRadios + "' " +
-                        "WHERE name='" + Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS + "'");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-            upgradeVersion = 70;
-        }
-
-        if (upgradeVersion == 70) {
-            // Update all built-in bookmarks.  Some of the package names have changed.
-            loadBookmarks(db);
-            upgradeVersion = 71;
-        }
-
-        if (upgradeVersion == 71) {
-             // New setting to specify whether to speak passwords in accessibility mode.
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD,
-                        R.bool.def_accessibility_speak_password);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 72;
-        }
-
-        if (upgradeVersion == 72) {
-            // update vibration settings
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
-                        + " VALUES(?,?);");
-                loadBooleanSetting(stmt, Settings.System.VIBRATE_IN_SILENT,
-                        R.bool.def_vibrate_in_silent);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 73;
-        }
-
-        if (upgradeVersion == 73) {
-            upgradeVibrateSettingFromNone(db);
-            upgradeVersion = 74;
-        }
-
-        if (upgradeVersion == 74) {
-            // URL from which WebView loads a JavaScript based screen-reader.
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
-                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
-                        R.string.def_accessibility_screen_reader_url);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 75;
-        }
-        if (upgradeVersion == 75) {
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            Cursor c = null;
-            try {
-                c = db.query(TABLE_SECURE, new String[] {"_id", "value"},
-                        "name='lockscreen.disabled'",
-                        null, null, null, null);
-                // only set default if it has not yet been set
-                if (c == null || c.getCount() == 0) {
-                    stmt = db.compileStatement("INSERT INTO system(name,value)"
-                            + " VALUES(?,?);");
-                    loadBooleanSetting(stmt, Settings.System.LOCKSCREEN_DISABLED,
-                            R.bool.def_lockscreen_disabled);
-                }
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (c != null) c.close();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 76;
-        }
-
-        /************* The following are Jelly Bean changes ************/
-
-        if (upgradeVersion == 76) {
-            // Removed VIBRATE_IN_SILENT setting
-            db.beginTransaction();
-            try {
-                db.execSQL("DELETE FROM system WHERE name='"
-                                + Settings.System.VIBRATE_IN_SILENT + "'");
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-
-            upgradeVersion = 77;
-        }
-
-        if (upgradeVersion == 77) {
-            // Introduce "vibrate when ringing" setting
-            loadVibrateWhenRingingSetting(db);
-
-            upgradeVersion = 78;
-        }
-
-        if (upgradeVersion == 78) {
-            // The JavaScript based screen-reader URL changes in JellyBean.
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
-                        R.string.def_accessibility_screen_reader_url);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 79;
-        }
-
-        if (upgradeVersion == 79) {
-            // Before touch exploration was a global setting controlled by the user
-            // via the UI. However, if the enabled accessibility services do not
-            // handle touch exploration mode, enabling it makes no sense. Therefore,
-            // now the services request touch exploration mode and the user is
-            // presented with a dialog to allow that and if she does we store that
-            // in the database. As a result of this change a user that has enabled
-            // accessibility, touch exploration, and some accessibility services
-            // may lose touch exploration state, thus rendering the device useless
-            // unless sighted help is provided, since the enabled service(s) are
-            // not in the list of services to which the user granted a permission
-            // to put the device in touch explore mode. Here we are allowing all
-            // enabled accessibility services to toggle touch exploration provided
-            // accessibility and touch exploration are enabled and no services can
-            // toggle touch exploration. Note that the user has already manually
-            // enabled the services and touch exploration which means the she has
-            // given consent to have these services work in touch exploration mode.
-            final boolean accessibilityEnabled = getIntValueFromTable(db, TABLE_SECURE,
-                    Settings.Secure.ACCESSIBILITY_ENABLED, 0) == 1;
-            final boolean touchExplorationEnabled = getIntValueFromTable(db, TABLE_SECURE,
-                    Settings.Secure.TOUCH_EXPLORATION_ENABLED, 0) == 1;
-            if (accessibilityEnabled && touchExplorationEnabled) {
-                String enabledServices = getStringValueFromTable(db, TABLE_SECURE,
-                        Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, "");
-                String touchExplorationGrantedServices = getStringValueFromTable(db, TABLE_SECURE,
-                        Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES, "");
-                if (TextUtils.isEmpty(touchExplorationGrantedServices)
-                        && !TextUtils.isEmpty(enabledServices)) {
-                    SQLiteStatement stmt = null;
-                    try {
-                        db.beginTransaction();
-                        stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
-                                + " VALUES(?,?);");
-                        loadSetting(stmt,
-                                Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
-                                enabledServices);
-                        db.setTransactionSuccessful();
-                    } finally {
-                        db.endTransaction();
-                        if (stmt != null) stmt.close();
-                    }
-                }
-            }
-            upgradeVersion = 80;
-        }
-
-        // vvv Jelly Bean MR1 changes begin here vvv
-
-        if (upgradeVersion == 80) {
-            // update screensaver settings
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ENABLED,
-                        com.android.internal.R.bool.config_dreamsEnabledByDefault);
-                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK,
-                        com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
-                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP,
-                        com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
-                loadStringSetting(stmt, Settings.Secure.SCREENSAVER_COMPONENTS,
-                        com.android.internal.R.string.config_dreamsDefaultComponent);
-                loadStringSetting(stmt, Settings.Secure.SCREENSAVER_DEFAULT_COMPONENT,
-                        com.android.internal.R.string.config_dreamsDefaultComponent);
-
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 81;
-        }
-
-        if (upgradeVersion == 81) {
-            // Add package verification setting
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE,
-                        R.bool.def_package_verifier_enable);
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 82;
-        }
-
-        if (upgradeVersion == 82) {
-            // Move to per-user settings dbs
-            if (mUserHandle == UserHandle.USER_OWNER) {
-
-                db.beginTransaction();
-                SQLiteStatement stmt = null;
-                try {
-                    // Migrate now-global settings. Note that this happens before
-                    // new users can be created.
-                    createGlobalTable(db);
-                    String[] settingsToMove = hashsetToStringArray(SettingsProvider.sSystemGlobalKeys);
-                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, false);
-                    settingsToMove = hashsetToStringArray(SettingsProvider.sSecureGlobalKeys);
-                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, false);
-
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                    if (stmt != null) stmt.close();
-                }
-            }
-            upgradeVersion = 83;
-        }
-
-        if (upgradeVersion == 83) {
-            // 1. Setting whether screen magnification is enabled.
-            // 2. Setting for screen magnification scale.
-            // 3. Setting for screen magnification auto update.
-            db.beginTransaction();
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
-                loadBooleanSetting(stmt,
-                        Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
-                        R.bool.def_accessibility_display_magnification_enabled);
-                stmt.close();
-                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
-                loadFractionSetting(stmt, Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
-                        R.fraction.def_accessibility_display_magnification_scale, 1);
-                stmt.close();
-                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
-                loadBooleanSetting(stmt,
-                        Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE,
-                        R.bool.def_accessibility_display_magnification_auto_update);
-
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 84;
-        }
-
-        if (upgradeVersion == 84) {
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                SQLiteStatement stmt = null;
-                try {
-                    // Patch up the slightly-wrong key migration from 82 -> 83 for those
-                    // devices that missed it, ignoring if the move is redundant
-                    String[] settingsToMove = {
-                            Settings.Secure.ADB_ENABLED,
-                            Settings.Secure.BLUETOOTH_ON,
-                            Settings.Secure.DATA_ROAMING,
-                            Settings.Secure.DEVICE_PROVISIONED,
-                            Settings.Secure.INSTALL_NON_MARKET_APPS,
-                            Settings.Secure.USB_MASS_STORAGE_ENABLED
-                    };
-                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                    if (stmt != null) stmt.close();
-                }
-            }
-            upgradeVersion = 85;
-        }
-
-        if (upgradeVersion == 85) {
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                try {
-                    // Fix up the migration, ignoring already-migrated elements, to snap up to
-                    // date with new changes to the set of global versus system/secure settings
-                    String[] settingsToMove = { Settings.System.STAY_ON_WHILE_PLUGGED_IN };
-                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);
-
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                }
-            }
-            upgradeVersion = 86;
-        }
-
-        if (upgradeVersion == 86) {
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                try {
-                    String[] settingsToMove = {
-                            Settings.Global.PACKAGE_VERIFIER_ENABLE,
-                            Settings.Global.PACKAGE_VERIFIER_TIMEOUT,
-                            Settings.Global.PACKAGE_VERIFIER_DEFAULT_RESPONSE
-                    };
-                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
-
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                }
-            }
-            upgradeVersion = 87;
-        }
-
-        if (upgradeVersion == 87) {
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                try {
-                    String[] settingsToMove = {
-                            Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS,
-                            Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS,
-                            Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS
-                    };
-                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
-
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                }
-            }
-            upgradeVersion = 88;
-        }
-
-        if (upgradeVersion == 88) {
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                try {
-                    String[] settingsToMove = {
-                            Settings.Global.BATTERY_DISCHARGE_DURATION_THRESHOLD,
-                            Settings.Global.BATTERY_DISCHARGE_THRESHOLD,
-                            Settings.Global.SEND_ACTION_APP_ERROR,
-                            Settings.Global.DROPBOX_AGE_SECONDS,
-                            Settings.Global.DROPBOX_MAX_FILES,
-                            Settings.Global.DROPBOX_QUOTA_KB,
-                            Settings.Global.DROPBOX_QUOTA_PERCENT,
-                            Settings.Global.DROPBOX_RESERVE_PERCENT,
-                            Settings.Global.DROPBOX_TAG_PREFIX,
-                            Settings.Global.ERROR_LOGCAT_PREFIX,
-                            Settings.Global.SYS_FREE_STORAGE_LOG_INTERVAL,
-                            Settings.Global.DISK_FREE_CHANGE_REPORTING_THRESHOLD,
-                            Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE,
-                            Settings.Global.SYS_STORAGE_THRESHOLD_MAX_BYTES,
-                            Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES,
-                            Settings.Global.SYNC_MAX_RETRY_DELAY_IN_SECONDS,
-                            Settings.Global.CONNECTIVITY_CHANGE_DELAY,
-                            Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED,
-                            Settings.Global.CAPTIVE_PORTAL_SERVER,
-                            Settings.Global.NSD_ON,
-                            Settings.Global.SET_INSTALL_LOCATION,
-                            Settings.Global.DEFAULT_INSTALL_LOCATION,
-                            Settings.Global.INET_CONDITION_DEBOUNCE_UP_DELAY,
-                            Settings.Global.INET_CONDITION_DEBOUNCE_DOWN_DELAY,
-                            Settings.Global.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT,
-                            Settings.Global.HTTP_PROXY,
-                            Settings.Global.GLOBAL_HTTP_PROXY_HOST,
-                            Settings.Global.GLOBAL_HTTP_PROXY_PORT,
-                            Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST,
-                            Settings.Global.SET_GLOBAL_HTTP_PROXY,
-                            Settings.Global.DEFAULT_DNS_SERVER,
-                    };
-                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                }
-            }
-            upgradeVersion = 89;
-        }
-
-        if (upgradeVersion == 89) {
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                try {
-                    String[] prefixesToMove = {
-                            Settings.Global.BLUETOOTH_HEADSET_PRIORITY_PREFIX,
-                            Settings.Global.BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX,
-                            Settings.Global.BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX,
-                    };
-
-                    movePrefixedSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, prefixesToMove);
-
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                }
-            }
-            upgradeVersion = 90;
-        }
-
-        if (upgradeVersion == 90) {
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                try {
-                    String[] systemToGlobal = {
-                            Settings.Global.WINDOW_ANIMATION_SCALE,
-                            Settings.Global.TRANSITION_ANIMATION_SCALE,
-                            Settings.Global.ANIMATOR_DURATION_SCALE,
-                            Settings.Global.FANCY_IME_ANIMATIONS,
-                            Settings.Global.COMPATIBILITY_MODE,
-                            Settings.Global.EMERGENCY_TONE,
-                            Settings.Global.CALL_AUTO_RETRY,
-                            Settings.Global.DEBUG_APP,
-                            Settings.Global.WAIT_FOR_DEBUGGER,
-                            Settings.Global.SHOW_PROCESSES,
-                            Settings.Global.ALWAYS_FINISH_ACTIVITIES,
-                    };
-                    String[] secureToGlobal = {
-                            Settings.Global.PREFERRED_NETWORK_MODE,
-                            Settings.Global.PREFERRED_CDMA_SUBSCRIPTION,
-                    };
-
-                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, systemToGlobal, true);
-                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, secureToGlobal, true);
-
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                }
-            }
-            upgradeVersion = 91;
-        }
-
-        if (upgradeVersion == 91) {
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                try {
-                    // Move ringer mode from system to global settings
-                    String[] settingsToMove = { Settings.Global.MODE_RINGER };
-                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);
-
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                }
-            }
-            upgradeVersion = 92;
-        }
-
-        if (upgradeVersion == 92) {
-            SQLiteStatement stmt = null;
-            try {
-                stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
-                        + " VALUES(?,?);");
-                if (mUserHandle == UserHandle.USER_OWNER) {
-                    // consider existing primary users to have made it through user setup
-                    // if the globally-scoped device-provisioned bit is set
-                    // (indicating they already made it through setup as primary)
-                    int deviceProvisioned = getIntValueFromTable(db, TABLE_GLOBAL,
-                            Settings.Global.DEVICE_PROVISIONED, 0);
-                    loadSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
-                            deviceProvisioned);
-                } else {
-                    // otherwise use the default
-                    loadBooleanSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
-                            R.bool.def_user_setup_complete);
-                }
-            } finally {
-                if (stmt != null) stmt.close();
-            }
-            upgradeVersion = 93;
-        }
-
-        if (upgradeVersion == 93) {
-            // Redo this step, since somehow it didn't work the first time for some users
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                SQLiteStatement stmt = null;
-                try {
-                    // Migrate now-global settings
-                    String[] settingsToMove = hashsetToStringArray(SettingsProvider.sSystemGlobalKeys);
-                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);
-                    settingsToMove = hashsetToStringArray(SettingsProvider.sSecureGlobalKeys);
-                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
-
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                    if (stmt != null) stmt.close();
-                }
-            }
-            upgradeVersion = 94;
-        }
-
-        if (upgradeVersion == 94) {
-            // Add wireless charging started sound setting
-            if (mUserHandle == UserHandle.USER_OWNER) {
-                db.beginTransaction();
-                SQLiteStatement stmt = null;
-                try {
-                    stmt = db.compileStatement("INSERT OR REPLACE INTO global(name,value)"
-                            + " VALUES(?,?);");
-                    loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND,
-                            R.string.def_wireless_charging_started_sound);
-                    db.setTransactionSuccessful();
-                } finally {
-                    db.endTransaction();
-                    if (stmt != null) stmt.close();
-                }
-            }
-            upgradeVersion = 95;
-        }
-
-        // *** Remember to update DATABASE_VERSION above!
-
-        if (upgradeVersion != currentVersion) {
-            Log.w(TAG, "Got stuck trying to upgrade from version " + upgradeVersion
-                    + ", must wipe the settings provider");
-            db.execSQL("DROP TABLE IF EXISTS global");
-            db.execSQL("DROP TABLE IF EXISTS globalIndex1");
-            db.execSQL("DROP TABLE IF EXISTS system");
-            db.execSQL("DROP INDEX IF EXISTS systemIndex1");
-            db.execSQL("DROP TABLE IF EXISTS secure");
-            db.execSQL("DROP INDEX IF EXISTS secureIndex1");
-            db.execSQL("DROP TABLE IF EXISTS gservices");
-            db.execSQL("DROP INDEX IF EXISTS gservicesIndex1");
-            db.execSQL("DROP TABLE IF EXISTS bluetooth_devices");
-            db.execSQL("DROP TABLE IF EXISTS bookmarks");
-            db.execSQL("DROP INDEX IF EXISTS bookmarksIndex1");
-            db.execSQL("DROP INDEX IF EXISTS bookmarksIndex2");
-            db.execSQL("DROP TABLE IF EXISTS favorites");
-            onCreate(db);
-
-            // Added for diagnosing settings.db wipes after the fact
-            String wipeReason = oldVersion + "/" + upgradeVersion + "/" + currentVersion;
-            db.execSQL("INSERT INTO secure(name,value) values('" +
-                    "wiped_db_reason" + "','" + wipeReason + "');");
-        }
-    }
-
-    private String[] hashsetToStringArray(HashSet<String> set) {
-        String[] array = new String[set.size()];
-        return set.toArray(array);
-    }
-
-    private void moveSettingsToNewTable(SQLiteDatabase db,
-            String sourceTable, String destTable,
-            String[] settingsToMove, boolean doIgnore) {
-        // Copy settings values from the source table to the dest, and remove from the source
-        SQLiteStatement insertStmt = null;
-        SQLiteStatement deleteStmt = null;
-
-        db.beginTransaction();
-        try {
-            insertStmt = db.compileStatement("INSERT "
-                    + (doIgnore ? " OR IGNORE " : "")
-                    + " INTO " + destTable + " (name,value) SELECT name,value FROM "
-                    + sourceTable + " WHERE name=?");
-            deleteStmt = db.compileStatement("DELETE FROM " + sourceTable + " WHERE name=?");
-
-            for (String setting : settingsToMove) {
-                insertStmt.bindString(1, setting);
-                insertStmt.execute();
-
-                deleteStmt.bindString(1, setting);
-                deleteStmt.execute();
-            }
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-            if (insertStmt != null) {
-                insertStmt.close();
-            }
-            if (deleteStmt != null) {
-                deleteStmt.close();
-            }
-        }
-    }
-
-    /**
-     * Move any settings with the given prefixes from the source table to the
-     * destination table.
-     */
-    private void movePrefixedSettingsToNewTable(
-            SQLiteDatabase db, String sourceTable, String destTable, String[] prefixesToMove) {
-        SQLiteStatement insertStmt = null;
-        SQLiteStatement deleteStmt = null;
-
-        db.beginTransaction();
-        try {
-            insertStmt = db.compileStatement("INSERT INTO " + destTable
-                    + " (name,value) SELECT name,value FROM " + sourceTable
-                    + " WHERE substr(name,0,?)=?");
-            deleteStmt = db.compileStatement(
-                    "DELETE FROM " + sourceTable + " WHERE substr(name,0,?)=?");
-
-            for (String prefix : prefixesToMove) {
-                insertStmt.bindLong(1, prefix.length() + 1);
-                insertStmt.bindString(2, prefix);
-                insertStmt.execute();
-
-                deleteStmt.bindLong(1, prefix.length() + 1);
-                deleteStmt.bindString(2, prefix);
-                deleteStmt.execute();
-            }
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-            if (insertStmt != null) {
-                insertStmt.close();
-            }
-            if (deleteStmt != null) {
-                deleteStmt.close();
-            }
-        }
-    }
-
-    private void upgradeLockPatternLocation(SQLiteDatabase db) {
-        Cursor c = db.query(TABLE_SYSTEM, new String[] {"_id", "value"}, "name='lock_pattern'",
-                null, null, null, null);
-        if (c.getCount() > 0) {
-            c.moveToFirst();
-            String lockPattern = c.getString(1);
-            if (!TextUtils.isEmpty(lockPattern)) {
-                // Convert lock pattern
-                try {
-                    LockPatternUtils lpu = new LockPatternUtils(mContext);
-                    List<LockPatternView.Cell> cellPattern =
-                            lpu.stringToPattern(lockPattern);
-                    lpu.saveLockPattern(cellPattern);
-                } catch (IllegalArgumentException e) {
-                    // Don't want corrupted lock pattern to hang the reboot process
-                }
-            }
-            c.close();
-            db.delete(TABLE_SYSTEM, "name='lock_pattern'", null);
-        } else {
-            c.close();
-        }
-    }
-
-    private void upgradeScreenTimeoutFromNever(SQLiteDatabase db) {
-        // See if the timeout is -1 (for "Never").
-        Cursor c = db.query(TABLE_SYSTEM, new String[] { "_id", "value" }, "name=? AND value=?",
-                new String[] { Settings.System.SCREEN_OFF_TIMEOUT, "-1" },
-                null, null, null);
-
-        SQLiteStatement stmt = null;
-        if (c.getCount() > 0) {
-            c.close();
-            try {
-                stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
-                        + " VALUES(?,?);");
-
-                // Set the timeout to 30 minutes in milliseconds
-                loadSetting(stmt, Settings.System.SCREEN_OFF_TIMEOUT,
-                        Integer.toString(30 * 60 * 1000));
-            } finally {
-                if (stmt != null) stmt.close();
-            }
-        } else {
-            c.close();
-        }
-    }
-
-    private void upgradeVibrateSettingFromNone(SQLiteDatabase db) {
-        int vibrateSetting = getIntValueFromSystem(db, Settings.System.VIBRATE_ON, 0);
-        // If the ringer vibrate value is invalid, set it to the default
-        if ((vibrateSetting & 3) == AudioManager.VIBRATE_SETTING_OFF) {
-            vibrateSetting = AudioService.getValueForVibrateSetting(0,
-                    AudioManager.VIBRATE_TYPE_RINGER, AudioManager.VIBRATE_SETTING_ONLY_SILENT);
-        }
-        // Apply the same setting to the notification vibrate value
-        vibrateSetting = AudioService.getValueForVibrateSetting(vibrateSetting,
-                AudioManager.VIBRATE_TYPE_NOTIFICATION, vibrateSetting);
-
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
-                    + " VALUES(?,?);");
-            loadSetting(stmt, Settings.System.VIBRATE_ON, vibrateSetting);
-        } finally {
-            if (stmt != null)
-                stmt.close();
-        }
-    }
-
-    private void upgradeScreenTimeout(SQLiteDatabase db) {
-        // Change screen timeout to current default
-        db.beginTransaction();
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
-                    + " VALUES(?,?);");
-            loadIntegerSetting(stmt, Settings.System.SCREEN_OFF_TIMEOUT,
-                    R.integer.def_screen_off_timeout);
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-            if (stmt != null)
-                stmt.close();
-        }
-    }
-
-    private void upgradeAutoBrightness(SQLiteDatabase db) {
-        db.beginTransaction();
-        try {
-            String value =
-                    mContext.getResources().getBoolean(
-                    R.bool.def_screen_brightness_automatic_mode) ? "1" : "0";
-            db.execSQL("INSERT OR REPLACE INTO system(name,value) values('" +
-                    Settings.System.SCREEN_BRIGHTNESS_MODE + "','" + value + "');");
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-        }
-    }
-
-    /**
-     * Loads the default set of bookmarked shortcuts from an xml file.
-     *
-     * @param db The database to write the values into
-     */
-    private void loadBookmarks(SQLiteDatabase db) {
-        ContentValues values = new ContentValues();
-
-        PackageManager packageManager = mContext.getPackageManager();
-        try {
-            XmlResourceParser parser = mContext.getResources().getXml(R.xml.bookmarks);
-            XmlUtils.beginDocument(parser, "bookmarks");
-
-            final int depth = parser.getDepth();
-            int type;
-
-            while (((type = parser.next()) != XmlPullParser.END_TAG ||
-                    parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
-
-                if (type != XmlPullParser.START_TAG) {
-                    continue;
-                }
-
-                String name = parser.getName();
-                if (!"bookmark".equals(name)) {
-                    break;
-                }
-
-                String pkg = parser.getAttributeValue(null, "package");
-                String cls = parser.getAttributeValue(null, "class");
-                String shortcutStr = parser.getAttributeValue(null, "shortcut");
-                String category = parser.getAttributeValue(null, "category");
-
-                int shortcutValue = shortcutStr.charAt(0);
-                if (TextUtils.isEmpty(shortcutStr)) {
-                    Log.w(TAG, "Unable to get shortcut for: " + pkg + "/" + cls);
-                    continue;
-                }
-
-                final Intent intent;
-                final String title;
-                if (pkg != null && cls != null) {
-                    ActivityInfo info = null;
-                    ComponentName cn = new ComponentName(pkg, cls);
-                    try {
-                        info = packageManager.getActivityInfo(cn, 0);
-                    } catch (PackageManager.NameNotFoundException e) {
-                        String[] packages = packageManager.canonicalToCurrentPackageNames(
-                                new String[] { pkg });
-                        cn = new ComponentName(packages[0], cls);
-                        try {
-                            info = packageManager.getActivityInfo(cn, 0);
-                        } catch (PackageManager.NameNotFoundException e1) {
-                            Log.w(TAG, "Unable to add bookmark: " + pkg + "/" + cls, e);
-                            continue;
-                        }
-                    }
-
-                    intent = new Intent(Intent.ACTION_MAIN, null);
-                    intent.addCategory(Intent.CATEGORY_LAUNCHER);
-                    intent.setComponent(cn);
-                    title = info.loadLabel(packageManager).toString();
-                } else if (category != null) {
-                    intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
-                    title = "";
-                } else {
-                    Log.w(TAG, "Unable to add bookmark for shortcut " + shortcutStr
-                            + ": missing package/class or category attributes");
-                    continue;
-                }
-
-                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                values.put(Settings.Bookmarks.INTENT, intent.toUri(0));
-                values.put(Settings.Bookmarks.TITLE, title);
-                values.put(Settings.Bookmarks.SHORTCUT, shortcutValue);
-                db.delete("bookmarks", "shortcut = ?",
-                        new String[] { Integer.toString(shortcutValue) });
-                db.insert("bookmarks", null, values);
-            }
-        } catch (XmlPullParserException e) {
-            Log.w(TAG, "Got execption parsing bookmarks.", e);
-        } catch (IOException e) {
-            Log.w(TAG, "Got execption parsing bookmarks.", e);
-        }
-    }
-
-    /**
-     * Loads the default volume levels. It is actually inserting the index of
-     * the volume array for each of the volume controls.
-     *
-     * @param db the database to insert the volume levels into
-     */
-    private void loadVolumeLevels(SQLiteDatabase db) {
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
-                    + " VALUES(?,?);");
-
-            loadSetting(stmt, Settings.System.VOLUME_MUSIC,
-                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_MUSIC]);
-            loadSetting(stmt, Settings.System.VOLUME_RING,
-                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_RING]);
-            loadSetting(stmt, Settings.System.VOLUME_SYSTEM,
-                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_SYSTEM]);
-            loadSetting(
-                    stmt,
-                    Settings.System.VOLUME_VOICE,
-                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_VOICE_CALL]);
-            loadSetting(stmt, Settings.System.VOLUME_ALARM,
-                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_ALARM]);
-            loadSetting(
-                    stmt,
-                    Settings.System.VOLUME_NOTIFICATION,
-                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_NOTIFICATION]);
-            loadSetting(
-                    stmt,
-                    Settings.System.VOLUME_BLUETOOTH_SCO,
-                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
-
-            // By default:
-            // - ringtones, notification, system and music streams are affected by ringer mode
-            // on non voice capable devices (tablets)
-            // - ringtones, notification and system streams are affected by ringer mode
-            // on voice capable devices (phones)
-            int ringerModeAffectedStreams = (1 << AudioManager.STREAM_RING) |
-                                            (1 << AudioManager.STREAM_NOTIFICATION) |
-                                            (1 << AudioManager.STREAM_SYSTEM) |
-                                            (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
-            if (!mContext.getResources().getBoolean(
-                    com.android.internal.R.bool.config_voice_capable)) {
-                ringerModeAffectedStreams |= (1 << AudioManager.STREAM_MUSIC);
-            }
-            loadSetting(stmt, Settings.System.MODE_RINGER_STREAMS_AFFECTED,
-                    ringerModeAffectedStreams);
-
-            loadSetting(stmt, Settings.System.MUTE_STREAMS_AFFECTED,
-                    ((1 << AudioManager.STREAM_MUSIC) |
-                     (1 << AudioManager.STREAM_RING) |
-                     (1 << AudioManager.STREAM_NOTIFICATION) |
-                     (1 << AudioManager.STREAM_SYSTEM)));
-        } finally {
-            if (stmt != null) stmt.close();
-        }
-
-        loadVibrateWhenRingingSetting(db);
-    }
-
-    private void loadVibrateSetting(SQLiteDatabase db, boolean deleteOld) {
-        if (deleteOld) {
-            db.execSQL("DELETE FROM system WHERE name='" + Settings.System.VIBRATE_ON + "'");
-        }
-
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
-                    + " VALUES(?,?);");
-
-            // Vibrate on by default for ringer, on for notification
-            int vibrate = 0;
-            vibrate = AudioService.getValueForVibrateSetting(vibrate,
-                    AudioManager.VIBRATE_TYPE_NOTIFICATION,
-                    AudioManager.VIBRATE_SETTING_ONLY_SILENT);
-            vibrate |= AudioService.getValueForVibrateSetting(vibrate,
-                    AudioManager.VIBRATE_TYPE_RINGER, AudioManager.VIBRATE_SETTING_ONLY_SILENT);
-            loadSetting(stmt, Settings.System.VIBRATE_ON, vibrate);
-        } finally {
-            if (stmt != null) stmt.close();
-        }
-    }
-
-    private void loadVibrateWhenRingingSetting(SQLiteDatabase db) {
-        // The default should be off. VIBRATE_SETTING_ONLY_SILENT should also be ignored here.
-        // Phone app should separately check whether AudioManager#getRingerMode() returns
-        // RINGER_MODE_VIBRATE, with which the device should vibrate anyway.
-        int vibrateSetting = getIntValueFromSystem(db, Settings.System.VIBRATE_ON,
-                AudioManager.VIBRATE_SETTING_OFF);
-        boolean vibrateWhenRinging = ((vibrateSetting & 3) == AudioManager.VIBRATE_SETTING_ON);
-
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
-                    + " VALUES(?,?);");
-            loadSetting(stmt, Settings.System.VIBRATE_WHEN_RINGING, vibrateWhenRinging ? 1 : 0);
-        } finally {
-            if (stmt != null) stmt.close();
-        }
-    }
-
-    private void loadSettings(SQLiteDatabase db) {
-        loadSystemSettings(db);
-        loadSecureSettings(db);
-        // The global table only exists for the 'owner' user
-        if (mUserHandle == UserHandle.USER_OWNER) {
-            loadGlobalSettings(db);
-        }
-    }
-
-    private void loadSystemSettings(SQLiteDatabase db) {
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
-                    + " VALUES(?,?);");
-
-            loadBooleanSetting(stmt, Settings.System.DIM_SCREEN,
-                    R.bool.def_dim_screen);
-            loadIntegerSetting(stmt, Settings.System.SCREEN_OFF_TIMEOUT,
-                    R.integer.def_screen_off_timeout);
-
-            // Set default cdma DTMF type
-            loadSetting(stmt, Settings.System.DTMF_TONE_TYPE_WHEN_DIALING, 0);
-
-            // Set default hearing aid
-            loadSetting(stmt, Settings.System.HEARING_AID, 0);
-
-            // Set default tty mode
-            loadSetting(stmt, Settings.System.TTY_MODE, 0);
-
-            // Set default noise suppression value
-            loadSetting(stmt, Settings.System.NOISE_SUPPRESSION, 0);
-
-            loadIntegerSetting(stmt, Settings.System.SCREEN_BRIGHTNESS,
-                    R.integer.def_screen_brightness);
-
-            loadBooleanSetting(stmt, Settings.System.SCREEN_BRIGHTNESS_MODE,
-                    R.bool.def_screen_brightness_automatic_mode);
-
-            loadDefaultAnimationSettings(stmt);
-
-            loadBooleanSetting(stmt, Settings.System.ACCELEROMETER_ROTATION,
-                    R.bool.def_accelerometer_rotation);
-
-            loadDefaultHapticSettings(stmt);
-
-            loadBooleanSetting(stmt, Settings.System.NOTIFICATION_LIGHT_PULSE,
-                    R.bool.def_notification_pulse);
-
-            loadUISoundEffectsSettings(stmt);
-
-            loadIntegerSetting(stmt, Settings.System.POINTER_SPEED,
-                    R.integer.def_pointer_speed);
-
-            loadIntegerSetting(stmt, Settings.System.STATUS_BAR_BATTERY,
-                    R.integer.def_battery_style);
-
-            loadIntegerSetting(stmt, Settings.System.STATUS_BAR_NOTIF_COUNT,
-                    R.integer.def_notif_count);
-
-            loadIntegerSetting(stmt, Settings.System.QS_QUICK_PULLDOWN,
-                    R.integer.def_qs_quick_pulldown);
-
-            loadStringSetting(stmt, Settings.System.LOCKSCREEN_TARGETS,
-                    R.string.def_lockscreen_targets);
-        } finally {
-            if (stmt != null) stmt.close();
-        }
-    }
-
-    private void loadUISoundEffectsSettings(SQLiteStatement stmt) {
-        loadBooleanSetting(stmt, Settings.System.DTMF_TONE_WHEN_DIALING,
-                R.bool.def_dtmf_tones_enabled);
-        loadBooleanSetting(stmt, Settings.System.SOUND_EFFECTS_ENABLED,
-                R.bool.def_sound_effects_enabled);
-        loadBooleanSetting(stmt, Settings.System.HAPTIC_FEEDBACK_ENABLED,
-                R.bool.def_haptic_feedback);
-        loadIntegerSetting(stmt, Settings.System.LOCKSCREEN_SOUNDS_ENABLED,
-            R.integer.def_lockscreen_sounds_enabled);
-    }
-
-    private void loadDefaultAnimationSettings(SQLiteStatement stmt) {
-        loadFractionSetting(stmt, Settings.System.WINDOW_ANIMATION_SCALE,
-                R.fraction.def_window_animation_scale, 1);
-        loadFractionSetting(stmt, Settings.System.TRANSITION_ANIMATION_SCALE,
-                R.fraction.def_window_transition_scale, 1);
-    }
-
-    private void loadDefaultHapticSettings(SQLiteStatement stmt) {
-        loadBooleanSetting(stmt, Settings.System.HAPTIC_FEEDBACK_ENABLED,
-                R.bool.def_haptic_feedback);
-    }
-
-    private void loadSecureSettings(SQLiteDatabase db) {
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
-                    + " VALUES(?,?);");
-
-            loadStringSetting(stmt, Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
-                    R.string.def_location_providers_allowed);
-
-            String wifiWatchList = SystemProperties.get("ro.com.android.wifi-watchlist");
-            if (!TextUtils.isEmpty(wifiWatchList)) {
-                loadSetting(stmt, Settings.Secure.WIFI_WATCHDOG_WATCH_LIST, wifiWatchList);
-            }
-
-            // Don't do this.  The SystemServer will initialize ADB_ENABLED from a
-            // persistent system property instead.
-            //loadSetting(stmt, Settings.Secure.ADB_ENABLED, 0);
-
-            // Allow mock locations default, based on build
-            loadSetting(stmt, Settings.Secure.ALLOW_MOCK_LOCATION,
-                    "1".equals(SystemProperties.get("ro.allow.mock.location")) ? 1 : 0);
-
-            loadSecure35Settings(stmt);
-
-            loadBooleanSetting(stmt, Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND,
-                    R.bool.def_mount_play_notification_snd);
-
-            loadBooleanSetting(stmt, Settings.Secure.MOUNT_UMS_AUTOSTART,
-                    R.bool.def_mount_ums_autostart);
-
-            loadBooleanSetting(stmt, Settings.Secure.MOUNT_UMS_PROMPT,
-                    R.bool.def_mount_ums_prompt);
-
-            loadBooleanSetting(stmt, Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED,
-                    R.bool.def_mount_ums_notify_enabled);
-
-            loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SCRIPT_INJECTION,
-                    R.bool.def_accessibility_script_injection);
-
-            loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_WEB_CONTENT_KEY_BINDINGS,
-                    R.string.def_accessibility_web_content_key_bindings);
-
-            loadIntegerSetting(stmt, Settings.Secure.LONG_PRESS_TIMEOUT,
-                    R.integer.def_long_press_timeout_millis);
-
-            loadBooleanSetting(stmt, Settings.Secure.TOUCH_EXPLORATION_ENABLED,
-                    R.bool.def_touch_exploration_enabled);
-
-            loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD,
-                    R.bool.def_accessibility_speak_password);
-
-            loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
-                    R.string.def_accessibility_screen_reader_url);
-
-            if (SystemProperties.getBoolean("ro.lockscreen.disable.default", false) == true) {
-                loadSetting(stmt, Settings.System.LOCKSCREEN_DISABLED, "1");
-            } else {
-                loadBooleanSetting(stmt, Settings.System.LOCKSCREEN_DISABLED,
-                        R.bool.def_lockscreen_disabled);
-            }
-
-            loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ENABLED,
-                    com.android.internal.R.bool.config_dreamsEnabledByDefault);
-            loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK,
-                    com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
-            loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP,
-                    com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
-            loadStringSetting(stmt, Settings.Secure.SCREENSAVER_COMPONENTS,
-                    com.android.internal.R.string.config_dreamsDefaultComponent);
-            loadStringSetting(stmt, Settings.Secure.SCREENSAVER_DEFAULT_COMPONENT,
-                    com.android.internal.R.string.config_dreamsDefaultComponent);
-
-            loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
-                    R.bool.def_accessibility_display_magnification_enabled);
-
-            loadFractionSetting(stmt, Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
-                    R.fraction.def_accessibility_display_magnification_scale, 1);
-
-            loadBooleanSetting(stmt,
-                    Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE,
-                    R.bool.def_accessibility_display_magnification_auto_update);
-
-            loadBooleanSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
-                    R.bool.def_user_setup_complete);
-        } finally {
-            if (stmt != null) stmt.close();
-        }
-    }
-
-    private void loadSecure35Settings(SQLiteStatement stmt) {
-        loadBooleanSetting(stmt, Settings.Secure.BACKUP_ENABLED,
-                R.bool.def_backup_enabled);
-
-        loadStringSetting(stmt, Settings.Secure.BACKUP_TRANSPORT,
-                R.string.def_backup_transport);
-    }
-
-    private void loadGlobalSettings(SQLiteDatabase db) {
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR IGNORE INTO global(name,value)"
-                    + " VALUES(?,?);");
-
-            // --- Previously in 'system'
-            loadBooleanSetting(stmt, Settings.Global.AIRPLANE_MODE_ON,
-                    R.bool.def_airplane_mode_on);
-
-            loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_RADIOS,
-                    R.string.def_airplane_mode_radios);
-
-            loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
-                    R.string.airplane_mode_toggleable_radios);
-
-            loadBooleanSetting(stmt, Settings.Global.ASSISTED_GPS_ENABLED,
-                    R.bool.assisted_gps_enabled);
-
-            loadBooleanSetting(stmt, Settings.Global.AUTO_TIME,
-                    R.bool.def_auto_time); // Sync time to NITZ
-
-            loadBooleanSetting(stmt, Settings.Global.AUTO_TIME_ZONE,
-                    R.bool.def_auto_time_zone); // Sync timezone to NITZ
-
-            loadSetting(stmt, Settings.Global.STAY_ON_WHILE_PLUGGED_IN,
-                    ("1".equals(SystemProperties.get("ro.kernel.qemu")) ||
-                        mContext.getResources().getBoolean(R.bool.def_stay_on_while_plugged_in))
-                     ? 1 : 0);
-
-            loadIntegerSetting(stmt, Settings.Global.WIFI_SLEEP_POLICY,
-                    R.integer.def_wifi_sleep_policy);
-
-            loadSetting(stmt, Settings.Global.MODE_RINGER,
-                    AudioManager.RINGER_MODE_NORMAL);
-
-            // --- Previously in 'secure'
-            loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE,
-                    R.bool.def_package_verifier_enable);
-
-            loadBooleanSetting(stmt, Settings.Global.WIFI_ON,
-                    R.bool.def_wifi_on);
-
-            loadBooleanSetting(stmt, Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
-                    R.bool.def_networks_available_notification_on);
-
-            loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON,
-                    R.bool.def_bluetooth_on);
-
-            // Enable or disable Cell Broadcast SMS
-            loadSetting(stmt, Settings.Global.CDMA_CELL_BROADCAST_SMS,
-                    RILConstants.CDMA_CELL_BROADCAST_SMS_DISABLED);
-
-            // Data roaming default, based on build
-            loadSetting(stmt, Settings.Global.DATA_ROAMING,
-                    "true".equalsIgnoreCase(
-                            SystemProperties.get("ro.com.android.dataroaming",
-                                    "false")) ? 1 : 0);
-
-            loadBooleanSetting(stmt, Settings.Global.DEVICE_PROVISIONED,
-                    R.bool.def_device_provisioned);
-
-            final int maxBytes = mContext.getResources().getInteger(
-                    R.integer.def_download_manager_max_bytes_over_mobile);
-            if (maxBytes > 0) {
-                loadSetting(stmt, Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE,
-                        Integer.toString(maxBytes));
-            }
-
-            final int recommendedMaxBytes = mContext.getResources().getInteger(
-                    R.integer.def_download_manager_recommended_max_bytes_over_mobile);
-            if (recommendedMaxBytes > 0) {
-                loadSetting(stmt, Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE,
-                        Integer.toString(recommendedMaxBytes));
-            }
-
-            // Mobile Data default, based on build
-            loadSetting(stmt, Settings.Global.MOBILE_DATA,
-                    "true".equalsIgnoreCase(
-                            SystemProperties.get("ro.com.android.mobiledata",
-                                    "true")) ? 1 : 0);
-
-            loadBooleanSetting(stmt, Settings.Global.NETSTATS_ENABLED,
-                    R.bool.def_netstats_enabled);
-
-            loadBooleanSetting(stmt, Settings.Global.INSTALL_NON_MARKET_APPS,
-                    R.bool.def_install_non_market_apps);
-
-            loadIntegerSetting(stmt, Settings.Global.NETWORK_PREFERENCE,
-                    R.integer.def_network_preference);
-
-            loadBooleanSetting(stmt, Settings.Global.USB_MASS_STORAGE_ENABLED,
-                    R.bool.def_usb_mass_storage_enabled);
-
-            loadIntegerSetting(stmt, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT,
-                    R.integer.def_max_dhcp_retries);
-
-            loadBooleanSetting(stmt, Settings.Global.WIFI_DISPLAY_ON,
-                    R.bool.def_wifi_display_on);
-
-            loadStringSetting(stmt, Settings.Global.LOCK_SOUND,
-                    R.string.def_lock_sound);
-            loadStringSetting(stmt, Settings.Global.UNLOCK_SOUND,
-                    R.string.def_unlock_sound);
-            loadIntegerSetting(stmt, Settings.Global.POWER_SOUNDS_ENABLED,
-                    R.integer.def_power_sounds_enabled);
-            loadStringSetting(stmt, Settings.Global.LOW_BATTERY_SOUND,
-                    R.string.def_low_battery_sound);
-            loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED,
-                    R.integer.def_dock_sounds_enabled);
-            loadStringSetting(stmt, Settings.Global.DESK_DOCK_SOUND,
-                    R.string.def_desk_dock_sound);
-            loadStringSetting(stmt, Settings.Global.DESK_UNDOCK_SOUND,
-                    R.string.def_desk_undock_sound);
-            loadStringSetting(stmt, Settings.Global.CAR_DOCK_SOUND,
-                    R.string.def_car_dock_sound);
-            loadStringSetting(stmt, Settings.Global.CAR_UNDOCK_SOUND,
-                    R.string.def_car_undock_sound);
-            loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND,
-                    R.string.def_wireless_charging_started_sound);
-
-            loadBooleanSetting(stmt, Settings.Global.POWER_NOTIFICATIONS_ENABLED,
-                    R.bool.def_power_notifications_enabled);
-            loadBooleanSetting(stmt, Settings.Global.POWER_NOTIFICATIONS_VIBRATE,
-                    R.bool.def_power_notifications_vibrate);
-            loadStringSetting(stmt, Settings.Global.POWER_NOTIFICATIONS_RINGTONE,
-                    R.string.def_power_notifications_ringtone);
-
-            loadSetting(stmt, Settings.Global.SET_INSTALL_LOCATION, 0);
-            loadSetting(stmt, Settings.Global.DEFAULT_INSTALL_LOCATION,
-                    PackageHelper.APP_INSTALL_AUTO);
-
-            // Set default cdma emergency tone
-            loadSetting(stmt, Settings.Global.EMERGENCY_TONE, 0);
-
-            // Set default cdma call auto retry
-            loadSetting(stmt, Settings.Global.CALL_AUTO_RETRY, 0);
-
-            // Set the preferred network mode to 0 = Global, CDMA default
-            int type;
-                type = SystemProperties.getInt("ro.telephony.default_network",
-                        RILConstants.PREFERRED_NETWORK_MODE);
-            loadSetting(stmt, Settings.Global.PREFERRED_NETWORK_MODE, type);
-
-            // --- New global settings start here
-        } finally {
-            if (stmt != null) stmt.close();
-        }
-    }
-
-    private void loadSetting(SQLiteStatement stmt, String key, Object value) {
-        stmt.bindString(1, key);
-        stmt.bindString(2, value.toString());
-        stmt.execute();
-    }
-
-    private void loadStringSetting(SQLiteStatement stmt, String key, int resid) {
-        loadSetting(stmt, key, mContext.getResources().getString(resid));
-    }
-
-    private void loadBooleanSetting(SQLiteStatement stmt, String key, int resid) {
-        loadSetting(stmt, key,
-                mContext.getResources().getBoolean(resid) ? "1" : "0");
-    }
-
-    private void loadIntegerSetting(SQLiteStatement stmt, String key, int resid) {
-        loadSetting(stmt, key,
-                Integer.toString(mContext.getResources().getInteger(resid)));
-    }
-
-    private void loadFractionSetting(SQLiteStatement stmt, String key, int resid, int base) {
-        loadSetting(stmt, key,
-                Float.toString(mContext.getResources().getFraction(resid, base, base)));
-    }
-
-    private int getIntValueFromSystem(SQLiteDatabase db, String name, int defaultValue) {
-        return getIntValueFromTable(db, TABLE_SYSTEM, name, defaultValue);
-    }
-
-    private int getIntValueFromTable(SQLiteDatabase db, String table, String name,
-            int defaultValue) {
-        String value = getStringValueFromTable(db, table, name, null);
-        return (value != null) ? Integer.parseInt(value) : defaultValue;
-    }
-
-    private String getStringValueFromTable(SQLiteDatabase db, String table, String name,
-            String defaultValue) {
-        Cursor c = null;
-        try {
-            c = db.query(table, new String[] { Settings.System.VALUE }, "name='" + name + "'",
-                    null, null, null, null);
-            if (c != null && c.moveToFirst()) {
-                String val = c.getString(0);
-                return val == null ? defaultValue : val;
-            }
-        } finally {
-            if (c != null) c.close();
-        }
-        return defaultValue;
-    }
-}
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.settings;
+
+import android.content.ComponentName;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.content.res.XmlResourceParser;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteStatement;
+import android.media.AudioManager;
+import android.media.AudioService;
+import android.net.ConnectivityManager;
+import android.os.Environment;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.provider.Settings.Global;
+import android.provider.Settings.Secure;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.internal.content.PackageHelper;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.util.XmlUtils;
+import com.android.internal.widget.LockPatternUtils;
+import com.android.internal.widget.LockPatternView;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.List;
+
+/**
+ * Database helper class for {@link SettingsProvider}.
+ * Mostly just has a bit {@link #onCreate} to initialize the database.
+ */
+public class DatabaseHelper extends SQLiteOpenHelper {
+    private static final String TAG = "SettingsProvider";
+    private static final String DATABASE_NAME = "settings.db";
+
+    // Please, please please. If you update the database version, check to make sure the
+    // database gets upgraded properly. At a minimum, please confirm that 'upgradeVersion'
+    // is properly propagated through your change.  Not doing so will result in a loss of user
+    // settings.
+    private static final int DATABASE_VERSION = 95;
+
+    private Context mContext;
+    private int mUserHandle;
+
+    private static final HashSet<String> mValidTables = new HashSet<String>();
+
+    private static final String TABLE_SYSTEM = "system";
+    private static final String TABLE_SECURE = "secure";
+    private static final String TABLE_GLOBAL = "global";
+
+    static {
+        mValidTables.add(TABLE_SYSTEM);
+        mValidTables.add(TABLE_SECURE);
+        mValidTables.add(TABLE_GLOBAL);
+        mValidTables.add("bluetooth_devices");
+        mValidTables.add("bookmarks");
+
+        // These are old.
+        mValidTables.add("favorites");
+        mValidTables.add("gservices");
+        mValidTables.add("old_favorites");
+    }
+
+    static String dbNameForUser(final int userHandle) {
+        // The owner gets the unadorned db name;
+        if (userHandle == UserHandle.USER_OWNER) {
+            return DATABASE_NAME;
+        } else {
+            // Place the database in the user-specific data tree so that it's
+            // cleaned up automatically when the user is deleted.
+            File databaseFile = new File(
+                    Environment.getUserSystemDirectory(userHandle), DATABASE_NAME);
+            return databaseFile.getPath();
+        }
+    }
+
+    public DatabaseHelper(Context context, int userHandle) {
+        super(context, dbNameForUser(userHandle), null, DATABASE_VERSION);
+        mContext = context;
+        mUserHandle = userHandle;
+        setWriteAheadLoggingEnabled(true);
+    }
+
+    public static boolean isValidTable(String name) {
+        return mValidTables.contains(name);
+    }
+
+    private void createSecureTable(SQLiteDatabase db) {
+        db.execSQL("CREATE TABLE secure (" +
+                "_id INTEGER PRIMARY KEY AUTOINCREMENT," +
+                "name TEXT UNIQUE ON CONFLICT REPLACE," +
+                "value TEXT" +
+                ");");
+        db.execSQL("CREATE INDEX secureIndex1 ON secure (name);");
+    }
+
+    private void createGlobalTable(SQLiteDatabase db) {
+        db.execSQL("CREATE TABLE global (" +
+                "_id INTEGER PRIMARY KEY AUTOINCREMENT," +
+                "name TEXT UNIQUE ON CONFLICT REPLACE," +
+                "value TEXT" +
+                ");");
+        db.execSQL("CREATE INDEX globalIndex1 ON global (name);");
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        db.execSQL("CREATE TABLE system (" +
+                    "_id INTEGER PRIMARY KEY AUTOINCREMENT," +
+                    "name TEXT UNIQUE ON CONFLICT REPLACE," +
+                    "value TEXT" +
+                    ");");
+        db.execSQL("CREATE INDEX systemIndex1 ON system (name);");
+
+        createSecureTable(db);
+
+        // Only create the global table for the singleton 'owner' user
+        if (mUserHandle == UserHandle.USER_OWNER) {
+            createGlobalTable(db);
+        }
+
+        db.execSQL("CREATE TABLE bluetooth_devices (" +
+                    "_id INTEGER PRIMARY KEY," +
+                    "name TEXT," +
+                    "addr TEXT," +
+                    "channel INTEGER," +
+                    "type INTEGER" +
+                    ");");
+
+        db.execSQL("CREATE TABLE bookmarks (" +
+                    "_id INTEGER PRIMARY KEY," +
+                    "title TEXT," +
+                    "folder TEXT," +
+                    "intent TEXT," +
+                    "shortcut INTEGER," +
+                    "ordering INTEGER" +
+                    ");");
+
+        db.execSQL("CREATE INDEX bookmarksIndex1 ON bookmarks (folder);");
+        db.execSQL("CREATE INDEX bookmarksIndex2 ON bookmarks (shortcut);");
+
+        // Populate bookmarks table with initial bookmarks
+        boolean onlyCore = false;
+        try {
+            onlyCore = IPackageManager.Stub.asInterface(ServiceManager.getService(
+                    "package")).isOnlyCoreApps();
+        } catch (RemoteException e) {
+        }
+        if (!onlyCore) {
+            loadBookmarks(db);
+        }
+
+        // Load initial volume levels into DB
+        loadVolumeLevels(db);
+
+        // Load inital settings values
+        loadSettings(db);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) {
+        Log.w(TAG, "Upgrading settings database from version " + oldVersion + " to "
+                + currentVersion);
+
+        int upgradeVersion = oldVersion;
+
+        // Pattern for upgrade blocks:
+        //
+        //    if (upgradeVersion == [the DATABASE_VERSION you set] - 1) {
+        //        .. your upgrade logic..
+        //        upgradeVersion = [the DATABASE_VERSION you set]
+        //    }
+
+        if (upgradeVersion == 20) {
+            /*
+             * Version 21 is part of the volume control refresh. There is no
+             * longer a UI-visible for setting notification vibrate on/off (in
+             * our design), but the functionality still exists. Force the
+             * notification vibrate to on.
+             */
+            loadVibrateSetting(db, true);
+
+            upgradeVersion = 21;
+        }
+
+        if (upgradeVersion < 22) {
+            upgradeVersion = 22;
+            // Upgrade the lock gesture storage location and format
+            upgradeLockPatternLocation(db);
+        }
+
+        if (upgradeVersion < 23) {
+            db.execSQL("UPDATE favorites SET iconResource=0 WHERE iconType=0");
+            upgradeVersion = 23;
+        }
+
+        if (upgradeVersion == 23) {
+            db.beginTransaction();
+            try {
+                db.execSQL("ALTER TABLE favorites ADD spanX INTEGER");
+                db.execSQL("ALTER TABLE favorites ADD spanY INTEGER");
+                // Shortcuts, applications, folders
+                db.execSQL("UPDATE favorites SET spanX=1, spanY=1 WHERE itemType<=0");
+                // Photo frames, clocks
+                db.execSQL(
+                    "UPDATE favorites SET spanX=2, spanY=2 WHERE itemType=1000 or itemType=1002");
+                // Search boxes
+                db.execSQL("UPDATE favorites SET spanX=4, spanY=1 WHERE itemType=1001");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 24;
+        }
+
+        if (upgradeVersion == 24) {
+            db.beginTransaction();
+            try {
+                // The value of the constants for preferring wifi or preferring mobile have been
+                // swapped, so reload the default.
+                db.execSQL("DELETE FROM system WHERE name='network_preference'");
+                db.execSQL("INSERT INTO system ('name', 'value') values ('network_preference', '" +
+                        ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + "')");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 25;
+        }
+
+        if (upgradeVersion == 25) {
+            db.beginTransaction();
+            try {
+                db.execSQL("ALTER TABLE favorites ADD uri TEXT");
+                db.execSQL("ALTER TABLE favorites ADD displayMode INTEGER");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 26;
+        }
+
+        if (upgradeVersion == 26) {
+            // This introduces the new secure settings table.
+            db.beginTransaction();
+            try {
+                createSecureTable(db);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 27;
+        }
+
+        if (upgradeVersion == 27) {
+            String[] settingsToMove = {
+                    Settings.Secure.ADB_ENABLED,
+                    Settings.Secure.ANDROID_ID,
+                    Settings.Secure.BLUETOOTH_ON,
+                    Settings.Secure.DATA_ROAMING,
+                    Settings.Secure.DEVICE_PROVISIONED,
+                    Settings.Secure.HTTP_PROXY,
+                    Settings.Secure.INSTALL_NON_MARKET_APPS,
+                    Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
+                    Settings.Secure.LOGGING_ID,
+                    Settings.Secure.NETWORK_PREFERENCE,
+                    Settings.Secure.PARENTAL_CONTROL_ENABLED,
+                    Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,
+                    Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,
+                    Settings.Secure.SETTINGS_CLASSNAME,
+                    Settings.Secure.USB_MASS_STORAGE_ENABLED,
+                    Settings.Secure.USE_GOOGLE_MAIL,
+                    Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
+                    Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
+                    Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,
+                    Settings.Secure.WIFI_ON,
+                    Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,
+                    Settings.Secure.WIFI_WATCHDOG_AP_COUNT,
+                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,
+                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,
+                    Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,
+                    Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,
+                    Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,
+                    Settings.Secure.WIFI_WATCHDOG_ON,
+                    Settings.Secure.WIFI_WATCHDOG_PING_COUNT,
+                    Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,
+                    Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS,
+                };
+            moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
+            upgradeVersion = 28;
+        }
+
+        if (upgradeVersion == 28 || upgradeVersion == 29) {
+            // Note: The upgrade to 28 was flawed since it didn't delete the old
+            // setting first before inserting. Combining 28 and 29 with the
+            // fixed version.
+
+            // This upgrade adds the STREAM_NOTIFICATION type to the list of
+            // types affected by ringer modes (silent, vibrate, etc.)
+            db.beginTransaction();
+            try {
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
+                int newValue = (1 << AudioManager.STREAM_RING)
+                        | (1 << AudioManager.STREAM_NOTIFICATION)
+                        | (1 << AudioManager.STREAM_SYSTEM);
+                db.execSQL("INSERT INTO system ('name', 'value') values ('"
+                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
+                        + String.valueOf(newValue) + "')");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+
+            upgradeVersion = 30;
+        }
+
+        if (upgradeVersion == 30) {
+            /*
+             * Upgrade 31 clears the title for all quick launch shortcuts so the
+             * activities' titles will be resolved at display time. Also, the
+             * folder is changed to '@quicklaunch'.
+             */
+            db.beginTransaction();
+            try {
+                db.execSQL("UPDATE bookmarks SET folder = '@quicklaunch'");
+                db.execSQL("UPDATE bookmarks SET title = ''");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 31;
+        }
+
+        if (upgradeVersion == 31) {
+            /*
+             * Animations are now managed in preferences, and may be
+             * enabled or disabled based on product resources.
+             */
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
+                stmt = db.compileStatement("INSERT INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadDefaultAnimationSettings(stmt);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 32;
+        }
+
+        if (upgradeVersion == 32) {
+            // The Wi-Fi watchdog SSID list is now seeded with the value of
+            // the property ro.com.android.wifi-watchlist
+            String wifiWatchList = SystemProperties.get("ro.com.android.wifi-watchlist");
+            if (!TextUtils.isEmpty(wifiWatchList)) {
+                db.beginTransaction();
+                try {
+                    db.execSQL("INSERT OR IGNORE INTO secure(name,value) values('" +
+                            Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + "','" +
+                            wifiWatchList + "');");
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                }
+            }
+            upgradeVersion = 33;
+        }
+
+        if (upgradeVersion == 33) {
+            // Set the default zoom controls to: tap-twice to bring up +/-
+            db.beginTransaction();
+            try {
+                db.execSQL("INSERT INTO system(name,value) values('zoom','2');");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 34;
+        }
+
+        if (upgradeVersion == 34) {
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                loadSecure35Settings(stmt);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 35;
+        }
+            // due to a botched merge from donut to eclair, the initialization of ASSISTED_GPS_ENABLED
+            // was accidentally done out of order here.
+            // to fix this, ASSISTED_GPS_ENABLED is now initialized while upgrading from 38 to 39,
+            // and we intentionally do nothing from 35 to 36 now.
+        if (upgradeVersion == 35) {
+            upgradeVersion = 36;
+        }
+
+        if (upgradeVersion == 36) {
+           // This upgrade adds the STREAM_SYSTEM_ENFORCED type to the list of
+            // types affected by ringer modes (silent, vibrate, etc.)
+            db.beginTransaction();
+            try {
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
+                int newValue = (1 << AudioManager.STREAM_RING)
+                        | (1 << AudioManager.STREAM_NOTIFICATION)
+                        | (1 << AudioManager.STREAM_SYSTEM)
+                        | (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
+                db.execSQL("INSERT INTO system ('name', 'value') values ('"
+                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
+                        + String.valueOf(newValue) + "')");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 37;
+        }
+
+        if (upgradeVersion == 37) {
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadStringSetting(stmt, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
+                        R.string.airplane_mode_toggleable_radios);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 38;
+        }
+
+        if (upgradeVersion == 38) {
+            db.beginTransaction();
+            try {
+                String value =
+                        mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? "1" : "0";
+                db.execSQL("INSERT OR IGNORE INTO secure(name,value) values('" +
+                        Settings.Global.ASSISTED_GPS_ENABLED + "','" + value + "');");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+
+            upgradeVersion = 39;
+        }
+
+        if (upgradeVersion == 39) {
+            upgradeAutoBrightness(db);
+            upgradeVersion = 40;
+        }
+
+        if (upgradeVersion == 40) {
+            /*
+             * All animations are now turned on by default!
+             */
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
+                stmt = db.compileStatement("INSERT INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadDefaultAnimationSettings(stmt);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 41;
+        }
+
+        if (upgradeVersion == 41) {
+            /*
+             * Initialize newly public haptic feedback setting
+             */
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.HAPTIC_FEEDBACK_ENABLED + "'");
+                stmt = db.compileStatement("INSERT INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadDefaultHapticSettings(stmt);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 42;
+        }
+
+        if (upgradeVersion == 42) {
+            /*
+             * Initialize new notification pulse setting
+             */
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadBooleanSetting(stmt, Settings.System.NOTIFICATION_LIGHT_PULSE,
+                        R.bool.def_notification_pulse);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 43;
+        }
+
+        if (upgradeVersion == 43) {
+            /*
+             * This upgrade stores bluetooth volume separately from voice volume
+             */
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadSetting(stmt, Settings.System.VOLUME_BLUETOOTH_SCO,
+                        AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 44;
+        }
+
+        if (upgradeVersion == 44) {
+            /*
+             * Gservices was moved into vendor/google.
+             */
+            db.execSQL("DROP TABLE IF EXISTS gservices");
+            db.execSQL("DROP INDEX IF EXISTS gservicesIndex1");
+            upgradeVersion = 45;
+        }
+
+        if (upgradeVersion == 45) {
+             /*
+              * New settings for MountService
+              */
+            db.beginTransaction();
+            try {
+                db.execSQL("INSERT INTO secure(name,value) values('" +
+                        Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + "','1');");
+                db.execSQL("INSERT INTO secure(name,value) values('" +
+                        Settings.Secure.MOUNT_UMS_AUTOSTART + "','0');");
+                db.execSQL("INSERT INTO secure(name,value) values('" +
+                        Settings.Secure.MOUNT_UMS_PROMPT + "','1');");
+                db.execSQL("INSERT INTO secure(name,value) values('" +
+                        Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + "','1');");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 46;
+        }
+
+        if (upgradeVersion == 46) {
+            /*
+             * The password mode constants have changed; reset back to no
+             * password.
+             */
+            db.beginTransaction();
+            try {
+                db.execSQL("DELETE FROM system WHERE name='lockscreen.password_type';");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+           upgradeVersion = 47;
+       }
+
+
+        if (upgradeVersion == 47) {
+            /*
+             * The password mode constants have changed again; reset back to no
+             * password.
+             */
+            db.beginTransaction();
+            try {
+                db.execSQL("DELETE FROM system WHERE name='lockscreen.password_type';");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+           upgradeVersion = 48;
+       }
+
+       if (upgradeVersion == 48) {
+           /*
+            * Default recognition service no longer initialized here,
+            * moved to RecognitionManagerService.
+            */
+           upgradeVersion = 49;
+       }
+
+       if (upgradeVersion == 49) {
+           /*
+            * New settings for new user interface noises.
+            */
+           db.beginTransaction();
+           SQLiteStatement stmt = null;
+           try {
+                stmt = db.compileStatement("INSERT INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadUISoundEffectsSettings(stmt);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+
+           upgradeVersion = 50;
+       }
+
+       if (upgradeVersion == 50) {
+           /*
+            * Install location no longer initiated here.
+            */
+           upgradeVersion = 51;
+       }
+
+       if (upgradeVersion == 51) {
+           /* Move the lockscreen related settings to Secure, including some private ones. */
+           String[] settingsToMove = {
+                   Secure.LOCK_PATTERN_ENABLED,
+                   Secure.LOCK_PATTERN_VISIBLE,
+                   Secure.LOCK_SHOW_ERROR_PATH,
+                   Secure.LOCK_DOTS_VISIBLE,
+                   Secure.LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED,
+                   "lockscreen.password_type",
+                   "lockscreen.lockoutattemptdeadline",
+                   "lockscreen.patterneverchosen",
+                   "lock_pattern_autolock",
+                   "lockscreen.lockedoutpermanently",
+                   "lockscreen.password_salt"
+           };
+           moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
+           upgradeVersion = 52;
+       }
+
+        if (upgradeVersion == 52) {
+            // new vibration/silent mode settings
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadBooleanSetting(stmt, Settings.System.VIBRATE_IN_SILENT,
+                        R.bool.def_vibrate_in_silent);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+
+            upgradeVersion = 53;
+        }
+
+        if (upgradeVersion == 53) {
+            /*
+             * New settings for set install location UI no longer initiated here.
+             */
+            upgradeVersion = 54;
+        }
+
+        if (upgradeVersion == 54) {
+            /*
+             * Update the screen timeout value if set to never
+             */
+            db.beginTransaction();
+            try {
+                upgradeScreenTimeoutFromNever(db);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+
+            upgradeVersion = 55;
+        }
+
+        if (upgradeVersion == 55) {
+            /* Move the install location settings. */
+            String[] settingsToMove = {
+                    Global.SET_INSTALL_LOCATION,
+                    Global.DEFAULT_INSTALL_LOCATION
+            };
+            moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadSetting(stmt, Global.SET_INSTALL_LOCATION, 0);
+                loadSetting(stmt, Global.DEFAULT_INSTALL_LOCATION,
+                        PackageHelper.APP_INSTALL_AUTO);
+                db.setTransactionSuccessful();
+             } finally {
+                 db.endTransaction();
+                 if (stmt != null) stmt.close();
+             }
+            upgradeVersion = 56;
+        }
+
+        if (upgradeVersion == 56) {
+            /*
+             * Add Bluetooth to list of toggleable radios in airplane mode
+             */
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS + "'");
+                stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadStringSetting(stmt, Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
+                        R.string.airplane_mode_toggleable_radios);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 57;
+        }
+
+        /************* The following are Honeycomb changes ************/
+
+        if (upgradeVersion == 57) {
+            /*
+             * New settings to:
+             *  1. Enable injection of accessibility scripts in WebViews.
+             *  2. Define the key bindings for traversing web content in WebViews.
+             */
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SCRIPT_INJECTION,
+                        R.bool.def_accessibility_script_injection);
+                stmt.close();
+                stmt = db.compileStatement("INSERT INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_WEB_CONTENT_KEY_BINDINGS,
+                        R.string.def_accessibility_web_content_key_bindings);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 58;
+        }
+
+        if (upgradeVersion == 58) {
+            /* Add default for new Auto Time Zone */
+            int autoTimeValue = getIntValueFromSystem(db, Settings.System.AUTO_TIME, 0);
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO system(name,value)" + " VALUES(?,?);");
+                loadSetting(stmt, Settings.System.AUTO_TIME_ZONE,
+                        autoTimeValue); // Sync timezone to NITZ if auto_time was enabled
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 59;
+        }
+
+        if (upgradeVersion == 59) {
+            // Persistence for the rotation lock feature.
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadBooleanSetting(stmt, Settings.System.USER_ROTATION,
+                        R.integer.def_user_rotation); // should be zero degrees
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 60;
+        }
+
+        if (upgradeVersion == 60) {
+            // Don't do this for upgrades from Gingerbread
+            // Were only required for intra-Honeycomb upgrades for testing
+            // upgradeScreenTimeout(db);
+            upgradeVersion = 61;
+        }
+
+        if (upgradeVersion == 61) {
+            // Don't do this for upgrades from Gingerbread
+            // Were only required for intra-Honeycomb upgrades for testing
+            // upgradeScreenTimeout(db);
+            upgradeVersion = 62;
+        }
+
+        // Change the default for screen auto-brightness mode
+        if (upgradeVersion == 62) {
+            // Don't do this for upgrades from Gingerbread
+            // Were only required for intra-Honeycomb upgrades for testing
+            // upgradeAutoBrightness(db);
+            upgradeVersion = 63;
+        }
+
+        if (upgradeVersion == 63) {
+            // This upgrade adds the STREAM_MUSIC type to the list of
+             // types affected by ringer modes (silent, vibrate, etc.)
+             db.beginTransaction();
+             try {
+                 db.execSQL("DELETE FROM system WHERE name='"
+                         + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
+                 int newValue = (1 << AudioManager.STREAM_RING)
+                         | (1 << AudioManager.STREAM_NOTIFICATION)
+                         | (1 << AudioManager.STREAM_SYSTEM)
+                         | (1 << AudioManager.STREAM_SYSTEM_ENFORCED)
+                         | (1 << AudioManager.STREAM_MUSIC);
+                 db.execSQL("INSERT INTO system ('name', 'value') values ('"
+                         + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
+                         + String.valueOf(newValue) + "')");
+                 db.setTransactionSuccessful();
+             } finally {
+                 db.endTransaction();
+             }
+             upgradeVersion = 64;
+         }
+
+        if (upgradeVersion == 64) {
+            // New setting to configure the long press timeout.
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                loadIntegerSetting(stmt, Settings.Secure.LONG_PRESS_TIMEOUT,
+                        R.integer.def_long_press_timeout_millis);
+                stmt.close();
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 65;
+        }
+
+        /************* The following are Ice Cream Sandwich changes ************/
+
+        if (upgradeVersion == 65) {
+            /*
+             * Animations are removed from Settings. Turned on by default
+             */
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.WINDOW_ANIMATION_SCALE + "'");
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.TRANSITION_ANIMATION_SCALE + "'");
+                stmt = db.compileStatement("INSERT INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadDefaultAnimationSettings(stmt);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 66;
+        }
+
+        if (upgradeVersion == 66) {
+            // This upgrade makes sure that MODE_RINGER_STREAMS_AFFECTED is set
+            // according to device voice capability
+            db.beginTransaction();
+            try {
+                int ringerModeAffectedStreams = (1 << AudioManager.STREAM_RING) |
+                                                (1 << AudioManager.STREAM_NOTIFICATION) |
+                                                (1 << AudioManager.STREAM_SYSTEM) |
+                                                (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
+                if (!mContext.getResources().getBoolean(
+                        com.android.internal.R.bool.config_voice_capable)) {
+                    ringerModeAffectedStreams |= (1 << AudioManager.STREAM_MUSIC);
+                }
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
+                db.execSQL("INSERT INTO system ('name', 'value') values ('"
+                        + Settings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
+                        + String.valueOf(ringerModeAffectedStreams) + "')");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 67;
+        }
+
+        if (upgradeVersion == 67) {
+            // New setting to enable touch exploration.
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                loadBooleanSetting(stmt, Settings.Secure.TOUCH_EXPLORATION_ENABLED,
+                        R.bool.def_touch_exploration_enabled);
+                stmt.close();
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 68;
+        }
+
+        if (upgradeVersion == 68) {
+            // Enable all system sounds by default
+            db.beginTransaction();
+            try {
+                db.execSQL("DELETE FROM system WHERE name='"
+                        + Settings.System.NOTIFICATIONS_USE_RING_VOLUME + "'");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 69;
+        }
+
+        if (upgradeVersion == 69) {
+            // Add RADIO_NFC to AIRPLANE_MODE_RADIO and AIRPLANE_MODE_TOGGLEABLE_RADIOS
+            String airplaneRadios = mContext.getResources().getString(
+                    R.string.def_airplane_mode_radios);
+            String toggleableRadios = mContext.getResources().getString(
+                    R.string.airplane_mode_toggleable_radios);
+            db.beginTransaction();
+            try {
+                db.execSQL("UPDATE system SET value='" + airplaneRadios + "' " +
+                        "WHERE name='" + Settings.System.AIRPLANE_MODE_RADIOS + "'");
+                db.execSQL("UPDATE system SET value='" + toggleableRadios + "' " +
+                        "WHERE name='" + Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS + "'");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+            upgradeVersion = 70;
+        }
+
+        if (upgradeVersion == 70) {
+            // Update all built-in bookmarks.  Some of the package names have changed.
+            loadBookmarks(db);
+            upgradeVersion = 71;
+        }
+
+        if (upgradeVersion == 71) {
+             // New setting to specify whether to speak passwords in accessibility mode.
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD,
+                        R.bool.def_accessibility_speak_password);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 72;
+        }
+
+        if (upgradeVersion == 72) {
+            // update vibration settings
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
+                        + " VALUES(?,?);");
+                loadBooleanSetting(stmt, Settings.System.VIBRATE_IN_SILENT,
+                        R.bool.def_vibrate_in_silent);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 73;
+        }
+
+        if (upgradeVersion == 73) {
+            upgradeVibrateSettingFromNone(db);
+            upgradeVersion = 74;
+        }
+
+        if (upgradeVersion == 74) {
+            // URL from which WebView loads a JavaScript based screen-reader.
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
+                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
+                        R.string.def_accessibility_screen_reader_url);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 75;
+        }
+        if (upgradeVersion == 75) {
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            Cursor c = null;
+            try {
+                c = db.query(TABLE_SECURE, new String[] {"_id", "value"},
+                        "name='lockscreen.disabled'",
+                        null, null, null, null);
+                // only set default if it has not yet been set
+                if (c == null || c.getCount() == 0) {
+                    stmt = db.compileStatement("INSERT INTO system(name,value)"
+                            + " VALUES(?,?);");
+                    loadBooleanSetting(stmt, Settings.System.LOCKSCREEN_DISABLED,
+                            R.bool.def_lockscreen_disabled);
+                }
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (c != null) c.close();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 76;
+        }
+
+        /************* The following are Jelly Bean changes ************/
+
+        if (upgradeVersion == 76) {
+            // Removed VIBRATE_IN_SILENT setting
+            db.beginTransaction();
+            try {
+                db.execSQL("DELETE FROM system WHERE name='"
+                                + Settings.System.VIBRATE_IN_SILENT + "'");
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+
+            upgradeVersion = 77;
+        }
+
+        if (upgradeVersion == 77) {
+            // Introduce "vibrate when ringing" setting
+            loadVibrateWhenRingingSetting(db);
+
+            upgradeVersion = 78;
+        }
+
+        if (upgradeVersion == 78) {
+            // The JavaScript based screen-reader URL changes in JellyBean.
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
+                        R.string.def_accessibility_screen_reader_url);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 79;
+        }
+
+        if (upgradeVersion == 79) {
+            // Before touch exploration was a global setting controlled by the user
+            // via the UI. However, if the enabled accessibility services do not
+            // handle touch exploration mode, enabling it makes no sense. Therefore,
+            // now the services request touch exploration mode and the user is
+            // presented with a dialog to allow that and if she does we store that
+            // in the database. As a result of this change a user that has enabled
+            // accessibility, touch exploration, and some accessibility services
+            // may lose touch exploration state, thus rendering the device useless
+            // unless sighted help is provided, since the enabled service(s) are
+            // not in the list of services to which the user granted a permission
+            // to put the device in touch explore mode. Here we are allowing all
+            // enabled accessibility services to toggle touch exploration provided
+            // accessibility and touch exploration are enabled and no services can
+            // toggle touch exploration. Note that the user has already manually
+            // enabled the services and touch exploration which means the she has
+            // given consent to have these services work in touch exploration mode.
+            final boolean accessibilityEnabled = getIntValueFromTable(db, TABLE_SECURE,
+                    Settings.Secure.ACCESSIBILITY_ENABLED, 0) == 1;
+            final boolean touchExplorationEnabled = getIntValueFromTable(db, TABLE_SECURE,
+                    Settings.Secure.TOUCH_EXPLORATION_ENABLED, 0) == 1;
+            if (accessibilityEnabled && touchExplorationEnabled) {
+                String enabledServices = getStringValueFromTable(db, TABLE_SECURE,
+                        Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, "");
+                String touchExplorationGrantedServices = getStringValueFromTable(db, TABLE_SECURE,
+                        Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES, "");
+                if (TextUtils.isEmpty(touchExplorationGrantedServices)
+                        && !TextUtils.isEmpty(enabledServices)) {
+                    SQLiteStatement stmt = null;
+                    try {
+                        db.beginTransaction();
+                        stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
+                                + " VALUES(?,?);");
+                        loadSetting(stmt,
+                                Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
+                                enabledServices);
+                        db.setTransactionSuccessful();
+                    } finally {
+                        db.endTransaction();
+                        if (stmt != null) stmt.close();
+                    }
+                }
+            }
+            upgradeVersion = 80;
+        }
+
+        // vvv Jelly Bean MR1 changes begin here vvv
+
+        if (upgradeVersion == 80) {
+            // update screensaver settings
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ENABLED,
+                        com.android.internal.R.bool.config_dreamsEnabledByDefault);
+                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK,
+                        com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
+                loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP,
+                        com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
+                loadStringSetting(stmt, Settings.Secure.SCREENSAVER_COMPONENTS,
+                        com.android.internal.R.string.config_dreamsDefaultComponent);
+                loadStringSetting(stmt, Settings.Secure.SCREENSAVER_DEFAULT_COMPONENT,
+                        com.android.internal.R.string.config_dreamsDefaultComponent);
+
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 81;
+        }
+
+        if (upgradeVersion == 81) {
+            // Add package verification setting
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT OR REPLACE INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE,
+                        R.bool.def_package_verifier_enable);
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 82;
+        }
+
+        if (upgradeVersion == 82) {
+            // Move to per-user settings dbs
+            if (mUserHandle == UserHandle.USER_OWNER) {
+
+                db.beginTransaction();
+                SQLiteStatement stmt = null;
+                try {
+                    // Migrate now-global settings. Note that this happens before
+                    // new users can be created.
+                    createGlobalTable(db);
+                    String[] settingsToMove = hashsetToStringArray(SettingsProvider.sSystemGlobalKeys);
+                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, false);
+                    settingsToMove = hashsetToStringArray(SettingsProvider.sSecureGlobalKeys);
+                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, false);
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                    if (stmt != null) stmt.close();
+                }
+            }
+            upgradeVersion = 83;
+        }
+
+        if (upgradeVersion == 83) {
+            // 1. Setting whether screen magnification is enabled.
+            // 2. Setting for screen magnification scale.
+            // 3. Setting for screen magnification auto update.
+            db.beginTransaction();
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
+                loadBooleanSetting(stmt,
+                        Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
+                        R.bool.def_accessibility_display_magnification_enabled);
+                stmt.close();
+                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
+                loadFractionSetting(stmt, Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
+                        R.fraction.def_accessibility_display_magnification_scale, 1);
+                stmt.close();
+                stmt = db.compileStatement("INSERT INTO secure(name,value) VALUES(?,?);");
+                loadBooleanSetting(stmt,
+                        Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE,
+                        R.bool.def_accessibility_display_magnification_auto_update);
+
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 84;
+        }
+
+        if (upgradeVersion == 84) {
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                SQLiteStatement stmt = null;
+                try {
+                    // Patch up the slightly-wrong key migration from 82 -> 83 for those
+                    // devices that missed it, ignoring if the move is redundant
+                    String[] settingsToMove = {
+                            Settings.Secure.ADB_ENABLED,
+                            Settings.Secure.BLUETOOTH_ON,
+                            Settings.Secure.DATA_ROAMING,
+                            Settings.Secure.DEVICE_PROVISIONED,
+                            Settings.Secure.INSTALL_NON_MARKET_APPS,
+                            Settings.Secure.USB_MASS_STORAGE_ENABLED
+                    };
+                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                    if (stmt != null) stmt.close();
+                }
+            }
+            upgradeVersion = 85;
+        }
+
+        if (upgradeVersion == 85) {
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                try {
+                    // Fix up the migration, ignoring already-migrated elements, to snap up to
+                    // date with new changes to the set of global versus system/secure settings
+                    String[] settingsToMove = { Settings.System.STAY_ON_WHILE_PLUGGED_IN };
+                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                }
+            }
+            upgradeVersion = 86;
+        }
+
+        if (upgradeVersion == 86) {
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                try {
+                    String[] settingsToMove = {
+                            Settings.Global.PACKAGE_VERIFIER_ENABLE,
+                            Settings.Global.PACKAGE_VERIFIER_TIMEOUT,
+                            Settings.Global.PACKAGE_VERIFIER_DEFAULT_RESPONSE
+                    };
+                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                }
+            }
+            upgradeVersion = 87;
+        }
+
+        if (upgradeVersion == 87) {
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                try {
+                    String[] settingsToMove = {
+                            Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS,
+                            Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS,
+                            Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS
+                    };
+                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                }
+            }
+            upgradeVersion = 88;
+        }
+
+        if (upgradeVersion == 88) {
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                try {
+                    String[] settingsToMove = {
+                            Settings.Global.BATTERY_DISCHARGE_DURATION_THRESHOLD,
+                            Settings.Global.BATTERY_DISCHARGE_THRESHOLD,
+                            Settings.Global.SEND_ACTION_APP_ERROR,
+                            Settings.Global.DROPBOX_AGE_SECONDS,
+                            Settings.Global.DROPBOX_MAX_FILES,
+                            Settings.Global.DROPBOX_QUOTA_KB,
+                            Settings.Global.DROPBOX_QUOTA_PERCENT,
+                            Settings.Global.DROPBOX_RESERVE_PERCENT,
+                            Settings.Global.DROPBOX_TAG_PREFIX,
+                            Settings.Global.ERROR_LOGCAT_PREFIX,
+                            Settings.Global.SYS_FREE_STORAGE_LOG_INTERVAL,
+                            Settings.Global.DISK_FREE_CHANGE_REPORTING_THRESHOLD,
+                            Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE,
+                            Settings.Global.SYS_STORAGE_THRESHOLD_MAX_BYTES,
+                            Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES,
+                            Settings.Global.SYNC_MAX_RETRY_DELAY_IN_SECONDS,
+                            Settings.Global.CONNECTIVITY_CHANGE_DELAY,
+                            Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED,
+                            Settings.Global.CAPTIVE_PORTAL_SERVER,
+                            Settings.Global.NSD_ON,
+                            Settings.Global.SET_INSTALL_LOCATION,
+                            Settings.Global.DEFAULT_INSTALL_LOCATION,
+                            Settings.Global.INET_CONDITION_DEBOUNCE_UP_DELAY,
+                            Settings.Global.INET_CONDITION_DEBOUNCE_DOWN_DELAY,
+                            Settings.Global.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT,
+                            Settings.Global.HTTP_PROXY,
+                            Settings.Global.GLOBAL_HTTP_PROXY_HOST,
+                            Settings.Global.GLOBAL_HTTP_PROXY_PORT,
+                            Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST,
+                            Settings.Global.SET_GLOBAL_HTTP_PROXY,
+                            Settings.Global.DEFAULT_DNS_SERVER,
+                    };
+                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                }
+            }
+            upgradeVersion = 89;
+        }
+
+        if (upgradeVersion == 89) {
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                try {
+                    String[] prefixesToMove = {
+                            Settings.Global.BLUETOOTH_HEADSET_PRIORITY_PREFIX,
+                            Settings.Global.BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX,
+                            Settings.Global.BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX,
+                    };
+
+                    movePrefixedSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, prefixesToMove);
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                }
+            }
+            upgradeVersion = 90;
+        }
+
+        if (upgradeVersion == 90) {
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                try {
+                    String[] systemToGlobal = {
+                            Settings.Global.WINDOW_ANIMATION_SCALE,
+                            Settings.Global.TRANSITION_ANIMATION_SCALE,
+                            Settings.Global.ANIMATOR_DURATION_SCALE,
+                            Settings.Global.FANCY_IME_ANIMATIONS,
+                            Settings.Global.COMPATIBILITY_MODE,
+                            Settings.Global.EMERGENCY_TONE,
+                            Settings.Global.CALL_AUTO_RETRY,
+                            Settings.Global.DEBUG_APP,
+                            Settings.Global.WAIT_FOR_DEBUGGER,
+                            Settings.Global.SHOW_PROCESSES,
+                            Settings.Global.ALWAYS_FINISH_ACTIVITIES,
+                    };
+                    String[] secureToGlobal = {
+                            Settings.Global.PREFERRED_NETWORK_MODE,
+                            Settings.Global.PREFERRED_CDMA_SUBSCRIPTION,
+                    };
+
+                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, systemToGlobal, true);
+                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, secureToGlobal, true);
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                }
+            }
+            upgradeVersion = 91;
+        }
+
+        if (upgradeVersion == 91) {
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                try {
+                    // Move ringer mode from system to global settings
+                    String[] settingsToMove = { Settings.Global.MODE_RINGER };
+                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                }
+            }
+            upgradeVersion = 92;
+        }
+
+        if (upgradeVersion == 92) {
+            SQLiteStatement stmt = null;
+            try {
+                stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
+                        + " VALUES(?,?);");
+                if (mUserHandle == UserHandle.USER_OWNER) {
+                    // consider existing primary users to have made it through user setup
+                    // if the globally-scoped device-provisioned bit is set
+                    // (indicating they already made it through setup as primary)
+                    int deviceProvisioned = getIntValueFromTable(db, TABLE_GLOBAL,
+                            Settings.Global.DEVICE_PROVISIONED, 0);
+                    loadSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
+                            deviceProvisioned);
+                } else {
+                    // otherwise use the default
+                    loadBooleanSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
+                            R.bool.def_user_setup_complete);
+                }
+            } finally {
+                if (stmt != null) stmt.close();
+            }
+            upgradeVersion = 93;
+        }
+
+        if (upgradeVersion == 93) {
+            // Redo this step, since somehow it didn't work the first time for some users
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                SQLiteStatement stmt = null;
+                try {
+                    // Migrate now-global settings
+                    String[] settingsToMove = hashsetToStringArray(SettingsProvider.sSystemGlobalKeys);
+                    moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_GLOBAL, settingsToMove, true);
+                    settingsToMove = hashsetToStringArray(SettingsProvider.sSecureGlobalKeys);
+                    moveSettingsToNewTable(db, TABLE_SECURE, TABLE_GLOBAL, settingsToMove, true);
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                    if (stmt != null) stmt.close();
+                }
+            }
+            upgradeVersion = 94;
+        }
+
+        if (upgradeVersion == 94) {
+            // Add wireless charging started sound setting
+            if (mUserHandle == UserHandle.USER_OWNER) {
+                db.beginTransaction();
+                SQLiteStatement stmt = null;
+                try {
+                    stmt = db.compileStatement("INSERT OR REPLACE INTO global(name,value)"
+                            + " VALUES(?,?);");
+                    loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND,
+                            R.string.def_wireless_charging_started_sound);
+                    db.setTransactionSuccessful();
+                } finally {
+                    db.endTransaction();
+                    if (stmt != null) stmt.close();
+                }
+            }
+            upgradeVersion = 95;
+        }
+
+        // *** Remember to update DATABASE_VERSION above!
+
+        if (upgradeVersion != currentVersion) {
+            Log.w(TAG, "Got stuck trying to upgrade from version " + upgradeVersion
+                    + ", must wipe the settings provider");
+            db.execSQL("DROP TABLE IF EXISTS global");
+            db.execSQL("DROP TABLE IF EXISTS globalIndex1");
+            db.execSQL("DROP TABLE IF EXISTS system");
+            db.execSQL("DROP INDEX IF EXISTS systemIndex1");
+            db.execSQL("DROP TABLE IF EXISTS secure");
+            db.execSQL("DROP INDEX IF EXISTS secureIndex1");
+            db.execSQL("DROP TABLE IF EXISTS gservices");
+            db.execSQL("DROP INDEX IF EXISTS gservicesIndex1");
+            db.execSQL("DROP TABLE IF EXISTS bluetooth_devices");
+            db.execSQL("DROP TABLE IF EXISTS bookmarks");
+            db.execSQL("DROP INDEX IF EXISTS bookmarksIndex1");
+            db.execSQL("DROP INDEX IF EXISTS bookmarksIndex2");
+            db.execSQL("DROP TABLE IF EXISTS favorites");
+            onCreate(db);
+
+            // Added for diagnosing settings.db wipes after the fact
+            String wipeReason = oldVersion + "/" + upgradeVersion + "/" + currentVersion;
+            db.execSQL("INSERT INTO secure(name,value) values('" +
+                    "wiped_db_reason" + "','" + wipeReason + "');");
+        }
+    }
+
+    private String[] hashsetToStringArray(HashSet<String> set) {
+        String[] array = new String[set.size()];
+        return set.toArray(array);
+    }
+
+    private void moveSettingsToNewTable(SQLiteDatabase db,
+            String sourceTable, String destTable,
+            String[] settingsToMove, boolean doIgnore) {
+        // Copy settings values from the source table to the dest, and remove from the source
+        SQLiteStatement insertStmt = null;
+        SQLiteStatement deleteStmt = null;
+
+        db.beginTransaction();
+        try {
+            insertStmt = db.compileStatement("INSERT "
+                    + (doIgnore ? " OR IGNORE " : "")
+                    + " INTO " + destTable + " (name,value) SELECT name,value FROM "
+                    + sourceTable + " WHERE name=?");
+            deleteStmt = db.compileStatement("DELETE FROM " + sourceTable + " WHERE name=?");
+
+            for (String setting : settingsToMove) {
+                insertStmt.bindString(1, setting);
+                insertStmt.execute();
+
+                deleteStmt.bindString(1, setting);
+                deleteStmt.execute();
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+            if (insertStmt != null) {
+                insertStmt.close();
+            }
+            if (deleteStmt != null) {
+                deleteStmt.close();
+            }
+        }
+    }
+
+    /**
+     * Move any settings with the given prefixes from the source table to the
+     * destination table.
+     */
+    private void movePrefixedSettingsToNewTable(
+            SQLiteDatabase db, String sourceTable, String destTable, String[] prefixesToMove) {
+        SQLiteStatement insertStmt = null;
+        SQLiteStatement deleteStmt = null;
+
+        db.beginTransaction();
+        try {
+            insertStmt = db.compileStatement("INSERT INTO " + destTable
+                    + " (name,value) SELECT name,value FROM " + sourceTable
+                    + " WHERE substr(name,0,?)=?");
+            deleteStmt = db.compileStatement(
+                    "DELETE FROM " + sourceTable + " WHERE substr(name,0,?)=?");
+
+            for (String prefix : prefixesToMove) {
+                insertStmt.bindLong(1, prefix.length() + 1);
+                insertStmt.bindString(2, prefix);
+                insertStmt.execute();
+
+                deleteStmt.bindLong(1, prefix.length() + 1);
+                deleteStmt.bindString(2, prefix);
+                deleteStmt.execute();
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+            if (insertStmt != null) {
+                insertStmt.close();
+            }
+            if (deleteStmt != null) {
+                deleteStmt.close();
+            }
+        }
+    }
+
+    private void upgradeLockPatternLocation(SQLiteDatabase db) {
+        Cursor c = db.query(TABLE_SYSTEM, new String[] {"_id", "value"}, "name='lock_pattern'",
+                null, null, null, null);
+        if (c.getCount() > 0) {
+            c.moveToFirst();
+            String lockPattern = c.getString(1);
+            if (!TextUtils.isEmpty(lockPattern)) {
+                // Convert lock pattern
+                try {
+                    LockPatternUtils lpu = new LockPatternUtils(mContext);
+                    List<LockPatternView.Cell> cellPattern =
+                            lpu.stringToPattern(lockPattern);
+                    lpu.saveLockPattern(cellPattern);
+                } catch (IllegalArgumentException e) {
+                    // Don't want corrupted lock pattern to hang the reboot process
+                }
+            }
+            c.close();
+            db.delete(TABLE_SYSTEM, "name='lock_pattern'", null);
+        } else {
+            c.close();
+        }
+    }
+
+    private void upgradeScreenTimeoutFromNever(SQLiteDatabase db) {
+        // See if the timeout is -1 (for "Never").
+        Cursor c = db.query(TABLE_SYSTEM, new String[] { "_id", "value" }, "name=? AND value=?",
+                new String[] { Settings.System.SCREEN_OFF_TIMEOUT, "-1" },
+                null, null, null);
+
+        SQLiteStatement stmt = null;
+        if (c.getCount() > 0) {
+            c.close();
+            try {
+                stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
+                        + " VALUES(?,?);");
+
+                // Set the timeout to 30 minutes in milliseconds
+                loadSetting(stmt, Settings.System.SCREEN_OFF_TIMEOUT,
+                        Integer.toString(30 * 60 * 1000));
+            } finally {
+                if (stmt != null) stmt.close();
+            }
+        } else {
+            c.close();
+        }
+    }
+
+    private void upgradeVibrateSettingFromNone(SQLiteDatabase db) {
+        int vibrateSetting = getIntValueFromSystem(db, Settings.System.VIBRATE_ON, 0);
+        // If the ringer vibrate value is invalid, set it to the default
+        if ((vibrateSetting & 3) == AudioManager.VIBRATE_SETTING_OFF) {
+            vibrateSetting = AudioService.getValueForVibrateSetting(0,
+                    AudioManager.VIBRATE_TYPE_RINGER, AudioManager.VIBRATE_SETTING_ONLY_SILENT);
+        }
+        // Apply the same setting to the notification vibrate value
+        vibrateSetting = AudioService.getValueForVibrateSetting(vibrateSetting,
+                AudioManager.VIBRATE_TYPE_NOTIFICATION, vibrateSetting);
+
+        SQLiteStatement stmt = null;
+        try {
+            stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
+                    + " VALUES(?,?);");
+            loadSetting(stmt, Settings.System.VIBRATE_ON, vibrateSetting);
+        } finally {
+            if (stmt != null)
+                stmt.close();
+        }
+    }
+
+    private void upgradeScreenTimeout(SQLiteDatabase db) {
+        // Change screen timeout to current default
+        db.beginTransaction();
+        SQLiteStatement stmt = null;
+        try {
+            stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
+                    + " VALUES(?,?);");
+            loadIntegerSetting(stmt, Settings.System.SCREEN_OFF_TIMEOUT,
+                    R.integer.def_screen_off_timeout);
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+            if (stmt != null)
+                stmt.close();
+        }
+    }
+
+    private void upgradeAutoBrightness(SQLiteDatabase db) {
+        db.beginTransaction();
+        try {
+            String value =
+                    mContext.getResources().getBoolean(
+                    R.bool.def_screen_brightness_automatic_mode) ? "1" : "0";
+            db.execSQL("INSERT OR REPLACE INTO system(name,value) values('" +
+                    Settings.System.SCREEN_BRIGHTNESS_MODE + "','" + value + "');");
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Loads the default set of bookmarked shortcuts from an xml file.
+     *
+     * @param db The database to write the values into
+     */
+    private void loadBookmarks(SQLiteDatabase db) {
+        ContentValues values = new ContentValues();
+
+        PackageManager packageManager = mContext.getPackageManager();
+        try {
+            XmlResourceParser parser = mContext.getResources().getXml(R.xml.bookmarks);
+            XmlUtils.beginDocument(parser, "bookmarks");
+
+            final int depth = parser.getDepth();
+            int type;
+
+            while (((type = parser.next()) != XmlPullParser.END_TAG ||
+                    parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
+
+                if (type != XmlPullParser.START_TAG) {
+                    continue;
+                }
+
+                String name = parser.getName();
+                if (!"bookmark".equals(name)) {
+                    break;
+                }
+
+                String pkg = parser.getAttributeValue(null, "package");
+                String cls = parser.getAttributeValue(null, "class");
+                String shortcutStr = parser.getAttributeValue(null, "shortcut");
+                String category = parser.getAttributeValue(null, "category");
+
+                int shortcutValue = shortcutStr.charAt(0);
+                if (TextUtils.isEmpty(shortcutStr)) {
+                    Log.w(TAG, "Unable to get shortcut for: " + pkg + "/" + cls);
+                    continue;
+                }
+
+                final Intent intent;
+                final String title;
+                if (pkg != null && cls != null) {
+                    ActivityInfo info = null;
+                    ComponentName cn = new ComponentName(pkg, cls);
+                    try {
+                        info = packageManager.getActivityInfo(cn, 0);
+                    } catch (PackageManager.NameNotFoundException e) {
+                        String[] packages = packageManager.canonicalToCurrentPackageNames(
+                                new String[] { pkg });
+                        cn = new ComponentName(packages[0], cls);
+                        try {
+                            info = packageManager.getActivityInfo(cn, 0);
+                        } catch (PackageManager.NameNotFoundException e1) {
+                            Log.w(TAG, "Unable to add bookmark: " + pkg + "/" + cls, e);
+                            continue;
+                        }
+                    }
+
+                    intent = new Intent(Intent.ACTION_MAIN, null);
+                    intent.addCategory(Intent.CATEGORY_LAUNCHER);
+                    intent.setComponent(cn);
+                    title = info.loadLabel(packageManager).toString();
+                } else if (category != null) {
+                    intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
+                    title = "";
+                } else {
+                    Log.w(TAG, "Unable to add bookmark for shortcut " + shortcutStr
+                            + ": missing package/class or category attributes");
+                    continue;
+                }
+
+                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                values.put(Settings.Bookmarks.INTENT, intent.toUri(0));
+                values.put(Settings.Bookmarks.TITLE, title);
+                values.put(Settings.Bookmarks.SHORTCUT, shortcutValue);
+                db.delete("bookmarks", "shortcut = ?",
+                        new String[] { Integer.toString(shortcutValue) });
+                db.insert("bookmarks", null, values);
+            }
+        } catch (XmlPullParserException e) {
+            Log.w(TAG, "Got execption parsing bookmarks.", e);
+        } catch (IOException e) {
+            Log.w(TAG, "Got execption parsing bookmarks.", e);
+        }
+    }
+
+    /**
+     * Loads the default volume levels. It is actually inserting the index of
+     * the volume array for each of the volume controls.
+     *
+     * @param db the database to insert the volume levels into
+     */
+    private void loadVolumeLevels(SQLiteDatabase db) {
+        SQLiteStatement stmt = null;
+        try {
+            stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
+                    + " VALUES(?,?);");
+
+            loadSetting(stmt, Settings.System.VOLUME_MUSIC,
+                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_MUSIC]);
+            loadSetting(stmt, Settings.System.VOLUME_FM,
+                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_FM]);					
+            loadSetting(stmt, Settings.System.VOLUME_RING,
+                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_RING]);
+            loadSetting(stmt, Settings.System.VOLUME_SYSTEM,
+                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_SYSTEM]);
+            loadSetting(
+                    stmt,
+                    Settings.System.VOLUME_VOICE,
+                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_VOICE_CALL]);
+            loadSetting(stmt, Settings.System.VOLUME_ALARM,
+                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_ALARM]);
+            loadSetting(
+                    stmt,
+                    Settings.System.VOLUME_NOTIFICATION,
+                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_NOTIFICATION]);
+            loadSetting(
+                    stmt,
+                    Settings.System.VOLUME_BLUETOOTH_SCO,
+                    AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
+
+            // By default:
+            // - ringtones, notification, system and music streams are affected by ringer mode
+            // on non voice capable devices (tablets)
+            // - ringtones, notification and system streams are affected by ringer mode
+            // on voice capable devices (phones)
+            int ringerModeAffectedStreams = (1 << AudioManager.STREAM_RING) |
+                                            (1 << AudioManager.STREAM_NOTIFICATION) |
+                                            (1 << AudioManager.STREAM_SYSTEM) |
+                                            (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
+            if (!mContext.getResources().getBoolean(
+                    com.android.internal.R.bool.config_voice_capable)) {
+                ringerModeAffectedStreams |= (1 << AudioManager.STREAM_MUSIC);
+            }
+            loadSetting(stmt, Settings.System.MODE_RINGER_STREAMS_AFFECTED,
+                    ringerModeAffectedStreams);
+
+            loadSetting(stmt, Settings.System.MUTE_STREAMS_AFFECTED,
+                    ((1 << AudioManager.STREAM_MUSIC) |
+                     (1 << AudioManager.STREAM_RING) |
+                     (1 << AudioManager.STREAM_NOTIFICATION) |
+                     (1 << AudioManager.STREAM_SYSTEM)));
+        } finally {
+            if (stmt != null) stmt.close();
+        }
+
+        loadVibrateWhenRingingSetting(db);
+    }
+
+    private void loadVibrateSetting(SQLiteDatabase db, boolean deleteOld) {
+        if (deleteOld) {
+            db.execSQL("DELETE FROM system WHERE name='" + Settings.System.VIBRATE_ON + "'");
+        }
+
+        SQLiteStatement stmt = null;
+        try {
+            stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
+                    + " VALUES(?,?);");
+
+            // Vibrate on by default for ringer, on for notification
+            int vibrate = 0;
+            vibrate = AudioService.getValueForVibrateSetting(vibrate,
+                    AudioManager.VIBRATE_TYPE_NOTIFICATION,
+                    AudioManager.VIBRATE_SETTING_ONLY_SILENT);
+            vibrate |= AudioService.getValueForVibrateSetting(vibrate,
+                    AudioManager.VIBRATE_TYPE_RINGER, AudioManager.VIBRATE_SETTING_ONLY_SILENT);
+            loadSetting(stmt, Settings.System.VIBRATE_ON, vibrate);
+        } finally {
+            if (stmt != null) stmt.close();
+        }
+    }
+
+    private void loadVibrateWhenRingingSetting(SQLiteDatabase db) {
+        // The default should be off. VIBRATE_SETTING_ONLY_SILENT should also be ignored here.
+        // Phone app should separately check whether AudioManager#getRingerMode() returns
+        // RINGER_MODE_VIBRATE, with which the device should vibrate anyway.
+        int vibrateSetting = getIntValueFromSystem(db, Settings.System.VIBRATE_ON,
+                AudioManager.VIBRATE_SETTING_OFF);
+        boolean vibrateWhenRinging = ((vibrateSetting & 3) == AudioManager.VIBRATE_SETTING_ON);
+
+        SQLiteStatement stmt = null;
+        try {
+            stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
+                    + " VALUES(?,?);");
+            loadSetting(stmt, Settings.System.VIBRATE_WHEN_RINGING, vibrateWhenRinging ? 1 : 0);
+        } finally {
+            if (stmt != null) stmt.close();
+        }
+    }
+
+    private void loadSettings(SQLiteDatabase db) {
+        loadSystemSettings(db);
+        loadSecureSettings(db);
+        // The global table only exists for the 'owner' user
+        if (mUserHandle == UserHandle.USER_OWNER) {
+            loadGlobalSettings(db);
+        }
+    }
+
+    private void loadSystemSettings(SQLiteDatabase db) {
+        SQLiteStatement stmt = null;
+        try {
+            stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
+                    + " VALUES(?,?);");
+
+            loadBooleanSetting(stmt, Settings.System.DIM_SCREEN,
+                    R.bool.def_dim_screen);
+            loadIntegerSetting(stmt, Settings.System.SCREEN_OFF_TIMEOUT,
+                    R.integer.def_screen_off_timeout);
+
+            // Set default cdma DTMF type
+            loadSetting(stmt, Settings.System.DTMF_TONE_TYPE_WHEN_DIALING, 0);
+
+            // Set default hearing aid
+            loadSetting(stmt, Settings.System.HEARING_AID, 0);
+
+            // Set default tty mode
+            loadSetting(stmt, Settings.System.TTY_MODE, 0);
+
+            // Set default noise suppression value
+            loadSetting(stmt, Settings.System.NOISE_SUPPRESSION, 0);
+
+            loadIntegerSetting(stmt, Settings.System.SCREEN_BRIGHTNESS,
+                    R.integer.def_screen_brightness);
+
+            loadBooleanSetting(stmt, Settings.System.SCREEN_BRIGHTNESS_MODE,
+                    R.bool.def_screen_brightness_automatic_mode);
+
+            loadDefaultAnimationSettings(stmt);
+
+            loadBooleanSetting(stmt, Settings.System.ACCELEROMETER_ROTATION,
+                    R.bool.def_accelerometer_rotation);
+
+            loadDefaultHapticSettings(stmt);
+
+            loadBooleanSetting(stmt, Settings.System.NOTIFICATION_LIGHT_PULSE,
+                    R.bool.def_notification_pulse);
+
+            loadUISoundEffectsSettings(stmt);
+
+            loadIntegerSetting(stmt, Settings.System.POINTER_SPEED,
+                    R.integer.def_pointer_speed);
+
+            loadIntegerSetting(stmt, Settings.System.STATUS_BAR_BATTERY,
+                    R.integer.def_battery_style);
+
+            loadIntegerSetting(stmt, Settings.System.STATUS_BAR_NOTIF_COUNT,
+                    R.integer.def_notif_count);
+
+            loadIntegerSetting(stmt, Settings.System.QS_QUICK_PULLDOWN,
+                    R.integer.def_qs_quick_pulldown);
+
+            loadStringSetting(stmt, Settings.System.LOCKSCREEN_TARGETS,
+                    R.string.def_lockscreen_targets);
+        } finally {
+            if (stmt != null) stmt.close();
+        }
+    }
+
+    private void loadUISoundEffectsSettings(SQLiteStatement stmt) {
+        loadBooleanSetting(stmt, Settings.System.DTMF_TONE_WHEN_DIALING,
+                R.bool.def_dtmf_tones_enabled);
+        loadBooleanSetting(stmt, Settings.System.SOUND_EFFECTS_ENABLED,
+                R.bool.def_sound_effects_enabled);
+        loadBooleanSetting(stmt, Settings.System.HAPTIC_FEEDBACK_ENABLED,
+                R.bool.def_haptic_feedback);
+        loadIntegerSetting(stmt, Settings.System.LOCKSCREEN_SOUNDS_ENABLED,
+            R.integer.def_lockscreen_sounds_enabled);
+    }
+
+    private void loadDefaultAnimationSettings(SQLiteStatement stmt) {
+        loadFractionSetting(stmt, Settings.System.WINDOW_ANIMATION_SCALE,
+                R.fraction.def_window_animation_scale, 1);
+        loadFractionSetting(stmt, Settings.System.TRANSITION_ANIMATION_SCALE,
+                R.fraction.def_window_transition_scale, 1);
+    }
+
+    private void loadDefaultHapticSettings(SQLiteStatement stmt) {
+        loadBooleanSetting(stmt, Settings.System.HAPTIC_FEEDBACK_ENABLED,
+                R.bool.def_haptic_feedback);
+    }
+
+    private void loadSecureSettings(SQLiteDatabase db) {
+        SQLiteStatement stmt = null;
+        try {
+            stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
+                    + " VALUES(?,?);");
+
+            loadStringSetting(stmt, Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
+                    R.string.def_location_providers_allowed);
+
+            String wifiWatchList = SystemProperties.get("ro.com.android.wifi-watchlist");
+            if (!TextUtils.isEmpty(wifiWatchList)) {
+                loadSetting(stmt, Settings.Secure.WIFI_WATCHDOG_WATCH_LIST, wifiWatchList);
+            }
+
+            // Don't do this.  The SystemServer will initialize ADB_ENABLED from a
+            // persistent system property instead.
+            //loadSetting(stmt, Settings.Secure.ADB_ENABLED, 0);
+
+            // Allow mock locations default, based on build
+            loadSetting(stmt, Settings.Secure.ALLOW_MOCK_LOCATION,
+                    "1".equals(SystemProperties.get("ro.allow.mock.location")) ? 1 : 0);
+
+            loadSecure35Settings(stmt);
+
+            loadBooleanSetting(stmt, Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND,
+                    R.bool.def_mount_play_notification_snd);
+
+            loadBooleanSetting(stmt, Settings.Secure.MOUNT_UMS_AUTOSTART,
+                    R.bool.def_mount_ums_autostart);
+
+            loadBooleanSetting(stmt, Settings.Secure.MOUNT_UMS_PROMPT,
+                    R.bool.def_mount_ums_prompt);
+
+            loadBooleanSetting(stmt, Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED,
+                    R.bool.def_mount_ums_notify_enabled);
+
+            loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SCRIPT_INJECTION,
+                    R.bool.def_accessibility_script_injection);
+
+            loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_WEB_CONTENT_KEY_BINDINGS,
+                    R.string.def_accessibility_web_content_key_bindings);
+
+            loadIntegerSetting(stmt, Settings.Secure.LONG_PRESS_TIMEOUT,
+                    R.integer.def_long_press_timeout_millis);
+
+            loadBooleanSetting(stmt, Settings.Secure.TOUCH_EXPLORATION_ENABLED,
+                    R.bool.def_touch_exploration_enabled);
+
+            loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD,
+                    R.bool.def_accessibility_speak_password);
+
+            loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
+                    R.string.def_accessibility_screen_reader_url);
+
+            if (SystemProperties.getBoolean("ro.lockscreen.disable.default", false) == true) {
+                loadSetting(stmt, Settings.System.LOCKSCREEN_DISABLED, "1");
+            } else {
+                loadBooleanSetting(stmt, Settings.System.LOCKSCREEN_DISABLED,
+                        R.bool.def_lockscreen_disabled);
+            }
+
+            loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ENABLED,
+                    com.android.internal.R.bool.config_dreamsEnabledByDefault);
+            loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK,
+                    com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
+            loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP,
+                    com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
+            loadStringSetting(stmt, Settings.Secure.SCREENSAVER_COMPONENTS,
+                    com.android.internal.R.string.config_dreamsDefaultComponent);
+            loadStringSetting(stmt, Settings.Secure.SCREENSAVER_DEFAULT_COMPONENT,
+                    com.android.internal.R.string.config_dreamsDefaultComponent);
+
+            loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
+                    R.bool.def_accessibility_display_magnification_enabled);
+
+            loadFractionSetting(stmt, Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
+                    R.fraction.def_accessibility_display_magnification_scale, 1);
+
+            loadBooleanSetting(stmt,
+                    Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_AUTO_UPDATE,
+                    R.bool.def_accessibility_display_magnification_auto_update);
+
+            loadBooleanSetting(stmt, Settings.Secure.USER_SETUP_COMPLETE,
+                    R.bool.def_user_setup_complete);
+        } finally {
+            if (stmt != null) stmt.close();
+        }
+    }
+
+    private void loadSecure35Settings(SQLiteStatement stmt) {
+        loadBooleanSetting(stmt, Settings.Secure.BACKUP_ENABLED,
+                R.bool.def_backup_enabled);
+
+        loadStringSetting(stmt, Settings.Secure.BACKUP_TRANSPORT,
+                R.string.def_backup_transport);
+    }
+
+    private void loadGlobalSettings(SQLiteDatabase db) {
+        SQLiteStatement stmt = null;
+        try {
+            stmt = db.compileStatement("INSERT OR IGNORE INTO global(name,value)"
+                    + " VALUES(?,?);");
+
+            // --- Previously in 'system'
+            loadBooleanSetting(stmt, Settings.Global.AIRPLANE_MODE_ON,
+                    R.bool.def_airplane_mode_on);
+
+            loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_RADIOS,
+                    R.string.def_airplane_mode_radios);
+
+            loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS,
+                    R.string.airplane_mode_toggleable_radios);
+
+            loadBooleanSetting(stmt, Settings.Global.ASSISTED_GPS_ENABLED,
+                    R.bool.assisted_gps_enabled);
+
+            loadBooleanSetting(stmt, Settings.Global.AUTO_TIME,
+                    R.bool.def_auto_time); // Sync time to NITZ
+
+            loadBooleanSetting(stmt, Settings.Global.AUTO_TIME_ZONE,
+                    R.bool.def_auto_time_zone); // Sync timezone to NITZ
+
+            loadSetting(stmt, Settings.Global.STAY_ON_WHILE_PLUGGED_IN,
+                    ("1".equals(SystemProperties.get("ro.kernel.qemu")) ||
+                        mContext.getResources().getBoolean(R.bool.def_stay_on_while_plugged_in))
+                     ? 1 : 0);
+
+            loadIntegerSetting(stmt, Settings.Global.WIFI_SLEEP_POLICY,
+                    R.integer.def_wifi_sleep_policy);
+
+            loadSetting(stmt, Settings.Global.MODE_RINGER,
+                    AudioManager.RINGER_MODE_NORMAL);
+
+            // --- Previously in 'secure'
+            loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE,
+                    R.bool.def_package_verifier_enable);
+
+            loadBooleanSetting(stmt, Settings.Global.WIFI_ON,
+                    R.bool.def_wifi_on);
+
+            loadBooleanSetting(stmt, Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
+                    R.bool.def_networks_available_notification_on);
+
+            loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON,
+                    R.bool.def_bluetooth_on);
+
+            // Enable or disable Cell Broadcast SMS
+            loadSetting(stmt, Settings.Global.CDMA_CELL_BROADCAST_SMS,
+                    RILConstants.CDMA_CELL_BROADCAST_SMS_DISABLED);
+
+            // Data roaming default, based on build
+            loadSetting(stmt, Settings.Global.DATA_ROAMING,
+                    "true".equalsIgnoreCase(
+                            SystemProperties.get("ro.com.android.dataroaming",
+                                    "false")) ? 1 : 0);
+
+            loadBooleanSetting(stmt, Settings.Global.DEVICE_PROVISIONED,
+                    R.bool.def_device_provisioned);
+
+            final int maxBytes = mContext.getResources().getInteger(
+                    R.integer.def_download_manager_max_bytes_over_mobile);
+            if (maxBytes > 0) {
+                loadSetting(stmt, Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE,
+                        Integer.toString(maxBytes));
+            }
+
+            final int recommendedMaxBytes = mContext.getResources().getInteger(
+                    R.integer.def_download_manager_recommended_max_bytes_over_mobile);
+            if (recommendedMaxBytes > 0) {
+                loadSetting(stmt, Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE,
+                        Integer.toString(recommendedMaxBytes));
+            }
+
+            // Mobile Data default, based on build
+            loadSetting(stmt, Settings.Global.MOBILE_DATA,
+                    "true".equalsIgnoreCase(
+                            SystemProperties.get("ro.com.android.mobiledata",
+                                    "true")) ? 1 : 0);
+
+            loadBooleanSetting(stmt, Settings.Global.NETSTATS_ENABLED,
+                    R.bool.def_netstats_enabled);
+
+            loadBooleanSetting(stmt, Settings.Global.INSTALL_NON_MARKET_APPS,
+                    R.bool.def_install_non_market_apps);
+
+            loadIntegerSetting(stmt, Settings.Global.NETWORK_PREFERENCE,
+                    R.integer.def_network_preference);
+
+            loadBooleanSetting(stmt, Settings.Global.USB_MASS_STORAGE_ENABLED,
+                    R.bool.def_usb_mass_storage_enabled);
+
+            loadIntegerSetting(stmt, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT,
+                    R.integer.def_max_dhcp_retries);
+
+            loadBooleanSetting(stmt, Settings.Global.WIFI_DISPLAY_ON,
+                    R.bool.def_wifi_display_on);
+
+            loadStringSetting(stmt, Settings.Global.LOCK_SOUND,
+                    R.string.def_lock_sound);
+            loadStringSetting(stmt, Settings.Global.UNLOCK_SOUND,
+                    R.string.def_unlock_sound);
+            loadIntegerSetting(stmt, Settings.Global.POWER_SOUNDS_ENABLED,
+                    R.integer.def_power_sounds_enabled);
+            loadStringSetting(stmt, Settings.Global.LOW_BATTERY_SOUND,
+                    R.string.def_low_battery_sound);
+            loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED,
+                    R.integer.def_dock_sounds_enabled);
+            loadStringSetting(stmt, Settings.Global.DESK_DOCK_SOUND,
+                    R.string.def_desk_dock_sound);
+            loadStringSetting(stmt, Settings.Global.DESK_UNDOCK_SOUND,
+                    R.string.def_desk_undock_sound);
+            loadStringSetting(stmt, Settings.Global.CAR_DOCK_SOUND,
+                    R.string.def_car_dock_sound);
+            loadStringSetting(stmt, Settings.Global.CAR_UNDOCK_SOUND,
+                    R.string.def_car_undock_sound);
+            loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND,
+                    R.string.def_wireless_charging_started_sound);
+
+            loadBooleanSetting(stmt, Settings.Global.POWER_NOTIFICATIONS_ENABLED,
+                    R.bool.def_power_notifications_enabled);
+            loadBooleanSetting(stmt, Settings.Global.POWER_NOTIFICATIONS_VIBRATE,
+                    R.bool.def_power_notifications_vibrate);
+            loadStringSetting(stmt, Settings.Global.POWER_NOTIFICATIONS_RINGTONE,
+                    R.string.def_power_notifications_ringtone);
+
+            loadSetting(stmt, Settings.Global.SET_INSTALL_LOCATION, 0);
+            loadSetting(stmt, Settings.Global.DEFAULT_INSTALL_LOCATION,
+                    PackageHelper.APP_INSTALL_AUTO);
+
+            // Set default cdma emergency tone
+            loadSetting(stmt, Settings.Global.EMERGENCY_TONE, 0);
+
+            // Set default cdma call auto retry
+            loadSetting(stmt, Settings.Global.CALL_AUTO_RETRY, 0);
+
+            // Set the preferred network mode to 0 = Global, CDMA default
+            int type;
+                type = SystemProperties.getInt("ro.telephony.default_network",
+                        RILConstants.PREFERRED_NETWORK_MODE);
+            loadSetting(stmt, Settings.Global.PREFERRED_NETWORK_MODE, type);
+
+            // --- New global settings start here
+        } finally {
+            if (stmt != null) stmt.close();
+        }
+    }
+
+    private void loadSetting(SQLiteStatement stmt, String key, Object value) {
+        stmt.bindString(1, key);
+        stmt.bindString(2, value.toString());
+        stmt.execute();
+    }
+
+    private void loadStringSetting(SQLiteStatement stmt, String key, int resid) {
+        loadSetting(stmt, key, mContext.getResources().getString(resid));
+    }
+
+    private void loadBooleanSetting(SQLiteStatement stmt, String key, int resid) {
+        loadSetting(stmt, key,
+                mContext.getResources().getBoolean(resid) ? "1" : "0");
+    }
+
+    private void loadIntegerSetting(SQLiteStatement stmt, String key, int resid) {
+        loadSetting(stmt, key,
+                Integer.toString(mContext.getResources().getInteger(resid)));
+    }
+
+    private void loadFractionSetting(SQLiteStatement stmt, String key, int resid, int base) {
+        loadSetting(stmt, key,
+                Float.toString(mContext.getResources().getFraction(resid, base, base)));
+    }
+
+    private int getIntValueFromSystem(SQLiteDatabase db, String name, int defaultValue) {
+        return getIntValueFromTable(db, TABLE_SYSTEM, name, defaultValue);
+    }
+
+    private int getIntValueFromTable(SQLiteDatabase db, String table, String name,
+            int defaultValue) {
+        String value = getStringValueFromTable(db, table, name, null);
+        return (value != null) ? Integer.parseInt(value) : defaultValue;
+    }
+
+    private String getStringValueFromTable(SQLiteDatabase db, String table, String name,
+            String defaultValue) {
+        Cursor c = null;
+        try {
+            c = db.query(table, new String[] { Settings.System.VALUE }, "name='" + name + "'",
+                    null, null, null, null);
+            if (c != null && c.moveToFirst()) {
+                String val = c.getString(0);
+                return val == null ? defaultValue : val;
+            }
+        } finally {
+            if (c != null) c.close();
+        }
+        return defaultValue;
+    }
+}
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index a5d0e72..37eec4d 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -1,5598 +1,5614 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * Copyright (C) 2012-2013 The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.internal.policy.impl;
-
-import android.app.ActivityManager;
-import android.app.ActivityManager.RunningAppProcessInfo;
-import android.app.ActivityManagerNative;
-import android.app.AppGlobals;
-import android.app.IActivityManager;
-import android.app.IUiModeManager;
-import android.app.KeyguardManager;
-import android.app.ProgressDialog;
-import android.app.SearchManager;
-import android.app.UiModeManager;
-import android.content.ActivityNotFoundException;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.ContextWrapper;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.ServiceConnection;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.content.res.CompatibilityInfo;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.database.ContentObserver;
-import android.graphics.PixelFormat;
-import android.graphics.Rect;
-import android.hardware.input.InputManager;
-import android.media.AudioManager;
-import android.media.IAudioService;
-import android.media.Ringtone;
-import android.media.RingtoneManager;
-import android.os.Bundle;
-import android.os.FactoryTest;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.IRemoteCallback;
-import android.os.Looper;
-import android.os.Message;
-import android.os.Messenger;
-import android.os.PowerManager;
-import android.os.Process;
-import android.os.RemoteException;
-import android.os.ServiceManager;
-import android.os.SystemClock;
-import android.os.SystemProperties;
-import android.os.UEventObserver;
-import android.os.UserHandle;
-import android.os.Vibrator;
-import android.provider.Settings;
-
-import com.android.internal.R;
-import com.android.internal.app.ThemeUtils;
-import com.android.internal.os.DeviceKeyHandler;
-import com.android.internal.os.IDeviceHandler;
-import com.android.internal.policy.PolicyManager;
-import com.android.internal.policy.impl.keyguard.KeyguardViewManager;
-import com.android.internal.policy.impl.keyguard.KeyguardViewMediator;
-import com.android.internal.statusbar.IStatusBarService;
-import com.android.internal.telephony.ITelephony;
-import com.android.internal.widget.PointerLocationView;
-
-import android.util.DisplayMetrics;
-import android.util.EventLog;
-import android.util.ExtendedPropertiesUtils;
-import android.util.Log;
-import android.util.Slog;
-import android.util.SparseArray;
-import android.view.Display;
-import android.view.Gravity;
-import android.view.HapticFeedbackConstants;
-import android.view.IApplicationToken;
-import android.view.IWindowManager;
-import android.view.InputChannel;
-import android.view.InputDevice;
-import android.view.InputEvent;
-import android.view.InputEventReceiver;
-import android.view.KeyCharacterMap;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.WindowManagerGlobal;
-import android.view.WindowOrientationListener;
-import android.view.Surface;
-import android.view.View;
-import android.view.ViewConfiguration;
-import android.view.Window;
-import android.view.WindowManager;
-import static android.view.WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW;
-import static android.view.WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN;
-import static android.view.WindowManager.LayoutParams.FLAG_FULLSCREEN;
-import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
-import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;
-import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS;
-import static android.view.WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;
-import static android.view.WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD;
-import static android.view.WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
-import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
-import static android.view.WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
-import static android.view.WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
-import static android.view.WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING;
-import static android.view.WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
-import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
-import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA_OVERLAY;
-import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;
-import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_STARTING;
-import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_SUB_PANEL;
-import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG;
-import static android.view.WindowManager.LayoutParams.TYPE_DISPLAY_OVERLAY;
-import static android.view.WindowManager.LayoutParams.TYPE_DRAG;
-import static android.view.WindowManager.LayoutParams.TYPE_DREAM;
-import static android.view.WindowManager.LayoutParams.TYPE_HIDDEN_NAV_CONSUMER;
-import static android.view.WindowManager.LayoutParams.TYPE_KEYGUARD;
-import static android.view.WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG;
-import static android.view.WindowManager.LayoutParams.TYPE_MAGNIFICATION_OVERLAY;
-import static android.view.WindowManager.LayoutParams.TYPE_PHONE;
-import static android.view.WindowManager.LayoutParams.TYPE_PRIORITY_PHONE;
-import static android.view.WindowManager.LayoutParams.TYPE_RECENTS_OVERLAY;
-import static android.view.WindowManager.LayoutParams.TYPE_SEARCH_BAR;
-import static android.view.WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY;
-import static android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR;
-import static android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL;
-import static android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR_SUB_PANEL;
-import static android.view.WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG;
-import static android.view.WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;
-import static android.view.WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
-import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD;
-import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG;
-import static android.view.WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY;
-import static android.view.WindowManager.LayoutParams.TYPE_TOAST;
-import static android.view.WindowManager.LayoutParams.TYPE_UNIVERSE_BACKGROUND;
-import static android.view.WindowManager.LayoutParams.TYPE_VOLUME_OVERLAY;
-import static android.view.WindowManager.LayoutParams.TYPE_WALLPAPER;
-import static android.view.WindowManager.LayoutParams.TYPE_POINTER;
-import static android.view.WindowManager.LayoutParams.TYPE_NAVIGATION_BAR;
-import static android.view.WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL;
-import static android.view.WindowManager.LayoutParams.TYPE_BOOT_PROGRESS;
-import android.view.WindowManagerPolicy;
-import static android.view.WindowManagerPolicy.WindowManagerFuncs.LID_ABSENT;
-import static android.view.WindowManagerPolicy.WindowManagerFuncs.LID_OPEN;
-import static android.view.WindowManagerPolicy.WindowManagerFuncs.LID_CLOSED;
-import android.view.KeyCharacterMap.FallbackAction;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
-import android.view.VolumePanel;
-import android.widget.Toast;
-import android.media.IAudioService;
-import android.media.AudioService;
-import android.media.AudioManager;
-
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.util.List;
-
-/**
- * WindowManagerPolicy implementation for the Android phone UI.  This
- * introduces a new method suffix, Lp, for an internal lock of the
- * PhoneWindowManager.  This is used to protect some internal state, and
- * can be acquired with either thw Lw and Li lock held, so has the restrictions
- * of both of those when held.
- */
-public class PhoneWindowManager implements WindowManagerPolicy {
-    static final String TAG = "WindowManager";
-    static final boolean DEBUG = false;
-    static final boolean localLOGV = false;
-    static final boolean DEBUG_LAYOUT = false;
-    static final boolean DEBUG_INPUT = false;
-    static final boolean DEBUG_STARTING_WINDOW = false;
-    static final boolean SHOW_STARTING_ANIMATIONS = true;
-    static final boolean SHOW_PROCESSES_ON_ALT_MENU = false;
-
-    // Whether to allow dock apps with METADATA_DOCK_HOME to temporarily take over the Home key.
-    // No longer recommended for desk docks; still useful in car docks.
-    static final boolean ENABLE_CAR_DOCK_HOME_CAPTURE = true;
-    static final boolean ENABLE_DESK_DOCK_HOME_CAPTURE = false;
-
-    static final int LONG_PRESS_POWER_NOTHING = 0;
-    static final int LONG_PRESS_POWER_GLOBAL_ACTIONS = 1;
-    static final int LONG_PRESS_POWER_SHUT_OFF = 2;
-    static final int LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM = 3;
-
-    // These need to match the documentation/constant in
-    // core/res/res/values/config.xml
-    static final int LONG_PRESS_HOME_NOTHING = 0;
-    static final int LONG_PRESS_HOME_RECENT_DIALOG = 1;
-    static final int LONG_PRESS_HOME_RECENT_SYSTEM_UI = 2;
-
-    static final int APPLICATION_MEDIA_SUBLAYER = -2;
-    static final int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1;
-    static final int APPLICATION_PANEL_SUBLAYER = 1;
-    static final int APPLICATION_SUB_PANEL_SUBLAYER = 2;
-
-    static public final String SYSTEM_DIALOG_REASON_KEY = "reason";
-    static public final String SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS = "globalactions";
-    static public final String SYSTEM_DIALOG_REASON_RECENT_APPS = "recentapps";
-    static public final String SYSTEM_DIALOG_REASON_HOME_KEY = "homekey";
-    static public final String SYSTEM_DIALOG_REASON_ASSIST = "assist";
-
-    // Available custom actions to perform on a key press.
-    // Must match values for KEY_HOME_LONG_PRESS_ACTION in:
-    // core/java/android/provider/Settings.java
-    private static final int KEY_ACTION_NOTHING = 0;
-    private static final int KEY_ACTION_MENU = 1;
-    private static final int KEY_ACTION_APP_SWITCH = 2;
-    private static final int KEY_ACTION_SEARCH = 3;
-    private static final int KEY_ACTION_VOICE_SEARCH = 4;
-    private static final int KEY_ACTION_IN_APP_SEARCH = 5;
-
-    // Masks for checking presence of hardware keys.
-    // Must match values in core/res/res/values/config.xml
-    private static final int KEY_MASK_HOME = 0x01;
-    private static final int KEY_MASK_BACK = 0x02;
-    private static final int KEY_MASK_MENU = 0x04;
-    private static final int KEY_MASK_ASSIST = 0x08;
-    private static final int KEY_MASK_APP_SWITCH = 0x10;
-
-    /**
-     * These are the system UI flags that, when changing, can cause the layout
-     * of the screen to change.
-     */
-    static final int SYSTEM_UI_CHANGING_LAYOUT =
-            View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN;
-
-    /* Table of Application Launch keys.  Maps from key codes to intent categories.
-     *
-     * These are special keys that are used to launch particular kinds of applications,
-     * such as a web browser.  HID defines nearly a hundred of them in the Consumer (0x0C)
-     * usage page.  We don't support quite that many yet...
-     */
-    static SparseArray<String> sApplicationLaunchKeyCategories;
-    static {
-        sApplicationLaunchKeyCategories = new SparseArray<String>();
-        sApplicationLaunchKeyCategories.append(
-                KeyEvent.KEYCODE_EXPLORER, Intent.CATEGORY_APP_BROWSER);
-        sApplicationLaunchKeyCategories.append(
-                KeyEvent.KEYCODE_ENVELOPE, Intent.CATEGORY_APP_EMAIL);
-        sApplicationLaunchKeyCategories.append(
-                KeyEvent.KEYCODE_CONTACTS, Intent.CATEGORY_APP_CONTACTS);
-        sApplicationLaunchKeyCategories.append(
-                KeyEvent.KEYCODE_CALENDAR, Intent.CATEGORY_APP_CALENDAR);
-        sApplicationLaunchKeyCategories.append(
-                KeyEvent.KEYCODE_MUSIC, Intent.CATEGORY_APP_MUSIC);
-        sApplicationLaunchKeyCategories.append(
-                KeyEvent.KEYCODE_CALCULATOR, Intent.CATEGORY_APP_CALCULATOR);
-    }
-
-    private final DeviceKeyHandler mDeviceKeyHandler;
-
-    /**
-     * Lock protecting internal state.  Must not call out into window
-     * manager with lock held.  (This lock will be acquired in places
-     * where the window manager is calling in with its own lock held.)
-     */
-    final Object mLock = new Object();
-
-    Context mContext;
-    Context mUiContext;
-    IWindowManager mWindowManager;
-    WindowManagerFuncs mWindowManagerFuncs;
-    PowerManager mPowerManager;
-    IStatusBarService mStatusBarService;
-    final Object mServiceAquireLock = new Object();
-    Vibrator mVibrator; // Vibrator for giving feedback of orientation changes
-    SearchManager mSearchManager;
-
-    // Vibrator pattern for haptic feedback of a long press.
-    long[] mLongPressVibePattern;
-
-    // Vibrator pattern for haptic feedback of virtual key press.
-    long[] mVirtualKeyVibePattern;
-    
-    // Vibrator pattern for a short vibration.
-    long[] mKeyboardTapVibePattern;
-
-    // Vibrator pattern for haptic feedback during boot when safe mode is disabled.
-    long[] mSafeModeDisabledVibePattern;
-    
-    // Vibrator pattern for haptic feedback during boot when safe mode is enabled.
-    long[] mSafeModeEnabledVibePattern;
-
-    /** If true, hitting shift & menu will broadcast Intent.ACTION_BUG_REPORT */
-    boolean mEnableShiftMenuBugReports = false;
-
-    boolean mHeadless;
-    boolean mSafeMode;
-    WindowState mStatusBar = null;
-    boolean mHasSystemNavBar;
-    int mStatusBarHeight;
-    WindowState mNavigationBar = null;
-    boolean mHasNavigationBar = false;
-    private boolean mNavBarFirstBootFlag = true;
-    boolean mCanHideNavigationBar = false;
-    boolean mNavigationBarCanMove = false; // can the navigation bar ever move to the side?
-    boolean mNavigationBarOnBottom = true; // is the navigation bar on the bottom *right now*?
-    int[] mNavigationBarHeightForRotation = new int[4];
-    int[] mNavigationBarWidthForRotation = new int[4];
-    int mUserNavBarHeight;
-    int mUserNavBarHeightLand;
-    int mUserNavBarWidth;
-
-    WindowState mKeyguard = null;
-    KeyguardViewMediator mKeyguardMediator;
-    GlobalActions mGlobalActions;
-    volatile boolean mPowerKeyHandled; // accessed from input reader and handler thread
-    boolean mPendingPowerKeyUpCanceled;
-    Handler mHandler;
-    WindowState mLastInputMethodWindow = null;
-    WindowState mLastInputMethodTargetWindow = null;
-
-    static final int RECENT_APPS_BEHAVIOR_SHOW_OR_DISMISS = 0;
-    static final int RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW = 1;
-    static final int RECENT_APPS_BEHAVIOR_DISMISS = 2;
-    static final int RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH = 3;
-
-    RecentApplicationsDialog mRecentAppsDialog;
-    int mRecentAppsDialogHeldModifiers;
-    boolean mLanguageSwitchKeyPressed;
-
-    int mLidState = LID_ABSENT;
-    boolean mHaveBuiltInKeyboard;
-
-    boolean mSystemReady;
-    boolean mSystemBooted;
-    boolean mHdmiPlugged;
-    boolean mWifiDisplayConnected;
-    int mUiMode;
-    int mDockMode = Intent.EXTRA_DOCK_STATE_UNDOCKED;
-    int mLidOpenRotation;
-    boolean mHasRemovableLid;
-    int mCarDockRotation;
-    int mDeskDockRotation;
-    int mHdmiRotation;
-    boolean mHdmiRotationLock;
-
-    int mUserRotationMode = WindowManagerPolicy.USER_ROTATION_FREE;
-    int mUserRotation = Surface.ROTATION_0;
-    int mUserRotationAngles = -1;
-    boolean mAccelerometerDefault;
-
-    int mAllowAllRotations = -1;
-    boolean mCarDockEnablesAccelerometer;
-    boolean mDeskDockEnablesAccelerometer;
-    int mLidKeyboardAccessibility;
-    int mLidNavigationAccessibility;
-    boolean mLidControlsSleep;
-    int mLongPressOnPowerBehavior = -1;
-    boolean mScreenOnEarly = false;
-    boolean mScreenOnFully = false;
-    boolean mOrientationSensorEnabled = false;
-    int mCurrentAppOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
-    boolean mHasSoftInput = false;
-    int mBackKillTimeout;
-    int mPointerLocationMode = 0; // guarded by mLock
-    int mDeviceHardwareKeys;
-    boolean mHasHomeKey;
-    boolean mHasMenuKey;
-    boolean mHasAssistKey;
-    boolean mHasAppSwitchKey;
-
-    // The last window we were told about in focusChanged.
-    WindowState mFocusedWindow;
-    IApplicationToken mFocusedApp;
-
-    // Behavior of volume wake
-    boolean mVolumeWakeScreen;
-
-    // Behavior of volbtn music controls
-    boolean mVolBtnMusicControls;
-    boolean mIsLongPress;
-
-    private static final class PointerLocationInputEventReceiver extends InputEventReceiver {
-        private final PointerLocationView mView;
-
-        public PointerLocationInputEventReceiver(InputChannel inputChannel, Looper looper,
-                PointerLocationView view) {
-            super(inputChannel, looper);
-            mView = view;
-        }
-
-        @Override
-        public void onInputEvent(InputEvent event) {
-            boolean handled = false;
-            try {
-                if (event instanceof MotionEvent
-                        && (event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
-                    final MotionEvent motionEvent = (MotionEvent)event;
-                    mView.addPointerEvent(motionEvent);
-                    handled = true;
-                }
-            } finally {
-                finishInputEvent(event, handled);
-            }
-        }
-    }
-
-    // Pointer location view state, only modified on the mHandler Looper.
-    PointerLocationInputEventReceiver mPointerLocationInputEventReceiver;
-    PointerLocationView mPointerLocationView;
-    InputChannel mPointerLocationInputChannel;
-
-    // The current size of the screen; really; (ir)regardless of whether the status
-    // bar can be hidden or not
-    int mUnrestrictedScreenLeft, mUnrestrictedScreenTop;
-    int mUnrestrictedScreenWidth, mUnrestrictedScreenHeight;
-    // The current size of the screen; these may be different than (0,0)-(dw,dh)
-    // if the status bar can't be hidden; in that case it effectively carves out
-    // that area of the display from all other windows.
-    int mRestrictedScreenLeft, mRestrictedScreenTop;
-    int mRestrictedScreenWidth, mRestrictedScreenHeight;
-    // During layout, the current screen borders accounting for any currently
-    // visible system UI elements.
-    int mSystemLeft, mSystemTop, mSystemRight, mSystemBottom;
-    // For applications requesting stable content insets, these are them.
-    int mStableLeft, mStableTop, mStableRight, mStableBottom;
-    // For applications requesting stable content insets but have also set the
-    // fullscreen window flag, these are the stable dimensions without the status bar.
-    int mStableFullscreenLeft, mStableFullscreenTop;
-    int mStableFullscreenRight, mStableFullscreenBottom;
-    // During layout, the current screen borders with all outer decoration
-    // (status bar, input method dock) accounted for.
-    int mCurLeft, mCurTop, mCurRight, mCurBottom;
-    // During layout, the frame in which content should be displayed
-    // to the user, accounting for all screen decoration except for any
-    // space they deem as available for other content.  This is usually
-    // the same as mCur*, but may be larger if the screen decor has supplied
-    // content insets.
-    int mContentLeft, mContentTop, mContentRight, mContentBottom;
-    // During layout, the current screen borders along which input method
-    // windows are placed.
-    int mDockLeft, mDockTop, mDockRight, mDockBottom;
-    // During layout, the layer at which the doc window is placed.
-    int mDockLayer;
-    // During layout, this is the layer of the status bar.
-    int mStatusBarLayer;
-    int mLastSystemUiFlags;
-    // Bits that we are in the process of clearing, so we want to prevent
-    // them from being set by applications until everything has been updated
-    // to have them clear.
-    int mResettingSystemUiFlags = 0;
-    // Bits that we are currently always keeping cleared.
-    int mForceClearedSystemUiFlags = 0;
-    // What we last reported to system UI about whether the compatibility
-    // menu needs to be displayed.
-    boolean mLastFocusNeedsMenu = false;
-
-    FakeWindow mHideNavFakeWindow = null;
-
-    static final Rect mTmpParentFrame = new Rect();
-    static final Rect mTmpDisplayFrame = new Rect();
-    static final Rect mTmpContentFrame = new Rect();
-    static final Rect mTmpVisibleFrame = new Rect();
-    static final Rect mTmpNavigationFrame = new Rect();
-    
-    WindowState mTopFullscreenOpaqueWindowState;
-    boolean mTopIsFullscreen;
-    boolean mForceStatusBar;
-    boolean mForceStatusBarFromKeyguard;
-    boolean mHideLockScreen;
-    boolean mForcingShowNavBar;
-    int mForcingShowNavBarLayer;
-
-    int mExpandedDesktopStyle = -1;
-    boolean mHideStatusBar;
-
-    // States of keyguard dismiss.
-    private static final int DISMISS_KEYGUARD_NONE = 0; // Keyguard not being dismissed.
-    private static final int DISMISS_KEYGUARD_START = 1; // Keyguard needs to be dismissed.
-    private static final int DISMISS_KEYGUARD_CONTINUE = 2; // Keyguard has been dismissed.
-    int mDismissKeyguard = DISMISS_KEYGUARD_NONE;
-
-    /** The window that is currently dismissing the keyguard. Dismissing the keyguard must only
-     * be done once per window. */
-    private WindowState mWinDismissingKeyguard;
-
-    boolean mShowingLockscreen;
-    boolean mShowingDream;
-    boolean mDreamingLockscreen;
-    boolean mHomePressed;
-    boolean mHomeLongPressed;
-    boolean mAppSwitchLongPressed;
-    Intent mHomeIntent;
-    Intent mCarDockIntent;
-    Intent mDeskDockIntent;
-    boolean mSearchKeyShortcutPending;
-    boolean mConsumeSearchKeyUp;
-    boolean mAssistKeyLongPressed;
-
-    // Used when key is pressed and performing non-default action
-    boolean mMenuDoCustomAction;
-
-    // Tracks user-customisable behavior for certain key events
-    private int mLongPressOnHomeBehavior = -1;
-    private int mPressOnMenuBehavior = -1;
-    private int mLongPressOnMenuBehavior = -1;
-    private int mPressOnAssistBehavior = -1;
-    private int mLongPressOnAssistBehavior = -1;
-    private int mPressOnAppSwitchBehavior = -1;
-    private int mLongPressOnAppSwitchBehavior = -1;
-
-    // To identify simulated keypresses, so we can perform
-    // the default action for that key
-    private boolean mIsVirtualKeypress;
-
-    // Tracks preloading of the recent apps screen
-    private boolean mRecentAppsPreloaded;
-
-    // support for activating the lock screen while the screen is on
-    boolean mAllowLockscreenWhenOn;
-    int mLockScreenTimeout;
-    boolean mLockScreenTimerActive;
-
-    // Behavior of ENDCALL Button.  (See Settings.System.END_BUTTON_BEHAVIOR.)
-    int mEndcallBehavior;
-
-    // Behavior of POWER button while in-call and screen on.
-    // (See Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR.)
-    int mIncallPowerBehavior;
-
-    Display mDisplay;
-
-    // Behavior of HOME button during incomming call ring.
-    // (See Settings.Secure.RING_HOME_BUTTON_BEHAVIOR.)
-    int mRingHomeBehavior;
-
-    int mLandscapeRotation = 0;  // default landscape rotation
-    int mSeascapeRotation = 0;   // "other" landscape rotation, 180 degrees from mLandscapeRotation
-    int mPortraitRotation = 0;   // default portrait rotation
-    int mUpsideDownRotation = 0; // "other" portrait rotation
-
-    // Screenshot trigger states
-    // Time to volume and power must be pressed within this interval of each other.
-    private static final long ACTION_CHORD_DEBOUNCE_DELAY_MILLIS = 150;
-    // Increase the chord delay when taking a screenshot from the keyguard
-    private static final float KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER = 2.5f;
-    private boolean mScreenshotChordEnabled;
-    private boolean mVolumeDownKeyTriggered;
-    private long mVolumeDownKeyTime;
-    private long mVolumeUpKeyTime;
-    private boolean mVolumeDownKeyConsumedByChord;
-    private boolean mVolumeUpKeyConsumedByChord;
-    private boolean mVolumeUpKeyTriggered;
-    private boolean mPowerKeyTriggered;
-    private long mPowerKeyTime;
-    private KeyguardManager mKeyguardManager;
-
-    private int mSystemDpi = 0;
-    private int mSystemUiDpi = 0;
-    private int mSystemUiLayout = 0;
-    private int mNavBarDpi = 0;
-    private int mStatusBarDpi = 0;
-
-    SettingsObserver mSettingsObserver;
-    ShortcutManager mShortcutManager;
-    PowerManager.WakeLock mBroadcastWakeLock;
-    boolean mHavePendingMediaKeyRepeatWithWakeLock;
-
-    // Fallback actions by key code.
-    private final SparseArray<KeyCharacterMap.FallbackAction> mFallbackActions =
-            new SparseArray<KeyCharacterMap.FallbackAction>();
-
-    private static final int MSG_ENABLE_POINTER_LOCATION = 1;
-    private static final int MSG_DISABLE_POINTER_LOCATION = 2;
-    private static final int MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK = 3;
-    private static final int MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK = 4;
-    private static final int MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK = 5;
-
-    private class PolicyHandler extends Handler {
-        @Override
-        public void handleMessage(Message msg) {
-            switch (msg.what) {
-                case MSG_ENABLE_POINTER_LOCATION:
-                    enablePointerLocation();
-                    break;
-                case MSG_DISABLE_POINTER_LOCATION:
-                    disablePointerLocation();
-                    break;
-                case MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK:
-                    dispatchMediaKeyWithWakeLock((KeyEvent)msg.obj);
-                    break;
-                case MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK:
-                    dispatchMediaKeyRepeatWithWakeLock((KeyEvent)msg.obj);
-                    break;
-                case MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK:
-                    mIsLongPress = true;
-                    dispatchMediaKeyWithWakeLockToAudioService((KeyEvent)msg.obj);
-                    dispatchMediaKeyWithWakeLockToAudioService(KeyEvent.changeAction((KeyEvent)msg.obj, KeyEvent.ACTION_UP));
-                    break;
-            }
-        }
-    }
-
-    private UEventObserver mHDMIObserver = new UEventObserver() {
-        @Override
-        public void onUEvent(UEventObserver.UEvent event) {
-            setHdmiPlugged("1".equals(event.get("SWITCH_STATE")));
-        }
-    };
-
-    class SettingsObserver extends ContentObserver {
-        SettingsObserver(Handler handler) {
-            super(handler);
-        }
-
-        void observe() {
-            // Observe all users' changes
-            ContentResolver resolver = mContext.getContentResolver();
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.END_BUTTON_BEHAVIOR), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.Secure.getUriFor(
-                    Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.Secure.getUriFor(
-                    Settings.Secure.RING_HOME_BUTTON_BEHAVIOR), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.VOLUME_WAKE_SCREEN), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.VOLBTN_MUSIC_CONTROLS), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.ACCELEROMETER_ROTATION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.USER_ROTATION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.SCREEN_OFF_TIMEOUT), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.POINTER_LOCATION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.Secure.getUriFor(
-                    Settings.Secure.DEFAULT_INPUT_METHOD), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    "fancy_rotation_anim"), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.EXPANDED_DESKTOP_STATE), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.EXPANDED_DESKTOP_STYLE), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.ACCELEROMETER_ROTATION_ANGLES), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.KEY_MENU_ACTION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.KEY_ASSIST_ACTION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.KEY_APP_SWITCH_ACTION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                    Settings.System.HARDWARE_KEY_REBINDING), false, this,
-                    UserHandle.USER_ALL);
-            resolver.registerContentObserver(Settings.System.getUriFor(
-                     Settings.System.HIDE_STATUSBAR), false, this);
-            updateSettings();
-        }
-
-        @Override
-        public void onChange(boolean selfChange) {
-            update(false);
-        }
-    }
-    
-    class MyOrientationListener extends WindowOrientationListener {
-        MyOrientationListener(Context context) {
-            super(context);
-        }
-        
-        @Override
-        public void onProposedRotationChanged(int rotation) {
-            if (localLOGV) Log.v(TAG, "onProposedRotationChanged, rotation=" + rotation);
-            updateRotation(false);
-        }
-    }
-    MyOrientationListener mOrientationListener;
-
-    public PhoneWindowManager(IDeviceHandler device) {
-        mDeviceKeyHandler = (device != null) ? device.getDeviceKeyHandler() : null;
-    }
-
-    IStatusBarService getStatusBarService() {
-        synchronized (mServiceAquireLock) {
-            if (mStatusBarService == null) {
-                mStatusBarService = IStatusBarService.Stub.asInterface(
-                        ServiceManager.getService("statusbar"));
-            }
-            return mStatusBarService;
-        }
-    }
-
-    /*
-     * We always let the sensor be switched on by default except when
-     * the user has explicitly disabled sensor based rotation or when the
-     * screen is switched off.
-     */
-    boolean needSensorRunningLp() {
-        if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR
-                || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR
-                || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT
-                || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE) {
-            // If the application has explicitly requested to follow the
-            // orientation, then we need to turn the sensor or.
-            return true;
-        }
-        if ((mCarDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_CAR) ||
-                (mDeskDockEnablesAccelerometer && (mDockMode == Intent.EXTRA_DOCK_STATE_DESK
-                        || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK
-                        || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK))) {
-            // enable accelerometer if we are docked in a dock that enables accelerometer
-            // orientation management,
-            return true;
-        }
-        if (mUserRotationMode == USER_ROTATION_LOCKED) {
-            // If the setting for using the sensor by default is enabled, then
-            // we will always leave it on.  Note that the user could go to
-            // a window that forces an orientation that does not use the
-            // sensor and in theory we could turn it off... however, when next
-            // turning it on we won't have a good value for the current
-            // orientation for a little bit, which can cause orientation
-            // changes to lag, so we'd like to keep it always on.  (It will
-            // still be turned off when the screen is off.)
-            return false;
-        }
-        return true;
-    }
-    
-    /*
-     * Various use cases for invoking this function
-     * screen turning off, should always disable listeners if already enabled
-     * screen turned on and current app has sensor based orientation, enable listeners 
-     * if not already enabled
-     * screen turned on and current app does not have sensor orientation, disable listeners if
-     * already enabled
-     * screen turning on and current app has sensor based orientation, enable listeners if needed
-     * screen turning on and current app has nosensor based orientation, do nothing
-     */
-    void updateOrientationListenerLp() {
-        if (!mOrientationListener.canDetectOrientation()) {
-            // If sensor is turned off or nonexistent for some reason
-            return;
-        }
-        //Could have been invoked due to screen turning on or off or
-        //change of the currently visible window's orientation
-        if (localLOGV) Log.v(TAG, "Screen status="+mScreenOnEarly+
-                ", current orientation="+mCurrentAppOrientation+
-                ", SensorEnabled="+mOrientationSensorEnabled);
-        boolean disable = true;
-        if (mScreenOnEarly) {
-            if (needSensorRunningLp()) {
-                disable = false;
-                //enable listener if not already enabled
-                if (!mOrientationSensorEnabled) {
-                    mOrientationListener.enable();
-                    if(localLOGV) Log.v(TAG, "Enabling listeners");
-                    mOrientationSensorEnabled = true;
-                }
-            } 
-        } 
-        //check if sensors need to be disabled
-        if (disable && mOrientationSensorEnabled) {
-            mOrientationListener.disable();
-            if(localLOGV) Log.v(TAG, "Disabling listeners");
-            mOrientationSensorEnabled = false;
-        }
-    }
-
-    private void interceptPowerKeyDown(boolean handled) {
-        mPowerKeyHandled = handled;
-        if (!handled) {
-            mHandler.postDelayed(mPowerLongPress, ViewConfiguration.getGlobalActionKeyTimeout());
-        }
-    }
-
-    private boolean interceptPowerKeyUp(boolean canceled) {
-        if (!mPowerKeyHandled) {
-            mHandler.removeCallbacks(mPowerLongPress);
-            return !canceled;
-        }
-        return false;
-    }
-
-    private void cancelPendingPowerKeyAction() {
-        if (!mPowerKeyHandled) {
-            mHandler.removeCallbacks(mPowerLongPress);
-        }
-        if (mPowerKeyTriggered) {
-            mPendingPowerKeyUpCanceled = true;
-        }
-    }
-
-    private void interceptScreenshotChord() {
-        if (mScreenshotChordEnabled
-                && mVolumeDownKeyTriggered && mPowerKeyTriggered && !mVolumeUpKeyTriggered) {
-            final long now = SystemClock.uptimeMillis();
-            if (now <= mVolumeDownKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS
-                    && now <= mPowerKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS) {
-                mVolumeDownKeyConsumedByChord = true;
-                cancelPendingPowerKeyAction();
-
-                mHandler.postDelayed(mScreenshotChordLongPress, getScreenshotChordLongPressDelay());
-            }
-        }
-    }
-
-    private long getScreenshotChordLongPressDelay() {
-        if (mKeyguardMediator.isShowing()) {
-            // Double the time it takes to take a screenshot from the keyguard
-            return (long) (KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER *
-                    ViewConfiguration.getGlobalActionKeyTimeout());
-        } else {
-            return ViewConfiguration.getGlobalActionKeyTimeout();
-        }
-    }
-
-    private void cancelPendingScreenshotChordAction() {
-        mHandler.removeCallbacks(mScreenshotChordLongPress);
-    }
-
-    private void interceptRingerChord() {
-        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered && mVolumeUpKeyTriggered) {
-            final long now = SystemClock.uptimeMillis();
-            if (now <= mVolumeDownKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS
-                    && now <= mVolumeUpKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS) {
-                mVolumeDownKeyConsumedByChord = true;
-                mVolumeUpKeyConsumedByChord = true;
-
-                mHandler.postDelayed(mRingerChordLongPress,
-                        ViewConfiguration.getGlobalActionKeyTimeout());
-            }
-        }
-    }
-
-    private void cancelPendingRingerChordAction() {
-        mHandler.removeCallbacks(mRingerChordLongPress);
-    }
-
-    private final Runnable mPowerLongPress = new Runnable() {
-        @Override
-        public void run() {
-            // The context isn't read
-            if (mLongPressOnPowerBehavior < 0) {
-                mLongPressOnPowerBehavior = mContext.getResources().getInteger(
-                        com.android.internal.R.integer.config_longPressOnPowerBehavior);
-            }
-            int resolvedBehavior = mLongPressOnPowerBehavior;
-            if (FactoryTest.isLongPressOnPowerOffEnabled()) {
-                resolvedBehavior = LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM;
-            }
-
-            switch (resolvedBehavior) {
-            case LONG_PRESS_POWER_NOTHING:
-                break;
-            case LONG_PRESS_POWER_GLOBAL_ACTIONS:
-                mPowerKeyHandled = true;
-                if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) {
-                    performAuditoryFeedbackForAccessibilityIfNeed();
-                }
-                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
-                showGlobalActionsDialog();
-                break;
-            case LONG_PRESS_POWER_SHUT_OFF:
-            case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:
-                mPowerKeyHandled = true;
-                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
-                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
-                mWindowManagerFuncs.shutdown(resolvedBehavior == LONG_PRESS_POWER_SHUT_OFF);
-                break;
-            }
-        }
-    };
-
-    private final Runnable mScreenshotChordLongPress = new Runnable() {
-        public void run() {
-            takeScreenshot();
-        }
-    };
-
-    private final Runnable mRingerChordLongPress = new Runnable() {
-        public void run() {
-            // Do the switch
-            final AudioManager am = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
-            final int ringerMode = am.getRingerMode();
-            final VolumePanel volumePanel = new VolumePanel(ThemeUtils.createUiContext(mContext),
-                                                              (AudioService) getAudioService());
-            if (ringerMode == AudioManager.RINGER_MODE_NORMAL) {
-                boolean vibrateSetting = Settings.System.getIntForUser(mContext.getContentResolver(),
-                        Settings.System.VIBRATE_WHEN_RINGING, 0, UserHandle.USER_CURRENT) != 0;
-                am.setRingerMode(vibrateSetting ? AudioManager.RINGER_MODE_VIBRATE :
-                                   AudioManager.RINGER_MODE_SILENT);
-            } else {
-                am.setRingerMode(AudioManager.RINGER_MODE_NORMAL);
-            }
-            volumePanel.postVolumeChanged(AudioManager.STREAM_RING,AudioManager.FLAG_SHOW_UI
-                                          | AudioManager.FLAG_VIBRATE);
-        }
-    };
-
-    Runnable mBackLongPress = new Runnable() {
-        public void run() {
-            try {
-                final Intent intent = new Intent(Intent.ACTION_MAIN);
-                String defaultHomePackage = "com.android.launcher";
-                intent.addCategory(Intent.CATEGORY_HOME);
-                final ResolveInfo res = mContext.getPackageManager().resolveActivity(intent, 0);
-                if (res.activityInfo != null && !res.activityInfo.packageName.equals("android")) {
-                    defaultHomePackage = res.activityInfo.packageName;
-                }
-                boolean targetKilled = false;
-                IActivityManager am = ActivityManagerNative.getDefault();
-                List<RunningAppProcessInfo> apps = am.getRunningAppProcesses();
-                for (RunningAppProcessInfo appInfo : apps) {
-                    int uid = appInfo.uid;
-                    // Make sure it's a foreground user application (not system,
-                    // root, phone, etc.)
-                    if (uid >= Process.FIRST_APPLICATION_UID && uid <= Process.LAST_APPLICATION_UID
-                            && appInfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
-                        if (appInfo.pkgList != null && (appInfo.pkgList.length > 0)) {
-                            for (String pkg : appInfo.pkgList) {
-                                if (!pkg.equals("com.android.systemui") && !pkg.equals(defaultHomePackage)) {
-                                    am.forceStopPackage(pkg, UserHandle.USER_CURRENT);
-                                    targetKilled = true;
-                                    break;
-                                }
-                            }
-                        } else {
-                            Process.killProcess(appInfo.pid);
-                            targetKilled = true;
-                        }
-                    }
-                    if (targetKilled) {
-                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
-                        Toast.makeText(mContext, R.string.app_killed_message, Toast.LENGTH_SHORT).show();
-                        break;
-                    }
-                }
-            } catch (RemoteException remoteException) {
-                // Do nothing; just let it go.
-            }
-        }
-    };
-
-    private KeyguardManager getKeyguardManager() {
-        if (mKeyguardManager == null) {
-            mKeyguardManager = (KeyguardManager) mContext.getSystemService(
-                    Context.KEYGUARD_SERVICE);
-        }
-        return mKeyguardManager;
-    }
-
-    void showGlobalActionsDialog() {
-        if (mGlobalActions == null) {
-            mGlobalActions = new GlobalActions(mContext, mWindowManagerFuncs);
-        }
-        final boolean keyguardLocked = getKeyguardManager().isKeyguardLocked();
-        mGlobalActions.showDialog(keyguardLocked, isDeviceProvisioned());
-        if (keyguardLocked) {
-            // since it took two seconds of long press to bring this up,
-            // poke the wake lock so they have some time to see the dialog.
-            mKeyguardMediator.userActivity();
-        }
-    }
-
-    boolean isDeviceProvisioned() {
-        return Settings.Global.getInt(
-                mContext.getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0) != 0;
-    }
-
-    private void triggerVirtualKeypress(final int keyCode) {
-        new Thread(new Runnable() {
-            public void run() {
-                InputManager im = InputManager.getInstance();
-                long now = SystemClock.uptimeMillis();
-
-                final KeyEvent downEvent = new KeyEvent(now, now, KeyEvent.ACTION_DOWN,
-                        keyCode, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0,
-                        KeyEvent.FLAG_FROM_SYSTEM, InputDevice.SOURCE_KEYBOARD);
-                final KeyEvent upEvent = KeyEvent.changeAction(downEvent, KeyEvent.ACTION_UP);
-
-                mIsVirtualKeypress = true;
-                im.injectInputEvent(downEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT);
-                im.injectInputEvent(upEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT);
-                mIsVirtualKeypress = false;
-            }
-        }).start();
-    }
-
-    private void performKeyAction(int behavior) {
-        switch (behavior) {
-            case KEY_ACTION_NOTHING:
-                break;
-            case KEY_ACTION_MENU:
-                triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
-                break;
-            case KEY_ACTION_APP_SWITCH:
-                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_RECENT_APPS);
-                try {
-                    IStatusBarService statusbar = getStatusBarService();
-                    if (statusbar != null) {
-                        statusbar.toggleRecentApps();
-                        mRecentAppsPreloaded = false;
-                    }
-                } catch (RemoteException e) {
-                    Slog.e(TAG, "RemoteException when showing recent apps", e);
-                    // re-acquire status bar service next time it is needed.
-                    mStatusBarService = null;
-                }
-                break;
-            case KEY_ACTION_SEARCH:
-                launchAssistAction();
-                break;
-            case KEY_ACTION_VOICE_SEARCH:
-                launchAssistLongPressAction();
-                break;
-            case KEY_ACTION_IN_APP_SEARCH:
-                triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
-                break;
-            default:
-                break;
-        }
-    }
-
-    private void preloadRecentApps() {
-        try {
-            IStatusBarService statusbar = getStatusBarService();
-            if (statusbar != null) {
-                statusbar.preloadRecentApps();
-                mRecentAppsPreloaded = true;
-            }
-        } catch (RemoteException e) {
-            Slog.e(TAG, "RemoteException when preloading recent apps", e);
-            // re-acquire status bar service next time it is needed.
-            mStatusBarService = null;
-        }
-    }
-
-    private void cancelPreloadRecentApps() {
-        try {
-            IStatusBarService statusbar = getStatusBarService();
-            if (statusbar != null) {
-                statusbar.cancelPreloadRecentApps();
-                mRecentAppsPreloaded = false;
-            }
-        } catch (RemoteException e) {
-            Slog.e(TAG, "RemoteException when showing recent apps", e);
-            // re-acquire status bar service next time it is needed.
-            mStatusBarService = null;
-        }
-    }
-
-    /**
-     * Create (if necessary) and show or dismiss the recent apps dialog according
-     * according to the requested behavior.
-     */
-    void showOrHideRecentAppsDialog(final int behavior) {
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                if (mRecentAppsDialog == null) {
-                    mRecentAppsDialog = new RecentApplicationsDialog(mContext);
-                }
-                if (mRecentAppsDialog.isShowing()) {
-                    switch (behavior) {
-                        case RECENT_APPS_BEHAVIOR_SHOW_OR_DISMISS:
-                        case RECENT_APPS_BEHAVIOR_DISMISS:
-                            mRecentAppsDialog.dismiss();
-                            break;
-                        case RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH:
-                            mRecentAppsDialog.dismissAndSwitch();
-                            break;
-                        case RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW:
-                        default:
-                            break;
-                    }
-                } else {
-                    switch (behavior) {
-                        case RECENT_APPS_BEHAVIOR_SHOW_OR_DISMISS:
-                            mRecentAppsDialog.show();
-                            break;
-                        case RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW:
-                            try {
-                                mWindowManager.setInTouchMode(false);
-                            } catch (RemoteException e) {
-                            }
-                            mRecentAppsDialog.show();
-                            break;
-                        case RECENT_APPS_BEHAVIOR_DISMISS:
-                        case RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH:
-                        default:
-                            break;
-                    }
-                }
-            }
-        });
-    }
-
-    /** {@inheritDoc} */
-    public void init(Context context, IWindowManager windowManager,
-            WindowManagerFuncs windowManagerFuncs) {
-        mContext = context;
-        mWindowManager = windowManager;
-        mWindowManagerFuncs = windowManagerFuncs;
-        mHeadless = "1".equals(SystemProperties.get("ro.config.headless", "0"));
-        if (!mHeadless) {
-            // don't create KeyguardViewMediator if headless
-            mKeyguardMediator = new KeyguardViewMediator(context, null);
-        }
-        mHandler = new PolicyHandler();
-        mOrientationListener = new MyOrientationListener(mContext);
-        try {
-            mOrientationListener.setCurrentRotation(windowManager.getRotation());
-        } catch (RemoteException ex) { }
-
-        updateHybridLayout();
-
-        mSettingsObserver = new SettingsObserver(mHandler);
-        mSettingsObserver.observe();
-
-        // SystemUI reboot
-        mContext.getContentResolver().registerContentObserver(
-                Settings.System.getUriFor(Settings.System.USER_INTERFACE_STATE), false, new ContentObserver(new Handler()) {
-            @Override
-            public void onChange(boolean selfChange) {
-                // Return for reset triggers
-                if (Settings.System.getInt(mContext.getContentResolver(), 
-                    Settings.System.USER_INTERFACE_STATE, 0) == 0) {
-                    return;
-                }
-
-                // Update layout
-                update(true);
-                
-                // Reset trigger
-                Settings.System.putInt(mContext.getContentResolver(), Settings.System.USER_INTERFACE_STATE, 0);
-            }});
-
-        // Expanded desktop
-        mContext.getContentResolver().registerContentObserver(
-                Settings.System.getUriFor(Settings.System.EXPANDED_DESKTOP_STATE),
-                    false, new ContentObserver(new Handler()) {
-            @Override
-            public void onChange(boolean selfChange) {
-                updateHybridLayout();
-                update(false);
-
-                // Restart default launcher activity
-                final PackageManager mPm = mContext.getPackageManager();
-                final ActivityManager am = (ActivityManager)mContext
-                        .getSystemService(Context.ACTIVITY_SERVICE);
-                final Intent intent = new Intent(Intent.ACTION_MAIN); 
-                intent.addCategory(Intent.CATEGORY_HOME); 
-                final ResolveInfo res = mPm.resolveActivity(intent, 0);
-                // Launcher is running task #1
-                List<ActivityManager.RunningTaskInfo> runningTasks = am.getRunningTasks(1);
-                if (runningTasks != null) {
-                    for (ActivityManager.RunningTaskInfo task : runningTasks) {
-                        String packageName = task.baseActivity.getPackageName();
-                        if (packageName.equals(res.activityInfo.packageName)) {
-                            closeApplication(packageName);
-                            break;
-                        }
-                    }
-                }
-            }
-        });
-
-        mShortcutManager = new ShortcutManager(context, mHandler);
-        mShortcutManager.observe();
-        mUiMode = context.getResources().getInteger(
-                com.android.internal.R.integer.config_defaultUiModeType);
-        mHomeIntent =  new Intent(Intent.ACTION_MAIN, null);
-        mHomeIntent.addCategory(Intent.CATEGORY_HOME);
-        mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
-        mCarDockIntent =  new Intent(Intent.ACTION_MAIN, null);
-        mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
-        mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
-        mDeskDockIntent =  new Intent(Intent.ACTION_MAIN, null);
-        mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
-        mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
-
-        mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
-        mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
-                "PhoneWindowManager.mBroadcastWakeLock");
-        mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
-        mLidOpenRotation = readRotation(
-                com.android.internal.R.integer.config_lidOpenRotation);
-        mCarDockRotation = readRotation(
-                com.android.internal.R.integer.config_carDockRotation);
-        mDeskDockRotation = readRotation(
-                com.android.internal.R.integer.config_deskDockRotation);
-        mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_carDockEnablesAccelerometer);
-        mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
-        mLidKeyboardAccessibility = mContext.getResources().getInteger(
-                com.android.internal.R.integer.config_lidKeyboardAccessibility);
-        mLidNavigationAccessibility = mContext.getResources().getInteger(
-                com.android.internal.R.integer.config_lidNavigationAccessibility);
-        mLidControlsSleep = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_lidControlsSleep);
-        mHasRemovableLid = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_hasRemovableLid);
-        mBackKillTimeout = mContext.getResources().getInteger(
-                com.android.internal.R.integer.config_backKillTimeout);
-        mDeviceHardwareKeys = mContext.getResources().getInteger(
-                com.android.internal.R.integer.config_deviceHardwareKeys);
-        mHasHomeKey = ((mDeviceHardwareKeys & KEY_MASK_HOME) != 0);
-        mHasMenuKey = ((mDeviceHardwareKeys & KEY_MASK_MENU) != 0);
-        mHasAssistKey = ((mDeviceHardwareKeys & KEY_MASK_ASSIST) != 0);
-        mHasAppSwitchKey = ((mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) != 0);
-
-        // register for dock events
-        IntentFilter filter = new IntentFilter();
-        filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
-        filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
-        filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
-        filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
-        filter.addAction(Intent.ACTION_DOCK_EVENT);
-        Intent intent = context.registerReceiver(mDockReceiver, filter);
-        if (intent != null) {
-            // Retrieve current sticky dock event broadcast.
-            mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
-                    Intent.EXTRA_DOCK_STATE_UNDOCKED);
-        }
-
-        // register for dream-related broadcasts
-        filter = new IntentFilter();
-        filter.addAction(Intent.ACTION_DREAMING_STARTED);
-        filter.addAction(Intent.ACTION_DREAMING_STOPPED);
-        context.registerReceiver(mDreamReceiver, filter);
-
-        // register for multiuser-relevant broadcasts
-        filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
-        context.registerReceiver(mMultiuserReceiver, filter);
-
-        mVibrator = (Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
-        // register for WIFI Display intents
-        IntentFilter wifiDisplayFilter = new IntentFilter(
-                                                Intent.ACTION_WIFI_DISPLAY_VIDEO);
-        Intent wifidisplayIntent = context.registerReceiver(
-                                      mWifiDisplayReceiver, wifiDisplayFilter);
-
-        mLongPressVibePattern = getLongIntArray(mContext.getResources(),
-                com.android.internal.R.array.config_longPressVibePattern);
-        mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(),
-                com.android.internal.R.array.config_virtualKeyVibePattern);
-        mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(),
-                com.android.internal.R.array.config_keyboardTapVibePattern);
-        mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(),
-                com.android.internal.R.array.config_safeModeDisabledVibePattern);
-        mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(),
-                com.android.internal.R.array.config_safeModeEnabledVibePattern);
-
-        mScreenshotChordEnabled = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_enableScreenshotChord);
-
-        // Controls rotation and the like.
-        initializeHdmiState();
-
-        // Match current screen state.
-        if (mPowerManager.isScreenOn()) {
-            screenTurningOn(null);
-        } else {
-            screenTurnedOff(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
-        }
-    }
-
-    public void setInitialDisplaySize(Display display, int width, int height, int density) {
-        mDisplay = display;
-
-        int shortSize, longSize;
-        if (width > height) {
-            shortSize = height;
-            longSize = width;
-            mLandscapeRotation = Surface.ROTATION_0;
-            mSeascapeRotation = Surface.ROTATION_180;
-            if (mContext.getResources().getBoolean(
-                    com.android.internal.R.bool.config_reverseDefaultRotation)) {
-                mPortraitRotation = Surface.ROTATION_90;
-                mUpsideDownRotation = Surface.ROTATION_270;
-            } else {
-                mPortraitRotation = Surface.ROTATION_270;
-                mUpsideDownRotation = Surface.ROTATION_90;
-            }
-        } else {
-            shortSize = width;
-            longSize = height;
-            mPortraitRotation = Surface.ROTATION_0;
-            mUpsideDownRotation = Surface.ROTATION_180;
-            if (mContext.getResources().getBoolean(
-                    com.android.internal.R.bool.config_reverseDefaultRotation)) {
-                mLandscapeRotation = Surface.ROTATION_270;
-                mSeascapeRotation = Surface.ROTATION_90;
-            } else {
-                mLandscapeRotation = Surface.ROTATION_90;
-                mSeascapeRotation = Surface.ROTATION_270;
-            }
-        }
-
-        getDimensions();
-   
-        // For demo purposes, allow the rotation of the HDMI display to be controlled.
-        // By default, HDMI locks rotation to landscape.
-        if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
-            mHdmiRotation = mPortraitRotation;
-        } else {
-            mHdmiRotation = mLandscapeRotation;
-        }
-        mHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", true);
-    }
-
-    private void closeApplication(String packageName) {
-        try {
-            ActivityManagerNative.getDefault().killApplicationProcess(
-                    packageName, AppGlobals.getPackageManager().getPackageUid(
-                    packageName, UserHandle.myUserId()));
-        } catch (RemoteException e) {
-            // Good luck next time!
-        }
-    }
-   
-    private void update(boolean updateUi) {
-        if (updateUi) {
-            updateHybridLayout();
-        }
-
-        updateSettings();
-        updateRotation(false);
-
-        if (updateUi) closeApplication("com.android.systemui");
-    }
-    
-    private int updateHybridLayout() {
-        boolean expDesktop = Settings.System.getInt(mContext.getContentResolver(),
-                    Settings.System.EXPANDED_DESKTOP_STATE, 0) == 1;
-        int oldSystemUILayout = mSystemUiLayout == 0 ?
-                ExtendedPropertiesUtils.getActualProperty("com.android.systemui.layout") : mSystemUiLayout;
-        ExtendedPropertiesUtils.refreshProperties();
-        mSystemDpi = ExtendedPropertiesUtils.getActualProperty("android.dpi");
-        mSystemUiDpi = ExtendedPropertiesUtils.getActualProperty("com.android.systemui.dpi");
-        mSystemUiLayout = ExtendedPropertiesUtils.getActualProperty("com.android.systemui.layout");
-        int mNavigationBarPercent = expDesktop ? 0 : Integer.parseInt(ExtendedPropertiesUtils.getProperty("com.android.systemui.navbar.dpi", "100"));
-        mNavBarDpi = mNavigationBarPercent * mSystemUiDpi / 100;
-        int mStatusBarPercent = Integer.parseInt(ExtendedPropertiesUtils.getProperty("com.android.systemui.statusbar.dpi", "100"));
-        mStatusBarDpi = mStatusBarPercent * mSystemUiDpi / 100;
-        return oldSystemUILayout;
-    }
-
-    public void updateSettings() {
-        DisplayMetrics metrics = new DisplayMetrics();
-        WindowManager wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
-        wm.getDefaultDisplay().getMetrics(metrics);
-        int density = metrics.densityDpi;
-        ContentResolver resolver = mContext.getContentResolver();
-        boolean updateRotation = false, updateDisplayMetrics = false;
-        synchronized (mLock) {
-            mEndcallBehavior = Settings.System.getIntForUser(resolver,
-                    Settings.System.END_BUTTON_BEHAVIOR,
-                    Settings.System.END_BUTTON_BEHAVIOR_DEFAULT,
-                    UserHandle.USER_CURRENT);
-            mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver,
-                    Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR,
-                    Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT,
-                    UserHandle.USER_CURRENT);
-            mRingHomeBehavior = Settings.Secure.getIntForUser(resolver,
-                    Settings.Secure.RING_HOME_BUTTON_BEHAVIOR,
-                    Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_DEFAULT,
-                    UserHandle.USER_CURRENT);
-            mVolumeWakeScreen = (Settings.System.getIntForUser(resolver,
-                    Settings.System.VOLUME_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1);
-            mVolBtnMusicControls = (Settings.System.getIntForUser(resolver,
-                    Settings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
-
-            mHasNavigationBar = !mHasSystemNavBar;
-
-            getDimensions();
-
-            boolean keyRebindingEnabled = Settings.System.getIntForUser(resolver,
-                    Settings.System.HARDWARE_KEY_REBINDING, 0, UserHandle.USER_CURRENT) == 1;
-
-            if (!keyRebindingEnabled) {
-                if (mHasHomeKey) {
-                    if (mHasAppSwitchKey) {
-                        mLongPressOnHomeBehavior = KEY_ACTION_NOTHING;
-                    } else {
-                        mLongPressOnHomeBehavior = KEY_ACTION_APP_SWITCH;
-                    }
-                }
-                if (mHasMenuKey) {
-                    mPressOnMenuBehavior = KEY_ACTION_MENU;
-                    if (mHasAssistKey) {
-                        mLongPressOnMenuBehavior = KEY_ACTION_NOTHING;
-                    } else {
-                        mLongPressOnMenuBehavior = KEY_ACTION_SEARCH;
-                    }
-                }
-                if (mHasAssistKey) {
-                    mPressOnAssistBehavior = KEY_ACTION_SEARCH;
-                    mLongPressOnAssistBehavior = KEY_ACTION_VOICE_SEARCH;
-                }
-                if (mHasAppSwitchKey) {
-                    mPressOnAppSwitchBehavior = KEY_ACTION_APP_SWITCH;
-                    mLongPressOnAppSwitchBehavior = KEY_ACTION_NOTHING;
-                }
-            } else {
-                if (mHasHomeKey) {
-                    if (mHasAppSwitchKey) {
-                        mLongPressOnHomeBehavior = Settings.System.getIntForUser(resolver,
-                                Settings.System.KEY_HOME_LONG_PRESS_ACTION,
-                                KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
-                    } else {
-                        mLongPressOnHomeBehavior = Settings.System.getIntForUser(resolver,
-                                Settings.System.KEY_HOME_LONG_PRESS_ACTION,
-                                KEY_ACTION_APP_SWITCH, UserHandle.USER_CURRENT);
-                    }
-                }
-                if (mHasMenuKey) {
-                    mPressOnMenuBehavior = Settings.System.getIntForUser(resolver,
-                            Settings.System.KEY_MENU_ACTION,
-                            KEY_ACTION_MENU, UserHandle.USER_CURRENT);
-                    if (mHasAssistKey) {
-                        mLongPressOnMenuBehavior = Settings.System.getIntForUser(resolver,
-                                Settings.System.KEY_MENU_LONG_PRESS_ACTION,
-                                KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
-                    } else {
-                        mLongPressOnMenuBehavior = Settings.System.getIntForUser(resolver,
-                                Settings.System.KEY_MENU_LONG_PRESS_ACTION,
-                                KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
-                    }
-                }
-                if (mHasAssistKey) {
-                    mPressOnAssistBehavior = Settings.System.getIntForUser(resolver,
-                            Settings.System.KEY_ASSIST_ACTION,
-                            KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
-                    mLongPressOnAssistBehavior = Settings.System.getIntForUser(resolver,
-                            Settings.System.KEY_ASSIST_LONG_PRESS_ACTION,
-                            KEY_ACTION_VOICE_SEARCH, UserHandle.USER_CURRENT);
-                }
-                if (mHasAppSwitchKey) {
-                    mPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver,
-                            Settings.System.KEY_APP_SWITCH_ACTION,
-                            KEY_ACTION_APP_SWITCH, UserHandle.USER_CURRENT);
-                    mLongPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver,
-                            Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION,
-                            KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
-                }
-            }
-
-            int expandedDesktopStyle = Settings.System.getIntForUser(resolver,
-                    Settings.System.EXPANDED_DESKTOP_STYLE, 0, UserHandle.USER_CURRENT);
-            if (Settings.System.getIntForUser(resolver,
-                        Settings.System.EXPANDED_DESKTOP_STATE, 0, UserHandle.USER_CURRENT) == 0) {
-                expandedDesktopStyle = 0;
-            }
-
-            if (expandedDesktopStyle != mExpandedDesktopStyle) {
-                mExpandedDesktopStyle = expandedDesktopStyle;
-                updateDisplayMetrics = true;
-            }
-
-            // Configure rotation lock.
-            int userRotation = Settings.System.getIntForUser(resolver,
-                    Settings.System.USER_ROTATION, Surface.ROTATION_0,
-                    UserHandle.USER_CURRENT);
-
-            if (mUserRotation != userRotation) {
-                mUserRotation = userRotation;
-                updateRotation = true;
-            }
-            int userRotationMode = Settings.System.getIntForUser(resolver,
-                    Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ?
-                            WindowManagerPolicy.USER_ROTATION_FREE :
-                                    WindowManagerPolicy.USER_ROTATION_LOCKED;
-            if (mUserRotationMode != userRotationMode) {
-                mUserRotationMode = userRotationMode;
-                updateRotation = true;
-                updateOrientationListenerLp();
-            }
-
-            mUserRotationAngles = Settings.System.getIntForUser(resolver,
-                    Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1, UserHandle.USER_CURRENT);
-
-            if (mSystemReady) {
-                int pointerLocation = Settings.System.getIntForUser(resolver,
-                        Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
-                if (mPointerLocationMode != pointerLocation) {
-                    mPointerLocationMode = pointerLocation;
-                    mHandler.sendEmptyMessage(pointerLocation != 0 ?
-                            MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
-                }
-            }
-
-            // Use screen off timeout setting as the timeout for the lockscreen
-            mLockScreenTimeout = Settings.System.getIntForUser(resolver,
-                    Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
-            String imId = Settings.Secure.getStringForUser(resolver,
-                    Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
-            boolean hasSoftInput = imId != null && imId.length() > 0;
-            if (mHasSoftInput != hasSoftInput) {
-                mHasSoftInput = hasSoftInput;
-                updateRotation = true;
-            }
-        }
-
-        if (updateRotation) {
-            updateRotation(true);
-        } else if (updateDisplayMetrics) {
-            updateDisplayMetrics();
-        }
-                
-    }
-    
-    public void getDimensions(){
-        float statusBarHeight = ((float)mContext.getResources().getDimensionPixelSize(
-                com.android.internal.R.dimen.status_bar_height) *
-                DisplayMetrics.DENSITY_DEVICE / mSystemDpi) /
-                DisplayMetrics.DENSITY_DEVICE * mStatusBarDpi;
-   
-        float navigationBarHeight = ((float)mContext.getResources().getDimensionPixelSize(
-                com.android.internal.R.dimen.navigation_bar_height) *
-                DisplayMetrics.DENSITY_DEVICE / mSystemDpi) /
-                DisplayMetrics.DENSITY_DEVICE * mNavBarDpi;
-   
-        float navigationBarWidth = ((float)mContext.getResources().getDimensionPixelSize(
-                com.android.internal.R.dimen.navigation_bar_width) *
-                DisplayMetrics.DENSITY_DEVICE / mSystemDpi) /
-                DisplayMetrics.DENSITY_DEVICE * mNavBarDpi;
-   
-        float navigationBarHeightLandscape = ((float)mContext.getResources().getDimensionPixelSize(
-                com.android.internal.R.dimen.navigation_bar_height_landscape) *
-                DisplayMetrics.DENSITY_DEVICE / mSystemDpi) /
-                DisplayMetrics.DENSITY_DEVICE * mNavBarDpi;
-   
-        mStatusBarHeight = Math.round(statusBarHeight);
-   
-        // Height of the navigation bar when presented horizontally at bottom
-        mNavigationBarHeightForRotation[mPortraitRotation] = 
-                mNavigationBarHeightForRotation[mUpsideDownRotation] = Math.round(navigationBarHeight);
-   
-        mNavigationBarHeightForRotation[mLandscapeRotation] =
-                mNavigationBarHeightForRotation[mSeascapeRotation] = Math.round(navigationBarHeightLandscape);
-   
-        // Width of the navigation bar when presented vertically along one side
-        mNavigationBarWidthForRotation[mPortraitRotation] = mNavigationBarWidthForRotation[mUpsideDownRotation] =
-                mNavigationBarWidthForRotation[mLandscapeRotation] = mNavigationBarWidthForRotation[mSeascapeRotation] =
-                Math.round(navigationBarWidth);
-   
-        if (mSystemUiLayout < 600) {
-            // 0-599dp: "phone" UI with a separate status & navigation bar
-            mHasSystemNavBar = false;
-            mNavigationBarCanMove = true;
-        } else if (mSystemUiLayout < 720) {
-            // 600+dp: "phone" UI with modifications for larger screens
-            mHasSystemNavBar = false;
-            mNavigationBarCanMove = false;
-        } else if (mSystemUiLayout == 1000) {
-            // 1000dp: "tablet" UI with a single combined status & navigation bar
-            mHasSystemNavBar = true;
-            mNavigationBarCanMove = false;
-        }
-   
-        mHasNavigationBar = !mHasSystemNavBar;
-   
-        if (mHasSystemNavBar) {
-            mCanHideNavigationBar = true;
-        } else if (mHasNavigationBar) {
-            // The navigation bar is at the right in landscape; it seems always
-            // useful to hide it for showing a video.
-            mCanHideNavigationBar = true;
-        } else {
-            mCanHideNavigationBar = false;
-        }
-   
-        // In case that we removed nav bar, set all sizes to 0 again
-        if(!mHasNavigationBar){
-            if(!mHasSystemNavBar || Settings.System.getInt(mContext.getContentResolver(),
-                    Settings.System.EXPANDED_DESKTOP_STATE, 0) == 1){
-                mNavigationBarWidthForRotation[mPortraitRotation]
-                           = mNavigationBarWidthForRotation[mUpsideDownRotation]
-                           = mNavigationBarWidthForRotation[mLandscapeRotation]
-                           = mNavigationBarWidthForRotation[mSeascapeRotation]
-                           = mNavigationBarHeightForRotation[mPortraitRotation]
-                           = mNavigationBarHeightForRotation[mUpsideDownRotation]
-                           = mNavigationBarHeightForRotation[mLandscapeRotation]
-                           = mNavigationBarHeightForRotation[mSeascapeRotation] = 0;
-            }
-        }
-    }
-
-    private void enablePointerLocation() {
-        if (mPointerLocationView == null) {
-            mPointerLocationView = new PointerLocationView(mContext);
-            mPointerLocationView.setPrintCoords(false);
-
-            WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
-                    WindowManager.LayoutParams.MATCH_PARENT,
-                    WindowManager.LayoutParams.MATCH_PARENT);
-            lp.type = WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY;
-            lp.flags = WindowManager.LayoutParams.FLAG_FULLSCREEN
-                    | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
-                    | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
-                    | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
-            if (ActivityManager.isHighEndGfx()) {
-                lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
-                lp.privateFlags |=
-                        WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;
-            }
-            lp.format = PixelFormat.TRANSLUCENT;
-            lp.setTitle("PointerLocation");
-            WindowManager wm = (WindowManager)
-                    mContext.getSystemService(Context.WINDOW_SERVICE);
-            lp.inputFeatures |= WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;
-            wm.addView(mPointerLocationView, lp);
-
-            mPointerLocationInputChannel =
-                    mWindowManagerFuncs.monitorInput("PointerLocationView");
-            mPointerLocationInputEventReceiver =
-                    new PointerLocationInputEventReceiver(mPointerLocationInputChannel,
-                            Looper.myLooper(), mPointerLocationView);
-        }
-    }
-
-    private void disablePointerLocation() {
-        if (mPointerLocationInputEventReceiver != null) {
-            mPointerLocationInputEventReceiver.dispose();
-            mPointerLocationInputEventReceiver = null;
-        }
-
-        if (mPointerLocationInputChannel != null) {
-            mPointerLocationInputChannel.dispose();
-            mPointerLocationInputChannel = null;
-        }
-
-        if (mPointerLocationView != null) {
-            WindowManager wm = (WindowManager)
-                    mContext.getSystemService(Context.WINDOW_SERVICE);
-            wm.removeView(mPointerLocationView);
-            mPointerLocationView = null;
-        }
-    }
-
-    private int readRotation(int resID) {
-        try {
-            int rotation = mContext.getResources().getInteger(resID);
-            switch (rotation) {
-                case 0:
-                    return Surface.ROTATION_0;
-                case 90:
-                    return Surface.ROTATION_90;
-                case 180:
-                    return Surface.ROTATION_180;
-                case 270:
-                    return Surface.ROTATION_270;
-            }
-        } catch (Resources.NotFoundException e) {
-            // fall through
-        }
-        return -1;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public int checkAddPermission(WindowManager.LayoutParams attrs) {
-        int type = attrs.type;
-        
-        if (type < WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW
-                || type > WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) {
-            return WindowManagerGlobal.ADD_OKAY;
-        }
-        String permission = null;
-        switch (type) {
-            case TYPE_TOAST:
-                // XXX right now the app process has complete control over
-                // this...  should introduce a token to let the system
-                // monitor/control what they are doing.
-                break;
-            case TYPE_DREAM:
-            case TYPE_INPUT_METHOD:
-            case TYPE_WALLPAPER:
-                // The window manager will check these.
-                break;
-            case TYPE_PHONE:
-            case TYPE_PRIORITY_PHONE:
-            case TYPE_SYSTEM_ALERT:
-            case TYPE_SYSTEM_ERROR:
-            case TYPE_SYSTEM_OVERLAY:
-                permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW;
-                break;
-            default:
-                permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;
-        }
-        if (permission != null) {
-            if (mContext.checkCallingOrSelfPermission(permission)
-                    != PackageManager.PERMISSION_GRANTED) {
-                return WindowManagerGlobal.ADD_PERMISSION_DENIED;
-            }
-        }
-        return WindowManagerGlobal.ADD_OKAY;
-    }
-
-    @Override
-    public boolean checkShowToOwnerOnly(WindowManager.LayoutParams attrs) {
-
-        // If this switch statement is modified, modify the comment in the declarations of
-        // the type in {@link WindowManager.LayoutParams} as well.
-        switch (attrs.type) {
-            default:
-                // These are the windows that by default are shown only to the user that created
-                // them. If this needs to be overridden, set
-                // {@link WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS} in
-                // {@link WindowManager.LayoutParams}. Note that permission
-                // {@link android.Manifest.permission.INTERNAL_SYSTEM_WINDOW} is required as well.
-                if ((attrs.privateFlags & PRIVATE_FLAG_SHOW_FOR_ALL_USERS) == 0) {
-                    return true;
-                }
-                break;
-
-            // These are the windows that by default are shown to all users. However, to
-            // protect against spoofing, check permissions below.
-            case TYPE_APPLICATION_STARTING:
-            case TYPE_BOOT_PROGRESS:
-            case TYPE_DISPLAY_OVERLAY:
-            case TYPE_HIDDEN_NAV_CONSUMER:
-            case TYPE_KEYGUARD:
-            case TYPE_KEYGUARD_DIALOG:
-            case TYPE_MAGNIFICATION_OVERLAY:
-            case TYPE_NAVIGATION_BAR:
-            case TYPE_NAVIGATION_BAR_PANEL:
-            case TYPE_PHONE:
-            case TYPE_POINTER:
-            case TYPE_PRIORITY_PHONE:
-            case TYPE_RECENTS_OVERLAY:
-            case TYPE_SEARCH_BAR:
-            case TYPE_STATUS_BAR:
-            case TYPE_STATUS_BAR_PANEL:
-            case TYPE_STATUS_BAR_SUB_PANEL:
-            case TYPE_SYSTEM_DIALOG:
-            case TYPE_UNIVERSE_BACKGROUND:
-            case TYPE_VOLUME_OVERLAY:
-                break;
-        }
-
-        // Check if third party app has set window to system window type.
-        return mContext.checkCallingOrSelfPermission(
-                android.Manifest.permission.INTERNAL_SYSTEM_WINDOW)
-                        != PackageManager.PERMISSION_GRANTED;
-    }
-
-    public void adjustWindowParamsLw(WindowManager.LayoutParams attrs) {
-        switch (attrs.type) {
-            case TYPE_SYSTEM_OVERLAY:
-            case TYPE_SECURE_SYSTEM_OVERLAY:
-            case TYPE_TOAST:
-                // These types of windows can't receive input events.
-                attrs.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
-                        | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
-                attrs.flags &= ~WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
-                break;
-        }
-    }
-    
-    void readLidState() {
-        mLidState = mWindowManagerFuncs.getLidState();
-    }
-    
-    private boolean isHidden(int accessibilityMode) {
-        switch (accessibilityMode) {
-            case 1:
-                return mLidState == LID_CLOSED;
-            case 2:
-                return mLidState == LID_OPEN;
-            default:
-                return false;
-        }
-    }
-
-    private boolean isBuiltInKeyboardVisible() {
-        return mHaveBuiltInKeyboard && !isHidden(mLidKeyboardAccessibility);
-    }
-
-    /** {@inheritDoc} */
-    public void adjustConfigurationLw(Configuration config, int keyboardPresence,
-            int navigationPresence) {
-        mHaveBuiltInKeyboard = (keyboardPresence & PRESENCE_INTERNAL) != 0;
-
-        readLidState();
-        applyLidSwitchState();
-
-        if (config.keyboard == Configuration.KEYBOARD_NOKEYS
-                || (keyboardPresence == PRESENCE_INTERNAL
-                        && isHidden(mLidKeyboardAccessibility))) {
-            config.hardKeyboardHidden = Configuration.HARDKEYBOARDHIDDEN_YES;
-            if (!mHasSoftInput) {
-                config.keyboardHidden = Configuration.KEYBOARDHIDDEN_YES;
-            }
-        }
-
-        if (config.navigation == Configuration.NAVIGATION_NONAV
-                || (navigationPresence == PRESENCE_INTERNAL
-                        && isHidden(mLidNavigationAccessibility))) {
-            config.navigationHidden = Configuration.NAVIGATIONHIDDEN_YES;
-        }
-    }
-
-    /** {@inheritDoc} */
-    public int windowTypeToLayerLw(int type) {
-        if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
-            return 2;
-        }
-        switch (type) {
-        case TYPE_UNIVERSE_BACKGROUND:
-            return 1;
-        case TYPE_WALLPAPER:
-            // wallpaper is at the bottom, though the window manager may move it.
-            return 2;
-        case TYPE_PHONE:
-            return 3;
-        case TYPE_SEARCH_BAR:
-            return 4;
-        case TYPE_RECENTS_OVERLAY:
-        case TYPE_SYSTEM_DIALOG:
-            return 5;
-        case TYPE_TOAST:
-            // toasts and the plugged-in battery thing
-            return 6;
-        case TYPE_PRIORITY_PHONE:
-            // SIM errors and unlock.  Not sure if this really should be in a high layer.
-            return 7;
-        case TYPE_DREAM:
-            // used for Dreams (screensavers with TYPE_DREAM windows)
-            return 8;
-        case TYPE_SYSTEM_ALERT:
-            // like the ANR / app crashed dialogs
-            return 9;
-        case TYPE_INPUT_METHOD:
-            // on-screen keyboards and other such input method user interfaces go here.
-            return 10;
-        case TYPE_INPUT_METHOD_DIALOG:
-            // on-screen keyboards and other such input method user interfaces go here.
-            return 11;
-        case TYPE_KEYGUARD:
-            // the keyguard; nothing on top of these can take focus, since they are
-            // responsible for power management when displayed.
-            return 12;
-        case TYPE_KEYGUARD_DIALOG:
-            return 13;
-        case TYPE_STATUS_BAR_SUB_PANEL:
-            return 14;
-        case TYPE_STATUS_BAR:
-            return 15;
-        case TYPE_STATUS_BAR_PANEL:
-            return 16;
-        case TYPE_VOLUME_OVERLAY:
-            // the on-screen volume indicator and controller shown when the user
-            // changes the device volume
-            return 17;
-        case TYPE_SYSTEM_OVERLAY:
-            // the on-screen volume indicator and controller shown when the user
-            // changes the device volume
-            return 18;
-        case TYPE_NAVIGATION_BAR:
-            // the navigation bar, if available, shows atop most things
-            return 19;
-        case TYPE_NAVIGATION_BAR_PANEL:
-            // some panels (e.g. search) need to show on top of the navigation bar
-            return 20;
-        case TYPE_SYSTEM_ERROR:
-            // system-level error dialogs
-            return 21;
-        case TYPE_MAGNIFICATION_OVERLAY:
-            // used to highlight the magnified portion of a display
-            return 22;
-        case TYPE_DISPLAY_OVERLAY:
-            // used to simulate secondary display devices
-            return 23;
-        case TYPE_DRAG:
-            // the drag layer: input for drag-and-drop is associated with this window,
-            // which sits above all other focusable windows
-            return 24;
-        case TYPE_SECURE_SYSTEM_OVERLAY:
-            return 25;
-        case TYPE_BOOT_PROGRESS:
-            return 26;
-        case TYPE_POINTER:
-            // the (mouse) pointer layer
-            return 27;
-        case TYPE_HIDDEN_NAV_CONSUMER:
-            return 28;
-        }
-        Log.e(TAG, "Unknown window type: " + type);
-        return 2;
-    }
-
-    /** {@inheritDoc} */
-    public int subWindowTypeToLayerLw(int type) {
-        switch (type) {
-        case TYPE_APPLICATION_PANEL:
-        case TYPE_APPLICATION_ATTACHED_DIALOG:
-            return APPLICATION_PANEL_SUBLAYER;
-        case TYPE_APPLICATION_MEDIA:
-            return APPLICATION_MEDIA_SUBLAYER;
-        case TYPE_APPLICATION_MEDIA_OVERLAY:
-            return APPLICATION_MEDIA_OVERLAY_SUBLAYER;
-        case TYPE_APPLICATION_SUB_PANEL:
-            return APPLICATION_SUB_PANEL_SUBLAYER;
-        }
-        Log.e(TAG, "Unknown sub-window type: " + type);
-        return 0;
-    }
-
-    public int getMaxWallpaperLayer() {
-        return windowTypeToLayerLw(TYPE_STATUS_BAR);
-    }
-
-    public int getAboveUniverseLayer() {
-        return windowTypeToLayerLw(TYPE_SYSTEM_ERROR);
-    }
-
-    public boolean hasSystemNavBar() {
-        return mHasSystemNavBar;
-    }
-
-    public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation) {
-        if (mHasNavigationBar && !expandedDesktopHidesNavigationBar()) {
-            // For a basic navigation bar, when we are in landscape mode we place
-            // the navigation bar to the side.
-            if (mNavigationBarCanMove && fullWidth > fullHeight) {
-                return fullWidth - mNavigationBarWidthForRotation[rotation];
-            }
-        }
-        return fullWidth;
-    }
-
-    public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation) {
-        if (mHasSystemNavBar && !expandedDesktopHidesNavigationBar()) {
-            // For the system navigation bar, we always place it at the bottom.
-            return fullHeight - mNavigationBarHeightForRotation[rotation];
-        }
-        if (mHasNavigationBar && !expandedDesktopHidesNavigationBar()) {
-            // For a basic navigation bar, when we are in portrait mode we place
-            // the navigation bar to the bottom.
-            if (!mNavigationBarCanMove || fullWidth < fullHeight) {
-                return fullHeight - mNavigationBarHeightForRotation[rotation];
-            }
-        }
-        return fullHeight;
-    }
-
-    public int getConfigDisplayWidth(int fullWidth, int fullHeight, int rotation) {
-        return getNonDecorDisplayWidth(fullWidth, fullHeight, rotation);
-    }
-
-    public int getConfigDisplayHeight(int fullWidth, int fullHeight, int rotation) {
-        // If we don't have a system nav bar, then there is a separate status
-        // bar at the top of the display.  We don't count that as part of the
-        // fixed decor, since it can hide; however, for purposes of configurations,
-        // we do want to exclude it since applications can't generally use that part
-        // of the screen.
-        if (!mHasSystemNavBar) {
-            return getNonDecorDisplayHeight(fullWidth, fullHeight, rotation) - mStatusBarHeight;
-        }
-        return getNonDecorDisplayHeight(fullWidth, fullHeight, rotation);
-    }
-
-    @Override
-    public int getWallpaperHeight(int rotation) {
-        return getWallpaperTop(rotation)+getWallpaperBottom(rotation);
-    }
-
-    @Override
-    public int getWallpaperWidth(int rotation) {
-        return getWallpaperLeft(rotation)+getWallpaperRight(rotation);
-    }
-
-    @Override
-    public int getWallpaperTop(int rotation) {
-        return mUnrestrictedScreenTop;
-    }
-
-    @Override
-    public int getWallpaperLeft(int rotation) {
-        return mUnrestrictedScreenLeft;
-    }
-
-    @Override
-    public int getWallpaperBottom(int rotation) {
-        return mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
-    }
-
-    @Override
-    public int getWallpaperRight(int rotation) {
-        return mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-    }
-
-    @Override
-    public boolean doesForceHide(WindowState win, WindowManager.LayoutParams attrs) {
-        return attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD;
-    }
-
-    @Override
-    public boolean canBeForceHidden(WindowState win, WindowManager.LayoutParams attrs) {
-        switch (attrs.type) {
-            case TYPE_STATUS_BAR:
-            case TYPE_NAVIGATION_BAR:
-            case TYPE_WALLPAPER:
-            case TYPE_DREAM:
-            case TYPE_UNIVERSE_BACKGROUND:
-            case TYPE_KEYGUARD:
-                return false;
-            default:
-                return true;
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public View addStartingWindow(IBinder appToken, String packageName, int theme,
-            CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes,
-            int icon, int windowFlags) {
-        if (!SHOW_STARTING_ANIMATIONS) {
-            return null;
-        }
-        if (packageName == null) {
-            return null;
-        }
-
-        WindowManager wm = null;
-        View view = null;
-
-        try {
-            Context context = mContext;
-            if (DEBUG_STARTING_WINDOW) Slog.d(TAG, "addStartingWindow " + packageName
-                    + ": nonLocalizedLabel=" + nonLocalizedLabel + " theme="
-                    + Integer.toHexString(theme));
-
-            try {
-                context = context.createPackageContext(packageName, 0);
-                if (theme != context.getThemeResId()) {
-                    context.setTheme(theme);
-                }
-            } catch (PackageManager.NameNotFoundException e) {
-                // Ignore
-            }
-
-            // Construct the Toast
-
-            Window win = PolicyManager.makeNewWindow(context);
-            final TypedArray ta = win.getWindowStyle();
-            if (ta.getBoolean(
-                        com.android.internal.R.styleable.Window_windowDisablePreview, false)
-                || ta.getBoolean(
-                        com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
-                return null;
-            }
-
-            Resources r = context.getResources();
-            win.setTitle(r.getText(labelRes, nonLocalizedLabel));
-
-            win.setType(
-                WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);
-            // Force the window flags: this is a fake window, so it is not really
-            // touchable or focusable by the user.  We also add in the ALT_FOCUSABLE_IM
-            // flag because we do know that the next window will take input
-            // focus, so we want to get the IME window up on top of us right away.
-            win.setFlags(
-                windowFlags|
-                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|
-                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|
-                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
-                windowFlags|
-                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|
-                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|
-                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
-
-            if (!compatInfo.supportsScreen()) {
-                win.addFlags(WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW);
-            }
-
-            win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,
-                    WindowManager.LayoutParams.MATCH_PARENT);
-
-            final WindowManager.LayoutParams params = win.getAttributes();
-            params.token = appToken;
-            params.packageName = packageName;
-            params.windowAnimations = win.getWindowStyle().getResourceId(
-                    com.android.internal.R.styleable.Window_windowAnimationStyle, 0);
-            params.privateFlags |=
-                    WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED;
-            params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
-            params.setTitle("Starting " + packageName);
-
-            wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
-            view = win.getDecorView();
-
-            if (win.isFloating()) {
-                // Whoops, there is no way to display an animation/preview
-                // of such a thing!  After all that work...  let's skip it.
-                // (Note that we must do this here because it is in
-                // getDecorView() where the theme is evaluated...  maybe
-                // we should peek the floating attribute from the theme
-                // earlier.)
-                return null;
-            }
-
-            if (DEBUG_STARTING_WINDOW) Slog.d(
-                TAG, "Adding starting window for " + packageName
-                + " / " + appToken + ": "
-                + (view.getParent() != null ? view : null));
-
-            wm.addView(view, params);
-
-            // Only return the view if it was successfully added to the
-            // window manager... which we can tell by it having a parent.
-            return view.getParent() != null ? view : null;
-        } catch (WindowManager.BadTokenException e) {
-            // ignore
-            Log.w(TAG, appToken + " already running, starting window not displayed");
-        } catch (RuntimeException e) {
-            // don't crash if something else bad happens, for example a
-            // failure loading resources because we are loading from an app
-            // on external storage that has been unmounted.
-            Log.w(TAG, appToken + " failed creating starting window", e);
-        } finally {
-            if (view != null && view.getParent() == null) {
-                Log.w(TAG, "view not successfully added to wm, removing view");
-                wm.removeViewImmediate(view);
-            }
-        }
-
-        return null;
-    }
-
-    /** {@inheritDoc} */
-    public void removeStartingWindow(IBinder appToken, View window) {
-        if (DEBUG_STARTING_WINDOW) {
-            RuntimeException e = new RuntimeException("here");
-            e.fillInStackTrace();
-            Log.v(TAG, "Removing starting window for " + appToken + ": " + window, e);
-        }
-
-        if (window != null) {
-            WindowManager wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
-            wm.removeView(window);
-        }
-    }
-
-    /**
-     * Preflight adding a window to the system.
-     * 
-     * Currently enforces that three window types are singletons:
-     * <ul>
-     * <li>STATUS_BAR_TYPE</li>
-     * <li>KEYGUARD_TYPE</li>
-     * </ul>
-     * 
-     * @param win The window to be added
-     * @param attrs Information about the window to be added
-     * 
-     * @return If ok, WindowManagerImpl.ADD_OKAY.  If too many singletons,
-     * WindowManagerImpl.ADD_MULTIPLE_SINGLETON
-     */
-    public int prepareAddWindowLw(WindowState win, WindowManager.LayoutParams attrs) {
-        switch (attrs.type) {
-            case TYPE_STATUS_BAR:
-                mContext.enforceCallingOrSelfPermission(
-                        android.Manifest.permission.STATUS_BAR_SERVICE,
-                        "PhoneWindowManager");
-                if (mStatusBar != null) {
-                    if (mStatusBar.isAlive()) {
-                        return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
-                    }
-                }
-                mStatusBar = win;
-                break;
-            case TYPE_NAVIGATION_BAR:
-                mContext.enforceCallingOrSelfPermission(
-                        android.Manifest.permission.STATUS_BAR_SERVICE,
-                        "PhoneWindowManager");
-                if (mNavigationBar != null) {
-                    if (mNavigationBar.isAlive()) {
-                        return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
-                    }
-                }
-                mNavigationBar = win;
-                if (DEBUG_LAYOUT) Log.i(TAG, "NAVIGATION BAR: " + mNavigationBar);
-                break;
-            case TYPE_NAVIGATION_BAR_PANEL:
-                mContext.enforceCallingOrSelfPermission(
-                        android.Manifest.permission.STATUS_BAR_SERVICE,
-                        "PhoneWindowManager");
-                break;
-            case TYPE_STATUS_BAR_PANEL:
-                mContext.enforceCallingOrSelfPermission(
-                        android.Manifest.permission.STATUS_BAR_SERVICE,
-                        "PhoneWindowManager");
-                break;
-            case TYPE_STATUS_BAR_SUB_PANEL:
-                mContext.enforceCallingOrSelfPermission(
-                        android.Manifest.permission.STATUS_BAR_SERVICE,
-                        "PhoneWindowManager");
-                break;
-            case TYPE_KEYGUARD:
-                if (mKeyguard != null) {
-                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
-                }
-                mKeyguard = win;
-                break;
-        }
-        return WindowManagerGlobal.ADD_OKAY;
-    }
-
-    /** {@inheritDoc} */
-    public void removeWindowLw(WindowState win) {
-        if (mStatusBar == win) {
-            mStatusBar = null;
-        } else if (mKeyguard == win) {
-            mKeyguard = null;
-        } else if (mNavigationBar == win) {
-            mNavigationBar = null;
-        }
-    }
-
-    static final boolean PRINT_ANIM = false;
-    
-    /** {@inheritDoc} */
-    public int selectAnimationLw(WindowState win, int transit) {
-        if (PRINT_ANIM) Log.i(TAG, "selectAnimation in " + win
-              + ": transit=" + transit);
-        if (win == mStatusBar) {
-            if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
-                return R.anim.dock_top_exit;
-            } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
-                return R.anim.dock_top_enter;
-            }
-        } else if (win == mNavigationBar) {
-            // This can be on either the bottom or the right.
-            if (mNavigationBarOnBottom) {
-                if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
-                    return R.anim.dock_bottom_exit;
-                } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
-                    return R.anim.dock_bottom_enter;
-                }
-            } else {
-                if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
-                    return R.anim.dock_right_exit;
-                } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
-                    return R.anim.dock_right_enter;
-                }
-            }
-        } if (transit == TRANSIT_PREVIEW_DONE) {
-            if (win.hasAppShownWindows()) {
-                if (PRINT_ANIM) Log.i(TAG, "**** STARTING EXIT");
-                return com.android.internal.R.anim.app_starting_exit;
-            }
-        } else if (win.getAttrs().type == TYPE_DREAM && mDreamingLockscreen
-                && transit == TRANSIT_ENTER) {
-            // Special case: we are animating in a dream, while the keyguard
-            // is shown.  We don't want an animation on the dream, because
-            // we need it shown immediately with the keyguard animating away
-            // to reveal it.
-            return -1;
-        }
-
-        return 0;
-    }
-
-    public Animation createForceHideEnterAnimation(boolean onWallpaper) {
-        return AnimationUtils.loadAnimation(mContext, onWallpaper
-                ? com.android.internal.R.anim.lock_screen_wallpaper_behind_enter
-                : com.android.internal.R.anim.lock_screen_behind_enter);
-    }
-    
-    static ITelephony getTelephonyService() {
-        return ITelephony.Stub.asInterface(
-                ServiceManager.checkService(Context.TELEPHONY_SERVICE));
-    }
-
-    static IAudioService getAudioService() {
-        IAudioService audioService = IAudioService.Stub.asInterface(
-                ServiceManager.checkService(Context.AUDIO_SERVICE));
-        if (audioService == null) {
-            Log.w(TAG, "Unable to find IAudioService interface.");
-        }
-        return audioService;
-    }
-
-    boolean keyguardOn() {
-        return keyguardIsShowingTq() || inKeyguardRestrictedKeyInputMode();
-    }
-
-    private static final int[] WINDOW_TYPES_WHERE_HOME_DOESNT_WORK = {
-            WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,
-            WindowManager.LayoutParams.TYPE_SYSTEM_ERROR,
-        };
-
-    /** {@inheritDoc} */
-    @Override
-    public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
-        final boolean keyguardOn = keyguardOn();
-        final int keyCode = event.getKeyCode();
-        final int repeatCount = event.getRepeatCount();
-        final int metaState = event.getMetaState();
-        final int flags = event.getFlags();
-        final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
-        final boolean canceled = event.isCanceled();
-        final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
-
-        if (DEBUG_INPUT) {
-            Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount="
-                    + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed
-                    + " canceled=" + canceled);
-        }
-
-        // If we think we might have a volume down & power/volume-up key chord on the way
-        // but we're not sure, then tell the dispatcher to wait a little while and
-        // try again later before dispatching.
-        if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
-            if (mVolumeDownKeyTriggered && !mPowerKeyTriggered && !mVolumeUpKeyTriggered) {
-                final long now = SystemClock.uptimeMillis();
-                final long timeoutTime = mVolumeDownKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS;
-                if (now < timeoutTime) {
-                    return timeoutTime - now;
-                }
-            } else if (mVolumeUpKeyTriggered && !mVolumeDownKeyTriggered) {
-                final long now = SystemClock.uptimeMillis();
-                final long timeoutTime = mVolumeUpKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS;
-                if (now < timeoutTime) {
-                    return timeoutTime - now;
-                }
-            }
-
-            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN
-                    && mVolumeDownKeyConsumedByChord) {
-                if (!down) {
-                    mVolumeDownKeyConsumedByChord = false;
-                }
-                return -1;
-            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP
-                    && mVolumeUpKeyConsumedByChord) {
-                if (!down) {
-                    mVolumeUpKeyConsumedByChord = false;
-                }
-                return -1;
-            }
-        }
-
-        if (keyCode == KeyEvent.KEYCODE_BACK && !down) {
-            mHandler.removeCallbacks(mBackLongPress);
-        }
-
-        // Specific device key handling
-        if (mDeviceKeyHandler != null) {
-            try {
-                // The device only should consume known keys.
-                if (mDeviceKeyHandler.handleKeyEvent(event)) {
-                    return -1;
-                }
-            } catch (Exception e) {
-                Slog.w(TAG, "Could not dispatch event to device key handler", e);
-            }
-        }
-
-        // First we always handle the home key here, so applications
-        // can never break it, although if keyguard is on, we do let
-        // it handle it, because that gives us the correct 5 second
-        // timeout.
-        if (keyCode == KeyEvent.KEYCODE_HOME) {
-
-            // If we have released the home key, and didn't do anything else
-            // while it was pressed, then it is time to go home!
-            if (!down && mHomePressed) {
-                final boolean homeWasLongPressed = mHomeLongPressed;
-                mHomeLongPressed = false;
-                mHomePressed = false;
-                if (!homeWasLongPressed) {
-                    if (mRecentAppsPreloaded) {
-                        cancelPreloadRecentApps();
-                    }
-                    mHomePressed = false;
-                    if (!canceled) {
-                        boolean incomingRinging = false;
-                        try {
-                            ITelephony telephonyService = getTelephonyService();
-                            if (telephonyService != null) {
-                                incomingRinging = telephonyService.isRinging();
-                            }
-                            if (incomingRinging) {
-                                if ((mRingHomeBehavior
-                                        & Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_ANSWER) != 0) {
-                                    Log.i(TAG, "Answering with HOME button.");
-                                    telephonyService.answerRingingCall();
-                                } else {
-                                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
-                                }
-                            } else {
-                                launchHomeFromHotKey();
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
-                        }
-                    } else {
-                        Log.i(TAG, "Ignoring HOME; event canceled.");
-                    }
-                    return -1;
-                }
-            }
-
-            // If a system window has focus, then it doesn't make sense
-            // right now to interact with applications.
-            WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
-            if (attrs != null) {
-                final int type = attrs.type;
-                if (type == WindowManager.LayoutParams.TYPE_KEYGUARD
-                        || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
-                    // the "app" is keyguard, so give it the key
-                    return 0;
-                }
-                final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
-                for (int i=0; i<typeCount; i++) {
-                    if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
-                        // don't do anything, but also don't pass it to the app
-                        return -1;
-                    }
-                }
-            }
-            if (down) {
-                if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
-                    preloadRecentApps();
-                }
-                if (repeatCount == 0) {
-                    mHomePressed = true;
-                } else if (longPress) {
-                    if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
-                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
-                        performKeyAction(mLongPressOnHomeBehavior);
-                        // Eat the long-press so it won't take us home when the key is released
-                        mHomeLongPressed = true;
-                    }
-                }
-            }
-            return -1;
-        } else if (keyCode == KeyEvent.KEYCODE_MENU) {
-            // Hijack modified menu keys for debugging features
-            final int chordBug = KeyEvent.META_SHIFT_ON;
-
-            if (down) {
-                if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH ||
-                        mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
-                    preloadRecentApps();
-                }
-                if (repeatCount == 0) {
-                    if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
-                        Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
-                        mContext.sendOrderedBroadcast(intent, null);
-                        return -1;
-                    } else if (SHOW_PROCESSES_ON_ALT_MENU &&
-                            (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
-                        Intent service = new Intent();
-                        service.setClassName(mContext, "com.android.server.LoadAverageService");
-                        ContentResolver res = mContext.getContentResolver();
-                        boolean shown = Settings.System.getInt(
-                                res, Settings.System.SHOW_PROCESSES, 0) != 0;
-                        if (!shown) {
-                            mContext.startService(service);
-                        } else {
-                            mContext.stopService(service);
-                        }
-                        Settings.System.putInt(
-                                res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
-                        return -1;
-                    } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !mIsVirtualKeypress) {
-                        mMenuDoCustomAction = true;
-                        return -1;
-                    }
-                } else if (longPress) {
-                    if (mRecentAppsPreloaded &&
-                            mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
-                        cancelPreloadRecentApps();
-                    }
-                    if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
-                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
-                        performKeyAction(mLongPressOnMenuBehavior);
-                        // Do not perform action when key is released
-                        mMenuDoCustomAction = false;
-                        return -1;
-                    }
-                }
-            } else {
-                if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH &&
-                        mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
-                    cancelPreloadRecentApps();
-                }
-                if (mMenuDoCustomAction) {
-                    mMenuDoCustomAction = false;
-                    if (!canceled && !keyguardOn) {
-                        performKeyAction(mPressOnMenuBehavior);
-                        return -1;
-                    }
-                }
-            }
-        } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
-            if (down) {
-                if (repeatCount == 0) {
-                    mSearchKeyShortcutPending = true;
-                    mConsumeSearchKeyUp = false;
-                }
-            } else {
-                mSearchKeyShortcutPending = false;
-                if (mConsumeSearchKeyUp) {
-                    mConsumeSearchKeyUp = false;
-                    return -1;
-                }
-            }
-            return 0;
-        } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
-            if (down) {
-                if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH ||
-                        mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
-                    preloadRecentApps();
-                }
-                if (repeatCount == 0) {
-                    mAppSwitchLongPressed = false;
-                } else if (longPress) {
-                    if (mRecentAppsPreloaded &&
-                            mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
-                        cancelPreloadRecentApps();
-                    }
-                    if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
-                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
-                        performKeyAction(mLongPressOnAppSwitchBehavior);
-                        mAppSwitchLongPressed = true;
-                    }
-                }
-            } else {
-                if (mAppSwitchLongPressed) {
-                    mAppSwitchLongPressed = false;
-                } else {
-                    if (mRecentAppsPreloaded &&
-                            mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
-                        cancelPreloadRecentApps();
-                    }
-                    if (!canceled && !keyguardOn) {
-                        performKeyAction(mPressOnAppSwitchBehavior);
-                    }
-                    return -1;
-                }
-            }
-            return -1;
-        } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
-            if (down) {
-                if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH ||
-                        mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
-                    preloadRecentApps();
-                }
-                if (repeatCount == 0) {
-                    mAssistKeyLongPressed = false;
-                } else if (longPress) {
-                    if (mRecentAppsPreloaded &&
-                            mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
-                        cancelPreloadRecentApps();
-                    }
-                    if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
-                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
-                        performKeyAction(mLongPressOnAssistBehavior);
-                        mAssistKeyLongPressed = true;
-                    }
-                }
-            } else {
-                if (mAssistKeyLongPressed) {
-                    mAssistKeyLongPressed = false;
-                } else {
-                    if (mRecentAppsPreloaded &&
-                            mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
-                        cancelPreloadRecentApps();
-                    }
-                    if (!keyguardOn) {
-                        performKeyAction(mPressOnAssistBehavior);
-                    }
-                }
-            }
-            return -1;
-        } else if (keyCode == KeyEvent.KEYCODE_BACK) {
-            if (Settings.Secure.getIntForUser(mContext.getContentResolver(),
-                    Settings.Secure.KILL_APP_LONGPRESS_BACK, 0, UserHandle.USER_CURRENT) == 1) {
-                if (down && repeatCount == 0) {
-                    mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
-                }
-            }
-        }
-
-        // Shortcuts are invoked through Search+key, so intercept those here
-        // Any printing key that is chorded with Search should be consumed
-        // even if no shortcut was invoked.  This prevents text from being
-        // inadvertently inserted when using a keyboard that has built-in macro
-        // shortcut keys (that emit Search+x) and some of them are not registered.
-        if (mSearchKeyShortcutPending) {
-            final KeyCharacterMap kcm = event.getKeyCharacterMap();
-            if (kcm.isPrintingKey(keyCode)) {
-                mConsumeSearchKeyUp = true;
-                mSearchKeyShortcutPending = false;
-                if (down && repeatCount == 0 && !keyguardOn) {
-                    Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
-                    if (shortcutIntent != null) {
-                        shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                        try {
-                            mContext.startActivity(shortcutIntent);
-                        } catch (ActivityNotFoundException ex) {
-                            Slog.w(TAG, "Dropping shortcut key combination because "
-                                    + "the activity to which it is registered was not found: "
-                                    + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
-                        }
-                    } else {
-                        Slog.i(TAG, "Dropping unregistered shortcut key combination: "
-                                + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
-                    }
-                }
-                return -1;
-            }
-        }
-
-        // Invoke shortcuts using Meta.
-        if (down && repeatCount == 0 && !keyguardOn
-                && (metaState & KeyEvent.META_META_ON) != 0) {
-            final KeyCharacterMap kcm = event.getKeyCharacterMap();
-            if (kcm.isPrintingKey(keyCode)) {
-                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode,
-                        metaState & ~(KeyEvent.META_META_ON
-                                | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
-                if (shortcutIntent != null) {
-                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                    try {
-                        mContext.startActivity(shortcutIntent);
-                    } catch (ActivityNotFoundException ex) {
-                        Slog.w(TAG, "Dropping shortcut key combination because "
-                                + "the activity to which it is registered was not found: "
-                                + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
-                    }
-                    return -1;
-                }
-            }
-        }
-
-        // Handle application launch keys.
-        if (down && repeatCount == 0 && !keyguardOn) {
-            String category = sApplicationLaunchKeyCategories.get(keyCode);
-            if (category != null) {
-                Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
-                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                try {
-                    mContext.startActivity(intent);
-                } catch (ActivityNotFoundException ex) {
-                    Slog.w(TAG, "Dropping application launch key because "
-                            + "the activity to which it is registered was not found: "
-                            + "keyCode=" + keyCode + ", category=" + category, ex);
-                }
-                return -1;
-            }
-        }
-
-        // Display task switcher for ALT-TAB or Meta-TAB.
-        if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
-            if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
-                final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
-                if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)
-                        || KeyEvent.metaStateHasModifiers(
-                                shiftlessModifiers, KeyEvent.META_META_ON)) {
-                    mRecentAppsDialogHeldModifiers = shiftlessModifiers;
-                    showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
-                    return -1;
-                }
-            }
-        } else if (!down && mRecentAppsDialogHeldModifiers != 0
-                && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
-            mRecentAppsDialogHeldModifiers = 0;
-            showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS :
-                    RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
-        }
-
-        // Handle keyboard language switching.
-        if (down && repeatCount == 0
-                && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH
-                        || (keyCode == KeyEvent.KEYCODE_SPACE
-                                && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
-            int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
-            mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
-            return -1;
-        }
-        if (mLanguageSwitchKeyPressed && !down
-                && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH
-                        || keyCode == KeyEvent.KEYCODE_SPACE)) {
-            mLanguageSwitchKeyPressed = false;
-            return -1;
-        }
-
-        // Let the application handle the key.
-        return 0;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) {
-        // Note: This method is only called if the initial down was unhandled.
-        if (DEBUG_INPUT) {
-            Slog.d(TAG, "Unhandled key: win=" + win + ", action=" + event.getAction()
-                    + ", flags=" + event.getFlags()
-                    + ", keyCode=" + event.getKeyCode()
-                    + ", scanCode=" + event.getScanCode()
-                    + ", metaState=" + event.getMetaState()
-                    + ", repeatCount=" + event.getRepeatCount()
-                    + ", policyFlags=" + policyFlags);
-        }
-
-        KeyEvent fallbackEvent = null;
-        if ((event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
-            final KeyCharacterMap kcm = event.getKeyCharacterMap();
-            final int keyCode = event.getKeyCode();
-            final int metaState = event.getMetaState();
-            final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN
-                    && event.getRepeatCount() == 0;
-
-            // Check for fallback actions specified by the key character map.
-            final FallbackAction fallbackAction;
-            if (initialDown) {
-                fallbackAction = kcm.getFallbackAction(keyCode, metaState);
-            } else {
-                fallbackAction = mFallbackActions.get(keyCode);
-            }
-
-            if (fallbackAction != null) {
-                if (DEBUG_INPUT) {
-                    Slog.d(TAG, "Fallback: keyCode=" + fallbackAction.keyCode
-                            + " metaState=" + Integer.toHexString(fallbackAction.metaState));
-                }
-
-                final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;
-                fallbackEvent = KeyEvent.obtain(
-                        event.getDownTime(), event.getEventTime(),
-                        event.getAction(), fallbackAction.keyCode,
-                        event.getRepeatCount(), fallbackAction.metaState,
-                        event.getDeviceId(), event.getScanCode(),
-                        flags, event.getSource(), null);
-
-                if (!interceptFallback(win, fallbackEvent, policyFlags)) {
-                    fallbackEvent.recycle();
-                    fallbackEvent = null;
-                }
-
-                if (initialDown) {
-                    mFallbackActions.put(keyCode, fallbackAction);
-                } else if (event.getAction() == KeyEvent.ACTION_UP) {
-                    mFallbackActions.remove(keyCode);
-                    fallbackAction.recycle();
-                }
-            }
-        }
-
-        if (DEBUG_INPUT) {
-            if (fallbackEvent == null) {
-                Slog.d(TAG, "No fallback.");
-            } else {
-                Slog.d(TAG, "Performing fallback: " + fallbackEvent);
-            }
-        }
-        return fallbackEvent;
-    }
-
-    private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) {
-        int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags, true);
-        if ((actions & ACTION_PASS_TO_USER) != 0) {
-            long delayMillis = interceptKeyBeforeDispatching(
-                    win, fallbackEvent, policyFlags);
-            if (delayMillis == 0) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void launchAssistLongPressAction() {
-        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_ASSIST);
-
-        // launch the search activity
-        Intent intent = new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
-        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        try {
-            // TODO: This only stops the factory-installed search manager.  
-            // Need to formalize an API to handle others
-            SearchManager searchManager = getSearchManager();
-            if (searchManager != null) {
-                searchManager.stopSearch();
-            }
-            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
-        } catch (ActivityNotFoundException e) {
-            Slog.w(TAG, "No activity to handle assist long press action.", e);
-        }
-    }
-
-    private void launchAssistAction() {
-        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_ASSIST);
-        Intent intent = ((SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE))
-                .getAssistIntent(mContext, UserHandle.USER_CURRENT);
-        if (intent != null) {
-            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                    | Intent.FLAG_ACTIVITY_SINGLE_TOP
-                    | Intent.FLAG_ACTIVITY_CLEAR_TOP);
-            try {
-                mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
-            } catch (ActivityNotFoundException e) {
-                Slog.w(TAG, "No activity to handle assist action.", e);
-            }
-        }
-    }
-
-    private SearchManager getSearchManager() {
-        if (mSearchManager == null) {
-            mSearchManager = (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
-        }
-        return mSearchManager;
-    }
-
-    /**
-     * A home key -> launch home action was detected.  Take the appropriate action
-     * given the situation with the keyguard.
-     */
-    void launchHomeFromHotKey() {
-        if (mKeyguardMediator != null && mKeyguardMediator.isShowingAndNotHidden()) {
-            // don't launch home if keyguard showing
-        } else if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
-            // when in keyguard restricted mode, must first verify unlock
-            // before launching home
-            mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult() {
-                public void onKeyguardExitResult(boolean success) {
-                    if (success) {
-                        try {
-                            ActivityManagerNative.getDefault().stopAppSwitches();
-                        } catch (RemoteException e) {
-                        }
-                        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
-                        startDockOrHome();
-                    }
-                }
-            });
-        } else {
-            // no keyguard stuff to worry about, just launch home!
-            try {
-                ActivityManagerNative.getDefault().stopAppSwitches();
-            } catch (RemoteException e) {
-            }
-            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
-            startDockOrHome();
-        }
-    }
-
-    /**
-     * A delayed callback use to determine when it is okay to re-allow applications
-     * to use certain system UI flags.  This is used to prevent applications from
-     * spamming system UI changes that prevent the navigation bar from being shown.
-     */
-    final Runnable mAllowSystemUiDelay = new Runnable() {
-        @Override public void run() {
-        }
-    };
-
-    /**
-     * Input handler used while nav bar is hidden.  Captures any touch on the screen,
-     * to determine when the nav bar should be shown and prevent applications from
-     * receiving those touches.
-     */
-    final class HideNavInputEventReceiver extends InputEventReceiver {
-        public HideNavInputEventReceiver(InputChannel inputChannel, Looper looper) {
-            super(inputChannel, looper);
-        }
-
-        @Override
-        public void onInputEvent(InputEvent event) {
-            boolean handled = false;
-            try {
-                if (event instanceof MotionEvent
-                        && (event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
-                    final MotionEvent motionEvent = (MotionEvent)event;
-                    if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
-                        // When the user taps down, we re-show the nav bar.
-                        boolean changed = false;
-                        synchronized (mLock) {
-                            // Any user activity always causes us to show the
-                            // navigation controls, if they had been hidden.
-                            // We also clear the low profile and only content
-                            // flags so that tapping on the screen will atomically
-                            // restore all currently hidden screen decorations.
-                            int newVal = mResettingSystemUiFlags |
-                                    View.SYSTEM_UI_FLAG_HIDE_NAVIGATION |
-                                    View.SYSTEM_UI_FLAG_LOW_PROFILE |
-                                    View.SYSTEM_UI_FLAG_FULLSCREEN;
-                            if (mResettingSystemUiFlags != newVal) {
-                                mResettingSystemUiFlags = newVal;
-                                changed = true;
-                            }
-                            // We don't allow the system's nav bar to be hidden
-                            // again for 1 second, to prevent applications from
-                            // spamming us and keeping it from being shown.
-                            newVal = mForceClearedSystemUiFlags |
-                                    View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
-                            if (mForceClearedSystemUiFlags != newVal) {
-                                mForceClearedSystemUiFlags = newVal;
-                                changed = true;
-                                mHandler.postDelayed(new Runnable() {
-                                    @Override public void run() {
-                                        synchronized (mLock) {
-                                            // Clear flags.
-                                            mForceClearedSystemUiFlags &=
-                                                    ~View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
-                                        }
-                                        mWindowManagerFuncs.reevaluateStatusBarVisibility();
-                                    }
-                                }, 1000);
-                            }
-                        }
-                        if (changed) {
-                            mWindowManagerFuncs.reevaluateStatusBarVisibility();
-                        }
-                    }
-                }
-            } finally {
-                finishInputEvent(event, handled);
-            }
-        }
-    }
-    final InputEventReceiver.Factory mHideNavInputEventReceiverFactory =
-            new InputEventReceiver.Factory() {
-        @Override
-        public InputEventReceiver createInputEventReceiver(
-                InputChannel inputChannel, Looper looper) {
-            return new HideNavInputEventReceiver(inputChannel, looper);
-        }
-    };
-
-    @Override
-    public int adjustSystemUiVisibilityLw(int visibility) {
-        // Reset any bits in mForceClearingStatusBarVisibility that
-        // are now clear.
-        mResettingSystemUiFlags &= visibility;
-        // Clear any bits in the new visibility that are currently being
-        // force cleared, before reporting it.
-        return visibility & ~mResettingSystemUiFlags
-                & ~mForceClearedSystemUiFlags;
-    }
-
-    @Override
-    public void getContentInsetHintLw(WindowManager.LayoutParams attrs, Rect contentInset) {
-        final int fl = attrs.flags;
-        final int systemUiVisibility = (attrs.systemUiVisibility|attrs.subtreeSystemUiVisibility);
-
-        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR))
-                == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
-            int availRight, availBottom;
-            if (shouldHideNavigationBarLw(systemUiVisibility)) {
-                availRight = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
-                availBottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
-            } else {
-                availRight = mRestrictedScreenLeft + mRestrictedScreenWidth;
-                availBottom = mRestrictedScreenTop + mRestrictedScreenHeight;
-            }
-            if ((systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0) {
-                if ((fl & FLAG_FULLSCREEN) != 0) {
-                    contentInset.set(mStableFullscreenLeft, mStableFullscreenTop,
-                            availRight - mStableFullscreenRight,
-                            availBottom - mStableFullscreenBottom);
-                } else {
-                    contentInset.set(mStableLeft, mStableTop,
-                            availRight - mStableRight, availBottom - mStableBottom);
-                }
-            } else if ((fl & FLAG_FULLSCREEN) != 0) {
-                contentInset.setEmpty();
-            } else if ((systemUiVisibility & (View.SYSTEM_UI_FLAG_FULLSCREEN
-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN)) == 0) {
-                contentInset.set(mCurLeft, mCurTop,
-                        availRight - mCurRight, availBottom - mCurBottom);
-            } else {
-                contentInset.set(mCurLeft, mCurTop,
-                        availRight - mCurRight, availBottom - mCurBottom);
-            }
-            return;
-        }
-        contentInset.setEmpty();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight,
-                              int displayRotation) {
-        mUnrestrictedScreenLeft = mUnrestrictedScreenTop = 0;
-        mUnrestrictedScreenWidth = displayWidth;
-        mUnrestrictedScreenHeight = displayHeight;
-        mRestrictedScreenLeft = mRestrictedScreenTop = 0;
-        mRestrictedScreenWidth = displayWidth;
-        mRestrictedScreenHeight = displayHeight;
-        mDockLeft = mContentLeft = mStableLeft = mStableFullscreenLeft
-                = mSystemLeft = mCurLeft = 0;
-        mDockTop = mContentTop = mStableTop = mStableFullscreenTop
-                = mSystemTop = mCurTop = 0;
-        mDockRight = mContentRight = mStableRight = mStableFullscreenRight
-                = mSystemRight = mCurRight = displayWidth;
-        mDockBottom = mContentBottom = mStableBottom = mStableFullscreenBottom
-                = mSystemBottom = mCurBottom = displayHeight;
-        mDockLayer = 0x10000000;
-        mStatusBarLayer = -1;
-
-        // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
-        final Rect pf = mTmpParentFrame;
-        final Rect df = mTmpDisplayFrame;
-        final Rect vf = mTmpVisibleFrame;
-        pf.left = df.left = vf.left = mDockLeft;
-        pf.top = df.top = vf.top = mDockTop;
-        pf.right = df.right = vf.right = mDockRight;
-        pf.bottom = df.bottom = vf.bottom = mDockBottom;
-
-        if (isDefaultDisplay) {
-            // For purposes of putting out fake window up to steal focus, we will
-            // drive nav being hidden only by whether it is requested.
-            boolean navVisible = (mLastSystemUiFlags&View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
-            int navWidth = mNavigationBarWidthForRotation[displayRotation];
-            int navHeight = mNavigationBarHeightForRotation[displayRotation];
-
-            // When the navigation bar isn't visible, we put up a fake
-            // input window to catch all touch events.  This way we can
-            // detect when the user presses anywhere to bring back the nav
-            // bar and ensure the application doesn't see the event.
-            if (navVisible) {
-                if (mHideNavFakeWindow != null) {
-                    mHideNavFakeWindow.dismiss();
-                    mHideNavFakeWindow = null;
-                }
-            } else if (mHideNavFakeWindow == null) {
-                mHideNavFakeWindow = mWindowManagerFuncs.addFakeWindow(
-                        mHandler.getLooper(), mHideNavInputEventReceiverFactory,
-                        "hidden nav", WindowManager.LayoutParams.TYPE_HIDDEN_NAV_CONSUMER,
-                        0, false, false, true);
-            }
-
-            // For purposes of positioning and showing the nav bar, if we have
-            // decided that it can't be hidden (because of the screen aspect ratio),
-            // then take that into account.
-            if (expandedDesktopHidesNavigationBar()
-                    && (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_SHOW_NAVIGATION_IN_EXPANDED_DESKTOP) == 0) {
-                navVisible = false;
-                navWidth = 0;
-                navHeight = 0;
-            } else if (!mCanHideNavigationBar) {
-                navVisible = true;
-            }
-
-            if (mNavigationBar != null) {
-                // Force the navigation bar to its appropriate place and
-                // size.  We need to do this directly, instead of relying on
-                // it to bubble up from the nav bar, because this needs to
-                // change atomically with screen rotations.
-                mNavigationBarOnBottom = (!mNavigationBarCanMove || displayWidth < displayHeight);
-                if (mNavigationBarOnBottom) {
-                    // It's a system nav bar or a portrait screen; nav bar goes on bottom.
-                    int top = displayHeight - navHeight;
-                    mTmpNavigationFrame.set(0, top, displayWidth, displayHeight);
-                    mStableBottom = mStableFullscreenBottom = mTmpNavigationFrame.top;
-                    if (navVisible) {
-                        mNavigationBar.showLw(true);
-                        mSystemBottom = mDockBottom = mTmpNavigationFrame.bottom - mDockTop;
-                    } else {
-                        // We currently want to hide the navigation UI.
-                        mNavigationBar.hideLw(true);
-                    }
-                    if (navVisible && !mNavigationBar.isAnimatingLw()) {
-                        // If the nav bar is currently requested to be visible,
-                        // and not in the process of animating on or off, then
-                        // we can tell the app that it is covered by it.
-                        mSystemBottom = displayHeight;
-                        mRestrictedScreenHeight = mTmpNavigationFrame.top - mDockTop;
-                    }
-                } else {
-                    // Landscape screen; nav bar goes to the right.
-                    int left = displayWidth - navWidth;
-                    mTmpNavigationFrame.set(left, 0, displayWidth, displayHeight);
-                    mStableRight = mStableFullscreenRight = mTmpNavigationFrame.left;
-                    if (navVisible) {
-                        mNavigationBar.showLw(true);
-                        mSystemRight = mDockRight = mTmpNavigationFrame.left - mDockLeft;
-                    } else {
-                        // We currently want to hide the navigation UI.
-                        mNavigationBar.hideLw(true);
-                    }
-                    if (navVisible && !mNavigationBar.isAnimatingLw()) {
-                        // If the nav bar is currently requested to be visible,
-                        // and not in the process of animating on or off, then
-                        // we can tell the app that it is covered by it.
-                        mSystemRight = displayWidth;
-                        mRestrictedScreenWidth = mTmpNavigationFrame.left - mDockLeft;
-                    }
-                }
-                // Make sure the content and current rectangles are updated to
-                // account for the restrictions from the navigation bar.
-                mContentTop = mCurTop = mDockTop;
-                mContentBottom = mCurBottom = mDockBottom;
-                mContentLeft = mCurLeft = mDockLeft;
-                mContentRight = mCurRight = mDockRight;
-                mStatusBarLayer = mNavigationBar.getSurfaceLayer();
-                // And compute the final frame.
-                mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame,
-                        mTmpNavigationFrame, mTmpNavigationFrame);
-                if (DEBUG_LAYOUT) Log.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
-            }
-            if (DEBUG_LAYOUT) Log.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)",
-                    mDockLeft, mDockTop, mDockRight, mDockBottom));
-
-            // decide where the status bar goes ahead of time
-            if (mStatusBar != null) {
-                // apply any navigation bar insets
-                pf.left = df.left = mUnrestrictedScreenLeft;
-                pf.top = df.top = mUnrestrictedScreenTop;
-                pf.right = df.right = mUnrestrictedScreenWidth - mUnrestrictedScreenLeft;
-                pf.bottom = df.bottom = mUnrestrictedScreenHeight - mUnrestrictedScreenTop;
-                vf.left = mStableLeft;
-                vf.top = mStableTop;
-                vf.right = mStableRight;
-                vf.bottom = mStableBottom;
-
-                if(navVisible && !mNavigationBarOnBottom) {
-                    pf.right = df.right = vf.right = mTmpNavigationFrame.left;
-                }
-
-                mStatusBarLayer = mStatusBar.getSurfaceLayer();
-
-                // Let the status bar determine its size.
-                mStatusBar.computeFrameLw(pf, df, vf, vf);
-
-                // For layout, the status bar is always at the top with our fixed height
-                // (except if it's hidden by expanded desktop, in which case we know it's
-                // never shown)
-                if (!expandedDesktopHidesStatusBar()) {
-                    mStableTop = mUnrestrictedScreenTop + mStatusBarHeight;
-                }
-
-                // If the status bar is hidden, we don't want to cause
-                // windows behind it to scroll.
-                if (mStatusBar.isVisibleLw()) {
-                    // Status bar may go away, so the screen area it occupies
-                    // is available to apps but just covering them when the
-                    // status bar is visible.
-                    mDockTop = mUnrestrictedScreenTop+mStatusBarHeight;
-
-                    mContentTop = mCurTop = mDockTop;
-                    mContentBottom = mCurBottom = mDockBottom;
-                    mContentLeft = mCurLeft = mDockLeft;
-                    mContentRight = mCurRight = mDockRight;
-
-                    if (DEBUG_LAYOUT) Log.v(TAG, "Status bar: " +
-                        String.format(
-                            "dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]",
-                            mDockLeft, mDockTop, mDockRight, mDockBottom,
-                            mContentLeft, mContentTop, mContentRight, mContentBottom,
-                            mCurLeft, mCurTop, mCurRight, mCurBottom));
-                }
-                if (mStatusBar.isVisibleLw() && !mStatusBar.isAnimatingLw()) {
-                    // If the status bar is currently requested to be visible,
-                    // and not in the process of animating on or off, then
-                    // we can tell the app that it is covered by it.
-                    mSystemTop = mUnrestrictedScreenTop;
-                }
-            }
-            mDockBottom = navVisible ? mRestrictedScreenTop + mRestrictedScreenHeight : mDockBottom;
-            mDockRight = navVisible ? mRestrictedScreenLeft + mRestrictedScreenWidth: mDockRight;
-        }
-    }
-
-    /** {@inheritDoc} */
-    public int getSystemDecorRectLw(Rect systemRect) {
-        systemRect.left = mSystemLeft;
-        systemRect.top = mSystemTop;
-        systemRect.right = mSystemRight;
-        systemRect.bottom = mSystemBottom;
-        if (mStatusBar != null) return mStatusBar.getSurfaceLayer();
-        if (mNavigationBar != null) return mNavigationBar.getSurfaceLayer();
-        return 0;
-    }
-
-    void setAttachedWindowFrames(WindowState win, int fl, int adjust,
-            WindowState attached, boolean insetDecors, Rect pf, Rect df, Rect cf, Rect vf) {
-        if (win.getSurfaceLayer() > mDockLayer && attached.getSurfaceLayer() < mDockLayer) {
-            // Here's a special case: if this attached window is a panel that is
-            // above the dock window, and the window it is attached to is below
-            // the dock window, then the frames we computed for the window it is
-            // attached to can not be used because the dock is effectively part
-            // of the underlying window and the attached window is floating on top
-            // of the whole thing.  So, we ignore the attached window and explicitly
-            // compute the frames that would be appropriate without the dock.
-            df.left = cf.left = vf.left = mDockLeft;
-            df.top = cf.top = vf.top = mDockTop;
-            df.right = cf.right = vf.right = mDockRight;
-            df.bottom = cf.bottom = vf.bottom = mDockBottom;
-        } else {
-            // The effective display frame of the attached window depends on
-            // whether it is taking care of insetting its content.  If not,
-            // we need to use the parent's content frame so that the entire
-            // window is positioned within that content.  Otherwise we can use
-            // the display frame and let the attached window take care of
-            // positioning its content appropriately.
-            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
-                cf.set(attached.getDisplayFrameLw());
-            } else {
-                // If the window is resizing, then we want to base the content
-                // frame on our attached content frame to resize...  however,
-                // things can be tricky if the attached window is NOT in resize
-                // mode, in which case its content frame will be larger.
-                // Ungh.  So to deal with that, make sure the content frame
-                // we end up using is not covering the IM dock.
-                cf.set(attached.getContentFrameLw());
-                if (attached.getSurfaceLayer() < mDockLayer) {
-                    if (cf.left < mContentLeft) cf.left = mContentLeft;
-                    if (cf.top < mContentTop) cf.top = mContentTop;
-                    if (cf.right > mContentRight) cf.right = mContentRight;
-                    if (cf.bottom > mContentBottom) cf.bottom = mContentBottom;
-                }
-            }
-            df.set(insetDecors ? attached.getDisplayFrameLw() : cf);
-            vf.set(attached.getVisibleFrameLw());
-        }
-        // The LAYOUT_IN_SCREEN flag is used to determine whether the attached
-        // window should be positioned relative to its parent or the entire
-        // screen.
-        pf.set((fl & FLAG_LAYOUT_IN_SCREEN) == 0
-                ? attached.getFrameLw() : df);
-    }
-
-    private void applyStableConstraints(int sysui, int fl, Rect r) {
-        if ((sysui & View.SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0) {
-            // If app is requesting a stable layout, don't let the
-            // content insets go below the stable values.
-            if ((fl & FLAG_FULLSCREEN) != 0) {
-                if (r.left < mStableFullscreenLeft) r.left = mStableFullscreenLeft;
-                if (r.top < mStableFullscreenTop) r.top = mStableFullscreenTop;
-                if (r.right > mStableFullscreenRight) r.right = mStableFullscreenRight;
-                if (r.bottom > mStableFullscreenBottom) r.bottom = mStableFullscreenBottom;
-            } else {
-                if (r.left < mStableLeft) r.left = mStableLeft;
-                if (r.top < mStableTop) r.top = mStableTop;
-                if (r.right > mStableRight) r.right = mStableRight;
-                if (r.bottom > mStableBottom) r.bottom = mStableBottom;
-            }
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public void layoutWindowLw(WindowState win, WindowManager.LayoutParams attrs,
-            WindowState attached) {
-        // we've already done the status bar
-        if (win == mStatusBar || win == mNavigationBar) {
-            return;
-        }
-        final boolean isDefaultDisplay = win.isDefaultDisplay();
-        final boolean needsToOffsetInputMethodTarget = isDefaultDisplay &&
-                (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
-        if (needsToOffsetInputMethodTarget) {
-            if (DEBUG_LAYOUT) {
-                Slog.i(TAG, "Offset ime target window by the last ime window state");
-            }
-            offsetInputMethodWindowLw(mLastInputMethodWindow);
-        }
-
-        final int fl = attrs.flags;
-        final int sim = attrs.softInputMode;
-        final int sysUiFl = win.getSystemUiVisibility();
-
-        final Rect pf = mTmpParentFrame;
-        final Rect df = mTmpDisplayFrame;
-        final Rect cf = mTmpContentFrame;
-        final Rect vf = mTmpVisibleFrame;
-
-        final boolean hasNavBar = (isDefaultDisplay && mHasNavigationBar
-                && mNavigationBar != null && mNavigationBar.isVisibleLw());
-        final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
-        if (!isDefaultDisplay) {
-            if (attached != null) {
-                // If this window is attached to another, our display
-                // frame is the same as the one we are attached to.
-                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, cf, vf);
-            } else {
-                // Give the window full screen.
-                pf.left = df.left = cf.left = mUnrestrictedScreenLeft;
-                pf.top = df.top = cf.top = mUnrestrictedScreenTop;
-                pf.right = df.right = cf.right
-                        = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
-                pf.bottom = df.bottom = cf.bottom
-                        = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
-            }
-        } else  if (attrs.type == TYPE_INPUT_METHOD) {
-            pf.left = df.left = cf.left = vf.left = mDockLeft;
-            pf.top = df.top = cf.top = vf.top = mDockTop;
-            pf.right = df.right = cf.right = vf.right = mDockRight;
-            pf.bottom = df.bottom = cf.bottom = vf.bottom = mDockBottom;
-            // IM dock windows always go to the bottom of the screen.
-            attrs.gravity = Gravity.BOTTOM;
-            mDockLayer = win.getSurfaceLayer();
-        } else if (attrs.type == TYPE_WALLPAPER) {
-            pf.left = df.left = cf.left = vf.left = getWallpaperLeft(mUserRotation);
-            pf.top = df.top = cf.top = vf.top = getWallpaperTop(mUserRotation);
-            pf.right = df.right = cf.right = vf.right = getWallpaperRight(mUserRotation);
-            pf.bottom = df.bottom = cf.bottom = vf.bottom = getWallpaperBottom(mUserRotation);
-        } else {
-            if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR))
-                    == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)
-                    && (sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) {
-                if (DEBUG_LAYOUT)
-                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() 
-                            + "): IN_SCREEN, INSET_DECOR, !FULLSCREEN");
-                // This is the case for a normal activity window: we want it
-                // to cover all of the screen space, and it can take care of
-                // moving its contents to account for screen decorations that
-                // intrude into that space.
-                if (attached != null) {
-                    // If this window is attached to another, our display
-                    // frame is the same as the one we are attached to.
-                    setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, cf, vf);
-                } else {
-                    if (attrs.type == TYPE_STATUS_BAR_PANEL
-                            || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
-                        // Status bar panels are the only windows who can go on top of
-                        // the status bar.  They are protected by the STATUS_BAR_SERVICE
-                        // permission, so they have the same privileges as the status
-                        // bar itself.
-                        //
-                        // However, they should still dodge the navigation bar if it exists.
-
-                        pf.left = df.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
-                        pf.top = df.top = mUnrestrictedScreenTop;
-                        pf.right = df.right = hasNavBar
-                                            ? mRestrictedScreenLeft+mRestrictedScreenWidth
-                                            : mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-                        pf.bottom = df.bottom = hasNavBar
-                                              ? mRestrictedScreenTop+mRestrictedScreenHeight
-                                              : mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
-
-                        if (DEBUG_LAYOUT) {
-                            Log.v(TAG, String.format(
-                                        "Laying out status bar window: (%d,%d - %d,%d)",
-                                        pf.left, pf.top, pf.right, pf.bottom));
-                        }
-                    } else if (shouldHideNavigationBarLw(sysUiFl)
-                            && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW
-                            && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
-                        // Asking for layout as if the nav bar is hidden, lets the
-                        // application extend into the unrestricted screen area.  We
-                        // only do this for application windows to ensure no window that
-                        // can be above the nav bar can do this.
-                        pf.left = df.left = mUnrestrictedScreenLeft;
-                        pf.top = df.top = mUnrestrictedScreenTop;
-                        pf.right = df.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-                        pf.bottom = df.bottom = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
-                    } else {
-                        pf.left = df.left = mRestrictedScreenLeft;
-                        pf.top = df.top = mRestrictedScreenTop;
-                        pf.right = df.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
-                        pf.bottom = df.bottom = mRestrictedScreenTop+mRestrictedScreenHeight;
-                    }
-
-                    if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
-                        cf.left = mDockLeft;
-                        cf.top = mDockTop;
-                        cf.right = mDockRight;
-                        cf.bottom = mDockBottom;
-                    } else {
-                        cf.left = mContentLeft;
-                        cf.top = mContentTop;
-                        cf.right = mContentRight;
-                        cf.bottom = mContentBottom;
-                    }
-
-                    applyStableConstraints(sysUiFl, fl, cf);
-                    if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
-                        vf.left = mCurLeft;
-                        vf.top = mCurTop;
-                        vf.right = mCurRight;
-                        vf.bottom = mCurBottom;
-                    } else {
-                        vf.set(cf);
-                    }
-                }
-            } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl
-                    & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-                            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
-                if (DEBUG_LAYOUT)
-                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
-                // A window that has requested to fill the entire screen just
-                // gets everything, period.
-                if (attrs.type == TYPE_STATUS_BAR_PANEL
-                        || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
-                    pf.left = df.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
-                    pf.top = df.top = cf.top = mUnrestrictedScreenTop;
-                    pf.right = df.right = cf.right = hasNavBar
-                                        ? mRestrictedScreenLeft+mRestrictedScreenWidth
-                                        : mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-                    pf.bottom = df.bottom = cf.bottom = hasNavBar
-                                          ? mRestrictedScreenTop+mRestrictedScreenHeight
-                                          : mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
-                    if (DEBUG_LAYOUT) {
-                        Log.v(TAG, String.format(
-                                    "Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)",
-                                    pf.left, pf.top, pf.right, pf.bottom));
-                    }
-                } else if (attrs.type == TYPE_NAVIGATION_BAR
-                        || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
-                    // The navigation bar has Real Ultimate Power.
-                    pf.left = df.left = mUnrestrictedScreenLeft;
-                    pf.top = df.top = mUnrestrictedScreenTop;
-                    pf.right = df.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-                    pf.bottom = df.bottom = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
-                    if (DEBUG_LAYOUT) {
-                        Log.v(TAG, String.format(
-                                    "Laying out navigation bar window: (%d,%d - %d,%d)",
-                                    pf.left, pf.top, pf.right, pf.bottom));
-                    }
-                } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY
-                                || attrs.type == TYPE_BOOT_PROGRESS)
-                        && ((fl & FLAG_FULLSCREEN) != 0)) {
-                    // Fullscreen secure system overlays get what they ask for.
-                    pf.left = df.left = mUnrestrictedScreenLeft;
-                    pf.top = df.top = mUnrestrictedScreenTop;
-                    pf.right = df.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-                    pf.bottom = df.bottom = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
-                } else if (attrs.type == TYPE_BOOT_PROGRESS
-                        || attrs.type == TYPE_UNIVERSE_BACKGROUND) {
-                    // Boot progress screen always covers entire display.
-                    pf.left = df.left = cf.left = mUnrestrictedScreenLeft;
-                    pf.top = df.top = cf.top = mUnrestrictedScreenTop;
-                    pf.right = df.right = cf.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-                    pf.bottom = df.bottom = cf.bottom
-                            = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
-                } else if (shouldHideNavigationBarLw(sysUiFl)
-                        && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW
-                        && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
-                    // Asking for layout as if the nav bar is hidden, lets the
-                    // application extend into the unrestricted screen area.  We
-                    // only do this for application windows to ensure no window that
-                    // can be above the nav bar can do this.
-                    // XXX This assumes that an app asking for this will also
-                    // ask for layout in only content.  We can't currently figure out
-                    // what the screen would be if only laying out to hide the nav bar.
-                    pf.left = df.left = cf.left = mUnrestrictedScreenLeft;
-                    pf.top = df.top = cf.top = mUnrestrictedScreenTop;
-                    pf.right = df.right = cf.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-                    pf.bottom = df.bottom = cf.bottom
-                            = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
-                } else {
-                    pf.left = df.left = cf.left = mRestrictedScreenLeft;
-                    pf.top = df.top = cf.top = mRestrictedScreenTop;
-                    pf.right = df.right = cf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
-                    pf.bottom = df.bottom = cf.bottom
-                            = mRestrictedScreenTop+mRestrictedScreenHeight;
-                }
-
-                applyStableConstraints(sysUiFl, fl, cf);
-
-                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
-                    vf.left = mCurLeft;
-                    vf.top = mCurTop;
-                    vf.right = mCurRight;
-                    vf.bottom = mCurBottom;
-                } else {
-                    vf.set(cf);
-                }
-            } else if (attached != null) {
-                if (DEBUG_LAYOUT)
-                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
-                // A child window should be placed inside of the same visible
-                // frame that its parent had.
-                setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, cf, vf);
-            } else {
-                if (DEBUG_LAYOUT)
-                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
-                // Otherwise, a normal window must be placed inside the content
-                // of all screen decorations.
-                if (attrs.type == TYPE_STATUS_BAR_PANEL) {
-                    // Status bar panels are the only windows who can go on top of
-                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
-                    // permission, so they have the same privileges as the status
-                    // bar itself.
-                    pf.left = df.left = cf.left = mRestrictedScreenLeft;
-                    pf.top = df.top = cf.top = mRestrictedScreenTop;
-                    pf.right = df.right = cf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
-                    pf.bottom = df.bottom = cf.bottom
-                            = mRestrictedScreenTop+mRestrictedScreenHeight;
-                } else {
-                    pf.left = mContentLeft;
-                    pf.top = mContentTop;
-                    pf.right = mContentRight;
-                    pf.bottom = mContentBottom;
-                    if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
-                        df.left = cf.left = mDockLeft;
-                        df.top = cf.top = mDockTop;
-                        df.right = cf.right = mDockRight;
-                        df.bottom = cf.bottom = mDockBottom;
-                    } else {
-                        df.left = cf.left = mRestrictedScreenLeft;
-                        df.top = cf.top = mRestrictedScreenTop;
-                        df.right = cf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
-                        df.bottom = cf.bottom = mRestrictedScreenTop+mRestrictedScreenHeight;
-                    }
-                    if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
-                        vf.left = mRestrictedScreenLeft;
-                        vf.top =  mRestrictedScreenTop;
-                        vf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
-                        vf.bottom = mRestrictedScreenTop+mRestrictedScreenHeight;;
-                    } else {
-                        vf.set(cf);
-                    }
-                }
-            }
-        }
-
-        if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
-            df.left = df.top = cf.left = cf.top = vf.left = vf.top = -10000;
-            df.right = df.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
-        }
-
-        if (DEBUG_LAYOUT) Log.v(TAG, "Compute frame " + attrs.getTitle()
-                + ": sim=#" + Integer.toHexString(sim)
-                + " attach=" + attached + " type=" + attrs.type 
-                + String.format(" flags=0x%08x", fl)
-                + " pf=" + pf.toShortString() + " df=" + df.toShortString()
-                + " cf=" + cf.toShortString() + " vf=" + vf.toShortString());
-
-        win.computeFrameLw(pf, df, cf, vf);
-
-        // Dock windows carve out the bottom of the screen, so normal windows
-        // can't appear underneath them.
-        if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw()
-                && !win.getGivenInsetsPendingLw()) {
-            setLastInputMethodWindowLw(null, null);
-            offsetInputMethodWindowLw(win);
-        }
-    }
-
-    private boolean expandedDesktopHidesStatusBar() {
-        return mExpandedDesktopStyle == 2;
-    }
-
-    private boolean expandedDesktopHidesNavigationBar() {
-        return mExpandedDesktopStyle != 0;
-    }
-
-    private boolean shouldHideNavigationBarLw(int systemUiVisibility) {
-        if (expandedDesktopHidesNavigationBar()) {
-            if ((systemUiVisibility & View.SYSTEM_UI_FLAG_SHOW_NAVIGATION_IN_EXPANDED_DESKTOP) == 0) {
-                return true;
-            }
-        }
-
-        if (mCanHideNavigationBar) {
-            if ((systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    private void offsetInputMethodWindowLw(WindowState win) {
-        int top = win.getContentFrameLw().top;
-        top += win.getGivenContentInsetsLw().top;
-        if (mContentBottom > top) {
-            mContentBottom = top;
-        }
-        top = win.getVisibleFrameLw().top;
-        top += win.getGivenVisibleInsetsLw().top;
-        if (mCurBottom > top) {
-            mCurBottom = top;
-        }
-        if (DEBUG_LAYOUT) Log.v(TAG, "Input method: mDockBottom="
-                + mDockBottom + " mContentBottom="
-                + mContentBottom + " mCurBottom=" + mCurBottom);
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public void finishLayoutLw() {
-        return;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public void beginPostLayoutPolicyLw(int displayWidth, int displayHeight) {
-        mTopFullscreenOpaqueWindowState = null;
-        mForceStatusBar = false;
-        mForceStatusBarFromKeyguard = false;
-        mForcingShowNavBar = false;
-        mForcingShowNavBarLayer = -1;
-        
-        mHideLockScreen = false;
-        mAllowLockscreenWhenOn = false;
-        mDismissKeyguard = DISMISS_KEYGUARD_NONE;
-        mShowingLockscreen = false;
-        mShowingDream = false;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public void applyPostLayoutPolicyLw(WindowState win,
-                                WindowManager.LayoutParams attrs) {
-        if (DEBUG_LAYOUT) Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw="
-                + win.isVisibleOrBehindKeyguardLw());
-        if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags
-                &WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0) {
-            if (mForcingShowNavBarLayer < 0) {
-                mForcingShowNavBar = true;
-                mForcingShowNavBarLayer = win.getSurfaceLayer();
-            }
-        }
-        if (mTopFullscreenOpaqueWindowState == null &&
-                win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
-            if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
-                if (attrs.type == TYPE_KEYGUARD) {
-                    mForceStatusBarFromKeyguard = true;
-                } else {
-                    mForceStatusBar = true;
-                }
-            }
-            if (attrs.type == TYPE_KEYGUARD) {
-                mShowingLockscreen = true;
-            }
-            boolean applyWindow = attrs.type >= FIRST_APPLICATION_WINDOW
-                    && attrs.type <= LAST_APPLICATION_WINDOW;
-            if (attrs.type == TYPE_DREAM) {
-                // If the lockscreen was showing when the dream started then wait
-                // for the dream to draw before hiding the lockscreen.
-                if (!mDreamingLockscreen
-                        || (win.isVisibleLw() && win.hasDrawnLw())) {
-                    mShowingDream = true;
-                    applyWindow = true;
-                }
-            }
-            if (applyWindow
-                    && attrs.x == 0 && attrs.y == 0
-                    && attrs.width == WindowManager.LayoutParams.MATCH_PARENT
-                    && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
-                if (DEBUG_LAYOUT) Log.v(TAG, "Fullscreen window: " + win);
-                mTopFullscreenOpaqueWindowState = win;
-                if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
-                    if (DEBUG_LAYOUT) Log.v(TAG, "Setting mHideLockScreen to true by win " + win);
-                    mHideLockScreen = true;
-                    mForceStatusBarFromKeyguard = false;
-                }
-                if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0
-                        && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
-                    if (DEBUG_LAYOUT) Log.v(TAG, "Setting mDismissKeyguard to true by win " + win);
-                    mDismissKeyguard = mWinDismissingKeyguard == win ?
-                            DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
-                    mWinDismissingKeyguard = win;
-                    mForceStatusBarFromKeyguard = false;
-                }
-                if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
-                    mAllowLockscreenWhenOn = true;
-                }
-            }
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public int finishPostLayoutPolicyLw() {
-        int changes = 0;
-        boolean topIsFullscreen = false;
-
-        final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null)
-                ? mTopFullscreenOpaqueWindowState.getAttrs()
-                : null;
-
-        // If we are not currently showing a dream then remember the current
-        // lockscreen state.  We will use this to determine whether the dream
-        // started while the lockscreen was showing and remember this state
-        // while the dream is showing.
-        if (!mShowingDream) {
-            mDreamingLockscreen = mShowingLockscreen;
-        }
-
-        if (mStatusBar != null) {
-            if (DEBUG_LAYOUT) Log.i(TAG, "force=" + mForceStatusBar
-                    + " forcefkg=" + mForceStatusBarFromKeyguard
-                    + " top=" + mTopFullscreenOpaqueWindowState);
-            if (expandedDesktopHidesStatusBar()) {
-                if (DEBUG_LAYOUT) Log.v(TAG, "Hiding status bar: expanded desktop enabled");
-                if (mStatusBar.hideLw(true)) changes |= FINISH_LAYOUT_REDO_LAYOUT;
-            } else if (mForceStatusBar || mForceStatusBarFromKeyguard) {
-                if (DEBUG_LAYOUT) Log.v(TAG, "Showing status bar: forced");
-                if (mStatusBar.showLw(true)) changes |= FINISH_LAYOUT_REDO_LAYOUT;
-            } else if (mTopFullscreenOpaqueWindowState != null) {
-                if (localLOGV) {
-                    Log.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw()
-                            + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
-                    Log.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs()
-                            + " lp.flags=0x" + Integer.toHexString(lp.flags));
-                }
-                topIsFullscreen = (lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0
-                        || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
-                // The subtle difference between the window for mTopFullscreenOpaqueWindowState
-                // and mTopIsFullscreen is that that mTopIsFullscreen is set only if the window
-                // has the FLAG_FULLSCREEN set.  Not sure if there is another way that to be the
-                // case though.
-                mHideStatusBar = Settings.System.getInt(mContext.getContentResolver(),
-                        Settings.System.HIDE_STATUSBAR, 0) == 1;
-                if (topIsFullscreen || mHideStatusBar) {
-                    if (DEBUG_LAYOUT) Log.v(TAG, "** HIDING status bar");
-                    if (mStatusBar.hideLw(true)) {
-                        changes |= FINISH_LAYOUT_REDO_LAYOUT;
-
-                        mHandler.post(new Runnable() {
-                            @Override
-                            public void run() {
-                            try {
-                                IStatusBarService statusbar = getStatusBarService();
-                                if (statusbar != null) {
-                                    statusbar.collapsePanels();
-                                }
-                            } catch (RemoteException ex) {
-                                // re-acquire status bar service next time it is needed.
-                                mStatusBarService = null;
-                            }
-                        }});
-                    } else if (DEBUG_LAYOUT) {
-                        Log.v(TAG, "Preventing status bar from hiding by policy");
-                    }
-                } else {
-                    if (DEBUG_LAYOUT) Log.v(TAG, "** SHOWING status bar: top is not fullscreen");
-                    if (mStatusBar.showLw(true)) changes |= FINISH_LAYOUT_REDO_LAYOUT;
-                }
-            }
-        }
-
-        mTopIsFullscreen = topIsFullscreen;
-
-        // Hide the key guard if a visible window explicitly specifies that it wants to be
-        // displayed when the screen is locked.
-        if (mKeyguard != null) {
-            if (localLOGV) Log.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard="
-                    + mHideLockScreen);
-            if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardMediator.isSecure()) {
-                if (mKeyguard.hideLw(true)) {
-                    changes |= FINISH_LAYOUT_REDO_LAYOUT
-                            | FINISH_LAYOUT_REDO_CONFIG
-                            | FINISH_LAYOUT_REDO_WALLPAPER;
-                }
-                if (mKeyguardMediator.isShowing()) {
-                    mHandler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            mKeyguardMediator.keyguardDone(false, false);
-                        }
-                    });
-                }
-            } else if (mHideLockScreen) {
-                if (mKeyguard.hideLw(true)) {
-                    changes |= FINISH_LAYOUT_REDO_LAYOUT
-                            | FINISH_LAYOUT_REDO_CONFIG
-                            | FINISH_LAYOUT_REDO_WALLPAPER;
-                }
-                mKeyguardMediator.setHidden(true);
-            } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
-                // This is the case of keyguard isSecure() and not mHideLockScreen.
-                if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
-                    // Only launch the next keyguard unlock window once per window.
-                    if (mKeyguard.showLw(true)) {
-                        changes |= FINISH_LAYOUT_REDO_LAYOUT
-                                | FINISH_LAYOUT_REDO_CONFIG
-                                | FINISH_LAYOUT_REDO_WALLPAPER;
-                    }
-                    mKeyguardMediator.setHidden(false);
-                    mHandler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            mKeyguardMediator.dismiss();
-                        }
-                    });
-                }
-            } else {
-                mWinDismissingKeyguard = null;
-                if (mKeyguard.showLw(true)) {
-                    changes |= FINISH_LAYOUT_REDO_LAYOUT
-                            | FINISH_LAYOUT_REDO_CONFIG
-                            | FINISH_LAYOUT_REDO_WALLPAPER;
-                }
-                mKeyguardMediator.setHidden(false);
-            }
-        }
-
-        if ((updateSystemUiVisibilityLw()&SYSTEM_UI_CHANGING_LAYOUT) != 0) {
-            // If the navigation bar has been hidden or shown, we need to do another
-            // layout pass to update that window.
-            changes |= FINISH_LAYOUT_REDO_LAYOUT;
-        }
-
-        // update since mAllowLockscreenWhenOn might have changed
-        updateLockScreenTimeout();
-        return changes;
-    }
-
-    public boolean allowAppAnimationsLw() {
-        if (mKeyguard != null && mKeyguard.isVisibleLw() && !mKeyguard.isAnimatingLw()) {
-            // If keyguard is currently visible, no reason to animate
-            // behind it.
-            return false;
-        }
-        return true;
-    }
-
-    public int focusChangedLw(WindowState lastFocus, WindowState newFocus) {
-        mFocusedWindow = newFocus;
-        if ((updateSystemUiVisibilityLw()&SYSTEM_UI_CHANGING_LAYOUT) != 0) {
-            // If the navigation bar has been hidden or shown, we need to do another
-            // layout pass to update that window.
-            return FINISH_LAYOUT_REDO_LAYOUT;
-        }
-        return 0;
-    }
-
-    /** {@inheritDoc} */
-    public void notifyLidSwitchChanged(long whenNanos, boolean lidOpen) {
-        // do nothing if headless
-        if (mHeadless) return;
-
-        // lid changed state
-        final int newLidState = lidOpen ? LID_OPEN : LID_CLOSED;
-        if (newLidState == mLidState) {
-            return;
-        }
-
-        mLidState = newLidState;
-        applyLidSwitchState();
-        updateRotation(true);
-
-        if (lidOpen) {
-            if (keyguardIsShowingTq()) {
-                mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(KeyEvent.KEYCODE_POWER);
-            } else {
-                mPowerManager.wakeUp(SystemClock.uptimeMillis());
-            }
-        } else if (!mLidControlsSleep) {
-            mPowerManager.userActivity(SystemClock.uptimeMillis(), false);
-        }
-    }
-
-    void setHdmiPlugged(boolean plugged) {
-        if (mHdmiPlugged != plugged) {
-            mHdmiPlugged = plugged;
-            updateRotation(true, true);
-            Intent intent = new Intent(ACTION_HDMI_PLUGGED);
-            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
-            intent.putExtra(EXTRA_HDMI_PLUGGED_STATE, plugged);
-            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
-        }
-    }
-
-    void initializeHdmiState() {
-        boolean plugged = false;
-        // watch for HDMI plug messages if the hdmi switch exists
-        if (new File("/sys/devices/virtual/switch/hdmi/state").exists()) {
-            mHDMIObserver.startObserving("DEVPATH=/devices/virtual/switch/hdmi");
-
-            final String filename = "/sys/class/switch/hdmi/state";
-            FileReader reader = null;
-            try {
-                reader = new FileReader(filename);
-                char[] buf = new char[15];
-                int n = reader.read(buf);
-                if (n > 1) {
-                    plugged = 0 != Integer.parseInt(new String(buf, 0, n-1));
-                }
-            } catch (IOException ex) {
-                Slog.w(TAG, "Couldn't read hdmi state from " + filename + ": " + ex);
-            } catch (NumberFormatException ex) {
-                Slog.w(TAG, "Couldn't read hdmi state from " + filename + ": " + ex);
-            } finally {
-                if (reader != null) {
-                    try {
-                        reader.close();
-                    } catch (IOException ex) {
-                    }
-                }
-            }
-        }
-        // This dance forces the code in setHdmiPlugged to run.
-        // Always do this so the sticky intent is stuck (to false) if there is no hdmi.
-        mHdmiPlugged = !plugged;
-        setHdmiPlugged(!mHdmiPlugged);
-    }
-
-    /**
-     * @return Whether music is being played right now.
-     */
-    boolean isMusicActive() {
-        final AudioManager am = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
-        if (am == null) {
-            Log.w(TAG, "isMusicActive: couldn't get AudioManager reference");
-            return false;
-        }
-        return am.isMusicActive();
-    }
-
-    /**
-     * Tell the audio service to adjust the volume appropriate to the event.
-     * @param keycode
-     */
-    void handleVolumeKey(int stream, int keycode) {
-        IAudioService audioService = getAudioService();
-        if (audioService == null) {
-            return;
-        }
-        try {
-            // since audio is playing, we shouldn't have to hold a wake lock
-            // during the call, but we do it as a precaution for the rare possibility
-            // that the music stops right before we call this
-            // TODO: Actually handle MUTE.
-            mBroadcastWakeLock.acquire();
-            audioService.adjustStreamVolume(stream,
-                keycode == KeyEvent.KEYCODE_VOLUME_UP
-                            ? AudioManager.ADJUST_RAISE
-                            : AudioManager.ADJUST_LOWER,
-                    0);
-        } catch (RemoteException e) {
-            Log.w(TAG, "IAudioService.adjustStreamVolume() threw RemoteException " + e);
-        } finally {
-            mBroadcastWakeLock.release();
-        }
-    }
-
-    final Object mScreenshotLock = new Object();
-    ServiceConnection mScreenshotConnection = null;
-
-    final Runnable mScreenshotTimeout = new Runnable() {
-        @Override public void run() {
-            synchronized (mScreenshotLock) {
-                if (mScreenshotConnection != null) {
-                    mContext.unbindService(mScreenshotConnection);
-                    mScreenshotConnection = null;
-                }
-            }
-        }
-    };
-
-    // Assume this is called from the Handler thread.
-    private void takeScreenshot() {
-        synchronized (mScreenshotLock) {
-            if (mScreenshotConnection != null) {
-                return;
-            }
-            ComponentName cn = new ComponentName("com.android.systemui",
-                    "com.android.systemui.screenshot.TakeScreenshotService");
-            Intent intent = new Intent();
-            intent.setComponent(cn);
-            ServiceConnection conn = new ServiceConnection() {
-                @Override
-                public void onServiceConnected(ComponentName name, IBinder service) {
-                    synchronized (mScreenshotLock) {
-                        if (mScreenshotConnection != this) {
-                            return;
-                        }
-                        Messenger messenger = new Messenger(service);
-                        Message msg = Message.obtain(null, 1);
-                        final ServiceConnection myConn = this;
-                        Handler h = new Handler(mHandler.getLooper()) {
-                            @Override
-                            public void handleMessage(Message msg) {
-                                synchronized (mScreenshotLock) {
-                                    if (mScreenshotConnection == myConn) {
-                                        mContext.unbindService(mScreenshotConnection);
-                                        mScreenshotConnection = null;
-                                        mHandler.removeCallbacks(mScreenshotTimeout);
-                                    }
-                                }
-                            }
-                        };
-                        msg.replyTo = new Messenger(h);
-                        msg.arg1 = msg.arg2 = 0;
-                        if (mStatusBar != null && mStatusBar.isVisibleLw())
-                            msg.arg1 = 1;
-                        if (mNavigationBar != null && mNavigationBar.isVisibleLw())
-                            msg.arg2 = 1;
-                        try {
-                            messenger.send(msg);
-                        } catch (RemoteException e) {
-                        }
-                    }
-                }
-                @Override
-                public void onServiceDisconnected(ComponentName name) {}
-            };
-            if (mContext.bindService(
-                    intent, conn, Context.BIND_AUTO_CREATE, UserHandle.USER_CURRENT)) {
-                mScreenshotConnection = conn;
-                mHandler.postDelayed(mScreenshotTimeout, 10000);
-            }
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags, boolean isScreenOn) {
-        if (!mSystemBooted) {
-            // If we have not yet booted, don't let key events do anything.
-            return 0;
-        }
-
-        final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
-        final boolean canceled = event.isCanceled();
-        int keyCode = event.getKeyCode();
-
-        final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
-
-        // If screen is off then we treat the case where the keyguard is open but hidden
-        // the same as if it were open and in front.
-        // This will prevent any keys other than the power button from waking the screen
-        // when the keyguard is hidden by another activity.
-        final boolean keyguardActive = (mKeyguardMediator == null ? false :
-                                            (isScreenOn ?
-                                                mKeyguardMediator.isShowingAndNotHidden() :
-                                                mKeyguardMediator.isShowing()));
-
-        if (keyCode == KeyEvent.KEYCODE_POWER) {
-            policyFlags |= WindowManagerPolicy.FLAG_WAKE;
-        }
-        final boolean isWakeKey = (policyFlags
-                & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0;
-
-        if (DEBUG_INPUT) {
-            Log.d(TAG, "interceptKeyTq keycode=" + keyCode
-                    + " screenIsOn=" + isScreenOn + " keyguardActive=" + keyguardActive
-                    + " policyFlags=" + Integer.toHexString(policyFlags)
-                    + " isWakeKey=" + isWakeKey);
-        }
-
-        if (down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0
-                && event.getRepeatCount() == 0) {
-            performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
-        }
-
-        // Basic policy based on screen state and keyguard.
-        // FIXME: This policy isn't quite correct.  We shouldn't care whether the screen
-        //        is on or off, really.  We should care about whether the device is in an
-        //        interactive state or is in suspend pretending to be "off".
-        //        The primary screen might be turned off due to proximity sensor or
-        //        because we are presenting media on an auxiliary screen or remotely controlling
-        //        the device some other way (which is why we have an exemption here for injected
-        //        events).
-        int result;
-        if ((isScreenOn && !mHeadless) || (isInjected && !isWakeKey)) {
-            // When the screen is on or if the key is injected pass the key to the application.
-            result = ACTION_PASS_TO_USER;
-        } else {
-            // When the screen is off and the key is not injected, determine whether
-            // to wake the device but don't pass the key to the application.
-            result = 0;
-            if (down && isWakeKey && isWakeKeyWhenScreenOff(keyCode)) {
-                if (keyguardActive) {
-                    // If the keyguard is showing, let it wake the device when ready.
-                    mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(keyCode);
-                } else if ((keyCode != KeyEvent.KEYCODE_VOLUME_UP) && (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN)) {
-                    // Otherwise, wake the device ourselves.
-                    result |= ACTION_WAKE_UP;
-                }
-            }
-        }
-
-        // Handle special keys.
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_ENDCALL: {
-                result &= ~ACTION_PASS_TO_USER;
-                if (down) {
-                    ITelephony telephonyService = getTelephonyService();
-                    boolean hungUp = false;
-                    if (telephonyService != null) {
-                        try {
-                            hungUp = telephonyService.endCall();
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
-                        }
-                    }
-                    interceptPowerKeyDown(!isScreenOn || hungUp);
-                } else {
-                    if (interceptPowerKeyUp(canceled)) {
-                        if ((mEndcallBehavior
-                                & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
-                            if (goHome()) {
-                                break;
-                            }
-                        }
-                        if ((mEndcallBehavior
-                                & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
-                            result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
-                        }
-                    }
-                }
-                break;
-            }
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-            case KeyEvent.KEYCODE_VOLUME_UP:
-            case KeyEvent.KEYCODE_VOLUME_MUTE: {
-                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
-                    if (down) {
-                        if (isScreenOn && !mVolumeDownKeyTriggered
-                                && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
-                            mVolumeDownKeyTriggered = true;
-                            mVolumeDownKeyTime = event.getDownTime();
-                            mVolumeDownKeyConsumedByChord = false;
-                            cancelPendingPowerKeyAction();
-                            interceptScreenshotChord();
-                            interceptRingerChord();
-                        }
-                    } else {
-                        mVolumeDownKeyTriggered = false;
-                        cancelPendingScreenshotChordAction();
-                        cancelPendingRingerChordAction();
-                    }
-                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
-                    if (down) {
-                        if (isScreenOn && !mVolumeUpKeyTriggered
-                                && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
-                            mVolumeUpKeyTriggered = true;
-                            mVolumeUpKeyTime = event.getDownTime();
-                            mVolumeUpKeyConsumedByChord = false;
-                            cancelPendingPowerKeyAction();
-                            cancelPendingScreenshotChordAction();
-                            interceptRingerChord();
-                        }
-                    } else {
-                        mVolumeUpKeyTriggered = false;
-                        cancelPendingScreenshotChordAction();
-                        cancelPendingRingerChordAction();
-                    }
-                }
-                if (down) {
-                    ITelephony telephonyService = getTelephonyService();
-                    if (telephonyService != null) {
-                        try {
-                            if (telephonyService.isRinging()) {
-                                // If an incoming call is ringing, either VOLUME key means
-                                // "silence ringer".  We handle these keys here, rather than
-                                // in the InCallScreen, to make sure we'll respond to them
-                                // even if the InCallScreen hasn't come to the foreground yet.
-                                // Look for the DOWN event here, to agree with the "fallback"
-                                // behavior in the InCallScreen.
-                                Log.i(TAG, "interceptKeyBeforeQueueing:"
-                                      + " VOLUME key-down while ringing: Silence ringer!");
-
-                                // Silence the ringer.  (It's safe to call this
-                                // even if the ringer has already been silenced.)
-                                telephonyService.silenceRinger();
-
-                                // And *don't* pass this key thru to the current activity
-                                // (which is probably the InCallScreen.)
-                                result &= ~ACTION_PASS_TO_USER;
-                                break;
-                            }
-                            if (telephonyService.isOffhook()
-                                    && (result & ACTION_PASS_TO_USER) == 0) {
-                                // If we are in call but we decided not to pass the key to
-                                // the application, handle the volume change here.
-                                handleVolumeKey(AudioManager.STREAM_VOICE_CALL, keyCode);
-                                break;
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
-                        }
-                    }
-                }
-                if (isMusicActive() && (result & ACTION_PASS_TO_USER) == 0) {
-                    if (mVolBtnMusicControls && down && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
-                        mIsLongPress = false;
-                        int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ?
-                                KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
-                        Message msg = mHandler.obtainMessage(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK,
-                                new KeyEvent(event.getDownTime(), event.getEventTime(), event.getAction(), newKeyCode, 0));
-                        msg.setAsynchronous(true);
-                        mHandler.sendMessageDelayed(msg, ViewConfiguration.getLongPressTimeout());
-                        break;
-                    } else {
-                        if (mVolBtnMusicControls && !down) {
-                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
-                            if (mIsLongPress) {
-                                break;
-                            }
-                        }
-                        if (!isScreenOn && !mVolumeWakeScreen) {
-                            handleVolumeKey(AudioManager.STREAM_MUSIC, keyCode);
-                        }
-                    }
-                }
-                if (isScreenOn || !mVolumeWakeScreen) {
-                    break;
-                } else if (keyguardActive) {
-                    keyCode = KeyEvent.KEYCODE_POWER;
-                    mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(keyCode);
-                } else {
-                    result |= ACTION_WAKE_UP;
-                    break;
-                }
-            }
-
-            case KeyEvent.KEYCODE_POWER: {
-                if ((mTopFullscreenOpaqueWindowState.getAttrs().flags
-                        & WindowManager.LayoutParams.PREVENT_POWER_KEY) != 0){
-                    return result;
-                }
-                result &= ~ACTION_PASS_TO_USER;
-                if (down) {
-                    if (isScreenOn && !mPowerKeyTriggered
-                            && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
-                        mPowerKeyTriggered = true;
-                        mPowerKeyTime = event.getDownTime();
-                        cancelPendingRingerChordAction();
-                        interceptScreenshotChord();
-                    }
-
-                    ITelephony telephonyService = getTelephonyService();
-                    boolean hungUp = false;
-                    if (telephonyService != null) {
-                        try {
-                            if (telephonyService.isRinging()) {
-                                // Pressing Power while there's a ringing incoming
-                                // call should silence the ringer.
-                                telephonyService.silenceRinger();
-                            } else if ((mIncallPowerBehavior
-                                    & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0
-                                    && telephonyService.isOffhook()) {
-                                // Otherwise, if "Power button ends call" is enabled,
-                                // the Power button will hang up any current active call.
-                                hungUp = telephonyService.endCall();
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
-                        }
-                    }
-                    interceptPowerKeyDown(!isScreenOn || hungUp
-                            || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
-                } else {
-                    mPowerKeyTriggered = false;
-                    cancelPendingScreenshotChordAction();
-                    if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
-                        result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
-                    }
-                    mPendingPowerKeyUpCanceled = false;
-                }
-                break;
-            }
-
-            case KeyEvent.KEYCODE_MEDIA_PLAY:
-            case KeyEvent.KEYCODE_MEDIA_PAUSE:
-            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-                if (down) {
-                    ITelephony telephonyService = getTelephonyService();
-                    if (telephonyService != null) {
-                        try {
-                            if (!telephonyService.isIdle()) {
-                                // Suppress PLAY/PAUSE toggle when phone is ringing or in-call
-                                // to avoid music playback.
-                                break;
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
-                        }
-                    }
-                }
-            case KeyEvent.KEYCODE_HEADSETHOOK:
-            case KeyEvent.KEYCODE_MUTE:
-            case KeyEvent.KEYCODE_MEDIA_STOP:
-            case KeyEvent.KEYCODE_MEDIA_NEXT:
-            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
-            case KeyEvent.KEYCODE_MEDIA_REWIND:
-            case KeyEvent.KEYCODE_MEDIA_RECORD:
-            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD: {
-                if ((result & ACTION_PASS_TO_USER) == 0) {
-                    // Only do this if we would otherwise not pass it to the user. In that
-                    // case, the PhoneWindow class will do the same thing, except it will
-                    // only do it if the showing app doesn't process the key on its own.
-                    // Note that we need to make a copy of the key event here because the
-                    // original key event will be recycled when we return.
-                    mBroadcastWakeLock.acquire();
-                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK,
-                            new KeyEvent(event));
-                    msg.setAsynchronous(true);
-                    msg.sendToTarget();
-                }
-                break;
-            }
-
-            case KeyEvent.KEYCODE_CALL: {
-                if (down) {
-                    ITelephony telephonyService = getTelephonyService();
-                    if (telephonyService != null) {
-                        try {
-                            if (telephonyService.isRinging()) {
-                                Log.i(TAG, "interceptKeyBeforeQueueing:"
-                                      + " CALL key-down while ringing: Answer the call!");
-                                telephonyService.answerRingingCall();
-
-                                // And *don't* pass this key thru to the current activity
-                                // (which is presumably the InCallScreen.)
-                                result &= ~ACTION_PASS_TO_USER;
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
-                        }
-                    }
-                }
-                break;
-            }
-        }
-        return result;
-    }
-
-    /**
-     * When the screen is off we ignore some keys that might otherwise typically
-     * be considered wake keys.  We filter them out here.
-     *
-     * {@link KeyEvent#KEYCODE_POWER} is notably absent from this list because it
-     * is always considered a wake key.
-     */
-    private boolean isWakeKeyWhenScreenOff(int keyCode) {
-        switch (keyCode) {
-            // ignore volume keys unless docked
-            case KeyEvent.KEYCODE_VOLUME_UP:
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-            case KeyEvent.KEYCODE_VOLUME_MUTE:
-                return mDockMode != Intent.EXTRA_DOCK_STATE_UNDOCKED;
-
-            // ignore media and camera keys
-            case KeyEvent.KEYCODE_MUTE:
-            case KeyEvent.KEYCODE_HEADSETHOOK:
-            case KeyEvent.KEYCODE_MEDIA_PLAY:
-            case KeyEvent.KEYCODE_MEDIA_PAUSE:
-            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-            case KeyEvent.KEYCODE_MEDIA_STOP:
-            case KeyEvent.KEYCODE_MEDIA_NEXT:
-            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
-            case KeyEvent.KEYCODE_MEDIA_REWIND:
-            case KeyEvent.KEYCODE_MEDIA_RECORD:
-            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
-            case KeyEvent.KEYCODE_CAMERA:
-                return false;
-        }
-        return true;
-    }
-
-
-    /** {@inheritDoc} */
-    @Override
-    public int interceptMotionBeforeQueueingWhenScreenOff(int policyFlags) {
-        int result = 0;
-
-        final boolean isWakeMotion = (policyFlags
-                & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0;
-        if (isWakeMotion) {
-            if (mKeyguardMediator != null && mKeyguardMediator.isShowing()) {
-                // If the keyguard is showing, let it decide what to do with the wake motion.
-                mKeyguardMediator.onWakeMotionWhenKeyguardShowingTq();
-            } else {
-                // Otherwise, wake the device ourselves.
-                result |= ACTION_WAKE_UP;
-            }
-        }
-        return result;
-    }
-
-    void dispatchMediaKeyWithWakeLock(KeyEvent event) {
-        if (DEBUG_INPUT) {
-            Slog.d(TAG, "dispatchMediaKeyWithWakeLock: " + event);
-        }
-
-        if (mHavePendingMediaKeyRepeatWithWakeLock) {
-            if (DEBUG_INPUT) {
-                Slog.d(TAG, "dispatchMediaKeyWithWakeLock: canceled repeat");
-            }
-
-            mHandler.removeMessages(MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK);
-            mHavePendingMediaKeyRepeatWithWakeLock = false;
-            mBroadcastWakeLock.release(); // pending repeat was holding onto the wake lock
-        }
-
-        dispatchMediaKeyWithWakeLockToAudioService(event);
-
-        if (event.getAction() == KeyEvent.ACTION_DOWN
-                && event.getRepeatCount() == 0) {
-            mHavePendingMediaKeyRepeatWithWakeLock = true;
-
-            Message msg = mHandler.obtainMessage(
-                    MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK, event);
-            msg.setAsynchronous(true);
-            mHandler.sendMessageDelayed(msg, ViewConfiguration.getKeyRepeatTimeout());
-        } else {
-            mBroadcastWakeLock.release();
-        }
-    }
-
-    void dispatchMediaKeyRepeatWithWakeLock(KeyEvent event) {
-        mHavePendingMediaKeyRepeatWithWakeLock = false;
-
-        KeyEvent repeatEvent = KeyEvent.changeTimeRepeat(event,
-                SystemClock.uptimeMillis(), 1, event.getFlags() | KeyEvent.FLAG_LONG_PRESS);
-        if (DEBUG_INPUT) {
-            Slog.d(TAG, "dispatchMediaKeyRepeatWithWakeLock: " + repeatEvent);
-        }
-
-        dispatchMediaKeyWithWakeLockToAudioService(repeatEvent);
-        mBroadcastWakeLock.release();
-    }
-
-    void dispatchMediaKeyWithWakeLockToAudioService(KeyEvent event) {
-        if (ActivityManagerNative.isSystemReady()) {
-            IAudioService audioService = getAudioService();
-            if (audioService != null) {
-                try {
-                    audioService.dispatchMediaKeyEventUnderWakelock(event);
-                } catch (RemoteException e) {
-                    Log.e(TAG, "dispatchMediaKeyEvent threw exception " + e);
-                }
-            }
-        }
-    }
-
-    BroadcastReceiver mDockReceiver = new BroadcastReceiver() {
-        public void onReceive(Context context, Intent intent) {
-            if (Intent.ACTION_DOCK_EVENT.equals(intent.getAction())) {
-                mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
-                        Intent.EXTRA_DOCK_STATE_UNDOCKED);
-            } else {
-                try {
-                    IUiModeManager uiModeService = IUiModeManager.Stub.asInterface(
-                            ServiceManager.getService(Context.UI_MODE_SERVICE));
-                    mUiMode = uiModeService.getCurrentModeType();
-                } catch (RemoteException e) {
-                }
-            }
-            updateRotation(true);
-            updateOrientationListenerLp();
-        }
-    };
-
-    BroadcastReceiver mDreamReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (Intent.ACTION_DREAMING_STARTED.equals(intent.getAction())) {
-                if (mKeyguardMediator != null) {
-                    mKeyguardMediator.onDreamingStarted();
-                }
-            } else if (Intent.ACTION_DREAMING_STOPPED.equals(intent.getAction())) {
-                if (mKeyguardMediator != null) {
-                    mKeyguardMediator.onDreamingStopped();
-                }
-            }
-        }
-    };
-
-    BroadcastReceiver mMultiuserReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (Intent.ACTION_USER_SWITCHED.equals(intent.getAction())) {
-                // tickle the settings observer: this first ensures that we're
-                // observing the relevant settings for the newly-active user,
-                // and then updates our own bookkeeping based on the now-
-                // current user.
-
-                // force a re-application of focused window sysui visibility.
-                // the window may never have been shown for this user
-                // e.g. the keyguard when going through the new-user setup flow
-                synchronized(mLock) {
-                    mLastSystemUiFlags = 0;
-                    updateSystemUiVisibilityLw();
-                }
-            }
-        }
-    };
-    BroadcastReceiver mWifiDisplayReceiver = new BroadcastReceiver() {
-        public void onReceive(Context context, Intent intent) {
-        String action = intent.getAction();
-            if (action.equals(Intent.ACTION_WIFI_DISPLAY_VIDEO)) {
-                int state = intent.getIntExtra("state", 0);
-                if(state == 1) {
-                    mWifiDisplayConnected = true;
-                } else {
-                    mWifiDisplayConnected = false;
-                }
-                updateRotation(true);
-            }
-        }
-    };
-
-    BroadcastReceiver mThemeChangeReceiver = new BroadcastReceiver() {
-        public void onReceive(Context context, Intent intent) {
-            mUiContext = null;
-        }
-    };
-
-    @Override
-    public void screenTurnedOff(int why) {
-        EventLog.writeEvent(70000, 0);
-        synchronized (mLock) {
-            mScreenOnEarly = false;
-            mScreenOnFully = false;
-        }
-        if (mKeyguardMediator != null) {
-            mKeyguardMediator.onScreenTurnedOff(why);
-        }
-        synchronized (mLock) {
-            updateOrientationListenerLp();
-            updateLockScreenTimeout();
-        }
-    }
-
-    @Override
-    public void screenTurningOn(final ScreenOnListener screenOnListener) {
-        EventLog.writeEvent(70000, 1);
-        if (false) {
-            RuntimeException here = new RuntimeException("here");
-            here.fillInStackTrace();
-            Slog.i(TAG, "Screen turning on...", here);
-        }
-
-        synchronized (mLock) {
-            mScreenOnEarly = true;
-            updateOrientationListenerLp();
-            updateLockScreenTimeout();
-        }
-
-        waitForKeyguard(screenOnListener);
-    }
-
-    private void waitForKeyguard(final ScreenOnListener screenOnListener) {
-        if (mKeyguardMediator != null) {
-            if (screenOnListener != null) {
-                mKeyguardMediator.onScreenTurnedOn(new KeyguardViewManager.ShowListener() {
-                    @Override
-                    public void onShown(IBinder windowToken) {
-                        waitForKeyguardWindowDrawn(windowToken, screenOnListener);
-                    }
-                });
-                return;
-            } else {
-                mKeyguardMediator.onScreenTurnedOn(null);
-            }
-        } else {
-            Slog.i(TAG, "No keyguard mediator!");
-        }
-        finishScreenTurningOn(screenOnListener);
-    }
-
-    private void waitForKeyguardWindowDrawn(IBinder windowToken,
-            final ScreenOnListener screenOnListener) {
-        if (windowToken != null) {
-            try {
-                if (mWindowManager.waitForWindowDrawn(
-                        windowToken, new IRemoteCallback.Stub() {
-                    @Override
-                    public void sendResult(Bundle data) {
-                        Slog.i(TAG, "Lock screen displayed!");
-                        finishScreenTurningOn(screenOnListener);
-                    }
-                })) {
-                    return;
-                }
-            } catch (RemoteException ex) {
-                // Can't happen in system process.
-            }
-        }
-
-        Slog.i(TAG, "No lock screen!");
-        finishScreenTurningOn(screenOnListener);
-    }
-
-    private void finishScreenTurningOn(ScreenOnListener screenOnListener) {
-        synchronized (mLock) {
-            mScreenOnFully = true;
-        }
-
-        try {
-            mWindowManager.setEventDispatching(true);
-        } catch (RemoteException unhandled) {
-        }
-
-        if (screenOnListener != null) {
-            screenOnListener.onScreenOn();
-        }
-    }
-
-    @Override
-    public boolean isScreenOnEarly() {
-        return mScreenOnEarly;
-    }
-
-    @Override
-    public boolean isScreenOnFully() {
-        return mScreenOnFully;
-    }
-
-    /** {@inheritDoc} */
-    public void enableKeyguard(boolean enabled) {
-        if (mKeyguardMediator != null) {
-            mKeyguardMediator.setKeyguardEnabled(enabled);
-        }
-    }
-
-    /** {@inheritDoc} */
-    public void exitKeyguardSecurely(OnKeyguardExitResult callback) {
-        if (mKeyguardMediator != null) {
-            mKeyguardMediator.verifyUnlock(callback);
-        }
-    }
-
-    private boolean keyguardIsShowingTq() {
-        if (mKeyguardMediator == null) return false;
-        return mKeyguardMediator.isShowingAndNotHidden();
-    }
-
-
-    /** {@inheritDoc} */
-    public boolean isKeyguardLocked() {
-        return keyguardOn();
-    }
-
-    /** {@inheritDoc} */
-    public boolean isKeyguardSecure() {
-        if (mKeyguardMediator == null) return false;
-        return mKeyguardMediator.isSecure();
-    }
-
-    /** {@inheritDoc} */
-    public boolean inKeyguardRestrictedKeyInputMode() {
-        if (mKeyguardMediator == null) return false;
-        return mKeyguardMediator.isInputRestricted();
-    }
-
-    public void dismissKeyguardLw() {
-        if (mKeyguardMediator.isShowing()) {
-            mHandler.post(new Runnable() {
-                public void run() {
-                    if (mKeyguardMediator.isDismissable()) {
-                        // Can we just finish the keyguard straight away?
-                        mKeyguardMediator.keyguardDone(false, true);
-                    } else {
-                        // ask the keyguard to prompt the user to authenticate if necessary
-                        mKeyguardMediator.dismiss();
-                    }
-                }
-            });
-        }
-    }
-
-    void sendCloseSystemWindows() {
-        sendCloseSystemWindows(mContext, null);
-    }
-
-    void sendCloseSystemWindows(String reason) {
-        sendCloseSystemWindows(mContext, reason);
-    }
-
-    static void sendCloseSystemWindows(Context context, String reason) {
-        if (ActivityManagerNative.isSystemReady()) {
-            try {
-                ActivityManagerNative.getDefault().closeSystemDialogs(reason);
-            } catch (RemoteException e) {
-            }
-        }
-    }
-
-    @Override
-    public int rotationForOrientationLw(int orientation, int lastRotation) {
-        if (false) {
-            Slog.v(TAG, "rotationForOrientationLw(orient="
-                        + orientation + ", last=" + lastRotation
-                        + "); user=" + mUserRotation + " "
-                        + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED)
-                            ? "USER_ROTATION_LOCKED" : "")
-                        );
-        }
-
-        synchronized (mLock) {
-            int sensorRotation = mOrientationListener.getProposedRotation(); // may be -1
-            if (sensorRotation < 0) {
-                sensorRotation = lastRotation;
-            }
-
-            final int preferredRotation;
-            if ((mLidState == LID_OPEN && mLidOpenRotation >= 0)
-                    && !(mHasRemovableLid
-                            && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED)) {
-                // Ignore sensor when lid switch is open and rotation is forced
-                // and a removable lid was not undocked.
-                preferredRotation = mLidOpenRotation;
-            } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR
-                    && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
-                // Ignore sensor when in car dock unless explicitly enabled.
-                // This case can override the behavior of NOSENSOR, and can also
-                // enable 180 degree rotation while docked.
-                preferredRotation = mCarDockEnablesAccelerometer
-                        ? sensorRotation : mCarDockRotation;
-            } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK
-                    || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK
-                    || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK)
-                    && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
-                // Ignore sensor when in desk dock unless explicitly enabled.
-                // This case can override the behavior of NOSENSOR, and can also
-                // enable 180 degree rotation while docked.
-                preferredRotation = mDeskDockEnablesAccelerometer
-                        ? sensorRotation : mDeskDockRotation;
-            } else if ((mHdmiPlugged || mWifiDisplayConnected) &&
-                                                        mHdmiRotationLock) {
-                // Ignore sensor when plugged into HDMI.
-                // or Wifi display is connected
-                // Note that the dock orientation overrides the HDMI/Wifi
-                // orientation.
-                preferredRotation = mHdmiRotation;
-            } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE
-                            && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER
-                                    || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED))
-                    || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR
-                    || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR
-                    || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE
-                    || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
-                // Otherwise, use sensor only if requested by the application or enabled
-                // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
-                if (mAllowAllRotations < 0) {
-                    // Can't read this during init() because the context doesn't
-                    // have display metrics at that time so we cannot determine
-                    // tablet vs. phone then.
-                    mAllowAllRotations = mContext.getResources().getBoolean(
-                            com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
-                }
-                // Rotation setting bitmask
-                // 1=0 2=90 4=180 8=270
-                boolean allowed = true;
-                if (mUserRotationAngles < 0) {
-                    // Not set by user so use these defaults
-                    mUserRotationAngles = mAllowAllRotations == 1 ?
-                            (1 | 2 | 4 | 8) : // All angles
-                                (1 | 2 | 8); // All except 180
-                }
-                switch (sensorRotation) {
-                    case Surface.ROTATION_0:
-                        allowed = (mUserRotationAngles & 1) != 0;
-                        break;
-                    case Surface.ROTATION_90:
-                        allowed = (mUserRotationAngles & 2) != 0;
-                        break;
-                    case Surface.ROTATION_180:
-                        allowed = (mUserRotationAngles & 4) != 0;
-                        break;
-                    case Surface.ROTATION_270:
-                        allowed = (mUserRotationAngles & 8) != 0;
-                        break;
-                }
-                if (allowed) {
-                    preferredRotation = sensorRotation;
-                } else {
-                    preferredRotation = lastRotation;
-                }
-            } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED
-                    && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
-                // Apply rotation lock.  Does not apply to NOSENSOR.
-                // The idea is that the user rotation expresses a weak preference for the direction
-                // of gravity and as NOSENSOR is never affected by gravity, then neither should
-                // NOSENSOR be affected by rotation lock (although it will be affected by docks).
-                preferredRotation = mUserRotation;
-            } else {
-                // No overriding preference.
-                // We will do exactly what the application asked us to do.
-                preferredRotation = -1;
-            }
-
-            switch (orientation) {
-                case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
-                    // Return portrait unless overridden.
-                    if (isAnyPortrait(preferredRotation)) {
-                        return preferredRotation;
-                    }
-                    return mPortraitRotation;
-
-                case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
-                    // Return landscape unless overridden.
-                    if (isLandscapeOrSeascape(preferredRotation)) {
-                        return preferredRotation;
-                    }
-                    return mLandscapeRotation;
-
-                case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
-                    // Return reverse portrait unless overridden.
-                    if (isAnyPortrait(preferredRotation)) {
-                        return preferredRotation;
-                    }
-                    return mUpsideDownRotation;
-
-                case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
-                    // Return seascape unless overridden.
-                    if (isLandscapeOrSeascape(preferredRotation)) {
-                        return preferredRotation;
-                    }
-                    return mSeascapeRotation;
-
-                case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
-                    // Return either landscape rotation.
-                    if (isLandscapeOrSeascape(preferredRotation)) {
-                        return preferredRotation;
-                    }
-                    if (isLandscapeOrSeascape(lastRotation)) {
-                        return lastRotation;
-                    }
-                    return mLandscapeRotation;
-
-                case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
-                    // Return either portrait rotation.
-                    if (isAnyPortrait(preferredRotation)) {
-                        return preferredRotation;
-                    }
-                    if (isAnyPortrait(lastRotation)) {
-                        return lastRotation;
-                    }
-                    return mPortraitRotation;
-
-                default:
-                    // For USER, UNSPECIFIED, NOSENSOR, SENSOR and FULL_SENSOR,
-                    // just return the preferred orientation we already calculated.
-                    if (preferredRotation >= 0) {
-                        return preferredRotation;
-                    }
-                    return Surface.ROTATION_0;
-            }
-        }
-    }
-
-    @Override
-    public boolean rotationHasCompatibleMetricsLw(int orientation, int rotation) {
-        switch (orientation) {
-            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
-            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
-            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
-                return isAnyPortrait(rotation);
-
-            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
-            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
-            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
-                return isLandscapeOrSeascape(rotation);
-
-            default:
-                return true;
-        }
-    }
-
-    @Override
-    public void setRotationLw(int rotation) {
-        mOrientationListener.setCurrentRotation(rotation);
-    }
-
-    private boolean isLandscapeOrSeascape(int rotation) {
-        return rotation == mLandscapeRotation || rotation == mSeascapeRotation;
-    }
-
-    private boolean isAnyPortrait(int rotation) {
-        return rotation == mPortraitRotation || rotation == mUpsideDownRotation;
-    }
-
-
-    // User rotation: to be used when all else fails in assigning an orientation to the device
-    public void setUserRotationMode(int mode, int rot) {
-        ContentResolver res = mContext.getContentResolver();
-
-        // mUserRotationMode and mUserRotation will be assigned by the content observer
-        if (mode == WindowManagerPolicy.USER_ROTATION_LOCKED) {
-            Settings.System.putIntForUser(res,
-                    Settings.System.USER_ROTATION,
-                    rot,
-                    UserHandle.USER_CURRENT);
-            Settings.System.putIntForUser(res,
-                    Settings.System.ACCELEROMETER_ROTATION,
-                    0,
-                    UserHandle.USER_CURRENT);
-        } else {
-            Settings.System.putIntForUser(res,
-                    Settings.System.ACCELEROMETER_ROTATION,
-                    1,
-                    UserHandle.USER_CURRENT);
-        }
-    }
-
-    public void setSafeMode(boolean safeMode) {
-        mSafeMode = safeMode;
-        performHapticFeedbackLw(null, safeMode
-                ? HapticFeedbackConstants.SAFE_MODE_ENABLED
-                : HapticFeedbackConstants.SAFE_MODE_DISABLED, true);
-    }
-    
-    static long[] getLongIntArray(Resources r, int resid) {
-        int[] ar = r.getIntArray(resid);
-        if (ar == null) {
-            return null;
-        }
-        long[] out = new long[ar.length];
-        for (int i=0; i<ar.length; i++) {
-            out[i] = ar[i];
-        }
-        return out;
-    }
-    
-    /** {@inheritDoc} */
-    public void systemReady() {
-        if (mKeyguardMediator != null) {
-            // tell the keyguard
-            mKeyguardMediator.onSystemReady();
-        }
-        synchronized (mLock) {
-            updateOrientationListenerLp();
-            mSystemReady = true;
-            mHandler.post(new Runnable() {
-                public void run() {
-                    updateSettings();
-                }
-            });
-        }
-    }
-
-    /** {@inheritDoc} */
-    public void systemBooted() {
-        synchronized (mLock) {
-            mSystemBooted = true;
-        }
-    }
-
-    ProgressDialog mBootMsgDialog = null;
-
-    /**
-     * name of package currently being dex optimized
-     * as shown through this.showBootMessage(msg, always);
-     */
-    static String currentPackageName;
-    public void setPackageName(String pkgName) {
-        if (pkgName == null) {
-            pkgName = "stop.looking.at.me.swan";
-        }
-        this.currentPackageName = pkgName;
-    }
-
-    /** {@inheritDoc} */
-    public void showBootMessage(final CharSequence msg, final boolean always) {
-        if (mHeadless) return;
-        mHandler.post(new Runnable() {
-            @Override public void run() {
-                if (mBootMsgDialog == null) {
-                    mBootMsgDialog = new ProgressDialog(mContext) {
-                        // This dialog will consume all events coming in to
-                        // it, to avoid it trying to do things too early in boot.
-                        @Override public boolean dispatchKeyEvent(KeyEvent event) {
-                            return true;
-                        }
-                        @Override public boolean dispatchKeyShortcutEvent(KeyEvent event) {
-                            return true;
-                        }
-                        @Override public boolean dispatchTouchEvent(MotionEvent ev) {
-                            return true;
-                        }
-                        @Override public boolean dispatchTrackballEvent(MotionEvent ev) {
-                            return true;
-                        }
-                        @Override public boolean dispatchGenericMotionEvent(MotionEvent ev) {
-                            return true;
-                        }
-                        @Override public boolean dispatchPopulateAccessibilityEvent(
-                                AccessibilityEvent event) {
-                            return true;
-                        }
-                    };
-                    mBootMsgDialog.setTitle(R.string.android_upgrading_title);
-                    mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
-                    mBootMsgDialog.setIndeterminate(true);
-                    mBootMsgDialog.getWindow().setType(
-                            WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
-                    mBootMsgDialog.getWindow().addFlags(
-                            WindowManager.LayoutParams.FLAG_DIM_BEHIND
-                            | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
-                    mBootMsgDialog.getWindow().setDimAmount(1);
-                    WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();
-                    lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
-                    mBootMsgDialog.getWindow().setAttributes(lp);
-                    mBootMsgDialog.setCancelable(false);
-                    mBootMsgDialog.show();
-                }
-                mBootMsgDialog.setMessage(msg);
-                if (currentPackageName != null) {
-                    mBootMsgDialog.setTitle(msg);
-                    mBootMsgDialog.setMessage(currentPackageName);
-                }
-                if (msg.equals(mContext.getResources().getString(R.string.android_upgrading_starting_apps))) {
-                    mBootMsgDialog.setTitle(R.string.android_upgrading_title);
-                    mBootMsgDialog.setMessage(mContext.getResources().getString(R.string.android_upgrading_starting_apps));
-                }
-            }
-        });
-    }
-
-    /** {@inheritDoc} */
-    public void hideBootMessages() {
-        mHandler.post(new Runnable() {
-            @Override public void run() {
-                if (mBootMsgDialog != null) {
-                    mBootMsgDialog.dismiss();
-                    mBootMsgDialog = null;
-                }
-            }
-        });
-    }
-
-    /** {@inheritDoc} */
-    public void userActivity() {
-        // ***************************************
-        // NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
-        // ***************************************
-        // THIS IS CALLED FROM DEEP IN THE POWER MANAGER
-        // WITH ITS LOCKS HELD.
-        //
-        // This code must be VERY careful about the locks
-        // it acquires.
-        // In fact, the current code acquires way too many,
-        // and probably has lurking deadlocks.
-
-        synchronized (mScreenLockTimeout) {
-            if (mLockScreenTimerActive) {
-                // reset the timer
-                mHandler.removeCallbacks(mScreenLockTimeout);
-                mHandler.postDelayed(mScreenLockTimeout, mLockScreenTimeout);
-            }
-        }
-    }
-
-    class ScreenLockTimeout implements Runnable {
-        Bundle options;
-
-        @Override
-        public void run() {
-            synchronized (this) {
-                if (localLOGV) Log.v(TAG, "mScreenLockTimeout activating keyguard");
-                if (mKeyguardMediator != null) {
-                    mKeyguardMediator.doKeyguardTimeout(options);
-                }
-                mLockScreenTimerActive = false;
-                options = null;
-            }
-        }
-
-        public void setLockOptions(Bundle options) {
-            this.options = options;
-        }
-    }
-
-    ScreenLockTimeout mScreenLockTimeout = new ScreenLockTimeout();
-
-    public void lockNow(Bundle options) {
-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER, null);
-        mHandler.removeCallbacks(mScreenLockTimeout);
-        if (options != null) {
-            // In case multiple calls are made to lockNow, we don't wipe out the options
-            // until the runnable actually executes.
-            mScreenLockTimeout.setLockOptions(options);
-        }
-        mHandler.post(mScreenLockTimeout);
-    }
-
-    private void updateLockScreenTimeout() {
-        synchronized (mScreenLockTimeout) {
-            boolean enable = (mAllowLockscreenWhenOn && mScreenOnEarly &&
-                    mKeyguardMediator != null && mKeyguardMediator.isSecure());
-            if (mLockScreenTimerActive != enable) {
-                if (enable) {
-                    if (localLOGV) Log.v(TAG, "setting lockscreen timer");
-                    mHandler.postDelayed(mScreenLockTimeout, mLockScreenTimeout);
-                } else {
-                    if (localLOGV) Log.v(TAG, "clearing lockscreen timer");
-                    mHandler.removeCallbacks(mScreenLockTimeout);
-                }
-                mLockScreenTimerActive = enable;
-            }
-        }
-    }
-
-    /** {@inheritDoc} */
-    public void enableScreenAfterBoot() {
-        readLidState();
-        applyLidSwitchState();
-        updateRotation(true);
-    }
-
-    private void applyLidSwitchState() {
-        mPowerManager.setKeyboardVisibility(isBuiltInKeyboardVisible());
-
-        if (mLidState == LID_CLOSED && mLidControlsSleep) {
-            mPowerManager.goToSleep(SystemClock.uptimeMillis());
-        }
-    }
-
-    void updateRotation(boolean alwaysSendConfiguration) {
-        try {
-            //set orientation on WindowManager
-            mWindowManager.updateRotation(alwaysSendConfiguration, false);
-        } catch (RemoteException e) {
-            // Ignore
-        }
-    }
-
-    void updateRotation(boolean alwaysSendConfiguration, boolean forceRelayout) {
-        try {
-            //set orientation on WindowManager
-            mWindowManager.updateRotation(alwaysSendConfiguration, forceRelayout);
-        } catch (RemoteException e) {
-            // Ignore
-        }
-    }
-
-    void updateDisplayMetrics() {
-        try {
-            mWindowManager.updateDisplayMetrics();
-        } catch (RemoteException e) {
-            // Ignore
-        }
-    }
-
-    /**
-     * Return an Intent to launch the currently active dock app as home.  Returns
-     * null if the standard home should be launched, which is the case if any of the following is
-     * true:
-     * <ul>
-     *  <li>The device is not in either car mode or desk mode
-     *  <li>The device is in car mode but ENABLE_CAR_DOCK_HOME_CAPTURE is false
-     *  <li>The device is in desk mode but ENABLE_DESK_DOCK_HOME_CAPTURE is false
-     *  <li>The device is in car mode but there's no CAR_DOCK app with METADATA_DOCK_HOME
-     *  <li>The device is in desk mode but there's no DESK_DOCK app with METADATA_DOCK_HOME
-     * </ul>
-     * @return
-     */
-    Intent createHomeDockIntent() {
-        Intent intent = null;
-
-        // What home does is based on the mode, not the dock state.  That
-        // is, when in car mode you should be taken to car home regardless
-        // of whether we are actually in a car dock.
-        if (mUiMode == Configuration.UI_MODE_TYPE_CAR) {
-            if (ENABLE_CAR_DOCK_HOME_CAPTURE) {
-                intent = mCarDockIntent;
-            }
-        } else if (mUiMode == Configuration.UI_MODE_TYPE_DESK) {
-            if (ENABLE_DESK_DOCK_HOME_CAPTURE) {
-                intent = mDeskDockIntent;
-            }
-        }
-
-        if (intent == null) {
-            return null;
-        }
-
-        ActivityInfo ai = intent.resolveActivityInfo(
-                mContext.getPackageManager(), PackageManager.GET_META_DATA);
-        if (ai == null) {
-            return null;
-        }
-
-        if (ai.metaData != null && ai.metaData.getBoolean(Intent.METADATA_DOCK_HOME)) {
-            intent = new Intent(intent);
-            intent.setClassName(ai.packageName, ai.name);
-            return intent;
-        }
-
-        return null;
-    }
-
-    void startDockOrHome() {
-        Intent dock = createHomeDockIntent();
-        if (dock != null) {
-            try {
-                mContext.startActivity(dock);
-                return;
-            } catch (ActivityNotFoundException e) {
-            }
-        }
-        mContext.startActivityAsUser(mHomeIntent, UserHandle.CURRENT);
-    }
-    
-    /**
-     * goes to the home screen
-     * @return whether it did anything
-     */
-    boolean goHome() {
-        if (false) {
-            // This code always brings home to the front.
-            try {
-                ActivityManagerNative.getDefault().stopAppSwitches();
-            } catch (RemoteException e) {
-            }
-            sendCloseSystemWindows();
-            startDockOrHome();
-        } else {
-            // This code brings home to the front or, if it is already
-            // at the front, puts the device to sleep.
-            try {
-                if (SystemProperties.getInt("persist.sys.uts-test-mode", 0) == 1) {
-                    /// Roll back EndcallBehavior as the cupcake design to pass P1 lab entry.
-                    Log.d(TAG, "UTS-TEST-MODE");
-                } else {
-                    ActivityManagerNative.getDefault().stopAppSwitches();
-                    sendCloseSystemWindows();
-                    Intent dock = createHomeDockIntent();
-                    if (dock != null) {
-                        int result = ActivityManagerNative.getDefault()
-                                .startActivityAsUser(null, dock,
-                                        dock.resolveTypeIfNeeded(mContext.getContentResolver()),
-                                        null, null, 0,
-                                        ActivityManager.START_FLAG_ONLY_IF_NEEDED,
-                                        null, null, null, UserHandle.USER_CURRENT);
-                        if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
-                            return false;
-                        }
-                    }
-                }
-                int result = ActivityManagerNative.getDefault()
-                        .startActivityAsUser(null, mHomeIntent,
-                                mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),
-                                null, null, 0,
-                                ActivityManager.START_FLAG_ONLY_IF_NEEDED,
-                                null, null, null, UserHandle.USER_CURRENT);
-                if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
-                    return false;
-                }
-            } catch (RemoteException ex) {
-                // bummer, the activity manager, which is in this process, is dead
-            }
-        }
-        return true;
-    }
-    
-    public void setCurrentOrientationLw(int newOrientation) {
-        synchronized (mLock) {
-            if (newOrientation != mCurrentAppOrientation) {
-                mCurrentAppOrientation = newOrientation;
-                updateOrientationListenerLp();
-            }
-        }
-    }
-
-    private void performAuditoryFeedbackForAccessibilityIfNeed() {
-        if (!isGlobalAccessibilityGestureEnabled()) {
-            return;
-        }
-        AudioManager audioManager = (AudioManager) mContext.getSystemService(
-                Context.AUDIO_SERVICE);
-        if (audioManager.isSilentMode()) {
-            return;
-        }
-        Ringtone ringTone = RingtoneManager.getRingtone(mContext,
-                Settings.System.DEFAULT_NOTIFICATION_URI);
-        ringTone.setStreamType(AudioManager.STREAM_MUSIC);
-        ringTone.play();
-    }
-    private boolean isGlobalAccessibilityGestureEnabled() {
-        return Settings.Global.getInt(mContext.getContentResolver(),
-                Settings.Global.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED, 0) == 1;
-    }
-
-    public boolean performHapticFeedbackLw(WindowState win, int effectId, boolean always) {
-        if (!mVibrator.hasVibrator()) {
-            return false;
-        }
-        final boolean hapticsDisabled = Settings.System.getIntForUser(mContext.getContentResolver(),
-                Settings.System.HAPTIC_FEEDBACK_ENABLED, 0, UserHandle.USER_CURRENT) == 0;
-        if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
-            return false;
-        }
-        long[] pattern = null;
-        switch (effectId) {
-            case HapticFeedbackConstants.LONG_PRESS:
-                pattern = mLongPressVibePattern;
-                break;
-            case HapticFeedbackConstants.VIRTUAL_KEY:
-                pattern = mVirtualKeyVibePattern;
-                break;
-            case HapticFeedbackConstants.KEYBOARD_TAP:
-                pattern = mKeyboardTapVibePattern;
-                break;
-            case HapticFeedbackConstants.SAFE_MODE_DISABLED:
-                pattern = mSafeModeDisabledVibePattern;
-                break;
-            case HapticFeedbackConstants.SAFE_MODE_ENABLED:
-                pattern = mSafeModeEnabledVibePattern;
-                break;
-            default:
-                return false;
-        }
-        if (pattern.length == 1) {
-            // One-shot vibration
-            mVibrator.vibrate(pattern[0]);
-        } else {
-            // Pattern vibration
-            mVibrator.vibrate(pattern, -1);
-        }
-        return true;
-    }
-
-    @Override
-    public void keepScreenOnStartedLw() {
-    }
-
-    @Override
-    public void keepScreenOnStoppedLw() {
-        if (mKeyguardMediator != null && !mKeyguardMediator.isShowingAndNotHidden()) {
-            long curTime = SystemClock.uptimeMillis();
-            mPowerManager.userActivity(curTime, false);
-        }
-    }
-
-    private int updateSystemUiVisibilityLw() {
-        // If there is no window focused, there will be nobody to handle the events
-        // anyway, so just hang on in whatever state we're in until things settle down.
-        if (mFocusedWindow == null) {
-            return 0;
-        }
-        if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
-            // We are updating at a point where the keyguard has gotten
-            // focus, but we were last in a state where the top window is
-            // hiding it.  This is probably because the keyguard as been
-            // shown while the top window was displayed, so we want to ignore
-            // it here because this is just a very transient change and it
-            // will quickly lose focus once it correctly gets hidden.
-            return 0;
-        }
-        int tmpVisibility = mFocusedWindow.getSystemUiVisibility()
-                & ~mResettingSystemUiFlags
-                & ~mForceClearedSystemUiFlags;
-        if (mForcingShowNavBar && mFocusedWindow.getSurfaceLayer() < mForcingShowNavBarLayer) {
-            tmpVisibility &= ~View.SYSTEM_UI_CLEARABLE_FLAGS;
-        }
-        final int visibility = tmpVisibility;
-        int diff = visibility ^ mLastSystemUiFlags;
-        final boolean needsMenu = mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
-        if (diff == 0 && mLastFocusNeedsMenu == needsMenu
-                && mFocusedApp == mFocusedWindow.getAppToken()) {
-            return 0;
-        }
-        mLastSystemUiFlags = visibility;
-        mLastFocusNeedsMenu = needsMenu;
-        mFocusedApp = mFocusedWindow.getAppToken();
-        mHandler.post(new Runnable() {
-                public void run() {
-                    try {
-                        IStatusBarService statusbar = getStatusBarService();
-                        if (statusbar != null) {
-                            statusbar.setSystemUiVisibility(visibility, 0xffffffff);
-                            statusbar.topAppWindowChanged(needsMenu);
-                        }
-                    } catch (RemoteException e) {
-                        // re-acquire status bar service next time it is needed.
-                        mStatusBarService = null;
-                    }
-                }
-            });
-        return diff;
-    }
-
-    // Use this instead of checking config_showNavigationBar so that it can be consistently
-    // overridden by qemu.hw.mainkeys in the emulator.
-    public boolean hasNavigationBar() {
-        return mHasNavigationBar;
-    }
-
-    @Override
-    public void setLastInputMethodWindowLw(WindowState ime, WindowState target) {
-        mLastInputMethodWindow = ime;
-        mLastInputMethodTargetWindow = target;
-    }
-
-    @Override
-    public boolean canMagnifyWindowLw(WindowManager.LayoutParams attrs) {
-        switch (attrs.type) {
-            case WindowManager.LayoutParams.TYPE_INPUT_METHOD:
-            case WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG:
-            case WindowManager.LayoutParams.TYPE_NAVIGATION_BAR:
-            case WindowManager.LayoutParams.TYPE_MAGNIFICATION_OVERLAY: {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    @Override
-    public void setCurrentUserLw(int newUserId) {
-        if (mKeyguardMediator != null) {
-            mKeyguardMediator.setCurrentUser(newUserId);
-        }
-        if (mStatusBarService != null) {
-            try {
-                mStatusBarService.setCurrentUser(newUserId);
-            } catch (RemoteException e) {
-                // oh well
-            }
-        }
-        setLastInputMethodWindowLw(null, null);
-    }
-
-    @Override
-    public void showAssistant() {
-        mKeyguardMediator.showAssistant();
-    }
-
-    @Override
-    public void dump(String prefix, PrintWriter pw, String[] args) {
-        pw.print(prefix); pw.print("mSafeMode="); pw.print(mSafeMode);
-                pw.print(" mSystemReady="); pw.print(mSystemReady);
-                pw.print(" mSystemBooted="); pw.println(mSystemBooted);
-        pw.print(prefix); pw.print("mLidState="); pw.print(mLidState);
-                pw.print(" mLidOpenRotation="); pw.print(mLidOpenRotation);
-                pw.print(" mHdmiPlugged="); pw.println(mHdmiPlugged);
-        if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0
-                || mForceClearedSystemUiFlags != 0) {
-            pw.print(prefix); pw.print("mLastSystemUiFlags=0x");
-                    pw.print(Integer.toHexString(mLastSystemUiFlags));
-                    pw.print(" mResettingSystemUiFlags=0x");
-                    pw.print(Integer.toHexString(mResettingSystemUiFlags));
-                    pw.print(" mForceClearedSystemUiFlags=0x");
-                    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
-        }
-        if (mLastFocusNeedsMenu) {
-            pw.print(prefix); pw.print("mLastFocusNeedsMenu=");
-                    pw.println(mLastFocusNeedsMenu);
-        }
-        pw.print(prefix); pw.print("mUiMode="); pw.print(mUiMode);
-                pw.print(" mDockMode="); pw.print(mDockMode);
-                pw.print(" mCarDockRotation="); pw.print(mCarDockRotation);
-                pw.print(" mDeskDockRotation="); pw.println(mDeskDockRotation);
-        pw.print(prefix); pw.print("mUserRotationMode="); pw.print(mUserRotationMode);
-                pw.print(" mUserRotation="); pw.print(mUserRotation);
-                pw.print(" mAllowAllRotations="); pw.println(mAllowAllRotations);
-        pw.print(prefix); pw.print("mCurrentAppOrientation="); pw.println(mCurrentAppOrientation);
-        pw.print(prefix); pw.print("mCarDockEnablesAccelerometer=");
-                pw.print(mCarDockEnablesAccelerometer);
-                pw.print(" mDeskDockEnablesAccelerometer=");
-                pw.println(mDeskDockEnablesAccelerometer);
-        pw.print(prefix); pw.print("mLidKeyboardAccessibility=");
-                pw.print(mLidKeyboardAccessibility);
-                pw.print(" mLidNavigationAccessibility="); pw.print(mLidNavigationAccessibility);
-                pw.print(" mLidControlsSleep="); pw.println(mLidControlsSleep);
-        pw.print(prefix); pw.print("mLongPressOnPowerBehavior=");
-                pw.print(mLongPressOnPowerBehavior);
-                pw.print(" mHasSoftInput="); pw.println(mHasSoftInput);
-        pw.print(prefix); pw.print("mScreenOnEarly="); pw.print(mScreenOnEarly);
-                pw.print(" mScreenOnFully="); pw.print(mScreenOnFully);
-                pw.print(" mOrientationSensorEnabled="); pw.println(mOrientationSensorEnabled);
-        pw.print(prefix); pw.print("mUnrestrictedScreen=("); pw.print(mUnrestrictedScreenLeft);
-                pw.print(","); pw.print(mUnrestrictedScreenTop);
-                pw.print(") "); pw.print(mUnrestrictedScreenWidth);
-                pw.print("x"); pw.println(mUnrestrictedScreenHeight);
-        pw.print(prefix); pw.print("mRestrictedScreen=("); pw.print(mRestrictedScreenLeft);
-                pw.print(","); pw.print(mRestrictedScreenTop);
-                pw.print(") "); pw.print(mRestrictedScreenWidth);
-                pw.print("x"); pw.println(mRestrictedScreenHeight);
-        pw.print(prefix); pw.print("mStableFullscreen=("); pw.print(mStableFullscreenLeft);
-                pw.print(","); pw.print(mStableFullscreenTop);
-                pw.print(")-("); pw.print(mStableFullscreenRight);
-                pw.print(","); pw.print(mStableFullscreenBottom); pw.println(")");
-        pw.print(prefix); pw.print("mStable=("); pw.print(mStableLeft);
-                pw.print(","); pw.print(mStableTop);
-                pw.print(")-("); pw.print(mStableRight);
-                pw.print(","); pw.print(mStableBottom); pw.println(")");
-        pw.print(prefix); pw.print("mSystem=("); pw.print(mSystemLeft);
-                pw.print(","); pw.print(mSystemTop);
-                pw.print(")-("); pw.print(mSystemRight);
-                pw.print(","); pw.print(mSystemBottom); pw.println(")");
-        pw.print(prefix); pw.print("mCur=("); pw.print(mCurLeft);
-                pw.print(","); pw.print(mCurTop);
-                pw.print(")-("); pw.print(mCurRight);
-                pw.print(","); pw.print(mCurBottom); pw.println(")");
-        pw.print(prefix); pw.print("mContent=("); pw.print(mContentLeft);
-                pw.print(","); pw.print(mContentTop);
-                pw.print(")-("); pw.print(mContentRight);
-                pw.print(","); pw.print(mContentBottom); pw.println(")");
-        pw.print(prefix); pw.print("mDock=("); pw.print(mDockLeft);
-                pw.print(","); pw.print(mDockTop);
-                pw.print(")-("); pw.print(mDockRight);
-                pw.print(","); pw.print(mDockBottom); pw.println(")");
-        pw.print(prefix); pw.print("mDockLayer="); pw.print(mDockLayer);
-                pw.print(" mStatusBarLayer="); pw.println(mStatusBarLayer);
-        pw.print(prefix); pw.print("mShowingLockscreen="); pw.print(mShowingLockscreen);
-                pw.print(" mShowingDream="); pw.print(mShowingDream);
-                pw.print(" mDreamingLockscreen="); pw.println(mDreamingLockscreen);
-        if (mLastInputMethodWindow != null) {
-            pw.print(prefix); pw.print("mLastInputMethodWindow=");
-                    pw.println(mLastInputMethodWindow);
-        }
-        if (mLastInputMethodTargetWindow != null) {
-            pw.print(prefix); pw.print("mLastInputMethodTargetWindow=");
-                    pw.println(mLastInputMethodTargetWindow);
-        }
-        if (mStatusBar != null) {
-            pw.print(prefix); pw.print("mStatusBar=");
-                    pw.println(mStatusBar);
-        }
-        if (mNavigationBar != null) {
-            pw.print(prefix); pw.print("mNavigationBar=");
-                    pw.println(mNavigationBar);
-        }
-        if (mKeyguard != null) {
-            pw.print(prefix); pw.print("mKeyguard=");
-                    pw.println(mKeyguard);
-        }
-        if (mFocusedWindow != null) {
-            pw.print(prefix); pw.print("mFocusedWindow=");
-                    pw.println(mFocusedWindow);
-        }
-        if (mFocusedApp != null) {
-            pw.print(prefix); pw.print("mFocusedApp=");
-                    pw.println(mFocusedApp);
-        }
-        if (mWinDismissingKeyguard != null) {
-            pw.print(prefix); pw.print("mWinDismissingKeyguard=");
-                    pw.println(mWinDismissingKeyguard);
-        }
-        if (mTopFullscreenOpaqueWindowState != null) {
-            pw.print(prefix); pw.print("mTopFullscreenOpaqueWindowState=");
-                    pw.println(mTopFullscreenOpaqueWindowState);
-        }
-        if (mForcingShowNavBar) {
-            pw.print(prefix); pw.print("mForcingShowNavBar=");
-                    pw.println(mForcingShowNavBar); pw.print( "mForcingShowNavBarLayer=");
-                    pw.println(mForcingShowNavBarLayer);
-        }
-        pw.print(prefix); pw.print("mTopIsFullscreen="); pw.print(mTopIsFullscreen);
-                pw.print(" mHideLockScreen="); pw.println(mHideLockScreen);
-        pw.print(prefix); pw.print("mForceStatusBar="); pw.print(mForceStatusBar);
-                pw.print(" mForceStatusBarFromKeyguard=");
-                pw.println(mForceStatusBarFromKeyguard);
-        pw.print(prefix); pw.print("mDismissKeyguard="); pw.print(mDismissKeyguard);
-                pw.print(" mWinDismissingKeyguard="); pw.print(mWinDismissingKeyguard);
-                pw.print(" mHomePressed="); pw.println(mHomePressed);
-        pw.print(prefix); pw.print("mAllowLockscreenWhenOn="); pw.print(mAllowLockscreenWhenOn);
-                pw.print(" mLockScreenTimeout="); pw.print(mLockScreenTimeout);
-                pw.print(" mLockScreenTimerActive="); pw.println(mLockScreenTimerActive);
-        pw.print(prefix); pw.print("mEndcallBehavior="); pw.print(mEndcallBehavior);
-                pw.print(" mIncallPowerBehavior="); pw.print(mIncallPowerBehavior);
-                pw.print(" mRingHomeBehavior="); pw.print(mRingHomeBehavior);
-                pw.print(" mLongPressOnHomeBehavior="); pw.println(mLongPressOnHomeBehavior);
-        pw.print(prefix); pw.print("mLandscapeRotation="); pw.print(mLandscapeRotation);
-                pw.print(" mSeascapeRotation="); pw.println(mSeascapeRotation);
-        pw.print(prefix); pw.print("mPortraitRotation="); pw.print(mPortraitRotation);
-                pw.print(" mUpsideDownRotation="); pw.println(mUpsideDownRotation);
-        pw.print(prefix); pw.print("mHdmiRotation="); pw.print(mHdmiRotation);
-                pw.print(" mHdmiRotationLock="); pw.println(mHdmiRotationLock);
-    }
-}
-
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2012-2013 The CyanogenMod Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.policy.impl;
+
+import android.app.ActivityManager;
+import android.app.ActivityManager.RunningAppProcessInfo;
+import android.app.ActivityManagerNative;
+import android.app.AppGlobals;
+import android.app.IActivityManager;
+import android.app.IUiModeManager;
+import android.app.KeyguardManager;
+import android.app.ProgressDialog;
+import android.app.SearchManager;
+import android.app.UiModeManager;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.res.CompatibilityInfo;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.database.ContentObserver;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.hardware.input.InputManager;
+import android.media.AudioManager;
+import android.media.IAudioService;
+import android.media.Ringtone;
+import android.media.RingtoneManager;
+import android.os.Bundle;
+import android.os.FactoryTest;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.IRemoteCallback;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.PowerManager;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.os.UEventObserver;
+import android.os.UserHandle;
+import android.os.Vibrator;
+import android.provider.Settings;
+
+import com.android.internal.R;
+import com.android.internal.app.ThemeUtils;
+import com.android.internal.os.DeviceKeyHandler;
+import com.android.internal.os.IDeviceHandler;
+import com.android.internal.policy.PolicyManager;
+import com.android.internal.policy.impl.keyguard.KeyguardViewManager;
+import com.android.internal.policy.impl.keyguard.KeyguardViewMediator;
+import com.android.internal.statusbar.IStatusBarService;
+import com.android.internal.telephony.ITelephony;
+import com.android.internal.widget.PointerLocationView;
+
+import android.util.DisplayMetrics;
+import android.util.EventLog;
+import android.util.ExtendedPropertiesUtils;
+import android.util.Log;
+import android.util.Slog;
+import android.util.SparseArray;
+import android.view.Display;
+import android.view.Gravity;
+import android.view.HapticFeedbackConstants;
+import android.view.IApplicationToken;
+import android.view.IWindowManager;
+import android.view.InputChannel;
+import android.view.InputDevice;
+import android.view.InputEvent;
+import android.view.InputEventReceiver;
+import android.view.KeyCharacterMap;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.WindowManagerGlobal;
+import android.view.WindowOrientationListener;
+import android.view.Surface;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.Window;
+import android.view.WindowManager;
+import static android.view.WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW;
+import static android.view.WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN;
+import static android.view.WindowManager.LayoutParams.FLAG_FULLSCREEN;
+import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
+import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;
+import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS;
+import static android.view.WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;
+import static android.view.WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD;
+import static android.view.WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
+import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+import static android.view.WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
+import static android.view.WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
+import static android.view.WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING;
+import static android.view.WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
+import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
+import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA_OVERLAY;
+import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;
+import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_STARTING;
+import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_SUB_PANEL;
+import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG;
+import static android.view.WindowManager.LayoutParams.TYPE_DISPLAY_OVERLAY;
+import static android.view.WindowManager.LayoutParams.TYPE_DRAG;
+import static android.view.WindowManager.LayoutParams.TYPE_DREAM;
+import static android.view.WindowManager.LayoutParams.TYPE_HIDDEN_NAV_CONSUMER;
+import static android.view.WindowManager.LayoutParams.TYPE_KEYGUARD;
+import static android.view.WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG;
+import static android.view.WindowManager.LayoutParams.TYPE_MAGNIFICATION_OVERLAY;
+import static android.view.WindowManager.LayoutParams.TYPE_PHONE;
+import static android.view.WindowManager.LayoutParams.TYPE_PRIORITY_PHONE;
+import static android.view.WindowManager.LayoutParams.TYPE_RECENTS_OVERLAY;
+import static android.view.WindowManager.LayoutParams.TYPE_SEARCH_BAR;
+import static android.view.WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY;
+import static android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR;
+import static android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL;
+import static android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR_SUB_PANEL;
+import static android.view.WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG;
+import static android.view.WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;
+import static android.view.WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
+import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD;
+import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG;
+import static android.view.WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY;
+import static android.view.WindowManager.LayoutParams.TYPE_TOAST;
+import static android.view.WindowManager.LayoutParams.TYPE_UNIVERSE_BACKGROUND;
+import static android.view.WindowManager.LayoutParams.TYPE_VOLUME_OVERLAY;
+import static android.view.WindowManager.LayoutParams.TYPE_WALLPAPER;
+import static android.view.WindowManager.LayoutParams.TYPE_POINTER;
+import static android.view.WindowManager.LayoutParams.TYPE_NAVIGATION_BAR;
+import static android.view.WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL;
+import static android.view.WindowManager.LayoutParams.TYPE_BOOT_PROGRESS;
+import android.view.WindowManagerPolicy;
+import static android.view.WindowManagerPolicy.WindowManagerFuncs.LID_ABSENT;
+import static android.view.WindowManagerPolicy.WindowManagerFuncs.LID_OPEN;
+import static android.view.WindowManagerPolicy.WindowManagerFuncs.LID_CLOSED;
+import android.view.KeyCharacterMap.FallbackAction;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.view.VolumePanel;
+import android.widget.Toast;
+import android.media.IAudioService;
+import android.media.AudioService;
+import android.media.AudioManager;
+
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.List;
+
+/**
+ * WindowManagerPolicy implementation for the Android phone UI.  This
+ * introduces a new method suffix, Lp, for an internal lock of the
+ * PhoneWindowManager.  This is used to protect some internal state, and
+ * can be acquired with either thw Lw and Li lock held, so has the restrictions
+ * of both of those when held.
+ */
+public class PhoneWindowManager implements WindowManagerPolicy {
+    static final String TAG = "WindowManager";
+    static final boolean DEBUG = false;
+    static final boolean localLOGV = false;
+    static final boolean DEBUG_LAYOUT = false;
+    static final boolean DEBUG_INPUT = false;
+    static final boolean DEBUG_STARTING_WINDOW = false;
+    static final boolean SHOW_STARTING_ANIMATIONS = true;
+    static final boolean SHOW_PROCESSES_ON_ALT_MENU = false;
+
+    // Whether to allow dock apps with METADATA_DOCK_HOME to temporarily take over the Home key.
+    // No longer recommended for desk docks; still useful in car docks.
+    static final boolean ENABLE_CAR_DOCK_HOME_CAPTURE = true;
+    static final boolean ENABLE_DESK_DOCK_HOME_CAPTURE = false;
+
+    static final int LONG_PRESS_POWER_NOTHING = 0;
+    static final int LONG_PRESS_POWER_GLOBAL_ACTIONS = 1;
+    static final int LONG_PRESS_POWER_SHUT_OFF = 2;
+    static final int LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM = 3;
+
+    // These need to match the documentation/constant in
+    // core/res/res/values/config.xml
+    static final int LONG_PRESS_HOME_NOTHING = 0;
+    static final int LONG_PRESS_HOME_RECENT_DIALOG = 1;
+    static final int LONG_PRESS_HOME_RECENT_SYSTEM_UI = 2;
+
+    static final int APPLICATION_MEDIA_SUBLAYER = -2;
+    static final int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1;
+    static final int APPLICATION_PANEL_SUBLAYER = 1;
+    static final int APPLICATION_SUB_PANEL_SUBLAYER = 2;
+
+    static public final String SYSTEM_DIALOG_REASON_KEY = "reason";
+    static public final String SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS = "globalactions";
+    static public final String SYSTEM_DIALOG_REASON_RECENT_APPS = "recentapps";
+    static public final String SYSTEM_DIALOG_REASON_HOME_KEY = "homekey";
+    static public final String SYSTEM_DIALOG_REASON_ASSIST = "assist";
+
+    // Available custom actions to perform on a key press.
+    // Must match values for KEY_HOME_LONG_PRESS_ACTION in:
+    // core/java/android/provider/Settings.java
+    private static final int KEY_ACTION_NOTHING = 0;
+    private static final int KEY_ACTION_MENU = 1;
+    private static final int KEY_ACTION_APP_SWITCH = 2;
+    private static final int KEY_ACTION_SEARCH = 3;
+    private static final int KEY_ACTION_VOICE_SEARCH = 4;
+    private static final int KEY_ACTION_IN_APP_SEARCH = 5;
+
+    // Masks for checking presence of hardware keys.
+    // Must match values in core/res/res/values/config.xml
+    private static final int KEY_MASK_HOME = 0x01;
+    private static final int KEY_MASK_BACK = 0x02;
+    private static final int KEY_MASK_MENU = 0x04;
+    private static final int KEY_MASK_ASSIST = 0x08;
+    private static final int KEY_MASK_APP_SWITCH = 0x10;
+
+    /**
+     * These are the system UI flags that, when changing, can cause the layout
+     * of the screen to change.
+     */
+    static final int SYSTEM_UI_CHANGING_LAYOUT =
+            View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN;
+
+    /* Table of Application Launch keys.  Maps from key codes to intent categories.
+     *
+     * These are special keys that are used to launch particular kinds of applications,
+     * such as a web browser.  HID defines nearly a hundred of them in the Consumer (0x0C)
+     * usage page.  We don't support quite that many yet...
+     */
+    static SparseArray<String> sApplicationLaunchKeyCategories;
+    static {
+        sApplicationLaunchKeyCategories = new SparseArray<String>();
+        sApplicationLaunchKeyCategories.append(
+                KeyEvent.KEYCODE_EXPLORER, Intent.CATEGORY_APP_BROWSER);
+        sApplicationLaunchKeyCategories.append(
+                KeyEvent.KEYCODE_ENVELOPE, Intent.CATEGORY_APP_EMAIL);
+        sApplicationLaunchKeyCategories.append(
+                KeyEvent.KEYCODE_CONTACTS, Intent.CATEGORY_APP_CONTACTS);
+        sApplicationLaunchKeyCategories.append(
+                KeyEvent.KEYCODE_CALENDAR, Intent.CATEGORY_APP_CALENDAR);
+        sApplicationLaunchKeyCategories.append(
+                KeyEvent.KEYCODE_MUSIC, Intent.CATEGORY_APP_MUSIC);
+        sApplicationLaunchKeyCategories.append(
+                KeyEvent.KEYCODE_CALCULATOR, Intent.CATEGORY_APP_CALCULATOR);
+    }
+
+    private final DeviceKeyHandler mDeviceKeyHandler;
+
+    /**
+     * Lock protecting internal state.  Must not call out into window
+     * manager with lock held.  (This lock will be acquired in places
+     * where the window manager is calling in with its own lock held.)
+     */
+    final Object mLock = new Object();
+
+    Context mContext;
+    Context mUiContext;
+    IWindowManager mWindowManager;
+    WindowManagerFuncs mWindowManagerFuncs;
+    PowerManager mPowerManager;
+    IStatusBarService mStatusBarService;
+    final Object mServiceAquireLock = new Object();
+    Vibrator mVibrator; // Vibrator for giving feedback of orientation changes
+    SearchManager mSearchManager;
+
+    // Vibrator pattern for haptic feedback of a long press.
+    long[] mLongPressVibePattern;
+
+    // Vibrator pattern for haptic feedback of virtual key press.
+    long[] mVirtualKeyVibePattern;
+    
+    // Vibrator pattern for a short vibration.
+    long[] mKeyboardTapVibePattern;
+
+    // Vibrator pattern for haptic feedback during boot when safe mode is disabled.
+    long[] mSafeModeDisabledVibePattern;
+    
+    // Vibrator pattern for haptic feedback during boot when safe mode is enabled.
+    long[] mSafeModeEnabledVibePattern;
+
+    /** If true, hitting shift & menu will broadcast Intent.ACTION_BUG_REPORT */
+    boolean mEnableShiftMenuBugReports = false;
+
+    boolean mHeadless;
+    boolean mSafeMode;
+    WindowState mStatusBar = null;
+    boolean mHasSystemNavBar;
+    int mStatusBarHeight;
+    WindowState mNavigationBar = null;
+    boolean mHasNavigationBar = false;
+    private boolean mNavBarFirstBootFlag = true;
+    boolean mCanHideNavigationBar = false;
+    boolean mNavigationBarCanMove = false; // can the navigation bar ever move to the side?
+    boolean mNavigationBarOnBottom = true; // is the navigation bar on the bottom *right now*?
+    int[] mNavigationBarHeightForRotation = new int[4];
+    int[] mNavigationBarWidthForRotation = new int[4];
+    int mUserNavBarHeight;
+    int mUserNavBarHeightLand;
+    int mUserNavBarWidth;
+
+    WindowState mKeyguard = null;
+    KeyguardViewMediator mKeyguardMediator;
+    GlobalActions mGlobalActions;
+    volatile boolean mPowerKeyHandled; // accessed from input reader and handler thread
+    boolean mPendingPowerKeyUpCanceled;
+    Handler mHandler;
+    WindowState mLastInputMethodWindow = null;
+    WindowState mLastInputMethodTargetWindow = null;
+
+    static final int RECENT_APPS_BEHAVIOR_SHOW_OR_DISMISS = 0;
+    static final int RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW = 1;
+    static final int RECENT_APPS_BEHAVIOR_DISMISS = 2;
+    static final int RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH = 3;
+
+    RecentApplicationsDialog mRecentAppsDialog;
+    int mRecentAppsDialogHeldModifiers;
+    boolean mLanguageSwitchKeyPressed;
+
+    int mLidState = LID_ABSENT;
+    boolean mHaveBuiltInKeyboard;
+
+    boolean mSystemReady;
+    boolean mSystemBooted;
+    boolean mHdmiPlugged;
+    boolean mWifiDisplayConnected;
+    int mUiMode;
+    int mDockMode = Intent.EXTRA_DOCK_STATE_UNDOCKED;
+    int mLidOpenRotation;
+    boolean mHasRemovableLid;
+    int mCarDockRotation;
+    int mDeskDockRotation;
+    int mHdmiRotation;
+    boolean mHdmiRotationLock;
+
+    int mUserRotationMode = WindowManagerPolicy.USER_ROTATION_FREE;
+    int mUserRotation = Surface.ROTATION_0;
+    int mUserRotationAngles = -1;
+    boolean mAccelerometerDefault;
+
+    int mAllowAllRotations = -1;
+    boolean mCarDockEnablesAccelerometer;
+    boolean mDeskDockEnablesAccelerometer;
+    int mLidKeyboardAccessibility;
+    int mLidNavigationAccessibility;
+    boolean mLidControlsSleep;
+    int mLongPressOnPowerBehavior = -1;
+    boolean mScreenOnEarly = false;
+    boolean mScreenOnFully = false;
+    boolean mOrientationSensorEnabled = false;
+    int mCurrentAppOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+    boolean mHasSoftInput = false;
+    int mBackKillTimeout;
+    int mPointerLocationMode = 0; // guarded by mLock
+    int mDeviceHardwareKeys;
+    boolean mHasHomeKey;
+    boolean mHasMenuKey;
+    boolean mHasAssistKey;
+    boolean mHasAppSwitchKey;
+
+    // The last window we were told about in focusChanged.
+    WindowState mFocusedWindow;
+    IApplicationToken mFocusedApp;
+
+    // Behavior of volume wake
+    boolean mVolumeWakeScreen;
+
+    // Behavior of volbtn music controls
+    boolean mVolBtnMusicControls;
+    boolean mIsLongPress;
+
+    private static final class PointerLocationInputEventReceiver extends InputEventReceiver {
+        private final PointerLocationView mView;
+
+        public PointerLocationInputEventReceiver(InputChannel inputChannel, Looper looper,
+                PointerLocationView view) {
+            super(inputChannel, looper);
+            mView = view;
+        }
+
+        @Override
+        public void onInputEvent(InputEvent event) {
+            boolean handled = false;
+            try {
+                if (event instanceof MotionEvent
+                        && (event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
+                    final MotionEvent motionEvent = (MotionEvent)event;
+                    mView.addPointerEvent(motionEvent);
+                    handled = true;
+                }
+            } finally {
+                finishInputEvent(event, handled);
+            }
+        }
+    }
+
+    // Pointer location view state, only modified on the mHandler Looper.
+    PointerLocationInputEventReceiver mPointerLocationInputEventReceiver;
+    PointerLocationView mPointerLocationView;
+    InputChannel mPointerLocationInputChannel;
+
+    // The current size of the screen; really; (ir)regardless of whether the status
+    // bar can be hidden or not
+    int mUnrestrictedScreenLeft, mUnrestrictedScreenTop;
+    int mUnrestrictedScreenWidth, mUnrestrictedScreenHeight;
+    // The current size of the screen; these may be different than (0,0)-(dw,dh)
+    // if the status bar can't be hidden; in that case it effectively carves out
+    // that area of the display from all other windows.
+    int mRestrictedScreenLeft, mRestrictedScreenTop;
+    int mRestrictedScreenWidth, mRestrictedScreenHeight;
+    // During layout, the current screen borders accounting for any currently
+    // visible system UI elements.
+    int mSystemLeft, mSystemTop, mSystemRight, mSystemBottom;
+    // For applications requesting stable content insets, these are them.
+    int mStableLeft, mStableTop, mStableRight, mStableBottom;
+    // For applications requesting stable content insets but have also set the
+    // fullscreen window flag, these are the stable dimensions without the status bar.
+    int mStableFullscreenLeft, mStableFullscreenTop;
+    int mStableFullscreenRight, mStableFullscreenBottom;
+    // During layout, the current screen borders with all outer decoration
+    // (status bar, input method dock) accounted for.
+    int mCurLeft, mCurTop, mCurRight, mCurBottom;
+    // During layout, the frame in which content should be displayed
+    // to the user, accounting for all screen decoration except for any
+    // space they deem as available for other content.  This is usually
+    // the same as mCur*, but may be larger if the screen decor has supplied
+    // content insets.
+    int mContentLeft, mContentTop, mContentRight, mContentBottom;
+    // During layout, the current screen borders along which input method
+    // windows are placed.
+    int mDockLeft, mDockTop, mDockRight, mDockBottom;
+    // During layout, the layer at which the doc window is placed.
+    int mDockLayer;
+    // During layout, this is the layer of the status bar.
+    int mStatusBarLayer;
+    int mLastSystemUiFlags;
+    // Bits that we are in the process of clearing, so we want to prevent
+    // them from being set by applications until everything has been updated
+    // to have them clear.
+    int mResettingSystemUiFlags = 0;
+    // Bits that we are currently always keeping cleared.
+    int mForceClearedSystemUiFlags = 0;
+    // What we last reported to system UI about whether the compatibility
+    // menu needs to be displayed.
+    boolean mLastFocusNeedsMenu = false;
+
+    FakeWindow mHideNavFakeWindow = null;
+
+    static final Rect mTmpParentFrame = new Rect();
+    static final Rect mTmpDisplayFrame = new Rect();
+    static final Rect mTmpContentFrame = new Rect();
+    static final Rect mTmpVisibleFrame = new Rect();
+    static final Rect mTmpNavigationFrame = new Rect();
+    
+    WindowState mTopFullscreenOpaqueWindowState;
+    boolean mTopIsFullscreen;
+    boolean mForceStatusBar;
+    boolean mForceStatusBarFromKeyguard;
+    boolean mHideLockScreen;
+    boolean mForcingShowNavBar;
+    int mForcingShowNavBarLayer;
+
+    int mExpandedDesktopStyle = -1;
+    boolean mHideStatusBar;
+
+    // States of keyguard dismiss.
+    private static final int DISMISS_KEYGUARD_NONE = 0; // Keyguard not being dismissed.
+    private static final int DISMISS_KEYGUARD_START = 1; // Keyguard needs to be dismissed.
+    private static final int DISMISS_KEYGUARD_CONTINUE = 2; // Keyguard has been dismissed.
+    int mDismissKeyguard = DISMISS_KEYGUARD_NONE;
+
+    /** The window that is currently dismissing the keyguard. Dismissing the keyguard must only
+     * be done once per window. */
+    private WindowState mWinDismissingKeyguard;
+
+    boolean mShowingLockscreen;
+    boolean mShowingDream;
+    boolean mDreamingLockscreen;
+    boolean mHomePressed;
+    boolean mHomeLongPressed;
+    boolean mAppSwitchLongPressed;
+    Intent mHomeIntent;
+    Intent mCarDockIntent;
+    Intent mDeskDockIntent;
+    boolean mSearchKeyShortcutPending;
+    boolean mConsumeSearchKeyUp;
+    boolean mAssistKeyLongPressed;
+
+    // Used when key is pressed and performing non-default action
+    boolean mMenuDoCustomAction;
+
+    // Tracks user-customisable behavior for certain key events
+    private int mLongPressOnHomeBehavior = -1;
+    private int mPressOnMenuBehavior = -1;
+    private int mLongPressOnMenuBehavior = -1;
+    private int mPressOnAssistBehavior = -1;
+    private int mLongPressOnAssistBehavior = -1;
+    private int mPressOnAppSwitchBehavior = -1;
+    private int mLongPressOnAppSwitchBehavior = -1;
+
+    // To identify simulated keypresses, so we can perform
+    // the default action for that key
+    private boolean mIsVirtualKeypress;
+
+    // Tracks preloading of the recent apps screen
+    private boolean mRecentAppsPreloaded;
+
+    // support for activating the lock screen while the screen is on
+    boolean mAllowLockscreenWhenOn;
+    int mLockScreenTimeout;
+    boolean mLockScreenTimerActive;
+
+    // Behavior of ENDCALL Button.  (See Settings.System.END_BUTTON_BEHAVIOR.)
+    int mEndcallBehavior;
+
+    // Behavior of POWER button while in-call and screen on.
+    // (See Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR.)
+    int mIncallPowerBehavior;
+
+    Display mDisplay;
+
+    // Behavior of HOME button during incomming call ring.
+    // (See Settings.Secure.RING_HOME_BUTTON_BEHAVIOR.)
+    int mRingHomeBehavior;
+
+    int mLandscapeRotation = 0;  // default landscape rotation
+    int mSeascapeRotation = 0;   // "other" landscape rotation, 180 degrees from mLandscapeRotation
+    int mPortraitRotation = 0;   // default portrait rotation
+    int mUpsideDownRotation = 0; // "other" portrait rotation
+
+    // Screenshot trigger states
+    // Time to volume and power must be pressed within this interval of each other.
+    private static final long ACTION_CHORD_DEBOUNCE_DELAY_MILLIS = 150;
+    // Increase the chord delay when taking a screenshot from the keyguard
+    private static final float KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER = 2.5f;
+    private boolean mScreenshotChordEnabled;
+    private boolean mVolumeDownKeyTriggered;
+    private long mVolumeDownKeyTime;
+    private long mVolumeUpKeyTime;
+    private boolean mVolumeDownKeyConsumedByChord;
+    private boolean mVolumeUpKeyConsumedByChord;
+    private boolean mVolumeUpKeyTriggered;
+    private boolean mPowerKeyTriggered;
+    private long mPowerKeyTime;
+    private KeyguardManager mKeyguardManager;
+
+    private int mSystemDpi = 0;
+    private int mSystemUiDpi = 0;
+    private int mSystemUiLayout = 0;
+    private int mNavBarDpi = 0;
+    private int mStatusBarDpi = 0;
+
+    SettingsObserver mSettingsObserver;
+    ShortcutManager mShortcutManager;
+    PowerManager.WakeLock mBroadcastWakeLock;
+    boolean mHavePendingMediaKeyRepeatWithWakeLock;
+
+    // Fallback actions by key code.
+    private final SparseArray<KeyCharacterMap.FallbackAction> mFallbackActions =
+            new SparseArray<KeyCharacterMap.FallbackAction>();
+
+    private static final int MSG_ENABLE_POINTER_LOCATION = 1;
+    private static final int MSG_DISABLE_POINTER_LOCATION = 2;
+    private static final int MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK = 3;
+    private static final int MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK = 4;
+    private static final int MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK = 5;
+
+    private class PolicyHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_ENABLE_POINTER_LOCATION:
+                    enablePointerLocation();
+                    break;
+                case MSG_DISABLE_POINTER_LOCATION:
+                    disablePointerLocation();
+                    break;
+                case MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK:
+                    dispatchMediaKeyWithWakeLock((KeyEvent)msg.obj);
+                    break;
+                case MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK:
+                    dispatchMediaKeyRepeatWithWakeLock((KeyEvent)msg.obj);
+                    break;
+                case MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK:
+                    mIsLongPress = true;
+                    dispatchMediaKeyWithWakeLockToAudioService((KeyEvent)msg.obj);
+                    dispatchMediaKeyWithWakeLockToAudioService(KeyEvent.changeAction((KeyEvent)msg.obj, KeyEvent.ACTION_UP));
+                    break;
+            }
+        }
+    }
+
+    private UEventObserver mHDMIObserver = new UEventObserver() {
+        @Override
+        public void onUEvent(UEventObserver.UEvent event) {
+            setHdmiPlugged("1".equals(event.get("SWITCH_STATE")));
+        }
+    };
+
+    class SettingsObserver extends ContentObserver {
+        SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        void observe() {
+            // Observe all users' changes
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.END_BUTTON_BEHAVIOR), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.Secure.getUriFor(
+                    Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.Secure.getUriFor(
+                    Settings.Secure.RING_HOME_BUTTON_BEHAVIOR), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.VOLUME_WAKE_SCREEN), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.VOLBTN_MUSIC_CONTROLS), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.ACCELEROMETER_ROTATION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.USER_ROTATION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.SCREEN_OFF_TIMEOUT), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.POINTER_LOCATION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.Secure.getUriFor(
+                    Settings.Secure.DEFAULT_INPUT_METHOD), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    "fancy_rotation_anim"), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.EXPANDED_DESKTOP_STATE), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.EXPANDED_DESKTOP_STYLE), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.ACCELEROMETER_ROTATION_ANGLES), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.KEY_MENU_ACTION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.KEY_ASSIST_ACTION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.KEY_APP_SWITCH_ACTION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.HARDWARE_KEY_REBINDING), false, this,
+                    UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                     Settings.System.HIDE_STATUSBAR), false, this);
+            updateSettings();
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            update(false);
+        }
+    }
+    
+    class MyOrientationListener extends WindowOrientationListener {
+        MyOrientationListener(Context context) {
+            super(context);
+        }
+        
+        @Override
+        public void onProposedRotationChanged(int rotation) {
+            if (localLOGV) Log.v(TAG, "onProposedRotationChanged, rotation=" + rotation);
+            updateRotation(false);
+        }
+    }
+    MyOrientationListener mOrientationListener;
+
+    public PhoneWindowManager(IDeviceHandler device) {
+        mDeviceKeyHandler = (device != null) ? device.getDeviceKeyHandler() : null;
+    }
+
+    IStatusBarService getStatusBarService() {
+        synchronized (mServiceAquireLock) {
+            if (mStatusBarService == null) {
+                mStatusBarService = IStatusBarService.Stub.asInterface(
+                        ServiceManager.getService("statusbar"));
+            }
+            return mStatusBarService;
+        }
+    }
+
+    /*
+     * We always let the sensor be switched on by default except when
+     * the user has explicitly disabled sensor based rotation or when the
+     * screen is switched off.
+     */
+    boolean needSensorRunningLp() {
+        if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR
+                || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR
+                || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT
+                || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE) {
+            // If the application has explicitly requested to follow the
+            // orientation, then we need to turn the sensor or.
+            return true;
+        }
+        if ((mCarDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_CAR) ||
+                (mDeskDockEnablesAccelerometer && (mDockMode == Intent.EXTRA_DOCK_STATE_DESK
+                        || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK
+                        || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK))) {
+            // enable accelerometer if we are docked in a dock that enables accelerometer
+            // orientation management,
+            return true;
+        }
+        if (mUserRotationMode == USER_ROTATION_LOCKED) {
+            // If the setting for using the sensor by default is enabled, then
+            // we will always leave it on.  Note that the user could go to
+            // a window that forces an orientation that does not use the
+            // sensor and in theory we could turn it off... however, when next
+            // turning it on we won't have a good value for the current
+            // orientation for a little bit, which can cause orientation
+            // changes to lag, so we'd like to keep it always on.  (It will
+            // still be turned off when the screen is off.)
+            return false;
+        }
+        return true;
+    }
+    
+    /*
+     * Various use cases for invoking this function
+     * screen turning off, should always disable listeners if already enabled
+     * screen turned on and current app has sensor based orientation, enable listeners 
+     * if not already enabled
+     * screen turned on and current app does not have sensor orientation, disable listeners if
+     * already enabled
+     * screen turning on and current app has sensor based orientation, enable listeners if needed
+     * screen turning on and current app has nosensor based orientation, do nothing
+     */
+    void updateOrientationListenerLp() {
+        if (!mOrientationListener.canDetectOrientation()) {
+            // If sensor is turned off or nonexistent for some reason
+            return;
+        }
+        //Could have been invoked due to screen turning on or off or
+        //change of the currently visible window's orientation
+        if (localLOGV) Log.v(TAG, "Screen status="+mScreenOnEarly+
+                ", current orientation="+mCurrentAppOrientation+
+                ", SensorEnabled="+mOrientationSensorEnabled);
+        boolean disable = true;
+        if (mScreenOnEarly) {
+            if (needSensorRunningLp()) {
+                disable = false;
+                //enable listener if not already enabled
+                if (!mOrientationSensorEnabled) {
+                    mOrientationListener.enable();
+                    if(localLOGV) Log.v(TAG, "Enabling listeners");
+                    mOrientationSensorEnabled = true;
+                }
+            } 
+        } 
+        //check if sensors need to be disabled
+        if (disable && mOrientationSensorEnabled) {
+            mOrientationListener.disable();
+            if(localLOGV) Log.v(TAG, "Disabling listeners");
+            mOrientationSensorEnabled = false;
+        }
+    }
+
+    private void interceptPowerKeyDown(boolean handled) {
+        mPowerKeyHandled = handled;
+        if (!handled) {
+            mHandler.postDelayed(mPowerLongPress, ViewConfiguration.getGlobalActionKeyTimeout());
+        }
+    }
+
+    private boolean interceptPowerKeyUp(boolean canceled) {
+        if (!mPowerKeyHandled) {
+            mHandler.removeCallbacks(mPowerLongPress);
+            return !canceled;
+        }
+        return false;
+    }
+
+    private void cancelPendingPowerKeyAction() {
+        if (!mPowerKeyHandled) {
+            mHandler.removeCallbacks(mPowerLongPress);
+        }
+        if (mPowerKeyTriggered) {
+            mPendingPowerKeyUpCanceled = true;
+        }
+    }
+
+    private void interceptScreenshotChord() {
+        if (mScreenshotChordEnabled
+                && mVolumeDownKeyTriggered && mPowerKeyTriggered && !mVolumeUpKeyTriggered) {
+            final long now = SystemClock.uptimeMillis();
+            if (now <= mVolumeDownKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS
+                    && now <= mPowerKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS) {
+                mVolumeDownKeyConsumedByChord = true;
+                cancelPendingPowerKeyAction();
+
+                mHandler.postDelayed(mScreenshotChordLongPress, getScreenshotChordLongPressDelay());
+            }
+        }
+    }
+
+    private long getScreenshotChordLongPressDelay() {
+        if (mKeyguardMediator.isShowing()) {
+            // Double the time it takes to take a screenshot from the keyguard
+            return (long) (KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER *
+                    ViewConfiguration.getGlobalActionKeyTimeout());
+        } else {
+            return ViewConfiguration.getGlobalActionKeyTimeout();
+        }
+    }
+
+    private void cancelPendingScreenshotChordAction() {
+        mHandler.removeCallbacks(mScreenshotChordLongPress);
+    }
+
+    private void interceptRingerChord() {
+        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered && mVolumeUpKeyTriggered) {
+            final long now = SystemClock.uptimeMillis();
+            if (now <= mVolumeDownKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS
+                    && now <= mVolumeUpKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS) {
+                mVolumeDownKeyConsumedByChord = true;
+                mVolumeUpKeyConsumedByChord = true;
+
+                mHandler.postDelayed(mRingerChordLongPress,
+                        ViewConfiguration.getGlobalActionKeyTimeout());
+            }
+        }
+    }
+
+    private void cancelPendingRingerChordAction() {
+        mHandler.removeCallbacks(mRingerChordLongPress);
+    }
+
+    private final Runnable mPowerLongPress = new Runnable() {
+        @Override
+        public void run() {
+            // The context isn't read
+            if (mLongPressOnPowerBehavior < 0) {
+                mLongPressOnPowerBehavior = mContext.getResources().getInteger(
+                        com.android.internal.R.integer.config_longPressOnPowerBehavior);
+            }
+            int resolvedBehavior = mLongPressOnPowerBehavior;
+            if (FactoryTest.isLongPressOnPowerOffEnabled()) {
+                resolvedBehavior = LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM;
+            }
+
+            switch (resolvedBehavior) {
+            case LONG_PRESS_POWER_NOTHING:
+                break;
+            case LONG_PRESS_POWER_GLOBAL_ACTIONS:
+                mPowerKeyHandled = true;
+                if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) {
+                    performAuditoryFeedbackForAccessibilityIfNeed();
+                }
+                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
+                showGlobalActionsDialog();
+                break;
+            case LONG_PRESS_POWER_SHUT_OFF:
+            case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:
+                mPowerKeyHandled = true;
+                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
+                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
+                mWindowManagerFuncs.shutdown(resolvedBehavior == LONG_PRESS_POWER_SHUT_OFF);
+                break;
+            }
+        }
+    };
+
+    private final Runnable mScreenshotChordLongPress = new Runnable() {
+        public void run() {
+            takeScreenshot();
+        }
+    };
+
+    private final Runnable mRingerChordLongPress = new Runnable() {
+        public void run() {
+            // Do the switch
+            final AudioManager am = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
+            final int ringerMode = am.getRingerMode();
+            final VolumePanel volumePanel = new VolumePanel(ThemeUtils.createUiContext(mContext),
+                                                              (AudioService) getAudioService());
+            if (ringerMode == AudioManager.RINGER_MODE_NORMAL) {
+                boolean vibrateSetting = Settings.System.getIntForUser(mContext.getContentResolver(),
+                        Settings.System.VIBRATE_WHEN_RINGING, 0, UserHandle.USER_CURRENT) != 0;
+                am.setRingerMode(vibrateSetting ? AudioManager.RINGER_MODE_VIBRATE :
+                                   AudioManager.RINGER_MODE_SILENT);
+            } else {
+                am.setRingerMode(AudioManager.RINGER_MODE_NORMAL);
+            }
+            volumePanel.postVolumeChanged(AudioManager.STREAM_RING,AudioManager.FLAG_SHOW_UI
+                                          | AudioManager.FLAG_VIBRATE);
+        }
+    };
+
+    Runnable mBackLongPress = new Runnable() {
+        public void run() {
+            try {
+                final Intent intent = new Intent(Intent.ACTION_MAIN);
+                String defaultHomePackage = "com.android.launcher";
+                intent.addCategory(Intent.CATEGORY_HOME);
+                final ResolveInfo res = mContext.getPackageManager().resolveActivity(intent, 0);
+                if (res.activityInfo != null && !res.activityInfo.packageName.equals("android")) {
+                    defaultHomePackage = res.activityInfo.packageName;
+                }
+                boolean targetKilled = false;
+                IActivityManager am = ActivityManagerNative.getDefault();
+                List<RunningAppProcessInfo> apps = am.getRunningAppProcesses();
+                for (RunningAppProcessInfo appInfo : apps) {
+                    int uid = appInfo.uid;
+                    // Make sure it's a foreground user application (not system,
+                    // root, phone, etc.)
+                    if (uid >= Process.FIRST_APPLICATION_UID && uid <= Process.LAST_APPLICATION_UID
+                            && appInfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
+                        if (appInfo.pkgList != null && (appInfo.pkgList.length > 0)) {
+                            for (String pkg : appInfo.pkgList) {
+                                if (!pkg.equals("com.android.systemui") && !pkg.equals(defaultHomePackage)) {
+                                    am.forceStopPackage(pkg, UserHandle.USER_CURRENT);
+                                    targetKilled = true;
+                                    break;
+                                }
+                            }
+                        } else {
+                            Process.killProcess(appInfo.pid);
+                            targetKilled = true;
+                        }
+                    }
+                    if (targetKilled) {
+                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
+                        Toast.makeText(mContext, R.string.app_killed_message, Toast.LENGTH_SHORT).show();
+                        break;
+                    }
+                }
+            } catch (RemoteException remoteException) {
+                // Do nothing; just let it go.
+            }
+        }
+    };
+
+    private KeyguardManager getKeyguardManager() {
+        if (mKeyguardManager == null) {
+            mKeyguardManager = (KeyguardManager) mContext.getSystemService(
+                    Context.KEYGUARD_SERVICE);
+        }
+        return mKeyguardManager;
+    }
+
+    void showGlobalActionsDialog() {
+        if (mGlobalActions == null) {
+            mGlobalActions = new GlobalActions(mContext, mWindowManagerFuncs);
+        }
+        final boolean keyguardLocked = getKeyguardManager().isKeyguardLocked();
+        mGlobalActions.showDialog(keyguardLocked, isDeviceProvisioned());
+        if (keyguardLocked) {
+            // since it took two seconds of long press to bring this up,
+            // poke the wake lock so they have some time to see the dialog.
+            mKeyguardMediator.userActivity();
+        }
+    }
+
+    boolean isDeviceProvisioned() {
+        return Settings.Global.getInt(
+                mContext.getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0) != 0;
+    }
+
+    private void triggerVirtualKeypress(final int keyCode) {
+        new Thread(new Runnable() {
+            public void run() {
+                InputManager im = InputManager.getInstance();
+                long now = SystemClock.uptimeMillis();
+
+                final KeyEvent downEvent = new KeyEvent(now, now, KeyEvent.ACTION_DOWN,
+                        keyCode, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0,
+                        KeyEvent.FLAG_FROM_SYSTEM, InputDevice.SOURCE_KEYBOARD);
+                final KeyEvent upEvent = KeyEvent.changeAction(downEvent, KeyEvent.ACTION_UP);
+
+                mIsVirtualKeypress = true;
+                im.injectInputEvent(downEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT);
+                im.injectInputEvent(upEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT);
+                mIsVirtualKeypress = false;
+            }
+        }).start();
+    }
+
+    private void performKeyAction(int behavior) {
+        switch (behavior) {
+            case KEY_ACTION_NOTHING:
+                break;
+            case KEY_ACTION_MENU:
+                triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
+                break;
+            case KEY_ACTION_APP_SWITCH:
+                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_RECENT_APPS);
+                try {
+                    IStatusBarService statusbar = getStatusBarService();
+                    if (statusbar != null) {
+                        statusbar.toggleRecentApps();
+                        mRecentAppsPreloaded = false;
+                    }
+                } catch (RemoteException e) {
+                    Slog.e(TAG, "RemoteException when showing recent apps", e);
+                    // re-acquire status bar service next time it is needed.
+                    mStatusBarService = null;
+                }
+                break;
+            case KEY_ACTION_SEARCH:
+                launchAssistAction();
+                break;
+            case KEY_ACTION_VOICE_SEARCH:
+                launchAssistLongPressAction();
+                break;
+            case KEY_ACTION_IN_APP_SEARCH:
+                triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
+                break;
+            default:
+                break;
+        }
+    }
+
+    private void preloadRecentApps() {
+        try {
+            IStatusBarService statusbar = getStatusBarService();
+            if (statusbar != null) {
+                statusbar.preloadRecentApps();
+                mRecentAppsPreloaded = true;
+            }
+        } catch (RemoteException e) {
+            Slog.e(TAG, "RemoteException when preloading recent apps", e);
+            // re-acquire status bar service next time it is needed.
+            mStatusBarService = null;
+        }
+    }
+
+    private void cancelPreloadRecentApps() {
+        try {
+            IStatusBarService statusbar = getStatusBarService();
+            if (statusbar != null) {
+                statusbar.cancelPreloadRecentApps();
+                mRecentAppsPreloaded = false;
+            }
+        } catch (RemoteException e) {
+            Slog.e(TAG, "RemoteException when showing recent apps", e);
+            // re-acquire status bar service next time it is needed.
+            mStatusBarService = null;
+        }
+    }
+
+    /**
+     * Create (if necessary) and show or dismiss the recent apps dialog according
+     * according to the requested behavior.
+     */
+    void showOrHideRecentAppsDialog(final int behavior) {
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                if (mRecentAppsDialog == null) {
+                    mRecentAppsDialog = new RecentApplicationsDialog(mContext);
+                }
+                if (mRecentAppsDialog.isShowing()) {
+                    switch (behavior) {
+                        case RECENT_APPS_BEHAVIOR_SHOW_OR_DISMISS:
+                        case RECENT_APPS_BEHAVIOR_DISMISS:
+                            mRecentAppsDialog.dismiss();
+                            break;
+                        case RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH:
+                            mRecentAppsDialog.dismissAndSwitch();
+                            break;
+                        case RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW:
+                        default:
+                            break;
+                    }
+                } else {
+                    switch (behavior) {
+                        case RECENT_APPS_BEHAVIOR_SHOW_OR_DISMISS:
+                            mRecentAppsDialog.show();
+                            break;
+                        case RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW:
+                            try {
+                                mWindowManager.setInTouchMode(false);
+                            } catch (RemoteException e) {
+                            }
+                            mRecentAppsDialog.show();
+                            break;
+                        case RECENT_APPS_BEHAVIOR_DISMISS:
+                        case RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH:
+                        default:
+                            break;
+                    }
+                }
+            }
+        });
+    }
+
+    /** {@inheritDoc} */
+    public void init(Context context, IWindowManager windowManager,
+            WindowManagerFuncs windowManagerFuncs) {
+        mContext = context;
+        mWindowManager = windowManager;
+        mWindowManagerFuncs = windowManagerFuncs;
+        mHeadless = "1".equals(SystemProperties.get("ro.config.headless", "0"));
+        if (!mHeadless) {
+            // don't create KeyguardViewMediator if headless
+            mKeyguardMediator = new KeyguardViewMediator(context, null);
+        }
+        mHandler = new PolicyHandler();
+        mOrientationListener = new MyOrientationListener(mContext);
+        try {
+            mOrientationListener.setCurrentRotation(windowManager.getRotation());
+        } catch (RemoteException ex) { }
+
+        updateHybridLayout();
+
+        mSettingsObserver = new SettingsObserver(mHandler);
+        mSettingsObserver.observe();
+
+        // SystemUI reboot
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.USER_INTERFACE_STATE), false, new ContentObserver(new Handler()) {
+            @Override
+            public void onChange(boolean selfChange) {
+                // Return for reset triggers
+                if (Settings.System.getInt(mContext.getContentResolver(), 
+                    Settings.System.USER_INTERFACE_STATE, 0) == 0) {
+                    return;
+                }
+
+                // Update layout
+                update(true);
+                
+                // Reset trigger
+                Settings.System.putInt(mContext.getContentResolver(), Settings.System.USER_INTERFACE_STATE, 0);
+            }});
+
+        // Expanded desktop
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.EXPANDED_DESKTOP_STATE),
+                    false, new ContentObserver(new Handler()) {
+            @Override
+            public void onChange(boolean selfChange) {
+                updateHybridLayout();
+                update(false);
+
+                // Restart default launcher activity
+                final PackageManager mPm = mContext.getPackageManager();
+                final ActivityManager am = (ActivityManager)mContext
+                        .getSystemService(Context.ACTIVITY_SERVICE);
+                final Intent intent = new Intent(Intent.ACTION_MAIN); 
+                intent.addCategory(Intent.CATEGORY_HOME); 
+                final ResolveInfo res = mPm.resolveActivity(intent, 0);
+                // Launcher is running task #1
+                List<ActivityManager.RunningTaskInfo> runningTasks = am.getRunningTasks(1);
+                if (runningTasks != null) {
+                    for (ActivityManager.RunningTaskInfo task : runningTasks) {
+                        String packageName = task.baseActivity.getPackageName();
+                        if (packageName.equals(res.activityInfo.packageName)) {
+                            closeApplication(packageName);
+                            break;
+                        }
+                    }
+                }
+            }
+        });
+
+        mShortcutManager = new ShortcutManager(context, mHandler);
+        mShortcutManager.observe();
+        mUiMode = context.getResources().getInteger(
+                com.android.internal.R.integer.config_defaultUiModeType);
+        mHomeIntent =  new Intent(Intent.ACTION_MAIN, null);
+        mHomeIntent.addCategory(Intent.CATEGORY_HOME);
+        mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
+        mCarDockIntent =  new Intent(Intent.ACTION_MAIN, null);
+        mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
+        mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
+        mDeskDockIntent =  new Intent(Intent.ACTION_MAIN, null);
+        mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
+        mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
+
+        mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
+                "PhoneWindowManager.mBroadcastWakeLock");
+        mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
+        mLidOpenRotation = readRotation(
+                com.android.internal.R.integer.config_lidOpenRotation);
+        mCarDockRotation = readRotation(
+                com.android.internal.R.integer.config_carDockRotation);
+        mDeskDockRotation = readRotation(
+                com.android.internal.R.integer.config_deskDockRotation);
+        mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_carDockEnablesAccelerometer);
+        mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
+        mLidKeyboardAccessibility = mContext.getResources().getInteger(
+                com.android.internal.R.integer.config_lidKeyboardAccessibility);
+        mLidNavigationAccessibility = mContext.getResources().getInteger(
+                com.android.internal.R.integer.config_lidNavigationAccessibility);
+        mLidControlsSleep = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_lidControlsSleep);
+        mHasRemovableLid = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_hasRemovableLid);
+        mBackKillTimeout = mContext.getResources().getInteger(
+                com.android.internal.R.integer.config_backKillTimeout);
+        mDeviceHardwareKeys = mContext.getResources().getInteger(
+                com.android.internal.R.integer.config_deviceHardwareKeys);
+        mHasHomeKey = ((mDeviceHardwareKeys & KEY_MASK_HOME) != 0);
+        mHasMenuKey = ((mDeviceHardwareKeys & KEY_MASK_MENU) != 0);
+        mHasAssistKey = ((mDeviceHardwareKeys & KEY_MASK_ASSIST) != 0);
+        mHasAppSwitchKey = ((mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) != 0);
+
+        // register for dock events
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
+        filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
+        filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
+        filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
+        filter.addAction(Intent.ACTION_DOCK_EVENT);
+        Intent intent = context.registerReceiver(mDockReceiver, filter);
+        if (intent != null) {
+            // Retrieve current sticky dock event broadcast.
+            mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
+                    Intent.EXTRA_DOCK_STATE_UNDOCKED);
+        }
+
+        // register for dream-related broadcasts
+        filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_DREAMING_STARTED);
+        filter.addAction(Intent.ACTION_DREAMING_STOPPED);
+        context.registerReceiver(mDreamReceiver, filter);
+
+        // register for multiuser-relevant broadcasts
+        filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
+        context.registerReceiver(mMultiuserReceiver, filter);
+
+        mVibrator = (Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
+        // register for WIFI Display intents
+        IntentFilter wifiDisplayFilter = new IntentFilter(
+                                                Intent.ACTION_WIFI_DISPLAY_VIDEO);
+        Intent wifidisplayIntent = context.registerReceiver(
+                                      mWifiDisplayReceiver, wifiDisplayFilter);
+
+        mLongPressVibePattern = getLongIntArray(mContext.getResources(),
+                com.android.internal.R.array.config_longPressVibePattern);
+        mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(),
+                com.android.internal.R.array.config_virtualKeyVibePattern);
+        mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(),
+                com.android.internal.R.array.config_keyboardTapVibePattern);
+        mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(),
+                com.android.internal.R.array.config_safeModeDisabledVibePattern);
+        mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(),
+                com.android.internal.R.array.config_safeModeEnabledVibePattern);
+
+        mScreenshotChordEnabled = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_enableScreenshotChord);
+
+        // Controls rotation and the like.
+        initializeHdmiState();
+
+        // Match current screen state.
+        if (mPowerManager.isScreenOn()) {
+            screenTurningOn(null);
+        } else {
+            screenTurnedOff(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
+        }
+    }
+
+    public void setInitialDisplaySize(Display display, int width, int height, int density) {
+        mDisplay = display;
+
+        int shortSize, longSize;
+        if (width > height) {
+            shortSize = height;
+            longSize = width;
+            mLandscapeRotation = Surface.ROTATION_0;
+            mSeascapeRotation = Surface.ROTATION_180;
+            if (mContext.getResources().getBoolean(
+                    com.android.internal.R.bool.config_reverseDefaultRotation)) {
+                mPortraitRotation = Surface.ROTATION_90;
+                mUpsideDownRotation = Surface.ROTATION_270;
+            } else {
+                mPortraitRotation = Surface.ROTATION_270;
+                mUpsideDownRotation = Surface.ROTATION_90;
+            }
+        } else {
+            shortSize = width;
+            longSize = height;
+            mPortraitRotation = Surface.ROTATION_0;
+            mUpsideDownRotation = Surface.ROTATION_180;
+            if (mContext.getResources().getBoolean(
+                    com.android.internal.R.bool.config_reverseDefaultRotation)) {
+                mLandscapeRotation = Surface.ROTATION_270;
+                mSeascapeRotation = Surface.ROTATION_90;
+            } else {
+                mLandscapeRotation = Surface.ROTATION_90;
+                mSeascapeRotation = Surface.ROTATION_270;
+            }
+        }
+
+        getDimensions();
+   
+        // For demo purposes, allow the rotation of the HDMI display to be controlled.
+        // By default, HDMI locks rotation to landscape.
+        if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
+            mHdmiRotation = mPortraitRotation;
+        } else {
+            mHdmiRotation = mLandscapeRotation;
+        }
+        mHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", true);
+    }
+
+    private void closeApplication(String packageName) {
+        try {
+            ActivityManagerNative.getDefault().killApplicationProcess(
+                    packageName, AppGlobals.getPackageManager().getPackageUid(
+                    packageName, UserHandle.myUserId()));
+        } catch (RemoteException e) {
+            // Good luck next time!
+        }
+    }
+   
+    private void update(boolean updateUi) {
+        if (updateUi) {
+            updateHybridLayout();
+        }
+
+        updateSettings();
+        updateRotation(false);
+
+        if (updateUi) closeApplication("com.android.systemui");
+    }
+    
+    private int updateHybridLayout() {
+        boolean expDesktop = Settings.System.getInt(mContext.getContentResolver(),
+                    Settings.System.EXPANDED_DESKTOP_STATE, 0) == 1;
+        int oldSystemUILayout = mSystemUiLayout == 0 ?
+                ExtendedPropertiesUtils.getActualProperty("com.android.systemui.layout") : mSystemUiLayout;
+        ExtendedPropertiesUtils.refreshProperties();
+        mSystemDpi = ExtendedPropertiesUtils.getActualProperty("android.dpi");
+        mSystemUiDpi = ExtendedPropertiesUtils.getActualProperty("com.android.systemui.dpi");
+        mSystemUiLayout = ExtendedPropertiesUtils.getActualProperty("com.android.systemui.layout");
+        int mNavigationBarPercent = expDesktop ? 0 : Integer.parseInt(ExtendedPropertiesUtils.getProperty("com.android.systemui.navbar.dpi", "100"));
+        mNavBarDpi = mNavigationBarPercent * mSystemUiDpi / 100;
+        int mStatusBarPercent = Integer.parseInt(ExtendedPropertiesUtils.getProperty("com.android.systemui.statusbar.dpi", "100"));
+        mStatusBarDpi = mStatusBarPercent * mSystemUiDpi / 100;
+        return oldSystemUILayout;
+    }
+
+    public void updateSettings() {
+        DisplayMetrics metrics = new DisplayMetrics();
+        WindowManager wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
+        wm.getDefaultDisplay().getMetrics(metrics);
+        int density = metrics.densityDpi;
+        ContentResolver resolver = mContext.getContentResolver();
+        boolean updateRotation = false, updateDisplayMetrics = false;
+        synchronized (mLock) {
+            mEndcallBehavior = Settings.System.getIntForUser(resolver,
+                    Settings.System.END_BUTTON_BEHAVIOR,
+                    Settings.System.END_BUTTON_BEHAVIOR_DEFAULT,
+                    UserHandle.USER_CURRENT);
+            mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver,
+                    Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR,
+                    Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT,
+                    UserHandle.USER_CURRENT);
+            mRingHomeBehavior = Settings.Secure.getIntForUser(resolver,
+                    Settings.Secure.RING_HOME_BUTTON_BEHAVIOR,
+                    Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_DEFAULT,
+                    UserHandle.USER_CURRENT);
+            mVolumeWakeScreen = (Settings.System.getIntForUser(resolver,
+                    Settings.System.VOLUME_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1);
+            mVolBtnMusicControls = (Settings.System.getIntForUser(resolver,
+                    Settings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
+
+            mHasNavigationBar = !mHasSystemNavBar;
+
+            getDimensions();
+
+            boolean keyRebindingEnabled = Settings.System.getIntForUser(resolver,
+                    Settings.System.HARDWARE_KEY_REBINDING, 0, UserHandle.USER_CURRENT) == 1;
+
+            if (!keyRebindingEnabled) {
+                if (mHasHomeKey) {
+                    if (mHasAppSwitchKey) {
+                        mLongPressOnHomeBehavior = KEY_ACTION_NOTHING;
+                    } else {
+                        mLongPressOnHomeBehavior = KEY_ACTION_APP_SWITCH;
+                    }
+                }
+                if (mHasMenuKey) {
+                    mPressOnMenuBehavior = KEY_ACTION_MENU;
+                    if (mHasAssistKey) {
+                        mLongPressOnMenuBehavior = KEY_ACTION_NOTHING;
+                    } else {
+                        mLongPressOnMenuBehavior = KEY_ACTION_SEARCH;
+                    }
+                }
+                if (mHasAssistKey) {
+                    mPressOnAssistBehavior = KEY_ACTION_SEARCH;
+                    mLongPressOnAssistBehavior = KEY_ACTION_VOICE_SEARCH;
+                }
+                if (mHasAppSwitchKey) {
+                    mPressOnAppSwitchBehavior = KEY_ACTION_APP_SWITCH;
+                    mLongPressOnAppSwitchBehavior = KEY_ACTION_NOTHING;
+                }
+            } else {
+                if (mHasHomeKey) {
+                    if (mHasAppSwitchKey) {
+                        mLongPressOnHomeBehavior = Settings.System.getIntForUser(resolver,
+                                Settings.System.KEY_HOME_LONG_PRESS_ACTION,
+                                KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
+                    } else {
+                        mLongPressOnHomeBehavior = Settings.System.getIntForUser(resolver,
+                                Settings.System.KEY_HOME_LONG_PRESS_ACTION,
+                                KEY_ACTION_APP_SWITCH, UserHandle.USER_CURRENT);
+                    }
+                }
+                if (mHasMenuKey) {
+                    mPressOnMenuBehavior = Settings.System.getIntForUser(resolver,
+                            Settings.System.KEY_MENU_ACTION,
+                            KEY_ACTION_MENU, UserHandle.USER_CURRENT);
+                    if (mHasAssistKey) {
+                        mLongPressOnMenuBehavior = Settings.System.getIntForUser(resolver,
+                                Settings.System.KEY_MENU_LONG_PRESS_ACTION,
+                                KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
+                    } else {
+                        mLongPressOnMenuBehavior = Settings.System.getIntForUser(resolver,
+                                Settings.System.KEY_MENU_LONG_PRESS_ACTION,
+                                KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
+                    }
+                }
+                if (mHasAssistKey) {
+                    mPressOnAssistBehavior = Settings.System.getIntForUser(resolver,
+                            Settings.System.KEY_ASSIST_ACTION,
+                            KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
+                    mLongPressOnAssistBehavior = Settings.System.getIntForUser(resolver,
+                            Settings.System.KEY_ASSIST_LONG_PRESS_ACTION,
+                            KEY_ACTION_VOICE_SEARCH, UserHandle.USER_CURRENT);
+                }
+                if (mHasAppSwitchKey) {
+                    mPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver,
+                            Settings.System.KEY_APP_SWITCH_ACTION,
+                            KEY_ACTION_APP_SWITCH, UserHandle.USER_CURRENT);
+                    mLongPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver,
+                            Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION,
+                            KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
+                }
+            }
+
+            int expandedDesktopStyle = Settings.System.getIntForUser(resolver,
+                    Settings.System.EXPANDED_DESKTOP_STYLE, 0, UserHandle.USER_CURRENT);
+            if (Settings.System.getIntForUser(resolver,
+                        Settings.System.EXPANDED_DESKTOP_STATE, 0, UserHandle.USER_CURRENT) == 0) {
+                expandedDesktopStyle = 0;
+            }
+
+            if (expandedDesktopStyle != mExpandedDesktopStyle) {
+                mExpandedDesktopStyle = expandedDesktopStyle;
+                updateDisplayMetrics = true;
+            }
+
+            // Configure rotation lock.
+            int userRotation = Settings.System.getIntForUser(resolver,
+                    Settings.System.USER_ROTATION, Surface.ROTATION_0,
+                    UserHandle.USER_CURRENT);
+
+            if (mUserRotation != userRotation) {
+                mUserRotation = userRotation;
+                updateRotation = true;
+            }
+            int userRotationMode = Settings.System.getIntForUser(resolver,
+                    Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ?
+                            WindowManagerPolicy.USER_ROTATION_FREE :
+                                    WindowManagerPolicy.USER_ROTATION_LOCKED;
+            if (mUserRotationMode != userRotationMode) {
+                mUserRotationMode = userRotationMode;
+                updateRotation = true;
+                updateOrientationListenerLp();
+            }
+
+            mUserRotationAngles = Settings.System.getIntForUser(resolver,
+                    Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1, UserHandle.USER_CURRENT);
+
+            if (mSystemReady) {
+                int pointerLocation = Settings.System.getIntForUser(resolver,
+                        Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
+                if (mPointerLocationMode != pointerLocation) {
+                    mPointerLocationMode = pointerLocation;
+                    mHandler.sendEmptyMessage(pointerLocation != 0 ?
+                            MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
+                }
+            }
+
+            // Use screen off timeout setting as the timeout for the lockscreen
+            mLockScreenTimeout = Settings.System.getIntForUser(resolver,
+                    Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
+            String imId = Settings.Secure.getStringForUser(resolver,
+                    Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
+            boolean hasSoftInput = imId != null && imId.length() > 0;
+            if (mHasSoftInput != hasSoftInput) {
+                mHasSoftInput = hasSoftInput;
+                updateRotation = true;
+            }
+        }
+
+        if (updateRotation) {
+            updateRotation(true);
+        } else if (updateDisplayMetrics) {
+            updateDisplayMetrics();
+        }
+                
+    }
+    
+    public void getDimensions(){
+        float statusBarHeight = ((float)mContext.getResources().getDimensionPixelSize(
+                com.android.internal.R.dimen.status_bar_height) *
+                DisplayMetrics.DENSITY_DEVICE / mSystemDpi) /
+                DisplayMetrics.DENSITY_DEVICE * mStatusBarDpi;
+   
+        float navigationBarHeight = ((float)mContext.getResources().getDimensionPixelSize(
+                com.android.internal.R.dimen.navigation_bar_height) *
+                DisplayMetrics.DENSITY_DEVICE / mSystemDpi) /
+                DisplayMetrics.DENSITY_DEVICE * mNavBarDpi;
+   
+        float navigationBarWidth = ((float)mContext.getResources().getDimensionPixelSize(
+                com.android.internal.R.dimen.navigation_bar_width) *
+                DisplayMetrics.DENSITY_DEVICE / mSystemDpi) /
+                DisplayMetrics.DENSITY_DEVICE * mNavBarDpi;
+   
+        float navigationBarHeightLandscape = ((float)mContext.getResources().getDimensionPixelSize(
+                com.android.internal.R.dimen.navigation_bar_height_landscape) *
+                DisplayMetrics.DENSITY_DEVICE / mSystemDpi) /
+                DisplayMetrics.DENSITY_DEVICE * mNavBarDpi;
+   
+        mStatusBarHeight = Math.round(statusBarHeight);
+   
+        // Height of the navigation bar when presented horizontally at bottom
+        mNavigationBarHeightForRotation[mPortraitRotation] = 
+                mNavigationBarHeightForRotation[mUpsideDownRotation] = Math.round(navigationBarHeight);
+   
+        mNavigationBarHeightForRotation[mLandscapeRotation] =
+                mNavigationBarHeightForRotation[mSeascapeRotation] = Math.round(navigationBarHeightLandscape);
+   
+        // Width of the navigation bar when presented vertically along one side
+        mNavigationBarWidthForRotation[mPortraitRotation] = mNavigationBarWidthForRotation[mUpsideDownRotation] =
+                mNavigationBarWidthForRotation[mLandscapeRotation] = mNavigationBarWidthForRotation[mSeascapeRotation] =
+                Math.round(navigationBarWidth);
+   
+        if (mSystemUiLayout < 600) {
+            // 0-599dp: "phone" UI with a separate status & navigation bar
+            mHasSystemNavBar = false;
+            mNavigationBarCanMove = true;
+        } else if (mSystemUiLayout < 720) {
+            // 600+dp: "phone" UI with modifications for larger screens
+            mHasSystemNavBar = false;
+            mNavigationBarCanMove = false;
+        } else if (mSystemUiLayout == 1000) {
+            // 1000dp: "tablet" UI with a single combined status & navigation bar
+            mHasSystemNavBar = true;
+            mNavigationBarCanMove = false;
+        }
+   
+        mHasNavigationBar = !mHasSystemNavBar;
+   
+        if (mHasSystemNavBar) {
+            mCanHideNavigationBar = true;
+        } else if (mHasNavigationBar) {
+            // The navigation bar is at the right in landscape; it seems always
+            // useful to hide it for showing a video.
+            mCanHideNavigationBar = true;
+        } else {
+            mCanHideNavigationBar = false;
+        }
+   
+        // In case that we removed nav bar, set all sizes to 0 again
+        if(!mHasNavigationBar){
+            if(!mHasSystemNavBar || Settings.System.getInt(mContext.getContentResolver(),
+                    Settings.System.EXPANDED_DESKTOP_STATE, 0) == 1){
+                mNavigationBarWidthForRotation[mPortraitRotation]
+                           = mNavigationBarWidthForRotation[mUpsideDownRotation]
+                           = mNavigationBarWidthForRotation[mLandscapeRotation]
+                           = mNavigationBarWidthForRotation[mSeascapeRotation]
+                           = mNavigationBarHeightForRotation[mPortraitRotation]
+                           = mNavigationBarHeightForRotation[mUpsideDownRotation]
+                           = mNavigationBarHeightForRotation[mLandscapeRotation]
+                           = mNavigationBarHeightForRotation[mSeascapeRotation] = 0;
+            }
+        }
+    }
+
+    private void enablePointerLocation() {
+        if (mPointerLocationView == null) {
+            mPointerLocationView = new PointerLocationView(mContext);
+            mPointerLocationView.setPrintCoords(false);
+
+            WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
+                    WindowManager.LayoutParams.MATCH_PARENT,
+                    WindowManager.LayoutParams.MATCH_PARENT);
+            lp.type = WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY;
+            lp.flags = WindowManager.LayoutParams.FLAG_FULLSCREEN
+                    | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
+                    | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
+                    | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
+            if (ActivityManager.isHighEndGfx()) {
+                lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
+                lp.privateFlags |=
+                        WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;
+            }
+            lp.format = PixelFormat.TRANSLUCENT;
+            lp.setTitle("PointerLocation");
+            WindowManager wm = (WindowManager)
+                    mContext.getSystemService(Context.WINDOW_SERVICE);
+            lp.inputFeatures |= WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;
+            wm.addView(mPointerLocationView, lp);
+
+            mPointerLocationInputChannel =
+                    mWindowManagerFuncs.monitorInput("PointerLocationView");
+            mPointerLocationInputEventReceiver =
+                    new PointerLocationInputEventReceiver(mPointerLocationInputChannel,
+                            Looper.myLooper(), mPointerLocationView);
+        }
+    }
+
+    private void disablePointerLocation() {
+        if (mPointerLocationInputEventReceiver != null) {
+            mPointerLocationInputEventReceiver.dispose();
+            mPointerLocationInputEventReceiver = null;
+        }
+
+        if (mPointerLocationInputChannel != null) {
+            mPointerLocationInputChannel.dispose();
+            mPointerLocationInputChannel = null;
+        }
+
+        if (mPointerLocationView != null) {
+            WindowManager wm = (WindowManager)
+                    mContext.getSystemService(Context.WINDOW_SERVICE);
+            wm.removeView(mPointerLocationView);
+            mPointerLocationView = null;
+        }
+    }
+
+    private int readRotation(int resID) {
+        try {
+            int rotation = mContext.getResources().getInteger(resID);
+            switch (rotation) {
+                case 0:
+                    return Surface.ROTATION_0;
+                case 90:
+                    return Surface.ROTATION_90;
+                case 180:
+                    return Surface.ROTATION_180;
+                case 270:
+                    return Surface.ROTATION_270;
+            }
+        } catch (Resources.NotFoundException e) {
+            // fall through
+        }
+        return -1;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public int checkAddPermission(WindowManager.LayoutParams attrs) {
+        int type = attrs.type;
+        
+        if (type < WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW
+                || type > WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) {
+            return WindowManagerGlobal.ADD_OKAY;
+        }
+        String permission = null;
+        switch (type) {
+            case TYPE_TOAST:
+                // XXX right now the app process has complete control over
+                // this...  should introduce a token to let the system
+                // monitor/control what they are doing.
+                break;
+            case TYPE_DREAM:
+            case TYPE_INPUT_METHOD:
+            case TYPE_WALLPAPER:
+                // The window manager will check these.
+                break;
+            case TYPE_PHONE:
+            case TYPE_PRIORITY_PHONE:
+            case TYPE_SYSTEM_ALERT:
+            case TYPE_SYSTEM_ERROR:
+            case TYPE_SYSTEM_OVERLAY:
+                permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW;
+                break;
+            default:
+                permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;
+        }
+        if (permission != null) {
+            if (mContext.checkCallingOrSelfPermission(permission)
+                    != PackageManager.PERMISSION_GRANTED) {
+                return WindowManagerGlobal.ADD_PERMISSION_DENIED;
+            }
+        }
+        return WindowManagerGlobal.ADD_OKAY;
+    }
+
+    @Override
+    public boolean checkShowToOwnerOnly(WindowManager.LayoutParams attrs) {
+
+        // If this switch statement is modified, modify the comment in the declarations of
+        // the type in {@link WindowManager.LayoutParams} as well.
+        switch (attrs.type) {
+            default:
+                // These are the windows that by default are shown only to the user that created
+                // them. If this needs to be overridden, set
+                // {@link WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS} in
+                // {@link WindowManager.LayoutParams}. Note that permission
+                // {@link android.Manifest.permission.INTERNAL_SYSTEM_WINDOW} is required as well.
+                if ((attrs.privateFlags & PRIVATE_FLAG_SHOW_FOR_ALL_USERS) == 0) {
+                    return true;
+                }
+                break;
+
+            // These are the windows that by default are shown to all users. However, to
+            // protect against spoofing, check permissions below.
+            case TYPE_APPLICATION_STARTING:
+            case TYPE_BOOT_PROGRESS:
+            case TYPE_DISPLAY_OVERLAY:
+            case TYPE_HIDDEN_NAV_CONSUMER:
+            case TYPE_KEYGUARD:
+            case TYPE_KEYGUARD_DIALOG:
+            case TYPE_MAGNIFICATION_OVERLAY:
+            case TYPE_NAVIGATION_BAR:
+            case TYPE_NAVIGATION_BAR_PANEL:
+            case TYPE_PHONE:
+            case TYPE_POINTER:
+            case TYPE_PRIORITY_PHONE:
+            case TYPE_RECENTS_OVERLAY:
+            case TYPE_SEARCH_BAR:
+            case TYPE_STATUS_BAR:
+            case TYPE_STATUS_BAR_PANEL:
+            case TYPE_STATUS_BAR_SUB_PANEL:
+            case TYPE_SYSTEM_DIALOG:
+            case TYPE_UNIVERSE_BACKGROUND:
+            case TYPE_VOLUME_OVERLAY:
+                break;
+        }
+
+        // Check if third party app has set window to system window type.
+        return mContext.checkCallingOrSelfPermission(
+                android.Manifest.permission.INTERNAL_SYSTEM_WINDOW)
+                        != PackageManager.PERMISSION_GRANTED;
+    }
+
+    public void adjustWindowParamsLw(WindowManager.LayoutParams attrs) {
+        switch (attrs.type) {
+            case TYPE_SYSTEM_OVERLAY:
+            case TYPE_SECURE_SYSTEM_OVERLAY:
+            case TYPE_TOAST:
+                // These types of windows can't receive input events.
+                attrs.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
+                        | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
+                attrs.flags &= ~WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
+                break;
+        }
+    }
+    
+    void readLidState() {
+        mLidState = mWindowManagerFuncs.getLidState();
+    }
+    
+    private boolean isHidden(int accessibilityMode) {
+        switch (accessibilityMode) {
+            case 1:
+                return mLidState == LID_CLOSED;
+            case 2:
+                return mLidState == LID_OPEN;
+            default:
+                return false;
+        }
+    }
+
+    private boolean isBuiltInKeyboardVisible() {
+        return mHaveBuiltInKeyboard && !isHidden(mLidKeyboardAccessibility);
+    }
+
+    /** {@inheritDoc} */
+    public void adjustConfigurationLw(Configuration config, int keyboardPresence,
+            int navigationPresence) {
+        mHaveBuiltInKeyboard = (keyboardPresence & PRESENCE_INTERNAL) != 0;
+
+        readLidState();
+        applyLidSwitchState();
+
+        if (config.keyboard == Configuration.KEYBOARD_NOKEYS
+                || (keyboardPresence == PRESENCE_INTERNAL
+                        && isHidden(mLidKeyboardAccessibility))) {
+            config.hardKeyboardHidden = Configuration.HARDKEYBOARDHIDDEN_YES;
+            if (!mHasSoftInput) {
+                config.keyboardHidden = Configuration.KEYBOARDHIDDEN_YES;
+            }
+        }
+
+        if (config.navigation == Configuration.NAVIGATION_NONAV
+                || (navigationPresence == PRESENCE_INTERNAL
+                        && isHidden(mLidNavigationAccessibility))) {
+            config.navigationHidden = Configuration.NAVIGATIONHIDDEN_YES;
+        }
+    }
+
+    /** {@inheritDoc} */
+    public int windowTypeToLayerLw(int type) {
+        if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
+            return 2;
+        }
+        switch (type) {
+        case TYPE_UNIVERSE_BACKGROUND:
+            return 1;
+        case TYPE_WALLPAPER:
+            // wallpaper is at the bottom, though the window manager may move it.
+            return 2;
+        case TYPE_PHONE:
+            return 3;
+        case TYPE_SEARCH_BAR:
+            return 4;
+        case TYPE_RECENTS_OVERLAY:
+        case TYPE_SYSTEM_DIALOG:
+            return 5;
+        case TYPE_TOAST:
+            // toasts and the plugged-in battery thing
+            return 6;
+        case TYPE_PRIORITY_PHONE:
+            // SIM errors and unlock.  Not sure if this really should be in a high layer.
+            return 7;
+        case TYPE_DREAM:
+            // used for Dreams (screensavers with TYPE_DREAM windows)
+            return 8;
+        case TYPE_SYSTEM_ALERT:
+            // like the ANR / app crashed dialogs
+            return 9;
+        case TYPE_INPUT_METHOD:
+            // on-screen keyboards and other such input method user interfaces go here.
+            return 10;
+        case TYPE_INPUT_METHOD_DIALOG:
+            // on-screen keyboards and other such input method user interfaces go here.
+            return 11;
+        case TYPE_KEYGUARD:
+            // the keyguard; nothing on top of these can take focus, since they are
+            // responsible for power management when displayed.
+            return 12;
+        case TYPE_KEYGUARD_DIALOG:
+            return 13;
+        case TYPE_STATUS_BAR_SUB_PANEL:
+            return 14;
+        case TYPE_STATUS_BAR:
+            return 15;
+        case TYPE_STATUS_BAR_PANEL:
+            return 16;
+        case TYPE_VOLUME_OVERLAY:
+            // the on-screen volume indicator and controller shown when the user
+            // changes the device volume
+            return 17;
+        case TYPE_SYSTEM_OVERLAY:
+            // the on-screen volume indicator and controller shown when the user
+            // changes the device volume
+            return 18;
+        case TYPE_NAVIGATION_BAR:
+            // the navigation bar, if available, shows atop most things
+            return 19;
+        case TYPE_NAVIGATION_BAR_PANEL:
+            // some panels (e.g. search) need to show on top of the navigation bar
+            return 20;
+        case TYPE_SYSTEM_ERROR:
+            // system-level error dialogs
+            return 21;
+        case TYPE_MAGNIFICATION_OVERLAY:
+            // used to highlight the magnified portion of a display
+            return 22;
+        case TYPE_DISPLAY_OVERLAY:
+            // used to simulate secondary display devices
+            return 23;
+        case TYPE_DRAG:
+            // the drag layer: input for drag-and-drop is associated with this window,
+            // which sits above all other focusable windows
+            return 24;
+        case TYPE_SECURE_SYSTEM_OVERLAY:
+            return 25;
+        case TYPE_BOOT_PROGRESS:
+            return 26;
+        case TYPE_POINTER:
+            // the (mouse) pointer layer
+            return 27;
+        case TYPE_HIDDEN_NAV_CONSUMER:
+            return 28;
+        }
+        Log.e(TAG, "Unknown window type: " + type);
+        return 2;
+    }
+
+    /** {@inheritDoc} */
+    public int subWindowTypeToLayerLw(int type) {
+        switch (type) {
+        case TYPE_APPLICATION_PANEL:
+        case TYPE_APPLICATION_ATTACHED_DIALOG:
+            return APPLICATION_PANEL_SUBLAYER;
+        case TYPE_APPLICATION_MEDIA:
+            return APPLICATION_MEDIA_SUBLAYER;
+        case TYPE_APPLICATION_MEDIA_OVERLAY:
+            return APPLICATION_MEDIA_OVERLAY_SUBLAYER;
+        case TYPE_APPLICATION_SUB_PANEL:
+            return APPLICATION_SUB_PANEL_SUBLAYER;
+        }
+        Log.e(TAG, "Unknown sub-window type: " + type);
+        return 0;
+    }
+
+    public int getMaxWallpaperLayer() {
+        return windowTypeToLayerLw(TYPE_STATUS_BAR);
+    }
+
+    public int getAboveUniverseLayer() {
+        return windowTypeToLayerLw(TYPE_SYSTEM_ERROR);
+    }
+
+    public boolean hasSystemNavBar() {
+        return mHasSystemNavBar;
+    }
+
+    public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation) {
+        if (mHasNavigationBar && !expandedDesktopHidesNavigationBar()) {
+            // For a basic navigation bar, when we are in landscape mode we place
+            // the navigation bar to the side.
+            if (mNavigationBarCanMove && fullWidth > fullHeight) {
+                return fullWidth - mNavigationBarWidthForRotation[rotation];
+            }
+        }
+        return fullWidth;
+    }
+
+    public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation) {
+        if (mHasSystemNavBar && !expandedDesktopHidesNavigationBar()) {
+            // For the system navigation bar, we always place it at the bottom.
+            return fullHeight - mNavigationBarHeightForRotation[rotation];
+        }
+        if (mHasNavigationBar && !expandedDesktopHidesNavigationBar()) {
+            // For a basic navigation bar, when we are in portrait mode we place
+            // the navigation bar to the bottom.
+            if (!mNavigationBarCanMove || fullWidth < fullHeight) {
+                return fullHeight - mNavigationBarHeightForRotation[rotation];
+            }
+        }
+        return fullHeight;
+    }
+
+    public int getConfigDisplayWidth(int fullWidth, int fullHeight, int rotation) {
+        return getNonDecorDisplayWidth(fullWidth, fullHeight, rotation);
+    }
+
+    public int getConfigDisplayHeight(int fullWidth, int fullHeight, int rotation) {
+        // If we don't have a system nav bar, then there is a separate status
+        // bar at the top of the display.  We don't count that as part of the
+        // fixed decor, since it can hide; however, for purposes of configurations,
+        // we do want to exclude it since applications can't generally use that part
+        // of the screen.
+        if (!mHasSystemNavBar) {
+            return getNonDecorDisplayHeight(fullWidth, fullHeight, rotation) - mStatusBarHeight;
+        }
+        return getNonDecorDisplayHeight(fullWidth, fullHeight, rotation);
+    }
+
+    @Override
+    public int getWallpaperHeight(int rotation) {
+        return getWallpaperTop(rotation)+getWallpaperBottom(rotation);
+    }
+
+    @Override
+    public int getWallpaperWidth(int rotation) {
+        return getWallpaperLeft(rotation)+getWallpaperRight(rotation);
+    }
+
+    @Override
+    public int getWallpaperTop(int rotation) {
+        return mUnrestrictedScreenTop;
+    }
+
+    @Override
+    public int getWallpaperLeft(int rotation) {
+        return mUnrestrictedScreenLeft;
+    }
+
+    @Override
+    public int getWallpaperBottom(int rotation) {
+        return mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+    }
+
+    @Override
+    public int getWallpaperRight(int rotation) {
+        return mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+    }
+
+    @Override
+    public boolean doesForceHide(WindowState win, WindowManager.LayoutParams attrs) {
+        return attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD;
+    }
+
+    @Override
+    public boolean canBeForceHidden(WindowState win, WindowManager.LayoutParams attrs) {
+        switch (attrs.type) {
+            case TYPE_STATUS_BAR:
+            case TYPE_NAVIGATION_BAR:
+            case TYPE_WALLPAPER:
+            case TYPE_DREAM:
+            case TYPE_UNIVERSE_BACKGROUND:
+            case TYPE_KEYGUARD:
+                return false;
+            default:
+                return true;
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public View addStartingWindow(IBinder appToken, String packageName, int theme,
+            CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes,
+            int icon, int windowFlags) {
+        if (!SHOW_STARTING_ANIMATIONS) {
+            return null;
+        }
+        if (packageName == null) {
+            return null;
+        }
+
+        WindowManager wm = null;
+        View view = null;
+
+        try {
+            Context context = mContext;
+            if (DEBUG_STARTING_WINDOW) Slog.d(TAG, "addStartingWindow " + packageName
+                    + ": nonLocalizedLabel=" + nonLocalizedLabel + " theme="
+                    + Integer.toHexString(theme));
+
+            try {
+                context = context.createPackageContext(packageName, 0);
+                if (theme != context.getThemeResId()) {
+                    context.setTheme(theme);
+                }
+            } catch (PackageManager.NameNotFoundException e) {
+                // Ignore
+            }
+
+            // Construct the Toast
+
+            Window win = PolicyManager.makeNewWindow(context);
+            final TypedArray ta = win.getWindowStyle();
+            if (ta.getBoolean(
+                        com.android.internal.R.styleable.Window_windowDisablePreview, false)
+                || ta.getBoolean(
+                        com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
+                return null;
+            }
+
+            Resources r = context.getResources();
+            win.setTitle(r.getText(labelRes, nonLocalizedLabel));
+
+            win.setType(
+                WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);
+            // Force the window flags: this is a fake window, so it is not really
+            // touchable or focusable by the user.  We also add in the ALT_FOCUSABLE_IM
+            // flag because we do know that the next window will take input
+            // focus, so we want to get the IME window up on top of us right away.
+            win.setFlags(
+                windowFlags|
+                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|
+                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|
+                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
+                windowFlags|
+                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|
+                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|
+                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
+
+            if (!compatInfo.supportsScreen()) {
+                win.addFlags(WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW);
+            }
+
+            win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,
+                    WindowManager.LayoutParams.MATCH_PARENT);
+
+            final WindowManager.LayoutParams params = win.getAttributes();
+            params.token = appToken;
+            params.packageName = packageName;
+            params.windowAnimations = win.getWindowStyle().getResourceId(
+                    com.android.internal.R.styleable.Window_windowAnimationStyle, 0);
+            params.privateFlags |=
+                    WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED;
+            params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+            params.setTitle("Starting " + packageName);
+
+            wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
+            view = win.getDecorView();
+
+            if (win.isFloating()) {
+                // Whoops, there is no way to display an animation/preview
+                // of such a thing!  After all that work...  let's skip it.
+                // (Note that we must do this here because it is in
+                // getDecorView() where the theme is evaluated...  maybe
+                // we should peek the floating attribute from the theme
+                // earlier.)
+                return null;
+            }
+
+            if (DEBUG_STARTING_WINDOW) Slog.d(
+                TAG, "Adding starting window for " + packageName
+                + " / " + appToken + ": "
+                + (view.getParent() != null ? view : null));
+
+            wm.addView(view, params);
+
+            // Only return the view if it was successfully added to the
+            // window manager... which we can tell by it having a parent.
+            return view.getParent() != null ? view : null;
+        } catch (WindowManager.BadTokenException e) {
+            // ignore
+            Log.w(TAG, appToken + " already running, starting window not displayed");
+        } catch (RuntimeException e) {
+            // don't crash if something else bad happens, for example a
+            // failure loading resources because we are loading from an app
+            // on external storage that has been unmounted.
+            Log.w(TAG, appToken + " failed creating starting window", e);
+        } finally {
+            if (view != null && view.getParent() == null) {
+                Log.w(TAG, "view not successfully added to wm, removing view");
+                wm.removeViewImmediate(view);
+            }
+        }
+
+        return null;
+    }
+
+    /** {@inheritDoc} */
+    public void removeStartingWindow(IBinder appToken, View window) {
+        if (DEBUG_STARTING_WINDOW) {
+            RuntimeException e = new RuntimeException("here");
+            e.fillInStackTrace();
+            Log.v(TAG, "Removing starting window for " + appToken + ": " + window, e);
+        }
+
+        if (window != null) {
+            WindowManager wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
+            wm.removeView(window);
+        }
+    }
+
+    /**
+     * Preflight adding a window to the system.
+     * 
+     * Currently enforces that three window types are singletons:
+     * <ul>
+     * <li>STATUS_BAR_TYPE</li>
+     * <li>KEYGUARD_TYPE</li>
+     * </ul>
+     * 
+     * @param win The window to be added
+     * @param attrs Information about the window to be added
+     * 
+     * @return If ok, WindowManagerImpl.ADD_OKAY.  If too many singletons,
+     * WindowManagerImpl.ADD_MULTIPLE_SINGLETON
+     */
+    public int prepareAddWindowLw(WindowState win, WindowManager.LayoutParams attrs) {
+        switch (attrs.type) {
+            case TYPE_STATUS_BAR:
+                mContext.enforceCallingOrSelfPermission(
+                        android.Manifest.permission.STATUS_BAR_SERVICE,
+                        "PhoneWindowManager");
+                if (mStatusBar != null) {
+                    if (mStatusBar.isAlive()) {
+                        return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
+                    }
+                }
+                mStatusBar = win;
+                break;
+            case TYPE_NAVIGATION_BAR:
+                mContext.enforceCallingOrSelfPermission(
+                        android.Manifest.permission.STATUS_BAR_SERVICE,
+                        "PhoneWindowManager");
+                if (mNavigationBar != null) {
+                    if (mNavigationBar.isAlive()) {
+                        return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
+                    }
+                }
+                mNavigationBar = win;
+                if (DEBUG_LAYOUT) Log.i(TAG, "NAVIGATION BAR: " + mNavigationBar);
+                break;
+            case TYPE_NAVIGATION_BAR_PANEL:
+                mContext.enforceCallingOrSelfPermission(
+                        android.Manifest.permission.STATUS_BAR_SERVICE,
+                        "PhoneWindowManager");
+                break;
+            case TYPE_STATUS_BAR_PANEL:
+                mContext.enforceCallingOrSelfPermission(
+                        android.Manifest.permission.STATUS_BAR_SERVICE,
+                        "PhoneWindowManager");
+                break;
+            case TYPE_STATUS_BAR_SUB_PANEL:
+                mContext.enforceCallingOrSelfPermission(
+                        android.Manifest.permission.STATUS_BAR_SERVICE,
+                        "PhoneWindowManager");
+                break;
+            case TYPE_KEYGUARD:
+                if (mKeyguard != null) {
+                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
+                }
+                mKeyguard = win;
+                break;
+        }
+        return WindowManagerGlobal.ADD_OKAY;
+    }
+
+    /** {@inheritDoc} */
+    public void removeWindowLw(WindowState win) {
+        if (mStatusBar == win) {
+            mStatusBar = null;
+        } else if (mKeyguard == win) {
+            mKeyguard = null;
+        } else if (mNavigationBar == win) {
+            mNavigationBar = null;
+        }
+    }
+
+    static final boolean PRINT_ANIM = false;
+    
+    /** {@inheritDoc} */
+    public int selectAnimationLw(WindowState win, int transit) {
+        if (PRINT_ANIM) Log.i(TAG, "selectAnimation in " + win
+              + ": transit=" + transit);
+        if (win == mStatusBar) {
+            if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
+                return R.anim.dock_top_exit;
+            } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
+                return R.anim.dock_top_enter;
+            }
+        } else if (win == mNavigationBar) {
+            // This can be on either the bottom or the right.
+            if (mNavigationBarOnBottom) {
+                if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
+                    return R.anim.dock_bottom_exit;
+                } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
+                    return R.anim.dock_bottom_enter;
+                }
+            } else {
+                if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
+                    return R.anim.dock_right_exit;
+                } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
+                    return R.anim.dock_right_enter;
+                }
+            }
+        } if (transit == TRANSIT_PREVIEW_DONE) {
+            if (win.hasAppShownWindows()) {
+                if (PRINT_ANIM) Log.i(TAG, "**** STARTING EXIT");
+                return com.android.internal.R.anim.app_starting_exit;
+            }
+        } else if (win.getAttrs().type == TYPE_DREAM && mDreamingLockscreen
+                && transit == TRANSIT_ENTER) {
+            // Special case: we are animating in a dream, while the keyguard
+            // is shown.  We don't want an animation on the dream, because
+            // we need it shown immediately with the keyguard animating away
+            // to reveal it.
+            return -1;
+        }
+
+        return 0;
+    }
+
+    public Animation createForceHideEnterAnimation(boolean onWallpaper) {
+        return AnimationUtils.loadAnimation(mContext, onWallpaper
+                ? com.android.internal.R.anim.lock_screen_wallpaper_behind_enter
+                : com.android.internal.R.anim.lock_screen_behind_enter);
+    }
+    
+    static ITelephony getTelephonyService() {
+        return ITelephony.Stub.asInterface(
+                ServiceManager.checkService(Context.TELEPHONY_SERVICE));
+    }
+
+    static IAudioService getAudioService() {
+        IAudioService audioService = IAudioService.Stub.asInterface(
+                ServiceManager.checkService(Context.AUDIO_SERVICE));
+        if (audioService == null) {
+            Log.w(TAG, "Unable to find IAudioService interface.");
+        }
+        return audioService;
+    }
+
+    boolean keyguardOn() {
+        return keyguardIsShowingTq() || inKeyguardRestrictedKeyInputMode();
+    }
+
+    private static final int[] WINDOW_TYPES_WHERE_HOME_DOESNT_WORK = {
+            WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,
+            WindowManager.LayoutParams.TYPE_SYSTEM_ERROR,
+        };
+
+    /** {@inheritDoc} */
+    @Override
+    public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
+        final boolean keyguardOn = keyguardOn();
+        final int keyCode = event.getKeyCode();
+        final int repeatCount = event.getRepeatCount();
+        final int metaState = event.getMetaState();
+        final int flags = event.getFlags();
+        final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
+        final boolean canceled = event.isCanceled();
+        final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
+
+        if (DEBUG_INPUT) {
+            Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount="
+                    + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed
+                    + " canceled=" + canceled);
+        }
+
+        // If we think we might have a volume down & power/volume-up key chord on the way
+        // but we're not sure, then tell the dispatcher to wait a little while and
+        // try again later before dispatching.
+        if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
+            if (mVolumeDownKeyTriggered && !mPowerKeyTriggered && !mVolumeUpKeyTriggered) {
+                final long now = SystemClock.uptimeMillis();
+                final long timeoutTime = mVolumeDownKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS;
+                if (now < timeoutTime) {
+                    return timeoutTime - now;
+                }
+            } else if (mVolumeUpKeyTriggered && !mVolumeDownKeyTriggered) {
+                final long now = SystemClock.uptimeMillis();
+                final long timeoutTime = mVolumeUpKeyTime + ACTION_CHORD_DEBOUNCE_DELAY_MILLIS;
+                if (now < timeoutTime) {
+                    return timeoutTime - now;
+                }
+            }
+
+            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN
+                    && mVolumeDownKeyConsumedByChord) {
+                if (!down) {
+                    mVolumeDownKeyConsumedByChord = false;
+                }
+                return -1;
+            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP
+                    && mVolumeUpKeyConsumedByChord) {
+                if (!down) {
+                    mVolumeUpKeyConsumedByChord = false;
+                }
+                return -1;
+            }
+        }
+
+        if (keyCode == KeyEvent.KEYCODE_BACK && !down) {
+            mHandler.removeCallbacks(mBackLongPress);
+        }
+
+        // Specific device key handling
+        if (mDeviceKeyHandler != null) {
+            try {
+                // The device only should consume known keys.
+                if (mDeviceKeyHandler.handleKeyEvent(event)) {
+                    return -1;
+                }
+            } catch (Exception e) {
+                Slog.w(TAG, "Could not dispatch event to device key handler", e);
+            }
+        }
+
+        // First we always handle the home key here, so applications
+        // can never break it, although if keyguard is on, we do let
+        // it handle it, because that gives us the correct 5 second
+        // timeout.
+        if (keyCode == KeyEvent.KEYCODE_HOME) {
+
+            // If we have released the home key, and didn't do anything else
+            // while it was pressed, then it is time to go home!
+            if (!down && mHomePressed) {
+                final boolean homeWasLongPressed = mHomeLongPressed;
+                mHomeLongPressed = false;
+                mHomePressed = false;
+                if (!homeWasLongPressed) {
+                    if (mRecentAppsPreloaded) {
+                        cancelPreloadRecentApps();
+                    }
+                    mHomePressed = false;
+                    if (!canceled) {
+                        boolean incomingRinging = false;
+                        try {
+                            ITelephony telephonyService = getTelephonyService();
+                            if (telephonyService != null) {
+                                incomingRinging = telephonyService.isRinging();
+                            }
+                            if (incomingRinging) {
+                                if ((mRingHomeBehavior
+                                        & Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_ANSWER) != 0) {
+                                    Log.i(TAG, "Answering with HOME button.");
+                                    telephonyService.answerRingingCall();
+                                } else {
+                                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
+                                }
+                            } else {
+                                launchHomeFromHotKey();
+                            }
+                        } catch (RemoteException ex) {
+                            Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
+                        }
+                    } else {
+                        Log.i(TAG, "Ignoring HOME; event canceled.");
+                    }
+                    return -1;
+                }
+            }
+
+            // If a system window has focus, then it doesn't make sense
+            // right now to interact with applications.
+            WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
+            if (attrs != null) {
+                final int type = attrs.type;
+                if (type == WindowManager.LayoutParams.TYPE_KEYGUARD
+                        || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
+                    // the "app" is keyguard, so give it the key
+                    return 0;
+                }
+                final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
+                for (int i=0; i<typeCount; i++) {
+                    if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
+                        // don't do anything, but also don't pass it to the app
+                        return -1;
+                    }
+                }
+            }
+            if (down) {
+                if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
+                    preloadRecentApps();
+                }
+                if (repeatCount == 0) {
+                    mHomePressed = true;
+                } else if (longPress) {
+                    if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
+                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
+                        performKeyAction(mLongPressOnHomeBehavior);
+                        // Eat the long-press so it won't take us home when the key is released
+                        mHomeLongPressed = true;
+                    }
+                }
+            }
+            return -1;
+        } else if (keyCode == KeyEvent.KEYCODE_MENU) {
+            // Hijack modified menu keys for debugging features
+            final int chordBug = KeyEvent.META_SHIFT_ON;
+
+            if (down) {
+                if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH ||
+                        mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
+                    preloadRecentApps();
+                }
+                if (repeatCount == 0) {
+                    if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
+                        Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
+                        mContext.sendOrderedBroadcast(intent, null);
+                        return -1;
+                    } else if (SHOW_PROCESSES_ON_ALT_MENU &&
+                            (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
+                        Intent service = new Intent();
+                        service.setClassName(mContext, "com.android.server.LoadAverageService");
+                        ContentResolver res = mContext.getContentResolver();
+                        boolean shown = Settings.System.getInt(
+                                res, Settings.System.SHOW_PROCESSES, 0) != 0;
+                        if (!shown) {
+                            mContext.startService(service);
+                        } else {
+                            mContext.stopService(service);
+                        }
+                        Settings.System.putInt(
+                                res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
+                        return -1;
+                    } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !mIsVirtualKeypress) {
+                        mMenuDoCustomAction = true;
+                        return -1;
+                    }
+                } else if (longPress) {
+                    if (mRecentAppsPreloaded &&
+                            mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
+                        cancelPreloadRecentApps();
+                    }
+                    if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
+                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
+                        performKeyAction(mLongPressOnMenuBehavior);
+                        // Do not perform action when key is released
+                        mMenuDoCustomAction = false;
+                        return -1;
+                    }
+                }
+            } else {
+                if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH &&
+                        mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
+                    cancelPreloadRecentApps();
+                }
+                if (mMenuDoCustomAction) {
+                    mMenuDoCustomAction = false;
+                    if (!canceled && !keyguardOn) {
+                        performKeyAction(mPressOnMenuBehavior);
+                        return -1;
+                    }
+                }
+            }
+        } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
+            if (down) {
+                if (repeatCount == 0) {
+                    mSearchKeyShortcutPending = true;
+                    mConsumeSearchKeyUp = false;
+                }
+            } else {
+                mSearchKeyShortcutPending = false;
+                if (mConsumeSearchKeyUp) {
+                    mConsumeSearchKeyUp = false;
+                    return -1;
+                }
+            }
+            return 0;
+        } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
+            if (down) {
+                if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH ||
+                        mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
+                    preloadRecentApps();
+                }
+                if (repeatCount == 0) {
+                    mAppSwitchLongPressed = false;
+                } else if (longPress) {
+                    if (mRecentAppsPreloaded &&
+                            mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
+                        cancelPreloadRecentApps();
+                    }
+                    if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
+                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
+                        performKeyAction(mLongPressOnAppSwitchBehavior);
+                        mAppSwitchLongPressed = true;
+                    }
+                }
+            } else {
+                if (mAppSwitchLongPressed) {
+                    mAppSwitchLongPressed = false;
+                } else {
+                    if (mRecentAppsPreloaded &&
+                            mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
+                        cancelPreloadRecentApps();
+                    }
+                    if (!canceled && !keyguardOn) {
+                        performKeyAction(mPressOnAppSwitchBehavior);
+                    }
+                    return -1;
+                }
+            }
+            return -1;
+        } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
+            if (down) {
+                if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH ||
+                        mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
+                    preloadRecentApps();
+                }
+                if (repeatCount == 0) {
+                    mAssistKeyLongPressed = false;
+                } else if (longPress) {
+                    if (mRecentAppsPreloaded &&
+                            mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
+                        cancelPreloadRecentApps();
+                    }
+                    if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
+                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
+                        performKeyAction(mLongPressOnAssistBehavior);
+                        mAssistKeyLongPressed = true;
+                    }
+                }
+            } else {
+                if (mAssistKeyLongPressed) {
+                    mAssistKeyLongPressed = false;
+                } else {
+                    if (mRecentAppsPreloaded &&
+                            mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
+                        cancelPreloadRecentApps();
+                    }
+                    if (!keyguardOn) {
+                        performKeyAction(mPressOnAssistBehavior);
+                    }
+                }
+            }
+            return -1;
+        } else if (keyCode == KeyEvent.KEYCODE_BACK) {
+            if (Settings.Secure.getIntForUser(mContext.getContentResolver(),
+                    Settings.Secure.KILL_APP_LONGPRESS_BACK, 0, UserHandle.USER_CURRENT) == 1) {
+                if (down && repeatCount == 0) {
+                    mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
+                }
+            }
+        }
+
+        // Shortcuts are invoked through Search+key, so intercept those here
+        // Any printing key that is chorded with Search should be consumed
+        // even if no shortcut was invoked.  This prevents text from being
+        // inadvertently inserted when using a keyboard that has built-in macro
+        // shortcut keys (that emit Search+x) and some of them are not registered.
+        if (mSearchKeyShortcutPending) {
+            final KeyCharacterMap kcm = event.getKeyCharacterMap();
+            if (kcm.isPrintingKey(keyCode)) {
+                mConsumeSearchKeyUp = true;
+                mSearchKeyShortcutPending = false;
+                if (down && repeatCount == 0 && !keyguardOn) {
+                    Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
+                    if (shortcutIntent != null) {
+                        shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                        try {
+                            mContext.startActivity(shortcutIntent);
+                        } catch (ActivityNotFoundException ex) {
+                            Slog.w(TAG, "Dropping shortcut key combination because "
+                                    + "the activity to which it is registered was not found: "
+                                    + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
+                        }
+                    } else {
+                        Slog.i(TAG, "Dropping unregistered shortcut key combination: "
+                                + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
+                    }
+                }
+                return -1;
+            }
+        }
+
+        // Invoke shortcuts using Meta.
+        if (down && repeatCount == 0 && !keyguardOn
+                && (metaState & KeyEvent.META_META_ON) != 0) {
+            final KeyCharacterMap kcm = event.getKeyCharacterMap();
+            if (kcm.isPrintingKey(keyCode)) {
+                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode,
+                        metaState & ~(KeyEvent.META_META_ON
+                                | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
+                if (shortcutIntent != null) {
+                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    try {
+                        mContext.startActivity(shortcutIntent);
+                    } catch (ActivityNotFoundException ex) {
+                        Slog.w(TAG, "Dropping shortcut key combination because "
+                                + "the activity to which it is registered was not found: "
+                                + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
+                    }
+                    return -1;
+                }
+            }
+        }
+
+        // Handle application launch keys.
+        if (down && repeatCount == 0 && !keyguardOn) {
+            String category = sApplicationLaunchKeyCategories.get(keyCode);
+            if (category != null) {
+                Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
+                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                try {
+                    mContext.startActivity(intent);
+                } catch (ActivityNotFoundException ex) {
+                    Slog.w(TAG, "Dropping application launch key because "
+                            + "the activity to which it is registered was not found: "
+                            + "keyCode=" + keyCode + ", category=" + category, ex);
+                }
+                return -1;
+            }
+        }
+
+        // Display task switcher for ALT-TAB or Meta-TAB.
+        if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
+            if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
+                final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
+                if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)
+                        || KeyEvent.metaStateHasModifiers(
+                                shiftlessModifiers, KeyEvent.META_META_ON)) {
+                    mRecentAppsDialogHeldModifiers = shiftlessModifiers;
+                    showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
+                    return -1;
+                }
+            }
+        } else if (!down && mRecentAppsDialogHeldModifiers != 0
+                && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
+            mRecentAppsDialogHeldModifiers = 0;
+            showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS :
+                    RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
+        }
+
+        // Handle keyboard language switching.
+        if (down && repeatCount == 0
+                && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH
+                        || (keyCode == KeyEvent.KEYCODE_SPACE
+                                && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
+            int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
+            mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
+            return -1;
+        }
+        if (mLanguageSwitchKeyPressed && !down
+                && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH
+                        || keyCode == KeyEvent.KEYCODE_SPACE)) {
+            mLanguageSwitchKeyPressed = false;
+            return -1;
+        }
+
+        // Let the application handle the key.
+        return 0;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) {
+        // Note: This method is only called if the initial down was unhandled.
+        if (DEBUG_INPUT) {
+            Slog.d(TAG, "Unhandled key: win=" + win + ", action=" + event.getAction()
+                    + ", flags=" + event.getFlags()
+                    + ", keyCode=" + event.getKeyCode()
+                    + ", scanCode=" + event.getScanCode()
+                    + ", metaState=" + event.getMetaState()
+                    + ", repeatCount=" + event.getRepeatCount()
+                    + ", policyFlags=" + policyFlags);
+        }
+
+        KeyEvent fallbackEvent = null;
+        if ((event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+            final KeyCharacterMap kcm = event.getKeyCharacterMap();
+            final int keyCode = event.getKeyCode();
+            final int metaState = event.getMetaState();
+            final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN
+                    && event.getRepeatCount() == 0;
+
+            // Check for fallback actions specified by the key character map.
+            final FallbackAction fallbackAction;
+            if (initialDown) {
+                fallbackAction = kcm.getFallbackAction(keyCode, metaState);
+            } else {
+                fallbackAction = mFallbackActions.get(keyCode);
+            }
+
+            if (fallbackAction != null) {
+                if (DEBUG_INPUT) {
+                    Slog.d(TAG, "Fallback: keyCode=" + fallbackAction.keyCode
+                            + " metaState=" + Integer.toHexString(fallbackAction.metaState));
+                }
+
+                final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;
+                fallbackEvent = KeyEvent.obtain(
+                        event.getDownTime(), event.getEventTime(),
+                        event.getAction(), fallbackAction.keyCode,
+                        event.getRepeatCount(), fallbackAction.metaState,
+                        event.getDeviceId(), event.getScanCode(),
+                        flags, event.getSource(), null);
+
+                if (!interceptFallback(win, fallbackEvent, policyFlags)) {
+                    fallbackEvent.recycle();
+                    fallbackEvent = null;
+                }
+
+                if (initialDown) {
+                    mFallbackActions.put(keyCode, fallbackAction);
+                } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                    mFallbackActions.remove(keyCode);
+                    fallbackAction.recycle();
+                }
+            }
+        }
+
+        if (DEBUG_INPUT) {
+            if (fallbackEvent == null) {
+                Slog.d(TAG, "No fallback.");
+            } else {
+                Slog.d(TAG, "Performing fallback: " + fallbackEvent);
+            }
+        }
+        return fallbackEvent;
+    }
+
+    private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) {
+        int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags, true);
+        if ((actions & ACTION_PASS_TO_USER) != 0) {
+            long delayMillis = interceptKeyBeforeDispatching(
+                    win, fallbackEvent, policyFlags);
+            if (delayMillis == 0) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void launchAssistLongPressAction() {
+        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_ASSIST);
+
+        // launch the search activity
+        Intent intent = new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        try {
+            // TODO: This only stops the factory-installed search manager.  
+            // Need to formalize an API to handle others
+            SearchManager searchManager = getSearchManager();
+            if (searchManager != null) {
+                searchManager.stopSearch();
+            }
+            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
+        } catch (ActivityNotFoundException e) {
+            Slog.w(TAG, "No activity to handle assist long press action.", e);
+        }
+    }
+
+    private void launchAssistAction() {
+        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_ASSIST);
+        Intent intent = ((SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE))
+                .getAssistIntent(mContext, UserHandle.USER_CURRENT);
+        if (intent != null) {
+            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                    | Intent.FLAG_ACTIVITY_SINGLE_TOP
+                    | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+            try {
+                mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
+            } catch (ActivityNotFoundException e) {
+                Slog.w(TAG, "No activity to handle assist action.", e);
+            }
+        }
+    }
+
+    private SearchManager getSearchManager() {
+        if (mSearchManager == null) {
+            mSearchManager = (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
+        }
+        return mSearchManager;
+    }
+
+    /**
+     * A home key -> launch home action was detected.  Take the appropriate action
+     * given the situation with the keyguard.
+     */
+    void launchHomeFromHotKey() {
+        if (mKeyguardMediator != null && mKeyguardMediator.isShowingAndNotHidden()) {
+            // don't launch home if keyguard showing
+        } else if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
+            // when in keyguard restricted mode, must first verify unlock
+            // before launching home
+            mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult() {
+                public void onKeyguardExitResult(boolean success) {
+                    if (success) {
+                        try {
+                            ActivityManagerNative.getDefault().stopAppSwitches();
+                        } catch (RemoteException e) {
+                        }
+                        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
+                        startDockOrHome();
+                    }
+                }
+            });
+        } else {
+            // no keyguard stuff to worry about, just launch home!
+            try {
+                ActivityManagerNative.getDefault().stopAppSwitches();
+            } catch (RemoteException e) {
+            }
+            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
+            startDockOrHome();
+        }
+    }
+
+    /**
+     * A delayed callback use to determine when it is okay to re-allow applications
+     * to use certain system UI flags.  This is used to prevent applications from
+     * spamming system UI changes that prevent the navigation bar from being shown.
+     */
+    final Runnable mAllowSystemUiDelay = new Runnable() {
+        @Override public void run() {
+        }
+    };
+
+    /**
+     * Input handler used while nav bar is hidden.  Captures any touch on the screen,
+     * to determine when the nav bar should be shown and prevent applications from
+     * receiving those touches.
+     */
+    final class HideNavInputEventReceiver extends InputEventReceiver {
+        public HideNavInputEventReceiver(InputChannel inputChannel, Looper looper) {
+            super(inputChannel, looper);
+        }
+
+        @Override
+        public void onInputEvent(InputEvent event) {
+            boolean handled = false;
+            try {
+                if (event instanceof MotionEvent
+                        && (event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
+                    final MotionEvent motionEvent = (MotionEvent)event;
+                    if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
+                        // When the user taps down, we re-show the nav bar.
+                        boolean changed = false;
+                        synchronized (mLock) {
+                            // Any user activity always causes us to show the
+                            // navigation controls, if they had been hidden.
+                            // We also clear the low profile and only content
+                            // flags so that tapping on the screen will atomically
+                            // restore all currently hidden screen decorations.
+                            int newVal = mResettingSystemUiFlags |
+                                    View.SYSTEM_UI_FLAG_HIDE_NAVIGATION |
+                                    View.SYSTEM_UI_FLAG_LOW_PROFILE |
+                                    View.SYSTEM_UI_FLAG_FULLSCREEN;
+                            if (mResettingSystemUiFlags != newVal) {
+                                mResettingSystemUiFlags = newVal;
+                                changed = true;
+                            }
+                            // We don't allow the system's nav bar to be hidden
+                            // again for 1 second, to prevent applications from
+                            // spamming us and keeping it from being shown.
+                            newVal = mForceClearedSystemUiFlags |
+                                    View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
+                            if (mForceClearedSystemUiFlags != newVal) {
+                                mForceClearedSystemUiFlags = newVal;
+                                changed = true;
+                                mHandler.postDelayed(new Runnable() {
+                                    @Override public void run() {
+                                        synchronized (mLock) {
+                                            // Clear flags.
+                                            mForceClearedSystemUiFlags &=
+                                                    ~View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
+                                        }
+                                        mWindowManagerFuncs.reevaluateStatusBarVisibility();
+                                    }
+                                }, 1000);
+                            }
+                        }
+                        if (changed) {
+                            mWindowManagerFuncs.reevaluateStatusBarVisibility();
+                        }
+                    }
+                }
+            } finally {
+                finishInputEvent(event, handled);
+            }
+        }
+    }
+    final InputEventReceiver.Factory mHideNavInputEventReceiverFactory =
+            new InputEventReceiver.Factory() {
+        @Override
+        public InputEventReceiver createInputEventReceiver(
+                InputChannel inputChannel, Looper looper) {
+            return new HideNavInputEventReceiver(inputChannel, looper);
+        }
+    };
+
+    @Override
+    public int adjustSystemUiVisibilityLw(int visibility) {
+        // Reset any bits in mForceClearingStatusBarVisibility that
+        // are now clear.
+        mResettingSystemUiFlags &= visibility;
+        // Clear any bits in the new visibility that are currently being
+        // force cleared, before reporting it.
+        return visibility & ~mResettingSystemUiFlags
+                & ~mForceClearedSystemUiFlags;
+    }
+
+    @Override
+    public void getContentInsetHintLw(WindowManager.LayoutParams attrs, Rect contentInset) {
+        final int fl = attrs.flags;
+        final int systemUiVisibility = (attrs.systemUiVisibility|attrs.subtreeSystemUiVisibility);
+
+        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR))
+                == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
+            int availRight, availBottom;
+            if (shouldHideNavigationBarLw(systemUiVisibility)) {
+                availRight = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
+                availBottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
+            } else {
+                availRight = mRestrictedScreenLeft + mRestrictedScreenWidth;
+                availBottom = mRestrictedScreenTop + mRestrictedScreenHeight;
+            }
+            if ((systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0) {
+                if ((fl & FLAG_FULLSCREEN) != 0) {
+                    contentInset.set(mStableFullscreenLeft, mStableFullscreenTop,
+                            availRight - mStableFullscreenRight,
+                            availBottom - mStableFullscreenBottom);
+                } else {
+                    contentInset.set(mStableLeft, mStableTop,
+                            availRight - mStableRight, availBottom - mStableBottom);
+                }
+            } else if ((fl & FLAG_FULLSCREEN) != 0) {
+                contentInset.setEmpty();
+            } else if ((systemUiVisibility & (View.SYSTEM_UI_FLAG_FULLSCREEN
+                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN)) == 0) {
+                contentInset.set(mCurLeft, mCurTop,
+                        availRight - mCurRight, availBottom - mCurBottom);
+            } else {
+                contentInset.set(mCurLeft, mCurTop,
+                        availRight - mCurRight, availBottom - mCurBottom);
+            }
+            return;
+        }
+        contentInset.setEmpty();
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight,
+                              int displayRotation) {
+        mUnrestrictedScreenLeft = mUnrestrictedScreenTop = 0;
+        mUnrestrictedScreenWidth = displayWidth;
+        mUnrestrictedScreenHeight = displayHeight;
+        mRestrictedScreenLeft = mRestrictedScreenTop = 0;
+        mRestrictedScreenWidth = displayWidth;
+        mRestrictedScreenHeight = displayHeight;
+        mDockLeft = mContentLeft = mStableLeft = mStableFullscreenLeft
+                = mSystemLeft = mCurLeft = 0;
+        mDockTop = mContentTop = mStableTop = mStableFullscreenTop
+                = mSystemTop = mCurTop = 0;
+        mDockRight = mContentRight = mStableRight = mStableFullscreenRight
+                = mSystemRight = mCurRight = displayWidth;
+        mDockBottom = mContentBottom = mStableBottom = mStableFullscreenBottom
+                = mSystemBottom = mCurBottom = displayHeight;
+        mDockLayer = 0x10000000;
+        mStatusBarLayer = -1;
+
+        // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
+        final Rect pf = mTmpParentFrame;
+        final Rect df = mTmpDisplayFrame;
+        final Rect vf = mTmpVisibleFrame;
+        pf.left = df.left = vf.left = mDockLeft;
+        pf.top = df.top = vf.top = mDockTop;
+        pf.right = df.right = vf.right = mDockRight;
+        pf.bottom = df.bottom = vf.bottom = mDockBottom;
+
+        if (isDefaultDisplay) {
+            // For purposes of putting out fake window up to steal focus, we will
+            // drive nav being hidden only by whether it is requested.
+            boolean navVisible = (mLastSystemUiFlags&View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
+            int navWidth = mNavigationBarWidthForRotation[displayRotation];
+            int navHeight = mNavigationBarHeightForRotation[displayRotation];
+
+            // When the navigation bar isn't visible, we put up a fake
+            // input window to catch all touch events.  This way we can
+            // detect when the user presses anywhere to bring back the nav
+            // bar and ensure the application doesn't see the event.
+            if (navVisible) {
+                if (mHideNavFakeWindow != null) {
+                    mHideNavFakeWindow.dismiss();
+                    mHideNavFakeWindow = null;
+                }
+            } else if (mHideNavFakeWindow == null) {
+                mHideNavFakeWindow = mWindowManagerFuncs.addFakeWindow(
+                        mHandler.getLooper(), mHideNavInputEventReceiverFactory,
+                        "hidden nav", WindowManager.LayoutParams.TYPE_HIDDEN_NAV_CONSUMER,
+                        0, false, false, true);
+            }
+
+            // For purposes of positioning and showing the nav bar, if we have
+            // decided that it can't be hidden (because of the screen aspect ratio),
+            // then take that into account.
+            if (expandedDesktopHidesNavigationBar()
+                    && (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_SHOW_NAVIGATION_IN_EXPANDED_DESKTOP) == 0) {
+                navVisible = false;
+                navWidth = 0;
+                navHeight = 0;
+            } else if (!mCanHideNavigationBar) {
+                navVisible = true;
+            }
+
+            if (mNavigationBar != null) {
+                // Force the navigation bar to its appropriate place and
+                // size.  We need to do this directly, instead of relying on
+                // it to bubble up from the nav bar, because this needs to
+                // change atomically with screen rotations.
+                mNavigationBarOnBottom = (!mNavigationBarCanMove || displayWidth < displayHeight);
+                if (mNavigationBarOnBottom) {
+                    // It's a system nav bar or a portrait screen; nav bar goes on bottom.
+                    int top = displayHeight - navHeight;
+                    mTmpNavigationFrame.set(0, top, displayWidth, displayHeight);
+                    mStableBottom = mStableFullscreenBottom = mTmpNavigationFrame.top;
+                    if (navVisible) {
+                        mNavigationBar.showLw(true);
+                        mSystemBottom = mDockBottom = mTmpNavigationFrame.bottom - mDockTop;
+                    } else {
+                        // We currently want to hide the navigation UI.
+                        mNavigationBar.hideLw(true);
+                    }
+                    if (navVisible && !mNavigationBar.isAnimatingLw()) {
+                        // If the nav bar is currently requested to be visible,
+                        // and not in the process of animating on or off, then
+                        // we can tell the app that it is covered by it.
+                        mSystemBottom = displayHeight;
+                        mRestrictedScreenHeight = mTmpNavigationFrame.top - mDockTop;
+                    }
+                } else {
+                    // Landscape screen; nav bar goes to the right.
+                    int left = displayWidth - navWidth;
+                    mTmpNavigationFrame.set(left, 0, displayWidth, displayHeight);
+                    mStableRight = mStableFullscreenRight = mTmpNavigationFrame.left;
+                    if (navVisible) {
+                        mNavigationBar.showLw(true);
+                        mSystemRight = mDockRight = mTmpNavigationFrame.left - mDockLeft;
+                    } else {
+                        // We currently want to hide the navigation UI.
+                        mNavigationBar.hideLw(true);
+                    }
+                    if (navVisible && !mNavigationBar.isAnimatingLw()) {
+                        // If the nav bar is currently requested to be visible,
+                        // and not in the process of animating on or off, then
+                        // we can tell the app that it is covered by it.
+                        mSystemRight = displayWidth;
+                        mRestrictedScreenWidth = mTmpNavigationFrame.left - mDockLeft;
+                    }
+                }
+                // Make sure the content and current rectangles are updated to
+                // account for the restrictions from the navigation bar.
+                mContentTop = mCurTop = mDockTop;
+                mContentBottom = mCurBottom = mDockBottom;
+                mContentLeft = mCurLeft = mDockLeft;
+                mContentRight = mCurRight = mDockRight;
+                mStatusBarLayer = mNavigationBar.getSurfaceLayer();
+                // And compute the final frame.
+                mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame,
+                        mTmpNavigationFrame, mTmpNavigationFrame);
+                if (DEBUG_LAYOUT) Log.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
+            }
+            if (DEBUG_LAYOUT) Log.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)",
+                    mDockLeft, mDockTop, mDockRight, mDockBottom));
+
+            // decide where the status bar goes ahead of time
+            if (mStatusBar != null) {
+                // apply any navigation bar insets
+                pf.left = df.left = mUnrestrictedScreenLeft;
+                pf.top = df.top = mUnrestrictedScreenTop;
+                pf.right = df.right = mUnrestrictedScreenWidth - mUnrestrictedScreenLeft;
+                pf.bottom = df.bottom = mUnrestrictedScreenHeight - mUnrestrictedScreenTop;
+                vf.left = mStableLeft;
+                vf.top = mStableTop;
+                vf.right = mStableRight;
+                vf.bottom = mStableBottom;
+
+                if(navVisible && !mNavigationBarOnBottom) {
+                    pf.right = df.right = vf.right = mTmpNavigationFrame.left;
+                }
+
+                mStatusBarLayer = mStatusBar.getSurfaceLayer();
+
+                // Let the status bar determine its size.
+                mStatusBar.computeFrameLw(pf, df, vf, vf);
+
+                // For layout, the status bar is always at the top with our fixed height
+                // (except if it's hidden by expanded desktop, in which case we know it's
+                // never shown)
+                if (!expandedDesktopHidesStatusBar()) {
+                    mStableTop = mUnrestrictedScreenTop + mStatusBarHeight;
+                }
+
+                // If the status bar is hidden, we don't want to cause
+                // windows behind it to scroll.
+                if (mStatusBar.isVisibleLw()) {
+                    // Status bar may go away, so the screen area it occupies
+                    // is available to apps but just covering them when the
+                    // status bar is visible.
+                    mDockTop = mUnrestrictedScreenTop+mStatusBarHeight;
+
+                    mContentTop = mCurTop = mDockTop;
+                    mContentBottom = mCurBottom = mDockBottom;
+                    mContentLeft = mCurLeft = mDockLeft;
+                    mContentRight = mCurRight = mDockRight;
+
+                    if (DEBUG_LAYOUT) Log.v(TAG, "Status bar: " +
+                        String.format(
+                            "dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]",
+                            mDockLeft, mDockTop, mDockRight, mDockBottom,
+                            mContentLeft, mContentTop, mContentRight, mContentBottom,
+                            mCurLeft, mCurTop, mCurRight, mCurBottom));
+                }
+                if (mStatusBar.isVisibleLw() && !mStatusBar.isAnimatingLw()) {
+                    // If the status bar is currently requested to be visible,
+                    // and not in the process of animating on or off, then
+                    // we can tell the app that it is covered by it.
+                    mSystemTop = mUnrestrictedScreenTop;
+                }
+            }
+            mDockBottom = navVisible ? mRestrictedScreenTop + mRestrictedScreenHeight : mDockBottom;
+            mDockRight = navVisible ? mRestrictedScreenLeft + mRestrictedScreenWidth: mDockRight;
+        }
+    }
+
+    /** {@inheritDoc} */
+    public int getSystemDecorRectLw(Rect systemRect) {
+        systemRect.left = mSystemLeft;
+        systemRect.top = mSystemTop;
+        systemRect.right = mSystemRight;
+        systemRect.bottom = mSystemBottom;
+        if (mStatusBar != null) return mStatusBar.getSurfaceLayer();
+        if (mNavigationBar != null) return mNavigationBar.getSurfaceLayer();
+        return 0;
+    }
+
+    void setAttachedWindowFrames(WindowState win, int fl, int adjust,
+            WindowState attached, boolean insetDecors, Rect pf, Rect df, Rect cf, Rect vf) {
+        if (win.getSurfaceLayer() > mDockLayer && attached.getSurfaceLayer() < mDockLayer) {
+            // Here's a special case: if this attached window is a panel that is
+            // above the dock window, and the window it is attached to is below
+            // the dock window, then the frames we computed for the window it is
+            // attached to can not be used because the dock is effectively part
+            // of the underlying window and the attached window is floating on top
+            // of the whole thing.  So, we ignore the attached window and explicitly
+            // compute the frames that would be appropriate without the dock.
+            df.left = cf.left = vf.left = mDockLeft;
+            df.top = cf.top = vf.top = mDockTop;
+            df.right = cf.right = vf.right = mDockRight;
+            df.bottom = cf.bottom = vf.bottom = mDockBottom;
+        } else {
+            // The effective display frame of the attached window depends on
+            // whether it is taking care of insetting its content.  If not,
+            // we need to use the parent's content frame so that the entire
+            // window is positioned within that content.  Otherwise we can use
+            // the display frame and let the attached window take care of
+            // positioning its content appropriately.
+            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
+                cf.set(attached.getDisplayFrameLw());
+            } else {
+                // If the window is resizing, then we want to base the content
+                // frame on our attached content frame to resize...  however,
+                // things can be tricky if the attached window is NOT in resize
+                // mode, in which case its content frame will be larger.
+                // Ungh.  So to deal with that, make sure the content frame
+                // we end up using is not covering the IM dock.
+                cf.set(attached.getContentFrameLw());
+                if (attached.getSurfaceLayer() < mDockLayer) {
+                    if (cf.left < mContentLeft) cf.left = mContentLeft;
+                    if (cf.top < mContentTop) cf.top = mContentTop;
+                    if (cf.right > mContentRight) cf.right = mContentRight;
+                    if (cf.bottom > mContentBottom) cf.bottom = mContentBottom;
+                }
+            }
+            df.set(insetDecors ? attached.getDisplayFrameLw() : cf);
+            vf.set(attached.getVisibleFrameLw());
+        }
+        // The LAYOUT_IN_SCREEN flag is used to determine whether the attached
+        // window should be positioned relative to its parent or the entire
+        // screen.
+        pf.set((fl & FLAG_LAYOUT_IN_SCREEN) == 0
+                ? attached.getFrameLw() : df);
+    }
+
+    private void applyStableConstraints(int sysui, int fl, Rect r) {
+        if ((sysui & View.SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0) {
+            // If app is requesting a stable layout, don't let the
+            // content insets go below the stable values.
+            if ((fl & FLAG_FULLSCREEN) != 0) {
+                if (r.left < mStableFullscreenLeft) r.left = mStableFullscreenLeft;
+                if (r.top < mStableFullscreenTop) r.top = mStableFullscreenTop;
+                if (r.right > mStableFullscreenRight) r.right = mStableFullscreenRight;
+                if (r.bottom > mStableFullscreenBottom) r.bottom = mStableFullscreenBottom;
+            } else {
+                if (r.left < mStableLeft) r.left = mStableLeft;
+                if (r.top < mStableTop) r.top = mStableTop;
+                if (r.right > mStableRight) r.right = mStableRight;
+                if (r.bottom > mStableBottom) r.bottom = mStableBottom;
+            }
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void layoutWindowLw(WindowState win, WindowManager.LayoutParams attrs,
+            WindowState attached) {
+        // we've already done the status bar
+        if (win == mStatusBar || win == mNavigationBar) {
+            return;
+        }
+        final boolean isDefaultDisplay = win.isDefaultDisplay();
+        final boolean needsToOffsetInputMethodTarget = isDefaultDisplay &&
+                (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
+        if (needsToOffsetInputMethodTarget) {
+            if (DEBUG_LAYOUT) {
+                Slog.i(TAG, "Offset ime target window by the last ime window state");
+            }
+            offsetInputMethodWindowLw(mLastInputMethodWindow);
+        }
+
+        final int fl = attrs.flags;
+        final int sim = attrs.softInputMode;
+        final int sysUiFl = win.getSystemUiVisibility();
+
+        final Rect pf = mTmpParentFrame;
+        final Rect df = mTmpDisplayFrame;
+        final Rect cf = mTmpContentFrame;
+        final Rect vf = mTmpVisibleFrame;
+
+        final boolean hasNavBar = (isDefaultDisplay && mHasNavigationBar
+                && mNavigationBar != null && mNavigationBar.isVisibleLw());
+        final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
+        if (!isDefaultDisplay) {
+            if (attached != null) {
+                // If this window is attached to another, our display
+                // frame is the same as the one we are attached to.
+                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, cf, vf);
+            } else {
+                // Give the window full screen.
+                pf.left = df.left = cf.left = mUnrestrictedScreenLeft;
+                pf.top = df.top = cf.top = mUnrestrictedScreenTop;
+                pf.right = df.right = cf.right
+                        = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
+                pf.bottom = df.bottom = cf.bottom
+                        = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
+            }
+        } else  if (attrs.type == TYPE_INPUT_METHOD) {
+            pf.left = df.left = cf.left = vf.left = mDockLeft;
+            pf.top = df.top = cf.top = vf.top = mDockTop;
+            pf.right = df.right = cf.right = vf.right = mDockRight;
+            pf.bottom = df.bottom = cf.bottom = vf.bottom = mDockBottom;
+            // IM dock windows always go to the bottom of the screen.
+            attrs.gravity = Gravity.BOTTOM;
+            mDockLayer = win.getSurfaceLayer();
+        } else if (attrs.type == TYPE_WALLPAPER) {
+            pf.left = df.left = cf.left = vf.left = getWallpaperLeft(mUserRotation);
+            pf.top = df.top = cf.top = vf.top = getWallpaperTop(mUserRotation);
+            pf.right = df.right = cf.right = vf.right = getWallpaperRight(mUserRotation);
+            pf.bottom = df.bottom = cf.bottom = vf.bottom = getWallpaperBottom(mUserRotation);
+        } else {
+            if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR))
+                    == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)
+                    && (sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) {
+                if (DEBUG_LAYOUT)
+                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() 
+                            + "): IN_SCREEN, INSET_DECOR, !FULLSCREEN");
+                // This is the case for a normal activity window: we want it
+                // to cover all of the screen space, and it can take care of
+                // moving its contents to account for screen decorations that
+                // intrude into that space.
+                if (attached != null) {
+                    // If this window is attached to another, our display
+                    // frame is the same as the one we are attached to.
+                    setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, cf, vf);
+                } else {
+                    if (attrs.type == TYPE_STATUS_BAR_PANEL
+                            || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
+                        // Status bar panels are the only windows who can go on top of
+                        // the status bar.  They are protected by the STATUS_BAR_SERVICE
+                        // permission, so they have the same privileges as the status
+                        // bar itself.
+                        //
+                        // However, they should still dodge the navigation bar if it exists.
+
+                        pf.left = df.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
+                        pf.top = df.top = mUnrestrictedScreenTop;
+                        pf.right = df.right = hasNavBar
+                                            ? mRestrictedScreenLeft+mRestrictedScreenWidth
+                                            : mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+                        pf.bottom = df.bottom = hasNavBar
+                                              ? mRestrictedScreenTop+mRestrictedScreenHeight
+                                              : mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+
+                        if (DEBUG_LAYOUT) {
+                            Log.v(TAG, String.format(
+                                        "Laying out status bar window: (%d,%d - %d,%d)",
+                                        pf.left, pf.top, pf.right, pf.bottom));
+                        }
+                    } else if (shouldHideNavigationBarLw(sysUiFl)
+                            && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW
+                            && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
+                        // Asking for layout as if the nav bar is hidden, lets the
+                        // application extend into the unrestricted screen area.  We
+                        // only do this for application windows to ensure no window that
+                        // can be above the nav bar can do this.
+                        pf.left = df.left = mUnrestrictedScreenLeft;
+                        pf.top = df.top = mUnrestrictedScreenTop;
+                        pf.right = df.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+                        pf.bottom = df.bottom = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                    } else {
+                        pf.left = df.left = mRestrictedScreenLeft;
+                        pf.top = df.top = mRestrictedScreenTop;
+                        pf.right = df.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
+                        pf.bottom = df.bottom = mRestrictedScreenTop+mRestrictedScreenHeight;
+                    }
+
+                    if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
+                        cf.left = mDockLeft;
+                        cf.top = mDockTop;
+                        cf.right = mDockRight;
+                        cf.bottom = mDockBottom;
+                    } else {
+                        cf.left = mContentLeft;
+                        cf.top = mContentTop;
+                        cf.right = mContentRight;
+                        cf.bottom = mContentBottom;
+                    }
+
+                    applyStableConstraints(sysUiFl, fl, cf);
+                    if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
+                        vf.left = mCurLeft;
+                        vf.top = mCurTop;
+                        vf.right = mCurRight;
+                        vf.bottom = mCurBottom;
+                    } else {
+                        vf.set(cf);
+                    }
+                }
+            } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl
+                    & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+                            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
+                if (DEBUG_LAYOUT)
+                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
+                // A window that has requested to fill the entire screen just
+                // gets everything, period.
+                if (attrs.type == TYPE_STATUS_BAR_PANEL
+                        || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
+                    pf.left = df.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
+                    pf.top = df.top = cf.top = mUnrestrictedScreenTop;
+                    pf.right = df.right = cf.right = hasNavBar
+                                        ? mRestrictedScreenLeft+mRestrictedScreenWidth
+                                        : mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+                    pf.bottom = df.bottom = cf.bottom = hasNavBar
+                                          ? mRestrictedScreenTop+mRestrictedScreenHeight
+                                          : mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                    if (DEBUG_LAYOUT) {
+                        Log.v(TAG, String.format(
+                                    "Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)",
+                                    pf.left, pf.top, pf.right, pf.bottom));
+                    }
+                } else if (attrs.type == TYPE_NAVIGATION_BAR
+                        || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
+                    // The navigation bar has Real Ultimate Power.
+                    pf.left = df.left = mUnrestrictedScreenLeft;
+                    pf.top = df.top = mUnrestrictedScreenTop;
+                    pf.right = df.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+                    pf.bottom = df.bottom = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                    if (DEBUG_LAYOUT) {
+                        Log.v(TAG, String.format(
+                                    "Laying out navigation bar window: (%d,%d - %d,%d)",
+                                    pf.left, pf.top, pf.right, pf.bottom));
+                    }
+                } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY
+                                || attrs.type == TYPE_BOOT_PROGRESS)
+                        && ((fl & FLAG_FULLSCREEN) != 0)) {
+                    // Fullscreen secure system overlays get what they ask for.
+                    pf.left = df.left = mUnrestrictedScreenLeft;
+                    pf.top = df.top = mUnrestrictedScreenTop;
+                    pf.right = df.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+                    pf.bottom = df.bottom = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                } else if (attrs.type == TYPE_BOOT_PROGRESS
+                        || attrs.type == TYPE_UNIVERSE_BACKGROUND) {
+                    // Boot progress screen always covers entire display.
+                    pf.left = df.left = cf.left = mUnrestrictedScreenLeft;
+                    pf.top = df.top = cf.top = mUnrestrictedScreenTop;
+                    pf.right = df.right = cf.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+                    pf.bottom = df.bottom = cf.bottom
+                            = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                } else if (shouldHideNavigationBarLw(sysUiFl)
+                        && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW
+                        && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
+                    // Asking for layout as if the nav bar is hidden, lets the
+                    // application extend into the unrestricted screen area.  We
+                    // only do this for application windows to ensure no window that
+                    // can be above the nav bar can do this.
+                    // XXX This assumes that an app asking for this will also
+                    // ask for layout in only content.  We can't currently figure out
+                    // what the screen would be if only laying out to hide the nav bar.
+                    pf.left = df.left = cf.left = mUnrestrictedScreenLeft;
+                    pf.top = df.top = cf.top = mUnrestrictedScreenTop;
+                    pf.right = df.right = cf.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+                    pf.bottom = df.bottom = cf.bottom
+                            = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                } else {
+                    pf.left = df.left = cf.left = mRestrictedScreenLeft;
+                    pf.top = df.top = cf.top = mRestrictedScreenTop;
+                    pf.right = df.right = cf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
+                    pf.bottom = df.bottom = cf.bottom
+                            = mRestrictedScreenTop+mRestrictedScreenHeight;
+                }
+
+                applyStableConstraints(sysUiFl, fl, cf);
+
+                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
+                    vf.left = mCurLeft;
+                    vf.top = mCurTop;
+                    vf.right = mCurRight;
+                    vf.bottom = mCurBottom;
+                } else {
+                    vf.set(cf);
+                }
+            } else if (attached != null) {
+                if (DEBUG_LAYOUT)
+                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
+                // A child window should be placed inside of the same visible
+                // frame that its parent had.
+                setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, cf, vf);
+            } else {
+                if (DEBUG_LAYOUT)
+                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
+                // Otherwise, a normal window must be placed inside the content
+                // of all screen decorations.
+                if (attrs.type == TYPE_STATUS_BAR_PANEL) {
+                    // Status bar panels are the only windows who can go on top of
+                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
+                    // permission, so they have the same privileges as the status
+                    // bar itself.
+                    pf.left = df.left = cf.left = mRestrictedScreenLeft;
+                    pf.top = df.top = cf.top = mRestrictedScreenTop;
+                    pf.right = df.right = cf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
+                    pf.bottom = df.bottom = cf.bottom
+                            = mRestrictedScreenTop+mRestrictedScreenHeight;
+                } else {
+                    pf.left = mContentLeft;
+                    pf.top = mContentTop;
+                    pf.right = mContentRight;
+                    pf.bottom = mContentBottom;
+                    if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
+                        df.left = cf.left = mDockLeft;
+                        df.top = cf.top = mDockTop;
+                        df.right = cf.right = mDockRight;
+                        df.bottom = cf.bottom = mDockBottom;
+                    } else {
+                        df.left = cf.left = mRestrictedScreenLeft;
+                        df.top = cf.top = mRestrictedScreenTop;
+                        df.right = cf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
+                        df.bottom = cf.bottom = mRestrictedScreenTop+mRestrictedScreenHeight;
+                    }
+                    if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
+                        vf.left = mRestrictedScreenLeft;
+                        vf.top =  mRestrictedScreenTop;
+                        vf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
+                        vf.bottom = mRestrictedScreenTop+mRestrictedScreenHeight;;
+                    } else {
+                        vf.set(cf);
+                    }
+                }
+            }
+        }
+
+        if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
+            df.left = df.top = cf.left = cf.top = vf.left = vf.top = -10000;
+            df.right = df.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
+        }
+
+        if (DEBUG_LAYOUT) Log.v(TAG, "Compute frame " + attrs.getTitle()
+                + ": sim=#" + Integer.toHexString(sim)
+                + " attach=" + attached + " type=" + attrs.type 
+                + String.format(" flags=0x%08x", fl)
+                + " pf=" + pf.toShortString() + " df=" + df.toShortString()
+                + " cf=" + cf.toShortString() + " vf=" + vf.toShortString());
+
+        win.computeFrameLw(pf, df, cf, vf);
+
+        // Dock windows carve out the bottom of the screen, so normal windows
+        // can't appear underneath them.
+        if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw()
+                && !win.getGivenInsetsPendingLw()) {
+            setLastInputMethodWindowLw(null, null);
+            offsetInputMethodWindowLw(win);
+        }
+    }
+
+    private boolean expandedDesktopHidesStatusBar() {
+        return mExpandedDesktopStyle == 2;
+    }
+
+    private boolean expandedDesktopHidesNavigationBar() {
+        return mExpandedDesktopStyle != 0;
+    }
+
+    private boolean shouldHideNavigationBarLw(int systemUiVisibility) {
+        if (expandedDesktopHidesNavigationBar()) {
+            if ((systemUiVisibility & View.SYSTEM_UI_FLAG_SHOW_NAVIGATION_IN_EXPANDED_DESKTOP) == 0) {
+                return true;
+            }
+        }
+
+        if (mCanHideNavigationBar) {
+            if ((systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private void offsetInputMethodWindowLw(WindowState win) {
+        int top = win.getContentFrameLw().top;
+        top += win.getGivenContentInsetsLw().top;
+        if (mContentBottom > top) {
+            mContentBottom = top;
+        }
+        top = win.getVisibleFrameLw().top;
+        top += win.getGivenVisibleInsetsLw().top;
+        if (mCurBottom > top) {
+            mCurBottom = top;
+        }
+        if (DEBUG_LAYOUT) Log.v(TAG, "Input method: mDockBottom="
+                + mDockBottom + " mContentBottom="
+                + mContentBottom + " mCurBottom=" + mCurBottom);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void finishLayoutLw() {
+        return;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void beginPostLayoutPolicyLw(int displayWidth, int displayHeight) {
+        mTopFullscreenOpaqueWindowState = null;
+        mForceStatusBar = false;
+        mForceStatusBarFromKeyguard = false;
+        mForcingShowNavBar = false;
+        mForcingShowNavBarLayer = -1;
+        
+        mHideLockScreen = false;
+        mAllowLockscreenWhenOn = false;
+        mDismissKeyguard = DISMISS_KEYGUARD_NONE;
+        mShowingLockscreen = false;
+        mShowingDream = false;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void applyPostLayoutPolicyLw(WindowState win,
+                                WindowManager.LayoutParams attrs) {
+        if (DEBUG_LAYOUT) Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw="
+                + win.isVisibleOrBehindKeyguardLw());
+        if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags
+                &WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0) {
+            if (mForcingShowNavBarLayer < 0) {
+                mForcingShowNavBar = true;
+                mForcingShowNavBarLayer = win.getSurfaceLayer();
+            }
+        }
+        if (mTopFullscreenOpaqueWindowState == null &&
+                win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
+            if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
+                if (attrs.type == TYPE_KEYGUARD) {
+                    mForceStatusBarFromKeyguard = true;
+                } else {
+                    mForceStatusBar = true;
+                }
+            }
+            if (attrs.type == TYPE_KEYGUARD) {
+                mShowingLockscreen = true;
+            }
+            boolean applyWindow = attrs.type >= FIRST_APPLICATION_WINDOW
+                    && attrs.type <= LAST_APPLICATION_WINDOW;
+            if (attrs.type == TYPE_DREAM) {
+                // If the lockscreen was showing when the dream started then wait
+                // for the dream to draw before hiding the lockscreen.
+                if (!mDreamingLockscreen
+                        || (win.isVisibleLw() && win.hasDrawnLw())) {
+                    mShowingDream = true;
+                    applyWindow = true;
+                }
+            }
+            if (applyWindow
+                    && attrs.x == 0 && attrs.y == 0
+                    && attrs.width == WindowManager.LayoutParams.MATCH_PARENT
+                    && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
+                if (DEBUG_LAYOUT) Log.v(TAG, "Fullscreen window: " + win);
+                mTopFullscreenOpaqueWindowState = win;
+                if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
+                    if (DEBUG_LAYOUT) Log.v(TAG, "Setting mHideLockScreen to true by win " + win);
+                    mHideLockScreen = true;
+                    mForceStatusBarFromKeyguard = false;
+                }
+                if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0
+                        && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
+                    if (DEBUG_LAYOUT) Log.v(TAG, "Setting mDismissKeyguard to true by win " + win);
+                    mDismissKeyguard = mWinDismissingKeyguard == win ?
+                            DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
+                    mWinDismissingKeyguard = win;
+                    mForceStatusBarFromKeyguard = false;
+                }
+                if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
+                    mAllowLockscreenWhenOn = true;
+                }
+            }
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public int finishPostLayoutPolicyLw() {
+        int changes = 0;
+        boolean topIsFullscreen = false;
+
+        final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null)
+                ? mTopFullscreenOpaqueWindowState.getAttrs()
+                : null;
+
+        // If we are not currently showing a dream then remember the current
+        // lockscreen state.  We will use this to determine whether the dream
+        // started while the lockscreen was showing and remember this state
+        // while the dream is showing.
+        if (!mShowingDream) {
+            mDreamingLockscreen = mShowingLockscreen;
+        }
+
+        if (mStatusBar != null) {
+            if (DEBUG_LAYOUT) Log.i(TAG, "force=" + mForceStatusBar
+                    + " forcefkg=" + mForceStatusBarFromKeyguard
+                    + " top=" + mTopFullscreenOpaqueWindowState);
+            if (expandedDesktopHidesStatusBar()) {
+                if (DEBUG_LAYOUT) Log.v(TAG, "Hiding status bar: expanded desktop enabled");
+                if (mStatusBar.hideLw(true)) changes |= FINISH_LAYOUT_REDO_LAYOUT;
+            } else if (mForceStatusBar || mForceStatusBarFromKeyguard) {
+                if (DEBUG_LAYOUT) Log.v(TAG, "Showing status bar: forced");
+                if (mStatusBar.showLw(true)) changes |= FINISH_LAYOUT_REDO_LAYOUT;
+            } else if (mTopFullscreenOpaqueWindowState != null) {
+                if (localLOGV) {
+                    Log.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw()
+                            + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
+                    Log.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs()
+                            + " lp.flags=0x" + Integer.toHexString(lp.flags));
+                }
+                topIsFullscreen = (lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0
+                        || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
+                // The subtle difference between the window for mTopFullscreenOpaqueWindowState
+                // and mTopIsFullscreen is that that mTopIsFullscreen is set only if the window
+                // has the FLAG_FULLSCREEN set.  Not sure if there is another way that to be the
+                // case though.
+                mHideStatusBar = Settings.System.getInt(mContext.getContentResolver(),
+                        Settings.System.HIDE_STATUSBAR, 0) == 1;
+                if (topIsFullscreen || mHideStatusBar) {
+                    if (DEBUG_LAYOUT) Log.v(TAG, "** HIDING status bar");
+                    if (mStatusBar.hideLw(true)) {
+                        changes |= FINISH_LAYOUT_REDO_LAYOUT;
+
+                        mHandler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                            try {
+                                IStatusBarService statusbar = getStatusBarService();
+                                if (statusbar != null) {
+                                    statusbar.collapsePanels();
+                                }
+                            } catch (RemoteException ex) {
+                                // re-acquire status bar service next time it is needed.
+                                mStatusBarService = null;
+                            }
+                        }});
+                    } else if (DEBUG_LAYOUT) {
+                        Log.v(TAG, "Preventing status bar from hiding by policy");
+                    }
+                } else {
+                    if (DEBUG_LAYOUT) Log.v(TAG, "** SHOWING status bar: top is not fullscreen");
+                    if (mStatusBar.showLw(true)) changes |= FINISH_LAYOUT_REDO_LAYOUT;
+                }
+            }
+        }
+
+        mTopIsFullscreen = topIsFullscreen;
+
+        // Hide the key guard if a visible window explicitly specifies that it wants to be
+        // displayed when the screen is locked.
+        if (mKeyguard != null) {
+            if (localLOGV) Log.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard="
+                    + mHideLockScreen);
+            if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardMediator.isSecure()) {
+                if (mKeyguard.hideLw(true)) {
+                    changes |= FINISH_LAYOUT_REDO_LAYOUT
+                            | FINISH_LAYOUT_REDO_CONFIG
+                            | FINISH_LAYOUT_REDO_WALLPAPER;
+                }
+                if (mKeyguardMediator.isShowing()) {
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            mKeyguardMediator.keyguardDone(false, false);
+                        }
+                    });
+                }
+            } else if (mHideLockScreen) {
+                if (mKeyguard.hideLw(true)) {
+                    changes |= FINISH_LAYOUT_REDO_LAYOUT
+                            | FINISH_LAYOUT_REDO_CONFIG
+                            | FINISH_LAYOUT_REDO_WALLPAPER;
+                }
+                mKeyguardMediator.setHidden(true);
+            } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
+                // This is the case of keyguard isSecure() and not mHideLockScreen.
+                if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
+                    // Only launch the next keyguard unlock window once per window.
+                    if (mKeyguard.showLw(true)) {
+                        changes |= FINISH_LAYOUT_REDO_LAYOUT
+                                | FINISH_LAYOUT_REDO_CONFIG
+                                | FINISH_LAYOUT_REDO_WALLPAPER;
+                    }
+                    mKeyguardMediator.setHidden(false);
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            mKeyguardMediator.dismiss();
+                        }
+                    });
+                }
+            } else {
+                mWinDismissingKeyguard = null;
+                if (mKeyguard.showLw(true)) {
+                    changes |= FINISH_LAYOUT_REDO_LAYOUT
+                            | FINISH_LAYOUT_REDO_CONFIG
+                            | FINISH_LAYOUT_REDO_WALLPAPER;
+                }
+                mKeyguardMediator.setHidden(false);
+            }
+        }
+
+        if ((updateSystemUiVisibilityLw()&SYSTEM_UI_CHANGING_LAYOUT) != 0) {
+            // If the navigation bar has been hidden or shown, we need to do another
+            // layout pass to update that window.
+            changes |= FINISH_LAYOUT_REDO_LAYOUT;
+        }
+
+        // update since mAllowLockscreenWhenOn might have changed
+        updateLockScreenTimeout();
+        return changes;
+    }
+
+    public boolean allowAppAnimationsLw() {
+        if (mKeyguard != null && mKeyguard.isVisibleLw() && !mKeyguard.isAnimatingLw()) {
+            // If keyguard is currently visible, no reason to animate
+            // behind it.
+            return false;
+        }
+        return true;
+    }
+
+    public int focusChangedLw(WindowState lastFocus, WindowState newFocus) {
+        mFocusedWindow = newFocus;
+        if ((updateSystemUiVisibilityLw()&SYSTEM_UI_CHANGING_LAYOUT) != 0) {
+            // If the navigation bar has been hidden or shown, we need to do another
+            // layout pass to update that window.
+            return FINISH_LAYOUT_REDO_LAYOUT;
+        }
+        return 0;
+    }
+
+    /** {@inheritDoc} */
+    public void notifyLidSwitchChanged(long whenNanos, boolean lidOpen) {
+        // do nothing if headless
+        if (mHeadless) return;
+
+        // lid changed state
+        final int newLidState = lidOpen ? LID_OPEN : LID_CLOSED;
+        if (newLidState == mLidState) {
+            return;
+        }
+
+        mLidState = newLidState;
+        applyLidSwitchState();
+        updateRotation(true);
+
+        if (lidOpen) {
+            if (keyguardIsShowingTq()) {
+                mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(KeyEvent.KEYCODE_POWER);
+            } else {
+                mPowerManager.wakeUp(SystemClock.uptimeMillis());
+            }
+        } else if (!mLidControlsSleep) {
+            mPowerManager.userActivity(SystemClock.uptimeMillis(), false);
+        }
+    }
+
+    void setHdmiPlugged(boolean plugged) {
+        if (mHdmiPlugged != plugged) {
+            mHdmiPlugged = plugged;
+            updateRotation(true, true);
+            Intent intent = new Intent(ACTION_HDMI_PLUGGED);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            intent.putExtra(EXTRA_HDMI_PLUGGED_STATE, plugged);
+            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+        }
+    }
+
+    void initializeHdmiState() {
+        boolean plugged = false;
+        // watch for HDMI plug messages if the hdmi switch exists
+        if (new File("/sys/devices/virtual/switch/hdmi/state").exists()) {
+            mHDMIObserver.startObserving("DEVPATH=/devices/virtual/switch/hdmi");
+
+            final String filename = "/sys/class/switch/hdmi/state";
+            FileReader reader = null;
+            try {
+                reader = new FileReader(filename);
+                char[] buf = new char[15];
+                int n = reader.read(buf);
+                if (n > 1) {
+                    plugged = 0 != Integer.parseInt(new String(buf, 0, n-1));
+                }
+            } catch (IOException ex) {
+                Slog.w(TAG, "Couldn't read hdmi state from " + filename + ": " + ex);
+            } catch (NumberFormatException ex) {
+                Slog.w(TAG, "Couldn't read hdmi state from " + filename + ": " + ex);
+            } finally {
+                if (reader != null) {
+                    try {
+                        reader.close();
+                    } catch (IOException ex) {
+                    }
+                }
+            }
+        }
+        // This dance forces the code in setHdmiPlugged to run.
+        // Always do this so the sticky intent is stuck (to false) if there is no hdmi.
+        mHdmiPlugged = !plugged;
+        setHdmiPlugged(!mHdmiPlugged);
+    }
+
+    /**
+     * @return Whether music is being played right now.
+     */
+    boolean isMusicActive() {
+        final AudioManager am = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
+        if (am == null) {
+            Log.w(TAG, "isMusicActive: couldn't get AudioManager reference");
+            return false;
+        }
+        return am.isMusicActive();
+    }
+
+    /**
+    * @return Whether FM is being played right now.
+    */
+    boolean isFMActive() {
+        final AudioManager am = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
+        if (am == null) {
+            Log.w(TAG, "isFMActive: couldn't get AudioManager reference");
+            return false;
+        }
+        return am.isFMActive();
+    }
+
+    /**	
+     * Tell the audio service to adjust the volume appropriate to the event.
+     * @param keycode
+     */
+    void handleVolumeKey(int stream, int keycode) {
+        IAudioService audioService = getAudioService();
+        if (audioService == null) {
+            return;
+        }
+        try {
+            // since audio is playing, we shouldn't have to hold a wake lock
+            // during the call, but we do it as a precaution for the rare possibility
+            // that the music stops right before we call this
+            // TODO: Actually handle MUTE.
+            mBroadcastWakeLock.acquire();
+            audioService.adjustStreamVolume(stream,
+                keycode == KeyEvent.KEYCODE_VOLUME_UP
+                            ? AudioManager.ADJUST_RAISE
+                            : AudioManager.ADJUST_LOWER,
+                    0);
+        } catch (RemoteException e) {
+            Log.w(TAG, "IAudioService.adjustStreamVolume() threw RemoteException " + e);
+        } finally {
+            mBroadcastWakeLock.release();
+        }
+    }
+
+    final Object mScreenshotLock = new Object();
+    ServiceConnection mScreenshotConnection = null;
+
+    final Runnable mScreenshotTimeout = new Runnable() {
+        @Override public void run() {
+            synchronized (mScreenshotLock) {
+                if (mScreenshotConnection != null) {
+                    mContext.unbindService(mScreenshotConnection);
+                    mScreenshotConnection = null;
+                }
+            }
+        }
+    };
+
+    // Assume this is called from the Handler thread.
+    private void takeScreenshot() {
+        synchronized (mScreenshotLock) {
+            if (mScreenshotConnection != null) {
+                return;
+            }
+            ComponentName cn = new ComponentName("com.android.systemui",
+                    "com.android.systemui.screenshot.TakeScreenshotService");
+            Intent intent = new Intent();
+            intent.setComponent(cn);
+            ServiceConnection conn = new ServiceConnection() {
+                @Override
+                public void onServiceConnected(ComponentName name, IBinder service) {
+                    synchronized (mScreenshotLock) {
+                        if (mScreenshotConnection != this) {
+                            return;
+                        }
+                        Messenger messenger = new Messenger(service);
+                        Message msg = Message.obtain(null, 1);
+                        final ServiceConnection myConn = this;
+                        Handler h = new Handler(mHandler.getLooper()) {
+                            @Override
+                            public void handleMessage(Message msg) {
+                                synchronized (mScreenshotLock) {
+                                    if (mScreenshotConnection == myConn) {
+                                        mContext.unbindService(mScreenshotConnection);
+                                        mScreenshotConnection = null;
+                                        mHandler.removeCallbacks(mScreenshotTimeout);
+                                    }
+                                }
+                            }
+                        };
+                        msg.replyTo = new Messenger(h);
+                        msg.arg1 = msg.arg2 = 0;
+                        if (mStatusBar != null && mStatusBar.isVisibleLw())
+                            msg.arg1 = 1;
+                        if (mNavigationBar != null && mNavigationBar.isVisibleLw())
+                            msg.arg2 = 1;
+                        try {
+                            messenger.send(msg);
+                        } catch (RemoteException e) {
+                        }
+                    }
+                }
+                @Override
+                public void onServiceDisconnected(ComponentName name) {}
+            };
+            if (mContext.bindService(
+                    intent, conn, Context.BIND_AUTO_CREATE, UserHandle.USER_CURRENT)) {
+                mScreenshotConnection = conn;
+                mHandler.postDelayed(mScreenshotTimeout, 10000);
+            }
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags, boolean isScreenOn) {
+        if (!mSystemBooted) {
+            // If we have not yet booted, don't let key events do anything.
+            return 0;
+        }
+
+        final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
+        final boolean canceled = event.isCanceled();
+        int keyCode = event.getKeyCode();
+
+        final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
+
+        // If screen is off then we treat the case where the keyguard is open but hidden
+        // the same as if it were open and in front.
+        // This will prevent any keys other than the power button from waking the screen
+        // when the keyguard is hidden by another activity.
+        final boolean keyguardActive = (mKeyguardMediator == null ? false :
+                                            (isScreenOn ?
+                                                mKeyguardMediator.isShowingAndNotHidden() :
+                                                mKeyguardMediator.isShowing()));
+
+        if (keyCode == KeyEvent.KEYCODE_POWER) {
+            policyFlags |= WindowManagerPolicy.FLAG_WAKE;
+        }
+        final boolean isWakeKey = (policyFlags
+                & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0;
+
+        if (DEBUG_INPUT) {
+            Log.d(TAG, "interceptKeyTq keycode=" + keyCode
+                    + " screenIsOn=" + isScreenOn + " keyguardActive=" + keyguardActive
+                    + " policyFlags=" + Integer.toHexString(policyFlags)
+                    + " isWakeKey=" + isWakeKey);
+        }
+
+        if (down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0
+                && event.getRepeatCount() == 0) {
+            performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
+        }
+
+        // Basic policy based on screen state and keyguard.
+        // FIXME: This policy isn't quite correct.  We shouldn't care whether the screen
+        //        is on or off, really.  We should care about whether the device is in an
+        //        interactive state or is in suspend pretending to be "off".
+        //        The primary screen might be turned off due to proximity sensor or
+        //        because we are presenting media on an auxiliary screen or remotely controlling
+        //        the device some other way (which is why we have an exemption here for injected
+        //        events).
+        int result;
+        if ((isScreenOn && !mHeadless) || (isInjected && !isWakeKey)) {
+            // When the screen is on or if the key is injected pass the key to the application.
+            result = ACTION_PASS_TO_USER;
+        } else {
+            // When the screen is off and the key is not injected, determine whether
+            // to wake the device but don't pass the key to the application.
+            result = 0;
+            if (down && isWakeKey && isWakeKeyWhenScreenOff(keyCode)) {
+                if (keyguardActive) {
+                    // If the keyguard is showing, let it wake the device when ready.
+                    mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(keyCode);
+                } else if ((keyCode != KeyEvent.KEYCODE_VOLUME_UP) && (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN)) {
+                    // Otherwise, wake the device ourselves.
+                    result |= ACTION_WAKE_UP;
+                }
+            }
+        }
+
+        // Handle special keys.
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_ENDCALL: {
+                result &= ~ACTION_PASS_TO_USER;
+                if (down) {
+                    ITelephony telephonyService = getTelephonyService();
+                    boolean hungUp = false;
+                    if (telephonyService != null) {
+                        try {
+                            hungUp = telephonyService.endCall();
+                        } catch (RemoteException ex) {
+                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                        }
+                    }
+                    interceptPowerKeyDown(!isScreenOn || hungUp);
+                } else {
+                    if (interceptPowerKeyUp(canceled)) {
+                        if ((mEndcallBehavior
+                                & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
+                            if (goHome()) {
+                                break;
+                            }
+                        }
+                        if ((mEndcallBehavior
+                                & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
+                            result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
+                        }
+                    }
+                }
+                break;
+            }
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+            case KeyEvent.KEYCODE_VOLUME_UP:
+            case KeyEvent.KEYCODE_VOLUME_MUTE: {
+                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
+                    if (down) {
+                        if (isScreenOn && !mVolumeDownKeyTriggered
+                                && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                            mVolumeDownKeyTriggered = true;
+                            mVolumeDownKeyTime = event.getDownTime();
+                            mVolumeDownKeyConsumedByChord = false;
+                            cancelPendingPowerKeyAction();
+                            interceptScreenshotChord();
+                            interceptRingerChord();
+                        }
+                    } else {
+                        mVolumeDownKeyTriggered = false;
+                        cancelPendingScreenshotChordAction();
+                        cancelPendingRingerChordAction();
+                    }
+                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
+                    if (down) {
+                        if (isScreenOn && !mVolumeUpKeyTriggered
+                                && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                            mVolumeUpKeyTriggered = true;
+                            mVolumeUpKeyTime = event.getDownTime();
+                            mVolumeUpKeyConsumedByChord = false;
+                            cancelPendingPowerKeyAction();
+                            cancelPendingScreenshotChordAction();
+                            interceptRingerChord();
+                        }
+                    } else {
+                        mVolumeUpKeyTriggered = false;
+                        cancelPendingScreenshotChordAction();
+                        cancelPendingRingerChordAction();
+                    }
+                }
+                if (down) {
+                    ITelephony telephonyService = getTelephonyService();
+                    if (telephonyService != null) {
+                        try {
+                            if (telephonyService.isRinging()) {
+                                // If an incoming call is ringing, either VOLUME key means
+                                // "silence ringer".  We handle these keys here, rather than
+                                // in the InCallScreen, to make sure we'll respond to them
+                                // even if the InCallScreen hasn't come to the foreground yet.
+                                // Look for the DOWN event here, to agree with the "fallback"
+                                // behavior in the InCallScreen.
+                                Log.i(TAG, "interceptKeyBeforeQueueing:"
+                                      + " VOLUME key-down while ringing: Silence ringer!");
+
+                                // Silence the ringer.  (It's safe to call this
+                                // even if the ringer has already been silenced.)
+                                telephonyService.silenceRinger();
+
+                                // And *don't* pass this key thru to the current activity
+                                // (which is probably the InCallScreen.)
+                                result &= ~ACTION_PASS_TO_USER;
+                                break;
+                            }
+                            if (telephonyService.isOffhook()
+                                    && (result & ACTION_PASS_TO_USER) == 0) {
+                                // If we are in call but we decided not to pass the key to
+                                // the application, handle the volume change here.
+                                handleVolumeKey(AudioManager.STREAM_VOICE_CALL, keyCode);
+                                break;
+                            }
+                        } catch (RemoteException ex) {
+                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                        }
+                    }
+                }
+                if (isFMActive() && (result & ACTION_PASS_TO_USER) == 0) {
+                    handleVolumeKey(AudioManager.STREAM_FM, keyCode);
+                    break;
+                } else if (isMusicActive() && (result & ACTION_PASS_TO_USER) == 0) {
+                    if (mVolBtnMusicControls && down && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
+                        mIsLongPress = false;
+                        int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ?
+                                KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
+                        Message msg = mHandler.obtainMessage(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK,
+                                new KeyEvent(event.getDownTime(), event.getEventTime(), event.getAction(), newKeyCode, 0));
+                        msg.setAsynchronous(true);
+                        mHandler.sendMessageDelayed(msg, ViewConfiguration.getLongPressTimeout());
+                        break;
+                    } else {
+                        if (mVolBtnMusicControls && !down) {
+                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
+                            if (mIsLongPress) {
+                                break;
+                            }
+                        }
+                        if (!isScreenOn && !mVolumeWakeScreen) {
+                            handleVolumeKey(AudioManager.STREAM_MUSIC, keyCode);
+                        }
+                    }
+                }
+                if (isScreenOn || !mVolumeWakeScreen) {
+                    break;
+                } else if (keyguardActive) {
+                    keyCode = KeyEvent.KEYCODE_POWER;
+                    mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(keyCode);
+                } else {
+                    result |= ACTION_WAKE_UP;
+                    break;
+                }
+            }
+
+            case KeyEvent.KEYCODE_POWER: {
+                if ((mTopFullscreenOpaqueWindowState.getAttrs().flags
+                        & WindowManager.LayoutParams.PREVENT_POWER_KEY) != 0){
+                    return result;
+                }
+                result &= ~ACTION_PASS_TO_USER;
+                if (down) {
+                    if (isScreenOn && !mPowerKeyTriggered
+                            && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                        mPowerKeyTriggered = true;
+                        mPowerKeyTime = event.getDownTime();
+                        cancelPendingRingerChordAction();
+                        interceptScreenshotChord();
+                    }
+
+                    ITelephony telephonyService = getTelephonyService();
+                    boolean hungUp = false;
+                    if (telephonyService != null) {
+                        try {
+                            if (telephonyService.isRinging()) {
+                                // Pressing Power while there's a ringing incoming
+                                // call should silence the ringer.
+                                telephonyService.silenceRinger();
+                            } else if ((mIncallPowerBehavior
+                                    & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0
+                                    && telephonyService.isOffhook()) {
+                                // Otherwise, if "Power button ends call" is enabled,
+                                // the Power button will hang up any current active call.
+                                hungUp = telephonyService.endCall();
+                            }
+                        } catch (RemoteException ex) {
+                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                        }
+                    }
+                    interceptPowerKeyDown(!isScreenOn || hungUp
+                            || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
+                } else {
+                    mPowerKeyTriggered = false;
+                    cancelPendingScreenshotChordAction();
+                    if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
+                        result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
+                    }
+                    mPendingPowerKeyUpCanceled = false;
+                }
+                break;
+            }
+
+            case KeyEvent.KEYCODE_MEDIA_PLAY:
+            case KeyEvent.KEYCODE_MEDIA_PAUSE:
+            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+                if (down) {
+                    ITelephony telephonyService = getTelephonyService();
+                    if (telephonyService != null) {
+                        try {
+                            if (!telephonyService.isIdle()) {
+                                // Suppress PLAY/PAUSE toggle when phone is ringing or in-call
+                                // to avoid music playback.
+                                break;
+                            }
+                        } catch (RemoteException ex) {
+                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                        }
+                    }
+                }
+            case KeyEvent.KEYCODE_HEADSETHOOK:
+            case KeyEvent.KEYCODE_MUTE:
+            case KeyEvent.KEYCODE_MEDIA_STOP:
+            case KeyEvent.KEYCODE_MEDIA_NEXT:
+            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+            case KeyEvent.KEYCODE_MEDIA_REWIND:
+            case KeyEvent.KEYCODE_MEDIA_RECORD:
+            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD: {
+                if ((result & ACTION_PASS_TO_USER) == 0) {
+                    // Only do this if we would otherwise not pass it to the user. In that
+                    // case, the PhoneWindow class will do the same thing, except it will
+                    // only do it if the showing app doesn't process the key on its own.
+                    // Note that we need to make a copy of the key event here because the
+                    // original key event will be recycled when we return.
+                    mBroadcastWakeLock.acquire();
+                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK,
+                            new KeyEvent(event));
+                    msg.setAsynchronous(true);
+                    msg.sendToTarget();
+                }
+                break;
+            }
+
+            case KeyEvent.KEYCODE_CALL: {
+                if (down) {
+                    ITelephony telephonyService = getTelephonyService();
+                    if (telephonyService != null) {
+                        try {
+                            if (telephonyService.isRinging()) {
+                                Log.i(TAG, "interceptKeyBeforeQueueing:"
+                                      + " CALL key-down while ringing: Answer the call!");
+                                telephonyService.answerRingingCall();
+
+                                // And *don't* pass this key thru to the current activity
+                                // (which is presumably the InCallScreen.)
+                                result &= ~ACTION_PASS_TO_USER;
+                            }
+                        } catch (RemoteException ex) {
+                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                        }
+                    }
+                }
+                break;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * When the screen is off we ignore some keys that might otherwise typically
+     * be considered wake keys.  We filter them out here.
+     *
+     * {@link KeyEvent#KEYCODE_POWER} is notably absent from this list because it
+     * is always considered a wake key.
+     */
+    private boolean isWakeKeyWhenScreenOff(int keyCode) {
+        switch (keyCode) {
+            // ignore volume keys unless docked
+            case KeyEvent.KEYCODE_VOLUME_UP:
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+            case KeyEvent.KEYCODE_VOLUME_MUTE:
+                return mDockMode != Intent.EXTRA_DOCK_STATE_UNDOCKED;
+
+            // ignore media and camera keys
+            case KeyEvent.KEYCODE_MUTE:
+            case KeyEvent.KEYCODE_HEADSETHOOK:
+            case KeyEvent.KEYCODE_MEDIA_PLAY:
+            case KeyEvent.KEYCODE_MEDIA_PAUSE:
+            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+            case KeyEvent.KEYCODE_MEDIA_STOP:
+            case KeyEvent.KEYCODE_MEDIA_NEXT:
+            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+            case KeyEvent.KEYCODE_MEDIA_REWIND:
+            case KeyEvent.KEYCODE_MEDIA_RECORD:
+            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
+            case KeyEvent.KEYCODE_CAMERA:
+                return false;
+        }
+        return true;
+    }
+
+
+    /** {@inheritDoc} */
+    @Override
+    public int interceptMotionBeforeQueueingWhenScreenOff(int policyFlags) {
+        int result = 0;
+
+        final boolean isWakeMotion = (policyFlags
+                & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0;
+        if (isWakeMotion) {
+            if (mKeyguardMediator != null && mKeyguardMediator.isShowing()) {
+                // If the keyguard is showing, let it decide what to do with the wake motion.
+                mKeyguardMediator.onWakeMotionWhenKeyguardShowingTq();
+            } else {
+                // Otherwise, wake the device ourselves.
+                result |= ACTION_WAKE_UP;
+            }
+        }
+        return result;
+    }
+
+    void dispatchMediaKeyWithWakeLock(KeyEvent event) {
+        if (DEBUG_INPUT) {
+            Slog.d(TAG, "dispatchMediaKeyWithWakeLock: " + event);
+        }
+
+        if (mHavePendingMediaKeyRepeatWithWakeLock) {
+            if (DEBUG_INPUT) {
+                Slog.d(TAG, "dispatchMediaKeyWithWakeLock: canceled repeat");
+            }
+
+            mHandler.removeMessages(MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK);
+            mHavePendingMediaKeyRepeatWithWakeLock = false;
+            mBroadcastWakeLock.release(); // pending repeat was holding onto the wake lock
+        }
+
+        dispatchMediaKeyWithWakeLockToAudioService(event);
+
+        if (event.getAction() == KeyEvent.ACTION_DOWN
+                && event.getRepeatCount() == 0) {
+            mHavePendingMediaKeyRepeatWithWakeLock = true;
+
+            Message msg = mHandler.obtainMessage(
+                    MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK, event);
+            msg.setAsynchronous(true);
+            mHandler.sendMessageDelayed(msg, ViewConfiguration.getKeyRepeatTimeout());
+        } else {
+            mBroadcastWakeLock.release();
+        }
+    }
+
+    void dispatchMediaKeyRepeatWithWakeLock(KeyEvent event) {
+        mHavePendingMediaKeyRepeatWithWakeLock = false;
+
+        KeyEvent repeatEvent = KeyEvent.changeTimeRepeat(event,
+                SystemClock.uptimeMillis(), 1, event.getFlags() | KeyEvent.FLAG_LONG_PRESS);
+        if (DEBUG_INPUT) {
+            Slog.d(TAG, "dispatchMediaKeyRepeatWithWakeLock: " + repeatEvent);
+        }
+
+        dispatchMediaKeyWithWakeLockToAudioService(repeatEvent);
+        mBroadcastWakeLock.release();
+    }
+
+    void dispatchMediaKeyWithWakeLockToAudioService(KeyEvent event) {
+        if (ActivityManagerNative.isSystemReady()) {
+            IAudioService audioService = getAudioService();
+            if (audioService != null) {
+                try {
+                    audioService.dispatchMediaKeyEventUnderWakelock(event);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "dispatchMediaKeyEvent threw exception " + e);
+                }
+            }
+        }
+    }
+
+    BroadcastReceiver mDockReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            if (Intent.ACTION_DOCK_EVENT.equals(intent.getAction())) {
+                mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
+                        Intent.EXTRA_DOCK_STATE_UNDOCKED);
+            } else {
+                try {
+                    IUiModeManager uiModeService = IUiModeManager.Stub.asInterface(
+                            ServiceManager.getService(Context.UI_MODE_SERVICE));
+                    mUiMode = uiModeService.getCurrentModeType();
+                } catch (RemoteException e) {
+                }
+            }
+            updateRotation(true);
+            updateOrientationListenerLp();
+        }
+    };
+
+    BroadcastReceiver mDreamReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Intent.ACTION_DREAMING_STARTED.equals(intent.getAction())) {
+                if (mKeyguardMediator != null) {
+                    mKeyguardMediator.onDreamingStarted();
+                }
+            } else if (Intent.ACTION_DREAMING_STOPPED.equals(intent.getAction())) {
+                if (mKeyguardMediator != null) {
+                    mKeyguardMediator.onDreamingStopped();
+                }
+            }
+        }
+    };
+
+    BroadcastReceiver mMultiuserReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Intent.ACTION_USER_SWITCHED.equals(intent.getAction())) {
+                // tickle the settings observer: this first ensures that we're
+                // observing the relevant settings for the newly-active user,
+                // and then updates our own bookkeeping based on the now-
+                // current user.
+
+                // force a re-application of focused window sysui visibility.
+                // the window may never have been shown for this user
+                // e.g. the keyguard when going through the new-user setup flow
+                synchronized(mLock) {
+                    mLastSystemUiFlags = 0;
+                    updateSystemUiVisibilityLw();
+                }
+            }
+        }
+    };
+    BroadcastReceiver mWifiDisplayReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+            if (action.equals(Intent.ACTION_WIFI_DISPLAY_VIDEO)) {
+                int state = intent.getIntExtra("state", 0);
+                if(state == 1) {
+                    mWifiDisplayConnected = true;
+                } else {
+                    mWifiDisplayConnected = false;
+                }
+                updateRotation(true);
+            }
+        }
+    };
+
+    BroadcastReceiver mThemeChangeReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            mUiContext = null;
+        }
+    };
+
+    @Override
+    public void screenTurnedOff(int why) {
+        EventLog.writeEvent(70000, 0);
+        synchronized (mLock) {
+            mScreenOnEarly = false;
+            mScreenOnFully = false;
+        }
+        if (mKeyguardMediator != null) {
+            mKeyguardMediator.onScreenTurnedOff(why);
+        }
+        synchronized (mLock) {
+            updateOrientationListenerLp();
+            updateLockScreenTimeout();
+        }
+    }
+
+    @Override
+    public void screenTurningOn(final ScreenOnListener screenOnListener) {
+        EventLog.writeEvent(70000, 1);
+        if (false) {
+            RuntimeException here = new RuntimeException("here");
+            here.fillInStackTrace();
+            Slog.i(TAG, "Screen turning on...", here);
+        }
+
+        synchronized (mLock) {
+            mScreenOnEarly = true;
+            updateOrientationListenerLp();
+            updateLockScreenTimeout();
+        }
+
+        waitForKeyguard(screenOnListener);
+    }
+
+    private void waitForKeyguard(final ScreenOnListener screenOnListener) {
+        if (mKeyguardMediator != null) {
+            if (screenOnListener != null) {
+                mKeyguardMediator.onScreenTurnedOn(new KeyguardViewManager.ShowListener() {
+                    @Override
+                    public void onShown(IBinder windowToken) {
+                        waitForKeyguardWindowDrawn(windowToken, screenOnListener);
+                    }
+                });
+                return;
+            } else {
+                mKeyguardMediator.onScreenTurnedOn(null);
+            }
+        } else {
+            Slog.i(TAG, "No keyguard mediator!");
+        }
+        finishScreenTurningOn(screenOnListener);
+    }
+
+    private void waitForKeyguardWindowDrawn(IBinder windowToken,
+            final ScreenOnListener screenOnListener) {
+        if (windowToken != null) {
+            try {
+                if (mWindowManager.waitForWindowDrawn(
+                        windowToken, new IRemoteCallback.Stub() {
+                    @Override
+                    public void sendResult(Bundle data) {
+                        Slog.i(TAG, "Lock screen displayed!");
+                        finishScreenTurningOn(screenOnListener);
+                    }
+                })) {
+                    return;
+                }
+            } catch (RemoteException ex) {
+                // Can't happen in system process.
+            }
+        }
+
+        Slog.i(TAG, "No lock screen!");
+        finishScreenTurningOn(screenOnListener);
+    }
+
+    private void finishScreenTurningOn(ScreenOnListener screenOnListener) {
+        synchronized (mLock) {
+            mScreenOnFully = true;
+        }
+
+        try {
+            mWindowManager.setEventDispatching(true);
+        } catch (RemoteException unhandled) {
+        }
+
+        if (screenOnListener != null) {
+            screenOnListener.onScreenOn();
+        }
+    }
+
+    @Override
+    public boolean isScreenOnEarly() {
+        return mScreenOnEarly;
+    }
+
+    @Override
+    public boolean isScreenOnFully() {
+        return mScreenOnFully;
+    }
+
+    /** {@inheritDoc} */
+    public void enableKeyguard(boolean enabled) {
+        if (mKeyguardMediator != null) {
+            mKeyguardMediator.setKeyguardEnabled(enabled);
+        }
+    }
+
+    /** {@inheritDoc} */
+    public void exitKeyguardSecurely(OnKeyguardExitResult callback) {
+        if (mKeyguardMediator != null) {
+            mKeyguardMediator.verifyUnlock(callback);
+        }
+    }
+
+    private boolean keyguardIsShowingTq() {
+        if (mKeyguardMediator == null) return false;
+        return mKeyguardMediator.isShowingAndNotHidden();
+    }
+
+
+    /** {@inheritDoc} */
+    public boolean isKeyguardLocked() {
+        return keyguardOn();
+    }
+
+    /** {@inheritDoc} */
+    public boolean isKeyguardSecure() {
+        if (mKeyguardMediator == null) return false;
+        return mKeyguardMediator.isSecure();
+    }
+
+    /** {@inheritDoc} */
+    public boolean inKeyguardRestrictedKeyInputMode() {
+        if (mKeyguardMediator == null) return false;
+        return mKeyguardMediator.isInputRestricted();
+    }
+
+    public void dismissKeyguardLw() {
+        if (mKeyguardMediator.isShowing()) {
+            mHandler.post(new Runnable() {
+                public void run() {
+                    if (mKeyguardMediator.isDismissable()) {
+                        // Can we just finish the keyguard straight away?
+                        mKeyguardMediator.keyguardDone(false, true);
+                    } else {
+                        // ask the keyguard to prompt the user to authenticate if necessary
+                        mKeyguardMediator.dismiss();
+                    }
+                }
+            });
+        }
+    }
+
+    void sendCloseSystemWindows() {
+        sendCloseSystemWindows(mContext, null);
+    }
+
+    void sendCloseSystemWindows(String reason) {
+        sendCloseSystemWindows(mContext, reason);
+    }
+
+    static void sendCloseSystemWindows(Context context, String reason) {
+        if (ActivityManagerNative.isSystemReady()) {
+            try {
+                ActivityManagerNative.getDefault().closeSystemDialogs(reason);
+            } catch (RemoteException e) {
+            }
+        }
+    }
+
+    @Override
+    public int rotationForOrientationLw(int orientation, int lastRotation) {
+        if (false) {
+            Slog.v(TAG, "rotationForOrientationLw(orient="
+                        + orientation + ", last=" + lastRotation
+                        + "); user=" + mUserRotation + " "
+                        + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED)
+                            ? "USER_ROTATION_LOCKED" : "")
+                        );
+        }
+
+        synchronized (mLock) {
+            int sensorRotation = mOrientationListener.getProposedRotation(); // may be -1
+            if (sensorRotation < 0) {
+                sensorRotation = lastRotation;
+            }
+
+            final int preferredRotation;
+            if ((mLidState == LID_OPEN && mLidOpenRotation >= 0)
+                    && !(mHasRemovableLid
+                            && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED)) {
+                // Ignore sensor when lid switch is open and rotation is forced
+                // and a removable lid was not undocked.
+                preferredRotation = mLidOpenRotation;
+            } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR
+                    && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
+                // Ignore sensor when in car dock unless explicitly enabled.
+                // This case can override the behavior of NOSENSOR, and can also
+                // enable 180 degree rotation while docked.
+                preferredRotation = mCarDockEnablesAccelerometer
+                        ? sensorRotation : mCarDockRotation;
+            } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK
+                    || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK
+                    || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK)
+                    && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
+                // Ignore sensor when in desk dock unless explicitly enabled.
+                // This case can override the behavior of NOSENSOR, and can also
+                // enable 180 degree rotation while docked.
+                preferredRotation = mDeskDockEnablesAccelerometer
+                        ? sensorRotation : mDeskDockRotation;
+            } else if ((mHdmiPlugged || mWifiDisplayConnected) &&
+                                                        mHdmiRotationLock) {
+                // Ignore sensor when plugged into HDMI.
+                // or Wifi display is connected
+                // Note that the dock orientation overrides the HDMI/Wifi
+                // orientation.
+                preferredRotation = mHdmiRotation;
+            } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE
+                            && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER
+                                    || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED))
+                    || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR
+                    || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR
+                    || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE
+                    || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
+                // Otherwise, use sensor only if requested by the application or enabled
+                // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
+                if (mAllowAllRotations < 0) {
+                    // Can't read this during init() because the context doesn't
+                    // have display metrics at that time so we cannot determine
+                    // tablet vs. phone then.
+                    mAllowAllRotations = mContext.getResources().getBoolean(
+                            com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
+                }
+                // Rotation setting bitmask
+                // 1=0 2=90 4=180 8=270
+                boolean allowed = true;
+                if (mUserRotationAngles < 0) {
+                    // Not set by user so use these defaults
+                    mUserRotationAngles = mAllowAllRotations == 1 ?
+                            (1 | 2 | 4 | 8) : // All angles
+                                (1 | 2 | 8); // All except 180
+                }
+                switch (sensorRotation) {
+                    case Surface.ROTATION_0:
+                        allowed = (mUserRotationAngles & 1) != 0;
+                        break;
+                    case Surface.ROTATION_90:
+                        allowed = (mUserRotationAngles & 2) != 0;
+                        break;
+                    case Surface.ROTATION_180:
+                        allowed = (mUserRotationAngles & 4) != 0;
+                        break;
+                    case Surface.ROTATION_270:
+                        allowed = (mUserRotationAngles & 8) != 0;
+                        break;
+                }
+                if (allowed) {
+                    preferredRotation = sensorRotation;
+                } else {
+                    preferredRotation = lastRotation;
+                }
+            } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED
+                    && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
+                // Apply rotation lock.  Does not apply to NOSENSOR.
+                // The idea is that the user rotation expresses a weak preference for the direction
+                // of gravity and as NOSENSOR is never affected by gravity, then neither should
+                // NOSENSOR be affected by rotation lock (although it will be affected by docks).
+                preferredRotation = mUserRotation;
+            } else {
+                // No overriding preference.
+                // We will do exactly what the application asked us to do.
+                preferredRotation = -1;
+            }
+
+            switch (orientation) {
+                case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
+                    // Return portrait unless overridden.
+                    if (isAnyPortrait(preferredRotation)) {
+                        return preferredRotation;
+                    }
+                    return mPortraitRotation;
+
+                case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
+                    // Return landscape unless overridden.
+                    if (isLandscapeOrSeascape(preferredRotation)) {
+                        return preferredRotation;
+                    }
+                    return mLandscapeRotation;
+
+                case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
+                    // Return reverse portrait unless overridden.
+                    if (isAnyPortrait(preferredRotation)) {
+                        return preferredRotation;
+                    }
+                    return mUpsideDownRotation;
+
+                case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
+                    // Return seascape unless overridden.
+                    if (isLandscapeOrSeascape(preferredRotation)) {
+                        return preferredRotation;
+                    }
+                    return mSeascapeRotation;
+
+                case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
+                    // Return either landscape rotation.
+                    if (isLandscapeOrSeascape(preferredRotation)) {
+                        return preferredRotation;
+                    }
+                    if (isLandscapeOrSeascape(lastRotation)) {
+                        return lastRotation;
+                    }
+                    return mLandscapeRotation;
+
+                case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
+                    // Return either portrait rotation.
+                    if (isAnyPortrait(preferredRotation)) {
+                        return preferredRotation;
+                    }
+                    if (isAnyPortrait(lastRotation)) {
+                        return lastRotation;
+                    }
+                    return mPortraitRotation;
+
+                default:
+                    // For USER, UNSPECIFIED, NOSENSOR, SENSOR and FULL_SENSOR,
+                    // just return the preferred orientation we already calculated.
+                    if (preferredRotation >= 0) {
+                        return preferredRotation;
+                    }
+                    return Surface.ROTATION_0;
+            }
+        }
+    }
+
+    @Override
+    public boolean rotationHasCompatibleMetricsLw(int orientation, int rotation) {
+        switch (orientation) {
+            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
+            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
+            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
+                return isAnyPortrait(rotation);
+
+            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
+            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
+            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
+                return isLandscapeOrSeascape(rotation);
+
+            default:
+                return true;
+        }
+    }
+
+    @Override
+    public void setRotationLw(int rotation) {
+        mOrientationListener.setCurrentRotation(rotation);
+    }
+
+    private boolean isLandscapeOrSeascape(int rotation) {
+        return rotation == mLandscapeRotation || rotation == mSeascapeRotation;
+    }
+
+    private boolean isAnyPortrait(int rotation) {
+        return rotation == mPortraitRotation || rotation == mUpsideDownRotation;
+    }
+
+
+    // User rotation: to be used when all else fails in assigning an orientation to the device
+    public void setUserRotationMode(int mode, int rot) {
+        ContentResolver res = mContext.getContentResolver();
+
+        // mUserRotationMode and mUserRotation will be assigned by the content observer
+        if (mode == WindowManagerPolicy.USER_ROTATION_LOCKED) {
+            Settings.System.putIntForUser(res,
+                    Settings.System.USER_ROTATION,
+                    rot,
+                    UserHandle.USER_CURRENT);
+            Settings.System.putIntForUser(res,
+                    Settings.System.ACCELEROMETER_ROTATION,
+                    0,
+                    UserHandle.USER_CURRENT);
+        } else {
+            Settings.System.putIntForUser(res,
+                    Settings.System.ACCELEROMETER_ROTATION,
+                    1,
+                    UserHandle.USER_CURRENT);
+        }
+    }
+
+    public void setSafeMode(boolean safeMode) {
+        mSafeMode = safeMode;
+        performHapticFeedbackLw(null, safeMode
+                ? HapticFeedbackConstants.SAFE_MODE_ENABLED
+                : HapticFeedbackConstants.SAFE_MODE_DISABLED, true);
+    }
+    
+    static long[] getLongIntArray(Resources r, int resid) {
+        int[] ar = r.getIntArray(resid);
+        if (ar == null) {
+            return null;
+        }
+        long[] out = new long[ar.length];
+        for (int i=0; i<ar.length; i++) {
+            out[i] = ar[i];
+        }
+        return out;
+    }
+    
+    /** {@inheritDoc} */
+    public void systemReady() {
+        if (mKeyguardMediator != null) {
+            // tell the keyguard
+            mKeyguardMediator.onSystemReady();
+        }
+        synchronized (mLock) {
+            updateOrientationListenerLp();
+            mSystemReady = true;
+            mHandler.post(new Runnable() {
+                public void run() {
+                    updateSettings();
+                }
+            });
+        }
+    }
+
+    /** {@inheritDoc} */
+    public void systemBooted() {
+        synchronized (mLock) {
+            mSystemBooted = true;
+        }
+    }
+
+    ProgressDialog mBootMsgDialog = null;
+
+    /**
+     * name of package currently being dex optimized
+     * as shown through this.showBootMessage(msg, always);
+     */
+    static String currentPackageName;
+    public void setPackageName(String pkgName) {
+        if (pkgName == null) {
+            pkgName = "stop.looking.at.me.swan";
+        }
+        this.currentPackageName = pkgName;
+    }
+
+    /** {@inheritDoc} */
+    public void showBootMessage(final CharSequence msg, final boolean always) {
+        if (mHeadless) return;
+        mHandler.post(new Runnable() {
+            @Override public void run() {
+                if (mBootMsgDialog == null) {
+                    mBootMsgDialog = new ProgressDialog(mContext) {
+                        // This dialog will consume all events coming in to
+                        // it, to avoid it trying to do things too early in boot.
+                        @Override public boolean dispatchKeyEvent(KeyEvent event) {
+                            return true;
+                        }
+                        @Override public boolean dispatchKeyShortcutEvent(KeyEvent event) {
+                            return true;
+                        }
+                        @Override public boolean dispatchTouchEvent(MotionEvent ev) {
+                            return true;
+                        }
+                        @Override public boolean dispatchTrackballEvent(MotionEvent ev) {
+                            return true;
+                        }
+                        @Override public boolean dispatchGenericMotionEvent(MotionEvent ev) {
+                            return true;
+                        }
+                        @Override public boolean dispatchPopulateAccessibilityEvent(
+                                AccessibilityEvent event) {
+                            return true;
+                        }
+                    };
+                    mBootMsgDialog.setTitle(R.string.android_upgrading_title);
+                    mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
+                    mBootMsgDialog.setIndeterminate(true);
+                    mBootMsgDialog.getWindow().setType(
+                            WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
+                    mBootMsgDialog.getWindow().addFlags(
+                            WindowManager.LayoutParams.FLAG_DIM_BEHIND
+                            | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
+                    mBootMsgDialog.getWindow().setDimAmount(1);
+                    WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();
+                    lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
+                    mBootMsgDialog.getWindow().setAttributes(lp);
+                    mBootMsgDialog.setCancelable(false);
+                    mBootMsgDialog.show();
+                }
+                mBootMsgDialog.setMessage(msg);
+                if (currentPackageName != null) {
+                    mBootMsgDialog.setTitle(msg);
+                    mBootMsgDialog.setMessage(currentPackageName);
+                }
+                if (msg.equals(mContext.getResources().getString(R.string.android_upgrading_starting_apps))) {
+                    mBootMsgDialog.setTitle(R.string.android_upgrading_title);
+                    mBootMsgDialog.setMessage(mContext.getResources().getString(R.string.android_upgrading_starting_apps));
+                }
+            }
+        });
+    }
+
+    /** {@inheritDoc} */
+    public void hideBootMessages() {
+        mHandler.post(new Runnable() {
+            @Override public void run() {
+                if (mBootMsgDialog != null) {
+                    mBootMsgDialog.dismiss();
+                    mBootMsgDialog = null;
+                }
+            }
+        });
+    }
+
+    /** {@inheritDoc} */
+    public void userActivity() {
+        // ***************************************
+        // NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
+        // ***************************************
+        // THIS IS CALLED FROM DEEP IN THE POWER MANAGER
+        // WITH ITS LOCKS HELD.
+        //
+        // This code must be VERY careful about the locks
+        // it acquires.
+        // In fact, the current code acquires way too many,
+        // and probably has lurking deadlocks.
+
+        synchronized (mScreenLockTimeout) {
+            if (mLockScreenTimerActive) {
+                // reset the timer
+                mHandler.removeCallbacks(mScreenLockTimeout);
+                mHandler.postDelayed(mScreenLockTimeout, mLockScreenTimeout);
+            }
+        }
+    }
+
+    class ScreenLockTimeout implements Runnable {
+        Bundle options;
+
+        @Override
+        public void run() {
+            synchronized (this) {
+                if (localLOGV) Log.v(TAG, "mScreenLockTimeout activating keyguard");
+                if (mKeyguardMediator != null) {
+                    mKeyguardMediator.doKeyguardTimeout(options);
+                }
+                mLockScreenTimerActive = false;
+                options = null;
+            }
+        }
+
+        public void setLockOptions(Bundle options) {
+            this.options = options;
+        }
+    }
+
+    ScreenLockTimeout mScreenLockTimeout = new ScreenLockTimeout();
+
+    public void lockNow(Bundle options) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER, null);
+        mHandler.removeCallbacks(mScreenLockTimeout);
+        if (options != null) {
+            // In case multiple calls are made to lockNow, we don't wipe out the options
+            // until the runnable actually executes.
+            mScreenLockTimeout.setLockOptions(options);
+        }
+        mHandler.post(mScreenLockTimeout);
+    }
+
+    private void updateLockScreenTimeout() {
+        synchronized (mScreenLockTimeout) {
+            boolean enable = (mAllowLockscreenWhenOn && mScreenOnEarly &&
+                    mKeyguardMediator != null && mKeyguardMediator.isSecure());
+            if (mLockScreenTimerActive != enable) {
+                if (enable) {
+                    if (localLOGV) Log.v(TAG, "setting lockscreen timer");
+                    mHandler.postDelayed(mScreenLockTimeout, mLockScreenTimeout);
+                } else {
+                    if (localLOGV) Log.v(TAG, "clearing lockscreen timer");
+                    mHandler.removeCallbacks(mScreenLockTimeout);
+                }
+                mLockScreenTimerActive = enable;
+            }
+        }
+    }
+
+    /** {@inheritDoc} */
+    public void enableScreenAfterBoot() {
+        readLidState();
+        applyLidSwitchState();
+        updateRotation(true);
+    }
+
+    private void applyLidSwitchState() {
+        mPowerManager.setKeyboardVisibility(isBuiltInKeyboardVisible());
+
+        if (mLidState == LID_CLOSED && mLidControlsSleep) {
+            mPowerManager.goToSleep(SystemClock.uptimeMillis());
+        }
+    }
+
+    void updateRotation(boolean alwaysSendConfiguration) {
+        try {
+            //set orientation on WindowManager
+            mWindowManager.updateRotation(alwaysSendConfiguration, false);
+        } catch (RemoteException e) {
+            // Ignore
+        }
+    }
+
+    void updateRotation(boolean alwaysSendConfiguration, boolean forceRelayout) {
+        try {
+            //set orientation on WindowManager
+            mWindowManager.updateRotation(alwaysSendConfiguration, forceRelayout);
+        } catch (RemoteException e) {
+            // Ignore
+        }
+    }
+
+    void updateDisplayMetrics() {
+        try {
+            mWindowManager.updateDisplayMetrics();
+        } catch (RemoteException e) {
+            // Ignore
+        }
+    }
+
+    /**
+     * Return an Intent to launch the currently active dock app as home.  Returns
+     * null if the standard home should be launched, which is the case if any of the following is
+     * true:
+     * <ul>
+     *  <li>The device is not in either car mode or desk mode
+     *  <li>The device is in car mode but ENABLE_CAR_DOCK_HOME_CAPTURE is false
+     *  <li>The device is in desk mode but ENABLE_DESK_DOCK_HOME_CAPTURE is false
+     *  <li>The device is in car mode but there's no CAR_DOCK app with METADATA_DOCK_HOME
+     *  <li>The device is in desk mode but there's no DESK_DOCK app with METADATA_DOCK_HOME
+     * </ul>
+     * @return
+     */
+    Intent createHomeDockIntent() {
+        Intent intent = null;
+
+        // What home does is based on the mode, not the dock state.  That
+        // is, when in car mode you should be taken to car home regardless
+        // of whether we are actually in a car dock.
+        if (mUiMode == Configuration.UI_MODE_TYPE_CAR) {
+            if (ENABLE_CAR_DOCK_HOME_CAPTURE) {
+                intent = mCarDockIntent;
+            }
+        } else if (mUiMode == Configuration.UI_MODE_TYPE_DESK) {
+            if (ENABLE_DESK_DOCK_HOME_CAPTURE) {
+                intent = mDeskDockIntent;
+            }
+        }
+
+        if (intent == null) {
+            return null;
+        }
+
+        ActivityInfo ai = intent.resolveActivityInfo(
+                mContext.getPackageManager(), PackageManager.GET_META_DATA);
+        if (ai == null) {
+            return null;
+        }
+
+        if (ai.metaData != null && ai.metaData.getBoolean(Intent.METADATA_DOCK_HOME)) {
+            intent = new Intent(intent);
+            intent.setClassName(ai.packageName, ai.name);
+            return intent;
+        }
+
+        return null;
+    }
+
+    void startDockOrHome() {
+        Intent dock = createHomeDockIntent();
+        if (dock != null) {
+            try {
+                mContext.startActivity(dock);
+                return;
+            } catch (ActivityNotFoundException e) {
+            }
+        }
+        mContext.startActivityAsUser(mHomeIntent, UserHandle.CURRENT);
+    }
+    
+    /**
+     * goes to the home screen
+     * @return whether it did anything
+     */
+    boolean goHome() {
+        if (false) {
+            // This code always brings home to the front.
+            try {
+                ActivityManagerNative.getDefault().stopAppSwitches();
+            } catch (RemoteException e) {
+            }
+            sendCloseSystemWindows();
+            startDockOrHome();
+        } else {
+            // This code brings home to the front or, if it is already
+            // at the front, puts the device to sleep.
+            try {
+                if (SystemProperties.getInt("persist.sys.uts-test-mode", 0) == 1) {
+                    /// Roll back EndcallBehavior as the cupcake design to pass P1 lab entry.
+                    Log.d(TAG, "UTS-TEST-MODE");
+                } else {
+                    ActivityManagerNative.getDefault().stopAppSwitches();
+                    sendCloseSystemWindows();
+                    Intent dock = createHomeDockIntent();
+                    if (dock != null) {
+                        int result = ActivityManagerNative.getDefault()
+                                .startActivityAsUser(null, dock,
+                                        dock.resolveTypeIfNeeded(mContext.getContentResolver()),
+                                        null, null, 0,
+                                        ActivityManager.START_FLAG_ONLY_IF_NEEDED,
+                                        null, null, null, UserHandle.USER_CURRENT);
+                        if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
+                            return false;
+                        }
+                    }
+                }
+                int result = ActivityManagerNative.getDefault()
+                        .startActivityAsUser(null, mHomeIntent,
+                                mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),
+                                null, null, 0,
+                                ActivityManager.START_FLAG_ONLY_IF_NEEDED,
+                                null, null, null, UserHandle.USER_CURRENT);
+                if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
+                    return false;
+                }
+            } catch (RemoteException ex) {
+                // bummer, the activity manager, which is in this process, is dead
+            }
+        }
+        return true;
+    }
+    
+    public void setCurrentOrientationLw(int newOrientation) {
+        synchronized (mLock) {
+            if (newOrientation != mCurrentAppOrientation) {
+                mCurrentAppOrientation = newOrientation;
+                updateOrientationListenerLp();
+            }
+        }
+    }
+
+    private void performAuditoryFeedbackForAccessibilityIfNeed() {
+        if (!isGlobalAccessibilityGestureEnabled()) {
+            return;
+        }
+        AudioManager audioManager = (AudioManager) mContext.getSystemService(
+                Context.AUDIO_SERVICE);
+        if (audioManager.isSilentMode()) {
+            return;
+        }
+        Ringtone ringTone = RingtoneManager.getRingtone(mContext,
+                Settings.System.DEFAULT_NOTIFICATION_URI);
+        ringTone.setStreamType(AudioManager.STREAM_MUSIC);
+        ringTone.play();
+    }
+    private boolean isGlobalAccessibilityGestureEnabled() {
+        return Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED, 0) == 1;
+    }
+
+    public boolean performHapticFeedbackLw(WindowState win, int effectId, boolean always) {
+        if (!mVibrator.hasVibrator()) {
+            return false;
+        }
+        final boolean hapticsDisabled = Settings.System.getIntForUser(mContext.getContentResolver(),
+                Settings.System.HAPTIC_FEEDBACK_ENABLED, 0, UserHandle.USER_CURRENT) == 0;
+        if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
+            return false;
+        }
+        long[] pattern = null;
+        switch (effectId) {
+            case HapticFeedbackConstants.LONG_PRESS:
+                pattern = mLongPressVibePattern;
+                break;
+            case HapticFeedbackConstants.VIRTUAL_KEY:
+                pattern = mVirtualKeyVibePattern;
+                break;
+            case HapticFeedbackConstants.KEYBOARD_TAP:
+                pattern = mKeyboardTapVibePattern;
+                break;
+            case HapticFeedbackConstants.SAFE_MODE_DISABLED:
+                pattern = mSafeModeDisabledVibePattern;
+                break;
+            case HapticFeedbackConstants.SAFE_MODE_ENABLED:
+                pattern = mSafeModeEnabledVibePattern;
+                break;
+            default:
+                return false;
+        }
+        if (pattern.length == 1) {
+            // One-shot vibration
+            mVibrator.vibrate(pattern[0]);
+        } else {
+            // Pattern vibration
+            mVibrator.vibrate(pattern, -1);
+        }
+        return true;
+    }
+
+    @Override
+    public void keepScreenOnStartedLw() {
+    }
+
+    @Override
+    public void keepScreenOnStoppedLw() {
+        if (mKeyguardMediator != null && !mKeyguardMediator.isShowingAndNotHidden()) {
+            long curTime = SystemClock.uptimeMillis();
+            mPowerManager.userActivity(curTime, false);
+        }
+    }
+
+    private int updateSystemUiVisibilityLw() {
+        // If there is no window focused, there will be nobody to handle the events
+        // anyway, so just hang on in whatever state we're in until things settle down.
+        if (mFocusedWindow == null) {
+            return 0;
+        }
+        if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
+            // We are updating at a point where the keyguard has gotten
+            // focus, but we were last in a state where the top window is
+            // hiding it.  This is probably because the keyguard as been
+            // shown while the top window was displayed, so we want to ignore
+            // it here because this is just a very transient change and it
+            // will quickly lose focus once it correctly gets hidden.
+            return 0;
+        }
+        int tmpVisibility = mFocusedWindow.getSystemUiVisibility()
+                & ~mResettingSystemUiFlags
+                & ~mForceClearedSystemUiFlags;
+        if (mForcingShowNavBar && mFocusedWindow.getSurfaceLayer() < mForcingShowNavBarLayer) {
+            tmpVisibility &= ~View.SYSTEM_UI_CLEARABLE_FLAGS;
+        }
+        final int visibility = tmpVisibility;
+        int diff = visibility ^ mLastSystemUiFlags;
+        final boolean needsMenu = mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
+        if (diff == 0 && mLastFocusNeedsMenu == needsMenu
+                && mFocusedApp == mFocusedWindow.getAppToken()) {
+            return 0;
+        }
+        mLastSystemUiFlags = visibility;
+        mLastFocusNeedsMenu = needsMenu;
+        mFocusedApp = mFocusedWindow.getAppToken();
+        mHandler.post(new Runnable() {
+                public void run() {
+                    try {
+                        IStatusBarService statusbar = getStatusBarService();
+                        if (statusbar != null) {
+                            statusbar.setSystemUiVisibility(visibility, 0xffffffff);
+                            statusbar.topAppWindowChanged(needsMenu);
+                        }
+                    } catch (RemoteException e) {
+                        // re-acquire status bar service next time it is needed.
+                        mStatusBarService = null;
+                    }
+                }
+            });
+        return diff;
+    }
+
+    // Use this instead of checking config_showNavigationBar so that it can be consistently
+    // overridden by qemu.hw.mainkeys in the emulator.
+    public boolean hasNavigationBar() {
+        return mHasNavigationBar;
+    }
+
+    @Override
+    public void setLastInputMethodWindowLw(WindowState ime, WindowState target) {
+        mLastInputMethodWindow = ime;
+        mLastInputMethodTargetWindow = target;
+    }
+
+    @Override
+    public boolean canMagnifyWindowLw(WindowManager.LayoutParams attrs) {
+        switch (attrs.type) {
+            case WindowManager.LayoutParams.TYPE_INPUT_METHOD:
+            case WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG:
+            case WindowManager.LayoutParams.TYPE_NAVIGATION_BAR:
+            case WindowManager.LayoutParams.TYPE_MAGNIFICATION_OVERLAY: {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public void setCurrentUserLw(int newUserId) {
+        if (mKeyguardMediator != null) {
+            mKeyguardMediator.setCurrentUser(newUserId);
+        }
+        if (mStatusBarService != null) {
+            try {
+                mStatusBarService.setCurrentUser(newUserId);
+            } catch (RemoteException e) {
+                // oh well
+            }
+        }
+        setLastInputMethodWindowLw(null, null);
+    }
+
+    @Override
+    public void showAssistant() {
+        mKeyguardMediator.showAssistant();
+    }
+
+    @Override
+    public void dump(String prefix, PrintWriter pw, String[] args) {
+        pw.print(prefix); pw.print("mSafeMode="); pw.print(mSafeMode);
+                pw.print(" mSystemReady="); pw.print(mSystemReady);
+                pw.print(" mSystemBooted="); pw.println(mSystemBooted);
+        pw.print(prefix); pw.print("mLidState="); pw.print(mLidState);
+                pw.print(" mLidOpenRotation="); pw.print(mLidOpenRotation);
+                pw.print(" mHdmiPlugged="); pw.println(mHdmiPlugged);
+        if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0
+                || mForceClearedSystemUiFlags != 0) {
+            pw.print(prefix); pw.print("mLastSystemUiFlags=0x");
+                    pw.print(Integer.toHexString(mLastSystemUiFlags));
+                    pw.print(" mResettingSystemUiFlags=0x");
+                    pw.print(Integer.toHexString(mResettingSystemUiFlags));
+                    pw.print(" mForceClearedSystemUiFlags=0x");
+                    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
+        }
+        if (mLastFocusNeedsMenu) {
+            pw.print(prefix); pw.print("mLastFocusNeedsMenu=");
+                    pw.println(mLastFocusNeedsMenu);
+        }
+        pw.print(prefix); pw.print("mUiMode="); pw.print(mUiMode);
+                pw.print(" mDockMode="); pw.print(mDockMode);
+                pw.print(" mCarDockRotation="); pw.print(mCarDockRotation);
+                pw.print(" mDeskDockRotation="); pw.println(mDeskDockRotation);
+        pw.print(prefix); pw.print("mUserRotationMode="); pw.print(mUserRotationMode);
+                pw.print(" mUserRotation="); pw.print(mUserRotation);
+                pw.print(" mAllowAllRotations="); pw.println(mAllowAllRotations);
+        pw.print(prefix); pw.print("mCurrentAppOrientation="); pw.println(mCurrentAppOrientation);
+        pw.print(prefix); pw.print("mCarDockEnablesAccelerometer=");
+                pw.print(mCarDockEnablesAccelerometer);
+                pw.print(" mDeskDockEnablesAccelerometer=");
+                pw.println(mDeskDockEnablesAccelerometer);
+        pw.print(prefix); pw.print("mLidKeyboardAccessibility=");
+                pw.print(mLidKeyboardAccessibility);
+                pw.print(" mLidNavigationAccessibility="); pw.print(mLidNavigationAccessibility);
+                pw.print(" mLidControlsSleep="); pw.println(mLidControlsSleep);
+        pw.print(prefix); pw.print("mLongPressOnPowerBehavior=");
+                pw.print(mLongPressOnPowerBehavior);
+                pw.print(" mHasSoftInput="); pw.println(mHasSoftInput);
+        pw.print(prefix); pw.print("mScreenOnEarly="); pw.print(mScreenOnEarly);
+                pw.print(" mScreenOnFully="); pw.print(mScreenOnFully);
+                pw.print(" mOrientationSensorEnabled="); pw.println(mOrientationSensorEnabled);
+        pw.print(prefix); pw.print("mUnrestrictedScreen=("); pw.print(mUnrestrictedScreenLeft);
+                pw.print(","); pw.print(mUnrestrictedScreenTop);
+                pw.print(") "); pw.print(mUnrestrictedScreenWidth);
+                pw.print("x"); pw.println(mUnrestrictedScreenHeight);
+        pw.print(prefix); pw.print("mRestrictedScreen=("); pw.print(mRestrictedScreenLeft);
+                pw.print(","); pw.print(mRestrictedScreenTop);
+                pw.print(") "); pw.print(mRestrictedScreenWidth);
+                pw.print("x"); pw.println(mRestrictedScreenHeight);
+        pw.print(prefix); pw.print("mStableFullscreen=("); pw.print(mStableFullscreenLeft);
+                pw.print(","); pw.print(mStableFullscreenTop);
+                pw.print(")-("); pw.print(mStableFullscreenRight);
+                pw.print(","); pw.print(mStableFullscreenBottom); pw.println(")");
+        pw.print(prefix); pw.print("mStable=("); pw.print(mStableLeft);
+                pw.print(","); pw.print(mStableTop);
+                pw.print(")-("); pw.print(mStableRight);
+                pw.print(","); pw.print(mStableBottom); pw.println(")");
+        pw.print(prefix); pw.print("mSystem=("); pw.print(mSystemLeft);
+                pw.print(","); pw.print(mSystemTop);
+                pw.print(")-("); pw.print(mSystemRight);
+                pw.print(","); pw.print(mSystemBottom); pw.println(")");
+        pw.print(prefix); pw.print("mCur=("); pw.print(mCurLeft);
+                pw.print(","); pw.print(mCurTop);
+                pw.print(")-("); pw.print(mCurRight);
+                pw.print(","); pw.print(mCurBottom); pw.println(")");
+        pw.print(prefix); pw.print("mContent=("); pw.print(mContentLeft);
+                pw.print(","); pw.print(mContentTop);
+                pw.print(")-("); pw.print(mContentRight);
+                pw.print(","); pw.print(mContentBottom); pw.println(")");
+        pw.print(prefix); pw.print("mDock=("); pw.print(mDockLeft);
+                pw.print(","); pw.print(mDockTop);
+                pw.print(")-("); pw.print(mDockRight);
+                pw.print(","); pw.print(mDockBottom); pw.println(")");
+        pw.print(prefix); pw.print("mDockLayer="); pw.print(mDockLayer);
+                pw.print(" mStatusBarLayer="); pw.println(mStatusBarLayer);
+        pw.print(prefix); pw.print("mShowingLockscreen="); pw.print(mShowingLockscreen);
+                pw.print(" mShowingDream="); pw.print(mShowingDream);
+                pw.print(" mDreamingLockscreen="); pw.println(mDreamingLockscreen);
+        if (mLastInputMethodWindow != null) {
+            pw.print(prefix); pw.print("mLastInputMethodWindow=");
+                    pw.println(mLastInputMethodWindow);
+        }
+        if (mLastInputMethodTargetWindow != null) {
+            pw.print(prefix); pw.print("mLastInputMethodTargetWindow=");
+                    pw.println(mLastInputMethodTargetWindow);
+        }
+        if (mStatusBar != null) {
+            pw.print(prefix); pw.print("mStatusBar=");
+                    pw.println(mStatusBar);
+        }
+        if (mNavigationBar != null) {
+            pw.print(prefix); pw.print("mNavigationBar=");
+                    pw.println(mNavigationBar);
+        }
+        if (mKeyguard != null) {
+            pw.print(prefix); pw.print("mKeyguard=");
+                    pw.println(mKeyguard);
+        }
+        if (mFocusedWindow != null) {
+            pw.print(prefix); pw.print("mFocusedWindow=");
+                    pw.println(mFocusedWindow);
+        }
+        if (mFocusedApp != null) {
+            pw.print(prefix); pw.print("mFocusedApp=");
+                    pw.println(mFocusedApp);
+        }
+        if (mWinDismissingKeyguard != null) {
+            pw.print(prefix); pw.print("mWinDismissingKeyguard=");
+                    pw.println(mWinDismissingKeyguard);
+        }
+        if (mTopFullscreenOpaqueWindowState != null) {
+            pw.print(prefix); pw.print("mTopFullscreenOpaqueWindowState=");
+                    pw.println(mTopFullscreenOpaqueWindowState);
+        }
+        if (mForcingShowNavBar) {
+            pw.print(prefix); pw.print("mForcingShowNavBar=");
+                    pw.println(mForcingShowNavBar); pw.print( "mForcingShowNavBarLayer=");
+                    pw.println(mForcingShowNavBarLayer);
+        }
+        pw.print(prefix); pw.print("mTopIsFullscreen="); pw.print(mTopIsFullscreen);
+                pw.print(" mHideLockScreen="); pw.println(mHideLockScreen);
+        pw.print(prefix); pw.print("mForceStatusBar="); pw.print(mForceStatusBar);
+                pw.print(" mForceStatusBarFromKeyguard=");
+                pw.println(mForceStatusBarFromKeyguard);
+        pw.print(prefix); pw.print("mDismissKeyguard="); pw.print(mDismissKeyguard);
+                pw.print(" mWinDismissingKeyguard="); pw.print(mWinDismissingKeyguard);
+                pw.print(" mHomePressed="); pw.println(mHomePressed);
+        pw.print(prefix); pw.print("mAllowLockscreenWhenOn="); pw.print(mAllowLockscreenWhenOn);
+                pw.print(" mLockScreenTimeout="); pw.print(mLockScreenTimeout);
+                pw.print(" mLockScreenTimerActive="); pw.println(mLockScreenTimerActive);
+        pw.print(prefix); pw.print("mEndcallBehavior="); pw.print(mEndcallBehavior);
+                pw.print(" mIncallPowerBehavior="); pw.print(mIncallPowerBehavior);
+                pw.print(" mRingHomeBehavior="); pw.print(mRingHomeBehavior);
+                pw.print(" mLongPressOnHomeBehavior="); pw.println(mLongPressOnHomeBehavior);
+        pw.print(prefix); pw.print("mLandscapeRotation="); pw.print(mLandscapeRotation);
+                pw.print(" mSeascapeRotation="); pw.println(mSeascapeRotation);
+        pw.print(prefix); pw.print("mPortraitRotation="); pw.print(mPortraitRotation);
+                pw.print(" mUpsideDownRotation="); pw.println(mUpsideDownRotation);
+        pw.print(prefix); pw.print("mHdmiRotation="); pw.print(mHdmiRotation);
+                pw.print(" mHdmiRotationLock="); pw.println(mHdmiRotationLock);
+    }
+}
+
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardViewBase.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardViewBase.java
index 6fcacd3..317d76c 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardViewBase.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardViewBase.java
@@ -1,264 +1,273 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.internal.policy.impl.keyguard;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.ColorFilter;
-import android.graphics.PixelFormat;
-import android.graphics.PorterDuff;
-import android.graphics.drawable.Drawable;
-import android.media.AudioManager;
-import android.media.IAudioService;
-import android.os.RemoteException;
-import android.os.ServiceManager;
-import android.telephony.TelephonyManager;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.util.Slog;
-import android.view.KeyEvent;
-import android.widget.FrameLayout;
-
-/**
- * Base class for keyguard view.  {@link #reset} is where you should
- * reset the state of your view.  Use the {@link KeyguardViewCallback} via
- * {@link #getCallback()} to send information back (such as poking the wake lock,
- * or finishing the keyguard).
- *
- * Handles intercepting of media keys that still work when the keyguard is
- * showing.
- */
-public abstract class KeyguardViewBase extends FrameLayout {
-
-    private static final int BACKGROUND_COLOR = 0x70000000;
-    private AudioManager mAudioManager;
-    private TelephonyManager mTelephonyManager = null;
-    protected KeyguardViewMediator.ViewMediatorCallback mViewMediatorCallback;
-
-    // Whether the volume keys should be handled by keyguard. If true, then
-    // they will be handled here for specific media types such as music, otherwise
-    // the audio service will bring up the volume dialog.
-    private static final boolean KEYGUARD_MANAGES_VOLUME = true;
-
-    // This is a faster way to draw the background on devices without hardware acceleration
-    private static final Drawable mBackgroundDrawable = new Drawable() {
-        @Override
-        public void draw(Canvas canvas) {
-            canvas.drawColor(BACKGROUND_COLOR, PorterDuff.Mode.SRC);
-        }
-
-        @Override
-        public void setAlpha(int alpha) {
-        }
-
-        @Override
-        public void setColorFilter(ColorFilter cf) {
-        }
-
-        @Override
-        public int getOpacity() {
-            return PixelFormat.TRANSLUCENT;
-        }
-    };
-
-    public KeyguardViewBase(Context context) {
-        this(context, null);
-    }
-
-    public KeyguardViewBase(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        resetBackground();
-    }
-
-    public void resetBackground() {
-        setBackground(mBackgroundDrawable);
-    }
-
-    /**
-     * Called when you need to reset the state of your view.
-     */
-    abstract public void reset();
-
-    /**
-     * Called when the screen turned off.
-     */
-    abstract public void onScreenTurnedOff();
-
-    /**
-     * Called when the screen turned on.
-     */
-    abstract public void onScreenTurnedOn();
-
-    /**
-     * Called when the view needs to be shown.
-     */
-    abstract public void show();
-
-    /**
-     * Called when a key has woken the device to give us a chance to adjust our
-     * state according the the key.  We are responsible for waking the device
-     * (by poking the wake lock) once we are ready.
-     *
-     * The 'Tq' suffix is per the documentation in {@link android.view.WindowManagerPolicy}.
-     * Be sure not to take any action that takes a long time; any significant
-     * action should be posted to a handler.
-     *
-     * @param keyCode The wake key, which may be relevant for configuring the
-     *   keyguard.  May be {@link KeyEvent#KEYCODE_UNKNOWN} if waking for a reason
-     *   other than a key press.
-     */
-    abstract public void wakeWhenReadyTq(int keyCode);
-
-    /**
-     * Verify that the user can get past the keyguard securely.  This is called,
-     * for example, when the phone disables the keyguard but then wants to launch
-     * something else that requires secure access.
-     *
-     * The result will be propogated back via {@link KeyguardViewCallback#keyguardDone(boolean)}
-     */
-    abstract public void verifyUnlock();
-
-    /**
-     * Called before this view is being removed.
-     */
-    abstract public void cleanUp();
-
-    /**
-     * Gets the desired user activity timeout in milliseconds, or -1 if the
-     * default should be used.
-     */
-    abstract public long getUserActivityTimeout();
-
-    @Override
-    public boolean dispatchKeyEvent(KeyEvent event) {
-        if (interceptMediaKey(event)) {
-            return true;
-        }
-        return super.dispatchKeyEvent(event);
-    }
-
-    /**
-     * Allows the media keys to work when the keyguard is showing.
-     * The media keys should be of no interest to the actual keyguard view(s),
-     * so intercepting them here should not be of any harm.
-     * @param event The key event
-     * @return whether the event was consumed as a media key.
-     */
-    private boolean interceptMediaKey(KeyEvent event) {
-        final int keyCode = event.getKeyCode();
-        if (event.getAction() == KeyEvent.ACTION_DOWN) {
-            switch (keyCode) {
-                case KeyEvent.KEYCODE_MEDIA_PLAY:
-                case KeyEvent.KEYCODE_MEDIA_PAUSE:
-                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-                    /* Suppress PLAY/PAUSE toggle when phone is ringing or
-                     * in-call to avoid music playback */
-                    if (mTelephonyManager == null) {
-                        mTelephonyManager = (TelephonyManager) getContext().getSystemService(
-                                Context.TELEPHONY_SERVICE);
-                    }
-                    if (mTelephonyManager != null &&
-                            mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
-                        return true;  // suppress key event
-                    }
-                case KeyEvent.KEYCODE_MUTE:
-                case KeyEvent.KEYCODE_HEADSETHOOK:
-                case KeyEvent.KEYCODE_MEDIA_STOP:
-                case KeyEvent.KEYCODE_MEDIA_NEXT:
-                case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
-                case KeyEvent.KEYCODE_MEDIA_REWIND:
-                case KeyEvent.KEYCODE_MEDIA_RECORD:
-                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD: {
-                    handleMediaKeyEvent(event);
-                    return true;
-                }
-
-                case KeyEvent.KEYCODE_VOLUME_UP:
-                case KeyEvent.KEYCODE_VOLUME_DOWN:
-                case KeyEvent.KEYCODE_VOLUME_MUTE: {
-                    if (KEYGUARD_MANAGES_VOLUME) {
-                        synchronized (this) {
-                            if (mAudioManager == null) {
-                                mAudioManager = (AudioManager) getContext().getSystemService(
-                                        Context.AUDIO_SERVICE);
-                            }
-                        }
-                        // Volume buttons should only function for music (local or remote).
-                        // TODO: Actually handle MUTE.
-                        mAudioManager.adjustLocalOrRemoteStreamVolume(
-                                AudioManager.STREAM_MUSIC,
-                                keyCode == KeyEvent.KEYCODE_VOLUME_UP
-                                        ? AudioManager.ADJUST_RAISE
-                                        : AudioManager.ADJUST_LOWER);
-                        // Don't execute default volume behavior
-                        return true;
-                    } else {
-                        return false;
-                    }
-                }
-            }
-        } else if (event.getAction() == KeyEvent.ACTION_UP) {
-            switch (keyCode) {
-                case KeyEvent.KEYCODE_MUTE:
-                case KeyEvent.KEYCODE_HEADSETHOOK:
-                case KeyEvent.KEYCODE_MEDIA_PLAY:
-                case KeyEvent.KEYCODE_MEDIA_PAUSE:
-                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-                case KeyEvent.KEYCODE_MEDIA_STOP:
-                case KeyEvent.KEYCODE_MEDIA_NEXT:
-                case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
-                case KeyEvent.KEYCODE_MEDIA_REWIND:
-                case KeyEvent.KEYCODE_MEDIA_RECORD:
-                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD: {
-                    handleMediaKeyEvent(event);
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    void handleMediaKeyEvent(KeyEvent keyEvent) {
-        IAudioService audioService = IAudioService.Stub.asInterface(
-                ServiceManager.checkService(Context.AUDIO_SERVICE));
-        if (audioService != null) {
-            try {
-                audioService.dispatchMediaKeyEvent(keyEvent);
-            } catch (RemoteException e) {
-                Log.e("KeyguardViewBase", "dispatchMediaKeyEvent threw exception " + e);
-            }
-        } else {
-            Slog.w("KeyguardViewBase", "Unable to find IAudioService for media key event");
-        }
-    }
-
-    @Override
-    public void dispatchSystemUiVisibilityChanged(int visibility) {
-        super.dispatchSystemUiVisibilityChanged(visibility);
-
-        if (!(mContext instanceof Activity)) {
-            setSystemUiVisibility(STATUS_BAR_DISABLE_BACK);
-        }
-    }
-
-    public void setViewMediatorCallback(
-            KeyguardViewMediator.ViewMediatorCallback viewMediatorCallback) {
-        mViewMediatorCallback = viewMediatorCallback;
-    }
-
-}
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.policy.impl.keyguard;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.PixelFormat;
+import android.graphics.PorterDuff;
+import android.graphics.drawable.Drawable;
+import android.media.AudioManager;
+import android.media.IAudioService;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.telephony.TelephonyManager;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.Slog;
+import android.view.KeyEvent;
+import android.widget.FrameLayout;
+
+/**
+ * Base class for keyguard view.  {@link #reset} is where you should
+ * reset the state of your view.  Use the {@link KeyguardViewCallback} via
+ * {@link #getCallback()} to send information back (such as poking the wake lock,
+ * or finishing the keyguard).
+ *
+ * Handles intercepting of media keys that still work when the keyguard is
+ * showing.
+ */
+public abstract class KeyguardViewBase extends FrameLayout {
+
+    private static final int BACKGROUND_COLOR = 0x70000000;
+    private AudioManager mAudioManager;
+    private TelephonyManager mTelephonyManager = null;
+    protected KeyguardViewMediator.ViewMediatorCallback mViewMediatorCallback;
+
+    // Whether the volume keys should be handled by keyguard. If true, then
+    // they will be handled here for specific media types such as music, otherwise
+    // the audio service will bring up the volume dialog.
+    private static final boolean KEYGUARD_MANAGES_VOLUME = true;
+
+    // This is a faster way to draw the background on devices without hardware acceleration
+    private static final Drawable mBackgroundDrawable = new Drawable() {
+        @Override
+        public void draw(Canvas canvas) {
+            canvas.drawColor(BACKGROUND_COLOR, PorterDuff.Mode.SRC);
+        }
+
+        @Override
+        public void setAlpha(int alpha) {
+        }
+
+        @Override
+        public void setColorFilter(ColorFilter cf) {
+        }
+
+        @Override
+        public int getOpacity() {
+            return PixelFormat.TRANSLUCENT;
+        }
+    };
+
+    public KeyguardViewBase(Context context) {
+        this(context, null);
+    }
+
+    public KeyguardViewBase(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        resetBackground();
+    }
+
+    public void resetBackground() {
+        setBackground(mBackgroundDrawable);
+    }
+
+    /**
+     * Called when you need to reset the state of your view.
+     */
+    abstract public void reset();
+
+    /**
+     * Called when the screen turned off.
+     */
+    abstract public void onScreenTurnedOff();
+
+    /**
+     * Called when the screen turned on.
+     */
+    abstract public void onScreenTurnedOn();
+
+    /**
+     * Called when the view needs to be shown.
+     */
+    abstract public void show();
+
+    /**
+     * Called when a key has woken the device to give us a chance to adjust our
+     * state according the the key.  We are responsible for waking the device
+     * (by poking the wake lock) once we are ready.
+     *
+     * The 'Tq' suffix is per the documentation in {@link android.view.WindowManagerPolicy}.
+     * Be sure not to take any action that takes a long time; any significant
+     * action should be posted to a handler.
+     *
+     * @param keyCode The wake key, which may be relevant for configuring the
+     *   keyguard.  May be {@link KeyEvent#KEYCODE_UNKNOWN} if waking for a reason
+     *   other than a key press.
+     */
+    abstract public void wakeWhenReadyTq(int keyCode);
+
+    /**
+     * Verify that the user can get past the keyguard securely.  This is called,
+     * for example, when the phone disables the keyguard but then wants to launch
+     * something else that requires secure access.
+     *
+     * The result will be propogated back via {@link KeyguardViewCallback#keyguardDone(boolean)}
+     */
+    abstract public void verifyUnlock();
+
+    /**
+     * Called before this view is being removed.
+     */
+    abstract public void cleanUp();
+
+    /**
+     * Gets the desired user activity timeout in milliseconds, or -1 if the
+     * default should be used.
+     */
+    abstract public long getUserActivityTimeout();
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        if (interceptMediaKey(event)) {
+            return true;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    /**
+     * Allows the media keys to work when the keyguard is showing.
+     * The media keys should be of no interest to the actual keyguard view(s),
+     * so intercepting them here should not be of any harm.
+     * @param event The key event
+     * @return whether the event was consumed as a media key.
+     */
+    private boolean interceptMediaKey(KeyEvent event) {
+        final int keyCode = event.getKeyCode();
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            switch (keyCode) {
+                case KeyEvent.KEYCODE_MEDIA_PLAY:
+                case KeyEvent.KEYCODE_MEDIA_PAUSE:
+                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+                    /* Suppress PLAY/PAUSE toggle when phone is ringing or
+                     * in-call to avoid music playback */
+                    if (mTelephonyManager == null) {
+                        mTelephonyManager = (TelephonyManager) getContext().getSystemService(
+                                Context.TELEPHONY_SERVICE);
+                    }
+                    if (mTelephonyManager != null &&
+                            mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
+                        return true;  // suppress key event
+                    }
+                case KeyEvent.KEYCODE_MUTE:
+                case KeyEvent.KEYCODE_HEADSETHOOK:
+                case KeyEvent.KEYCODE_MEDIA_STOP:
+                case KeyEvent.KEYCODE_MEDIA_NEXT:
+                case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+                case KeyEvent.KEYCODE_MEDIA_REWIND:
+                case KeyEvent.KEYCODE_MEDIA_RECORD:
+                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD: {
+                    handleMediaKeyEvent(event);
+                    return true;
+                }
+
+                case KeyEvent.KEYCODE_VOLUME_UP:
+                case KeyEvent.KEYCODE_VOLUME_DOWN:
+                case KeyEvent.KEYCODE_VOLUME_MUTE: {
+                    if (KEYGUARD_MANAGES_VOLUME) {
+                        synchronized (this) {
+                            if (mAudioManager == null) {
+                                mAudioManager = (AudioManager) getContext().getSystemService(
+                                        Context.AUDIO_SERVICE);
+                            }
+                        }
+                        // Volume buttons should only function for music (local or remote).
+						if (mAudioManager.isMusicActive()) {
+                        // TODO: Actually handle MUTE.
+                        mAudioManager.adjustLocalOrRemoteStreamVolume(
+                                AudioManager.STREAM_MUSIC,
+                                keyCode == KeyEvent.KEYCODE_VOLUME_UP
+                                        ? AudioManager.ADJUST_RAISE
+                                        : AudioManager.ADJUST_LOWER);
+                        } else if (mAudioManager.isFMActive()) {
+                        mAudioManager.adjustLocalOrRemoteStreamVolume(
+                                 AudioManager.STREAM_FM,
+                                 keyCode == KeyEvent.KEYCODE_VOLUME_UP
+                                         ? AudioManager.ADJUST_RAISE
+                                         : AudioManager.ADJUST_LOWER);
+                        }										
+                        // Don't execute default volume behavior
+                        return true;
+                    } else {
+                        return false;
+                    }
+                }
+            }
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+            switch (keyCode) {
+                case KeyEvent.KEYCODE_MUTE:
+                case KeyEvent.KEYCODE_HEADSETHOOK:
+                case KeyEvent.KEYCODE_MEDIA_PLAY:
+                case KeyEvent.KEYCODE_MEDIA_PAUSE:
+                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+                case KeyEvent.KEYCODE_MEDIA_STOP:
+                case KeyEvent.KEYCODE_MEDIA_NEXT:
+                case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+                case KeyEvent.KEYCODE_MEDIA_REWIND:
+                case KeyEvent.KEYCODE_MEDIA_RECORD:
+                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD: {
+                    handleMediaKeyEvent(event);
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    void handleMediaKeyEvent(KeyEvent keyEvent) {
+        IAudioService audioService = IAudioService.Stub.asInterface(
+                ServiceManager.checkService(Context.AUDIO_SERVICE));
+        if (audioService != null) {
+            try {
+                audioService.dispatchMediaKeyEvent(keyEvent);
+            } catch (RemoteException e) {
+                Log.e("KeyguardViewBase", "dispatchMediaKeyEvent threw exception " + e);
+            }
+        } else {
+            Slog.w("KeyguardViewBase", "Unable to find IAudioService for media key event");
+        }
+    }
+
+    @Override
+    public void dispatchSystemUiVisibilityChanged(int visibility) {
+        super.dispatchSystemUiVisibilityChanged(visibility);
+
+        if (!(mContext instanceof Activity)) {
+            setSystemUiVisibility(STATUS_BAR_DISABLE_BACK);
+        }
+    }
+
+    public void setViewMediatorCallback(
+            KeyguardViewMediator.ViewMediatorCallback viewMediatorCallback) {
+        mViewMediatorCallback = viewMediatorCallback;
+    }
+
+}
-- 
1.8.1.2

