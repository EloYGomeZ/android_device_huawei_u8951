From 9dac73f34ed10651da15c0507b571e405f607091 Mon Sep 17 00:00:00 2001
From: eloimuns <eloimuns@gmail.com>
Date: Mon, 28 Oct 2013 14:21:00 +0100
Subject: [PATCH] Fix on PAC Native

Change-Id: If2736b337a5257b3ef3b72acd8e6166db02d1108
---
 include/gui/SurfaceTexture.h       | 10 +++++++++-
 libs/gui/Android.mk                |  4 ++++
 libs/gui/SurfaceTexture.cpp        | 27 +++++++++++++++++++++++++++
 services/surfaceflinger/Layer.cpp  | 34 ++++++++++++++++++++++++++++++++--
 services/surfaceflinger/Android.mk |   5 +
 4 files changed, 77 insertions(+), 3 deletions(-)

diff --git a/include/gui/SurfaceTexture.h b/include/gui/SurfaceTexture.h
index 7c519ae..0edbd08 100644
--- a/include/gui/SurfaceTexture.h
+++ b/include/gui/SurfaceTexture.h
@@ -246,7 +246,11 @@ private:
         virtual ~BufferRejecter() { }
     };
     friend class Layer;
+#ifdef DECIDE_TEXTURE_TARGET
+    status_t updateTexImage(BufferRejecter* rejecter, bool skipSync, bool isComposition=false);
+#else
     status_t updateTexImage(BufferRejecter* rejecter, bool skipSync);
+#endif
 
     // createImage creates a new EGLImage from a GraphicBuffer.
     EGLImageKHR createImage(EGLDisplay dpy,
@@ -338,7 +342,11 @@ private:
     // glCopyTexSubImage to read from the texture.  This is a hack to work
     // around a GL driver limitation on the number of FBO attachments, which the
     // browser's tile cache exceeds.
-    const GLenum mTexTarget;
+#ifdef DECIDE_TEXTURE_TARGET
+    GLenum mTexTarget;
+#else
+     const GLenum mTexTarget;
+#endif
 
     // EGLSlot contains the information and object references that
     // SurfaceTexture maintains about a BufferQueue buffer slot.
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index 084ea0d..e1ab005 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -60,6 +60,10 @@ ifneq ($(TARGET_QCOM_DISPLAY_VARIANT),legacy)
 endif
 endif
 
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+    LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 ifeq (,$(ONE_SHOT_MAKEFILE))
diff --git a/libs/gui/SurfaceTexture.cpp b/libs/gui/SurfaceTexture.cpp
index b4dfb5e..efc66a1 100644
--- a/libs/gui/SurfaceTexture.cpp
+++ b/libs/gui/SurfaceTexture.cpp
@@ -195,7 +195,11 @@ status_t SurfaceTexture::releaseBufferLocked(int buf, EGLDisplay display,
     return err;
 }
 
+#ifdef DECIDE_TEXTURE_TARGET
+status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync, bool isComposition) {
+#else
 status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync) {
+#endif
     ATRACE_CALL();
     ST_LOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
@@ -238,6 +242,29 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync)
     err = acquireBufferLocked(&item);
     if (err == NO_ERROR) {
         int buf = item.mBuf;
+        
+#ifdef DECIDE_TEXTURE_TARGET
+        // GPU is not efficient in handling GL_TEXTURE_EXTERNAL_OES
+        // texture target. Depending on the image format, decide,
+        // the texture target to be used
+
+        if(isComposition){
+            switch (mSlots[buf].mGraphicBuffer->format) {
+                case HAL_PIXEL_FORMAT_RGBA_8888:
+                case HAL_PIXEL_FORMAT_RGBX_8888:
+                case HAL_PIXEL_FORMAT_RGB_888:
+                case HAL_PIXEL_FORMAT_RGB_565:
+                case HAL_PIXEL_FORMAT_BGRA_8888:
+                case HAL_PIXEL_FORMAT_RGBA_5551:
+                case HAL_PIXEL_FORMAT_RGBA_4444:
+                    mTexTarget = GL_TEXTURE_2D;
+                    break;
+                default:
+                    mTexTarget = GL_TEXTURE_EXTERNAL_OES;
+                    break;
+            }
+        }
+#endif
 
         // we call the rejecter here, in case the caller has a reason to
         // not accept this buffer. this is used by SurfaceFlinger to
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index c1561b2..30d1b8e 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -367,6 +367,9 @@ void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
 
     bool blackOutLayer = isProtected() || (isSecure() && !hw->isSecure());
 
+#ifdef DECIDE_TEXTURE_TARGET
+    GLuint currentTextureTarget = mSurfaceTexture->getCurrentTextureTarget();
+#endif
     if (!blackOutLayer) {
         // TODO: we could be more subtle with isFixedSize()
         const bool useFiltering = getFiltering() || needsFiltering(hw) || isFixedSize();
@@ -377,25 +380,46 @@ void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
         mSurfaceTexture->getTransformMatrix(textureMatrix);
 
         // Set things up for texturing.
-        glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureName);
+#ifdef DECIDE_TEXTURE_TARGET
+        glBindTexture(currentTextureTarget, mTextureName);
+#else
+         glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureName);
+#endif
         GLenum filter = GL_NEAREST;
         if (useFiltering) {
             filter = GL_LINEAR;
         }
+#ifdef DECIDE_TEXTURE_TARGET
+        glTexParameterx(currentTextureTarget, GL_TEXTURE_MAG_FILTER, filter);
+        glTexParameterx(currentTextureTarget, GL_TEXTURE_MIN_FILTER, filter);
+#else
         glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, filter);
         glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, filter);
+#endif
         glMatrixMode(GL_TEXTURE);
         glLoadMatrixf(textureMatrix);
         glMatrixMode(GL_MODELVIEW);
         glDisable(GL_TEXTURE_2D);
+#ifdef DECIDE_TEXTURE_TARGET
+        glEnable(currentTextureTarget);
+#else
         glEnable(GL_TEXTURE_EXTERNAL_OES);
+#endif
     } else {
+#ifdef DECIDE_TEXTURE_TARGET
+        glBindTexture(currentTextureTarget, mFlinger->getProtectedTexName());
+#else
         glBindTexture(GL_TEXTURE_2D, mFlinger->getProtectedTexName());
+#endif
         glMatrixMode(GL_TEXTURE);
         glLoadIdentity();
         glMatrixMode(GL_MODELVIEW);
+#ifdef DECIDE_TEXTURE_TARGET
+        glEnable(currentTextureTarget);
+#else
         glDisable(GL_TEXTURE_EXTERNAL_OES);
         glEnable(GL_TEXTURE_2D);
+#endif
     }
 
     drawWithOpenGL(hw, clip);
@@ -661,8 +685,14 @@ Region Layer::latchBuffer(bool& recomputeVisibleRegions)
 
 
         Reject r(mDrawingState, currentState(), recomputeVisibleRegions);
-
+#ifdef DECIDE_TEXTURE_TARGET
+        // While calling updateTexImage() from SurfaceFlinger, let it know
+        // by passing an extra parameter
+        // This will be true always.
+        if (mSurfaceTexture->updateTexImage(&r, true, true) < NO_ERROR) {
+#else
         if (mSurfaceTexture->updateTexImage(&r, true) < NO_ERROR) {
+#endif
             // something happened!
             recomputeVisibleRegions = true;
             return outDirtyRegion;
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index b3fa5fb..821a074 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -43,6 +43,11 @@ ifneq ($(NUM_FRAMEBUFFER_SURFACE_BUFFERS),)
   LOCAL_CFLAGS += -DNUM_FRAMEBUFFER_SURFACE_BUFFERS=$(NUM_FRAMEBUFFER_SURFACE_BUFFERS)
 endif
 
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+    LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
+endif
+
+
 LOCAL_SHARED_LIBRARIES := \
 	libcutils \
 	libdl \
-- 
1.8.1.2

